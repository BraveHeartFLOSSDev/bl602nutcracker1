typedef unsigned char   undefined;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned int    dword;
typedef long long    longlong;
typedef unsigned long long    qword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct stat stat, *Pstat;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __off_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    ulong __unused4;
    ulong __unused5;
};

typedef ulong size_t;

typedef struct __locale_data __locale_data, *P__locale_data;

struct __locale_data {
};

typedef struct __locale_struct __locale_struct, *P__locale_struct;

struct __locale_struct {
    struct __locale_data * __locales[13];
    ushort * __ctype_b;
    int * __ctype_tolower;
    int * __ctype_toupper;
    char * __names[13];
};

typedef struct __locale_struct * __locale_t;

typedef bool _Bool;

typedef undefined complex long double[32];

typedef qword complex float;

typedef undefined complex double[16];

typedef struct trpc_env_tag trpc_env_tag, *Ptrpc_env_tag;

typedef char int8_t;

typedef short __int16_t;

typedef __int16_t int16_t;

struct trpc_env_tag {
    int8_t power_dbm_max_rf;
    int8_t power_dbm_min_rf;
    int8_t power_dbm_lim_reg;
    undefined field_0x3;
    int16_t channel_freq;
    int8_t temperature;
    int8_t temperature_compensate;
};

typedef enum wiphy_flags {
    WIPHY_FLAG_CONTROL_PORT_PROTOCOL=-128,
    WIPHY_FLAG_SUPPORTS_TDLS=-32768,
    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL=2097152,
    WIPHY_FLAG_IBSS_RSN=256,
    WIPHY_FLAG_SUPPORTS_5_10_MHZ=4194304,
    WIPHY_FLAG_SUPPORTS_SCHED_SCAN=2048,
    WIPHY_FLAG_REPORTS_OBSS=262144,
    WIPHY_FLAG_PS_ON_BY_DEFAULT=16,
    WIPHY_FLAG_TDLS_EXTERNAL_SETUP=65536,
    WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD=524288,
    WIPHY_FLAG_HAVE_AP_SME=131072,
    WIPHY_FLAG_4ADDR_AP=32,
    WIPHY_FLAG_SUPPORTS_FW_ROAM=8192,
    WIPHY_FLAG_NETNS_OK=8,
    WIPHY_FLAG_AP_UAPSD=16384,
    WIPHY_FLAG_OFFCHAN_TX=1048576,
    WIPHY_FLAG_HAS_STATIC_WEP=16777216,
    WIPHY_FLAG_MESH_AUTH=1024,
    WIPHY_FLAG_HAS_CHANNEL_SWITCH=8388608,
    WIPHY_FLAG_4ADDR_STATION=64
} wiphy_flags;

typedef struct ieee80211_dot_d ieee80211_dot_d, *Pieee80211_dot_d;

typedef struct ieee80211_channel ieee80211_channel, *Pieee80211_channel;

typedef enum nl80211_band {
    NL80211_BAND_5GHZ=1,
    NL80211_BAND_2GHZ=0,
    NL80211_BAND_60GHZ=2,
    NUM_NL80211_BANDS=3
} nl80211_band;

typedef ushort uint16_t;

typedef uint16_t u16;

typedef ulong uint32_t;

typedef uint32_t u32.conflict;

typedef enum nl80211_dfs_state {
    NL80211_DFS_AVAILABLE=2,
    NL80211_DFS_UNAVAILABLE=1,
    NL80211_DFS_USABLE=0
} nl80211_dfs_state;

struct ieee80211_dot_d {
    char * code;
    int channel_num;
    struct ieee80211_channel * channels;
};

struct ieee80211_channel {
    enum nl80211_band band;
    undefined field_0x1;
    u16 center_freq;
    u16 hw_value;
    undefined field_0x6;
    undefined field_0x7;
    u32.conflict flags;
    int max_antenna_gain;
    int max_power;
    int max_reg_power;
    _Bool beacon_found;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
    u32.conflict orig_flags;
    int orig_mag;
    int orig_mpwr;
    enum nl80211_dfs_state dfs_state;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    ulong dfs_state_entered;
    uint dfs_cac_ms;
};

typedef struct cfg80211_bss_select_adjust cfg80211_bss_select_adjust, *Pcfg80211_bss_select_adjust;

typedef int8_t s8;

struct cfg80211_bss_select_adjust {
    enum nl80211_band band;
    s8 delta;
};

typedef enum ieee80211_channel_flags {
    IEEE80211_CHAN_NO_80MHZ=-128,
    IEEE80211_CHAN_NO_HT40PLUS=16,
    IEEE80211_CHAN_INDOOR_ONLY=512,
    IEEE80211_CHAN_NO_HT40MINUS=32,
    IEEE80211_CHAN_NO_160MHZ=256,
    IEEE80211_CHAN_NO_10MHZ=4096,
    IEEE80211_CHAN_DISABLED=1,
    IEEE80211_CHAN_NO_OFDM=64,
    IEEE80211_CHAN_RADAR=8,
    IEEE80211_CHAN_IR_CONCURRENT=1024,
    IEEE80211_CHAN_NO_20MHZ=2048,
    IEEE80211_CHAN_NO_IR=2
} ieee80211_channel_flags;

typedef union anon_union.conflict13d8a5 anon_union.conflict13d8a5, *Panon_union.conflict13d8a5;

union anon_union.conflict13d8a5 {
    enum nl80211_band band_pref;
    struct cfg80211_bss_select_adjust adjust;
};

typedef struct cfg80211_connect_params cfg80211_connect_params, *Pcfg80211_connect_params;

typedef uchar u8;


// WARNING! conflicting data type names: /DWARF/stddef.h/size_t - /stddef.h/size_t

typedef enum nl80211_auth_type {
    NL80211_AUTHTYPE_FT=2,
    NL80211_AUTHTYPE_FILS_SK=5,
    NL80211_AUTHTYPE_NETWORK_EAP=3,
    NL80211_AUTHTYPE_FILS_PK=7,
    NL80211_AUTHTYPE_AUTOMATIC=8,
    NL80211_AUTHTYPE_SHARED_KEY=1,
    NL80211_AUTHTYPE_MAX=7,
    __NL80211_AUTHTYPE_NUM=8,
    NL80211_AUTHTYPE_FILS_SK_PFS=6,
    NL80211_AUTHTYPE_OPEN_SYSTEM=0,
    NL80211_AUTHTYPE_SAE=4
} nl80211_auth_type;

typedef enum nl80211_mfp {
    NL80211_MFP_REQUIRED=1,
    NL80211_MFP_NO=0
} nl80211_mfp;

typedef struct cfg80211_crypto_settings cfg80211_crypto_settings, *Pcfg80211_crypto_settings;

typedef struct ieee80211_ht_cap ieee80211_ht_cap, *Pieee80211_ht_cap;

typedef struct cfg80211_bss_selection cfg80211_bss_selection, *Pcfg80211_bss_selection;

typedef uint16_t __be16;

typedef struct key_params key_params, *Pkey_params;

typedef uint16_t __le16;

typedef struct ieee80211_mcs_info ieee80211_mcs_info, *Pieee80211_mcs_info;

typedef uint32_t __le32;

typedef enum nl80211_bss_select_attr {
    NL80211_BSS_SELECT_ATTR_BAND_PREF=2,
    NL80211_BSS_SELECT_ATTR_MAX=3,
    NL80211_BSS_SELECT_ATTR_RSSI_ADJUST=3,
    __NL80211_BSS_SELECT_ATTR_INVALID=0,
    __NL80211_BSS_SELECT_ATTR_AFTER_LAST=4,
    NL80211_BSS_SELECT_ATTR_RSSI=1
} nl80211_bss_select_attr;

typedef union anon_union.conflict13d8a5_for_param anon_union.conflict13d8a5_for_param, *Panon_union.conflict13d8a5_for_param;

union anon_union.conflict13d8a5_for_param {
    enum nl80211_band band_pref;
    struct cfg80211_bss_select_adjust adjust;
};

struct cfg80211_bss_selection {
    enum nl80211_bss_select_attr behaviour;
    union anon_union.conflict13d8a5_for_param param;
};

struct cfg80211_crypto_settings {
    u32.conflict wpa_versions;
    u32.conflict cipher_group;
    int n_ciphers_pairwise;
    u32.conflict ciphers_pairwise[5];
    int n_akm_suites;
    u32.conflict akm_suites[2];
    _Bool control_port;
    undefined field_0x2d;
    __be16 control_port_ethertype;
    _Bool control_port_no_encrypt;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
    struct key_params * wep_keys;
    int wep_tx_key;
};

struct ieee80211_mcs_info {
    u8 rx_mask[10];
    __le16 rx_highest;
    u8 tx_params;
    u8 reserved[3];
};

struct ieee80211_ht_cap {
    __le16 cap_info;
    u8 ampdu_params_info;
    undefined field_0x3;
    struct ieee80211_mcs_info mcs;
    __le16 extended_ht_cap_info;
    undefined field_0x16;
    undefined field_0x17;
    __le32 tx_BF_cap_info;
    u8 antenna_selection_info;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

struct cfg80211_connect_params {
    struct ieee80211_channel channel;
    struct ieee80211_channel * channel_hint;
    u8 * bssid;
    u8 * bssid_hint;
    u8 * ssid;
    size_t ssid_len;
    enum nl80211_auth_type auth_type;
    undefined field_0x49;
    undefined field_0x4a;
    undefined field_0x4b;
    u8 * ie;
    size_t ie_len;
    _Bool privacy;
    enum nl80211_mfp mfp;
    undefined field_0x56;
    undefined field_0x57;
    struct cfg80211_crypto_settings crypto;
    u8 * key;
    u8 * pmk;
    u8 key_len;
    u8 pmk_len;
    u8 key_idx;
    undefined field_0x9f;
    u32.conflict flags;
    int bg_scan_period;
    struct ieee80211_ht_cap ht_capa;
    struct ieee80211_ht_cap ht_capa_mask;
    _Bool pbss;
    struct cfg80211_bss_selection bss_select;
    u8 * prev_bssid;
};

struct key_params {
    u8 * key;
    u8 * seq;
    int key_len;
    int seq_len;
    u32.conflict cipher;
};

typedef struct ieee80211_sta_ht_cap ieee80211_sta_ht_cap, *Pieee80211_sta_ht_cap;

struct ieee80211_sta_ht_cap {
    u16 cap;
    _Bool ht_supported;
    u8 ampdu_factor;
    u8 ampdu_density;
    undefined field_0x5;
    struct ieee80211_mcs_info mcs;
};

typedef struct ke_evt_tag ke_evt_tag, *Pke_evt_tag;

struct ke_evt_tag {
    void (* func)(int);
    int param;
};

typedef struct netconn netconn, *Pnetconn;

typedef enum netconn_evt {
    NETCONN_EVT_SENDPLUS=2,
    NETCONN_EVT_RCVMINUS=1,
    NETCONN_EVT_SENDMINUS=3,
    NETCONN_EVT_ERROR=4,
    NETCONN_EVT_RCVPLUS=0
} netconn_evt;

typedef uint16_t u16_t;

typedef enum netconn_type {
    NETCONN_TCP=16,
    NETCONN_UDP=32,
    NETCONN_UDPNOCHKSUM=34,
    NETCONN_INVALID=0,
    NETCONN_UDPLITE=33,
    NETCONN_RAW=64
} netconn_type;

typedef enum netconn_state {
    NETCONN_CLOSE=4,
    NETCONN_WRITE=1,
    NETCONN_LISTEN=2,
    NETCONN_NONE=0,
    NETCONN_CONNECT=3
} netconn_state;

typedef union anon_union.conflict1c7c2b_for_pcb anon_union.conflict1c7c2b_for_pcb, *Panon_union.conflict1c7c2b_for_pcb;

typedef int8_t s8_t;

typedef s8_t err_t;

typedef struct QueueDefinition QueueDefinition, *PQueueDefinition;

typedef struct QueueDefinition * QueueHandle_t;

typedef QueueHandle_t SemaphoreHandle_t;

typedef SemaphoreHandle_t sys_sem_t;

typedef QueueHandle_t sys_mbox_t;

typedef long int32_t;

typedef int32_t s32_t;

typedef uint32_t u32_t;

typedef uchar uint8_t;

typedef uint8_t u8_t;

typedef struct api_msg api_msg, *Papi_msg;

typedef struct ip_pcb ip_pcb, *Pip_pcb;

typedef struct tcp_pcb tcp_pcb, *Ptcp_pcb;

typedef struct pbuf pbuf, *Ppbuf;

typedef struct udp_pcb udp_pcb, *Pudp_pcb;

typedef struct ip4_addr ip4_addr, *Pip4_addr;

typedef struct ip4_addr ip4_addr_t;

typedef ip4_addr_t ip_addr_t;

typedef struct raw_pcb raw_pcb, *Praw_pcb;

typedef union anon_union.conflict18e1c3_for_u anon_union.conflict18e1c3_for_u, *Panon_union.conflict18e1c3_for_u;

typedef struct xLIST xLIST, *PxLIST;

typedef struct xLIST List_t;

typedef uint32_t UBaseType_t;

typedef union anon_union.conflict20568c_for_msg anon_union.conflict20568c_for_msg, *Panon_union.conflict20568c_for_msg;

typedef enum tcp_state {
    SYN_RCVD=3,
    CLOSE_WAIT=7,
    ESTABLISHED=4,
    CLOSED=0,
    CLOSING=8,
    SYN_SENT=2,
    LISTEN=1,
    FIN_WAIT_1=5,
    FIN_WAIT_2=6,
    LAST_ACK=9,
    TIME_WAIT=10
} tcp_state;

typedef u16_t tcpflags_t;

typedef u16_t tcpwnd_size_t;

typedef int16_t s16_t;

typedef struct tcp_seg tcp_seg, *Ptcp_seg;

typedef struct tcp_pcb_listen tcp_pcb_listen, *Ptcp_pcb_listen;

typedef err_t (* tcp_connected_fn)(void *, struct tcp_pcb *, err_t);

typedef struct QueuePointers QueuePointers, *PQueuePointers;

typedef struct QueuePointers QueuePointers_t;

typedef struct SemaphoreData SemaphoreData, *PSemaphoreData;

typedef struct SemaphoreData SemaphoreData_t;

typedef struct xLIST_ITEM xLIST_ITEM, *PxLIST_ITEM;

typedef struct xLIST_ITEM ListItem_t;

typedef struct xMINI_LIST_ITEM xMINI_LIST_ITEM, *PxMINI_LIST_ITEM;

typedef struct xMINI_LIST_ITEM MiniListItem_t;

typedef struct netbuf netbuf, *Pnetbuf;

typedef struct anon_struct.conflict14aecf anon_struct.conflict14aecf, *Panon_struct.conflict14aecf;

typedef struct anon_struct.conflict202123 anon_struct.conflict202123, *Panon_struct.conflict202123;

typedef struct anon_struct.conflict202154 anon_struct.conflict202154, *Panon_struct.conflict202154;

typedef struct anon_struct.conflict202191 anon_struct.conflict202191, *Panon_struct.conflict202191;

typedef struct anon_struct.conflict2021fc anon_struct.conflict2021fc, *Panon_struct.conflict2021fc;

typedef struct anon_struct.conflict202213 anon_struct.conflict202213, *Panon_struct.conflict202213;

typedef struct anon_struct.conflict202237 anon_struct.conflict202237, *Panon_struct.conflict202237;

typedef struct tcp_hdr tcp_hdr, *Ptcp_hdr;

typedef err_t (* tcp_accept_fn)(void *, struct tcp_pcb *, err_t);

typedef struct tskTaskControlBlock tskTaskControlBlock, *PtskTaskControlBlock;

typedef struct tskTaskControlBlock * TaskHandle_t;

typedef uint32_t TickType_t;

typedef struct netvector netvector, *Pnetvector;

typedef enum netconn_igmp {
    NETCONN_JOIN=0,
    NETCONN_LEAVE=1
} netconn_igmp;

typedef uint32_t StackType_t;

struct xMINI_LIST_ITEM {
    TickType_t xItemValue;
    struct xLIST_ITEM * pxNext;
    struct xLIST_ITEM * pxPrevious;
};

struct tcp_hdr {
    u16_t src;
    u16_t dest;
    u32_t seqno;
    u32_t ackno;
    u16_t _hdrlen_rsvd_flags;
    u16_t wnd;
    u16_t chksum;
    u16_t urgp;
};

struct anon_struct.conflict2021fc {
    size_t len;
};

struct anon_struct.conflict202123 {
    ip_addr_t * ipaddr;
    u16_t port;
    u8_t if_idx;
    undefined field_0x7;
};

struct netvector {
    void * ptr;
    size_t len;
};

struct ip4_addr {
    u32_t addr;
};

struct netbuf {
    struct pbuf * p;
    struct pbuf * ptr;
    ip_addr_t addr;
    u16_t port;
    u8_t flags;
    undefined field_0xf;
    u16_t toport_chksum;
    undefined field_0x12;
    undefined field_0x13;
};

union anon_union.conflict1c7c2b_for_pcb {
    struct ip_pcb * ip;
    struct tcp_pcb * tcp;
    struct udp_pcb * udp;
    struct raw_pcb * raw;
};

struct netconn {
    enum netconn_type type;
    enum netconn_state state;
    undefined field_0x2;
    undefined field_0x3;
    union anon_union.conflict1c7c2b_for_pcb pcb;
    err_t pending_err;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    sys_sem_t op_completed;
    sys_mbox_t recvmbox;
    sys_mbox_t acceptmbox;
    int socket;
    s32_t send_timeout;
    u32_t recv_timeout;
    u8_t flags;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    struct api_msg * current_msg;
    void (* callback)(struct netconn *, enum netconn_evt, u16_t);
};

struct xLIST_ITEM {
    TickType_t xItemValue;
    struct xLIST_ITEM * pxNext;
    struct xLIST_ITEM * pxPrevious;
    void * pvOwner;
    struct xLIST * pvContainer;
};

struct anon_struct.conflict202154 {
    ip_addr_t * ipaddr;
    u16_t * port;
    u8_t local;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

struct anon_struct.conflict14aecf {
    u8 action_code;
    u8[0] variable;
};

struct anon_struct.conflict202237 {
    ip_addr_t * multiaddr;
    ip_addr_t * netif_addr;
    u8_t if_idx;
    enum netconn_igmp join_or_leave;
    undefined field_0xa;
    undefined field_0xb;
};

struct anon_struct.conflict202191 {
    struct netvector * vector;
    u16_t vector_cnt;
    undefined field_0x6;
    undefined field_0x7;
    size_t vector_off;
    size_t len;
    size_t offset;
    u8_t apiflags;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
    u32_t time_started;
};

struct anon_struct.conflict202213 {
    u8_t shut;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    u32_t time_started;
};

union anon_union.conflict20568c_for_msg {
    struct netbuf * b;
    struct anon_struct.conflict14aecf n;
    struct anon_struct.conflict202123 bc;
    struct anon_struct.conflict202154 ad;
    struct anon_struct.conflict202191 w;
    struct anon_struct.conflict2021fc r;
    struct anon_struct.conflict202213 sd;
    struct anon_struct.conflict202237 jl;
};

struct api_msg {
    struct netconn * conn;
    err_t err;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    union anon_union.conflict20568c_for_msg msg;
};

struct tcp_pcb_listen {
    ip_addr_t local_ip;
    ip_addr_t remote_ip;
    u8_t netif_idx;
    u8_t so_options;
    u8_t tos;
    u8_t ttl;
    struct tcp_pcb_listen * next;
    void * callback_arg;
    enum tcp_state state;
    u8_t prio;
    u16_t local_port;
    tcp_accept_fn accept;
};

struct SemaphoreData {
    TaskHandle_t xMutexHolder;
    UBaseType_t uxRecursiveCallCount;
};

struct tskTaskControlBlock {
    StackType_t * pxTopOfStack;
    ListItem_t xStateListItem;
    ListItem_t xEventListItem;
    UBaseType_t uxPriority;
    StackType_t * pxStack;
    char pcTaskName[16];
    UBaseType_t uxCriticalNesting;
    UBaseType_t uxTCBNumber;
    UBaseType_t uxTaskNumber;
    UBaseType_t uxBasePriority;
    UBaseType_t uxMutexesHeld;
    uint32_t ulNotifiedValue;
    uint8_t ucNotifyState;
    uint8_t ucStaticallyAllocated;
    undefined field_0x5e;
    undefined field_0x5f;
};

struct QueuePointers {
    int8_t * pcTail;
    int8_t * pcReadFrom;
};

union anon_union.conflict18e1c3_for_u {
    QueuePointers_t xQueue;
    SemaphoreData_t xSemaphore;
};

struct xLIST {
    UBaseType_t uxNumberOfItems;
    ListItem_t * pxIndex;
    MiniListItem_t xListEnd;
};

struct QueueDefinition {
    int8_t * pcHead;
    int8_t * pcWriteTo;
    union anon_union.conflict18e1c3_for_u u;
    List_t xTasksWaitingToSend;
    List_t xTasksWaitingToReceive;
    UBaseType_t uxMessagesWaiting;
    UBaseType_t uxLength;
    UBaseType_t uxItemSize;
    int8_t cRxLock;
    int8_t cTxLock;
    uint8_t ucStaticallyAllocated;
    undefined field_0x47;
    UBaseType_t uxQueueNumber;
    uint8_t ucQueueType;
    undefined field_0x4d;
    undefined field_0x4e;
    undefined field_0x4f;
};

struct udp_pcb {
    ip_addr_t local_ip;
    ip_addr_t remote_ip;
    u8_t netif_idx;
    u8_t so_options;
    u8_t tos;
    u8_t ttl;
    struct udp_pcb * next;
    u8_t flags;
    undefined field_0x11;
    u16_t local_port;
    u16_t remote_port;
    undefined field_0x16;
    undefined field_0x17;
    ip4_addr_t mcast_ip4;
    u8_t mcast_ifindex;
    u8_t mcast_ttl;
    undefined field_0x1e;
    undefined field_0x1f;
    void (* recv)(void *, struct udp_pcb *, struct pbuf *, ip_addr_t *, u16_t);
    void * recv_arg;
};

struct tcp_pcb {
    ip_addr_t local_ip;
    ip_addr_t remote_ip;
    u8_t netif_idx;
    u8_t so_options;
    u8_t tos;
    u8_t ttl;
    struct tcp_pcb * next;
    void * callback_arg;
    enum tcp_state state;
    u8_t prio;
    u16_t local_port;
    u16_t remote_port;
    tcpflags_t flags;
    u8_t polltmr;
    u8_t pollinterval;
    u8_t last_timer;
    undefined field_0x1f;
    u32_t tmr;
    u32_t rcv_nxt;
    tcpwnd_size_t rcv_wnd;
    tcpwnd_size_t rcv_ann_wnd;
    u32_t rcv_ann_right_edge;
    s16_t rtime;
    u16_t mss;
    u32_t rttest;
    u32_t rtseq;
    s16_t sa;
    s16_t sv;
    s16_t rto;
    u8_t nrtx;
    u8_t dupacks;
    u32_t lastack;
    tcpwnd_size_t cwnd;
    tcpwnd_size_t ssthresh;
    u32_t rto_end;
    u32_t snd_nxt;
    u32_t snd_wl1;
    u32_t snd_wl2;
    u32_t snd_lbb;
    tcpwnd_size_t snd_wnd;
    tcpwnd_size_t snd_wnd_max;
    tcpwnd_size_t snd_buf;
    u16_t snd_queuelen;
    u16_t unsent_oversize;
    tcpwnd_size_t bytes_acked;
    struct tcp_seg * unsent;
    struct tcp_seg * unacked;
    struct tcp_seg * ooseq;
    struct pbuf * refused_data;
    struct tcp_pcb_listen * listener;
    err_t (* sent)(void *, struct tcp_pcb *, u16_t);
    err_t (* recv)(void *, struct tcp_pcb *, struct pbuf *, err_t);
    tcp_connected_fn connected;
    err_t (* poll)(void *, struct tcp_pcb *);
    void (* errf)(void *, err_t);
    u32_t keep_idle;
    u32_t keep_intvl;
    u32_t keep_cnt;
    u8_t persist_cnt;
    u8_t persist_backoff;
    u8_t persist_probe;
    u8_t keep_cnt_sent;
};

struct tcp_seg {
    struct tcp_seg * next;
    struct pbuf * p;
    u16_t len;
    u16_t chksum;
    u8_t chksum_swapped;
    u8_t flags;
    undefined field_0xe;
    undefined field_0xf;
    struct tcp_hdr * tcphdr;
};

struct ip_pcb {
    ip_addr_t local_ip;
    ip_addr_t remote_ip;
    u8_t netif_idx;
    u8_t so_options;
    u8_t tos;
    u8_t ttl;
};

struct pbuf {
    struct pbuf * next;
    void * payload;
    u16_t tot_len;
    u16_t len;
    u8_t type_internal;
    u8_t flags;
    u8_t ref;
    u8_t if_idx;
};

struct raw_pcb {
    ip_addr_t local_ip;
    ip_addr_t remote_ip;
    u8_t netif_idx;
    u8_t so_options;
    u8_t tos;
    u8_t ttl;
    struct raw_pcb * next;
    u8_t protocol;
    u8_t flags;
    u8_t mcast_ifindex;
    u8_t mcast_ttl;
    u8_t (* recv)(void *, struct raw_pcb *, struct pbuf *, ip_addr_t *);
    void * recv_arg;
};

typedef union anon_union.conflict1c7c2b anon_union.conflict1c7c2b, *Panon_union.conflict1c7c2b;

union anon_union.conflict1c7c2b {
    struct ip_pcb * ip;
    struct tcp_pcb * tcp;
    struct udp_pcb * udp;
    struct raw_pcb * raw;
};

typedef struct netconn.conflict1 netconn.conflict1, *Pnetconn.conflict1;

struct netconn.conflict1 {
    enum netconn_type type;
    enum netconn_state state;
    undefined field_0x2;
    undefined field_0x3;
    union anon_union.conflict1c7c2b_for_pcb pcb;
    err_t pending_err;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    sys_sem_t op_completed;
    sys_mbox_t recvmbox;
    sys_mbox_t acceptmbox;
    int socket;
    s32_t send_timeout;
    u32_t recv_timeout;
    u8_t flags;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    struct api_msg * current_msg;
    void (* callback)(struct netconn *, enum netconn_evt, u16_t);
};

typedef struct netconn.conflict netconn.conflict, *Pnetconn.conflict;

struct netconn.conflict {
    enum netconn_type type;
    enum netconn_state state;
    undefined field_0x2;
    undefined field_0x3;
    union anon_union.conflict1c7c2b_for_pcb pcb;
    err_t pending_err;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    sys_sem_t op_completed;
    sys_mbox_t recvmbox;
    sys_mbox_t acceptmbox;
    int socket;
    s32_t send_timeout;
    u32_t recv_timeout;
    u8_t flags;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    struct api_msg * current_msg;
    void (* callback)(struct netconn *, enum netconn_evt, u16_t);
};

typedef union MQTT_Connect_Header_Flags MQTT_Connect_Header_Flags, *PMQTT_Connect_Header_Flags;

typedef struct anon_struct.conflict248c12 anon_struct.conflict248c12, *Panon_struct.conflict248c12;

struct anon_struct.conflict248c12 {
    uint cleansession:1;
    uint will:1;
    uint willQoS:2;
    uint willRetain:1;
    uint password:1;
    uint username:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

union MQTT_Connect_Header_Flags {
    uint8_t all;
    struct anon_struct.conflict248c12 bits;
};

typedef union MQTT_Connack_Header_Flags MQTT_Connack_Header_Flags, *PMQTT_Connack_Header_Flags;

union MQTT_Connack_Header_Flags {
    uint8_t all;
    struct anon_struct.conflict248c12 bits;
};

typedef enum bl_sha_type_t {
    BL_SHA1=2,
    BL_SHA224=1,
    BL_SHA256=0
} bl_sha_type_t;

typedef struct bl_sha_ctx bl_sha_ctx, *Pbl_sha_ctx;

typedef struct _bl_sha_SEC_Eng_SHA256_Ctx_t _bl_sha_SEC_Eng_SHA256_Ctx_t, *P_bl_sha_SEC_Eng_SHA256_Ctx_t;

struct _bl_sha_SEC_Eng_SHA256_Ctx_t {
    uint32_t total[2];
    uint32_t * shaBuf;
    uint32_t * shaPadding;
    uint8_t shaFeed;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

struct bl_sha_ctx {
    struct _bl_sha_SEC_Eng_SHA256_Ctx_t sha_ctx;
    uint32_t tmp[16];
    uint32_t pad[16];
};

typedef struct bl_sha_ctx bl_sha_ctx_t;

typedef struct cipher_key_buf cipher_key_buf, *Pcipher_key_buf;

typedef struct cipher_key_buf cipher_key_buf_t;

typedef struct cipher_key_t cipher_key_t, *Pcipher_key_t;

typedef union ckd ckd, *Pckd;

typedef struct eapolHskData_t eapolHskData_t, *PeapolHskData_t;

typedef uchar UINT8;

typedef struct KeyData_t KeyData_t, *PKeyData_t;

typedef ulong UINT32;

typedef ushort UINT16;

struct KeyData_t {
    UINT8 Key[16];
    UINT8 RxMICKey[8];
    UINT8 TxMICKey[8];
    UINT32 TxIV32;
    UINT16 TxIV16;
    UINT16 KeyIndex;
};

struct eapolHskData_t {
    UINT8 ANonce[32];
    struct KeyData_t pwsKeyData;
};

union ckd {
    struct eapolHskData_t hskData;
};

struct cipher_key_t {
    union ckd ckd;
};

struct cipher_key_buf {
    struct cipher_key_t cipher_key;
};

typedef void * __gnuc_va_list;

typedef __gnuc_va_list va_list;

typedef struct Efuse_Device_Info_Type Efuse_Device_Info_Type, *PEfuse_Device_Info_Type;

struct Efuse_Device_Info_Type {
    uint32_t rsvd:22;
    uint32_t customerID:2;
    uint32_t rsvd_info:3;
    uint32_t memoryInfo:2;
    uint32_t coreInfo:1;
    uint32_t mcuInfo:1;
    uint32_t pinInfo:1;
};

typedef enum EF_Ctrl_SF_AES_Type {
    EF_CTRL_SF_AES_NONE=0,
    EF_CTRL_SF_AES_128=1,
    EF_CTRL_SF_AES_192=2,
    EF_CTRL_SF_AES_256=3
} EF_Ctrl_SF_AES_Type;

typedef struct Efuse_ADC_Gain_Coeff_Type Efuse_ADC_Gain_Coeff_Type, *PEfuse_ADC_Gain_Coeff_Type;

struct Efuse_ADC_Gain_Coeff_Type {
    uint32_t adcGainCoeff:12;
    uint32_t adcGainCoeffParity:1;
    uint32_t adcGainCoeffEn:1;
    uint32_t reserved:18;
};

typedef struct Efuse_Ana_RC32M_Trim_Type Efuse_Ana_RC32M_Trim_Type, *PEfuse_Ana_RC32M_Trim_Type;

struct Efuse_Ana_RC32M_Trim_Type {
    uint32_t trimRc32mCodeFrExt:8;
    uint32_t trimRc32mCodeFrExtParity:1;
    uint32_t trimRc32mExtCodeEn:1;
    uint32_t reserved:22;
};

typedef struct EF_Ctrl_Sec_Param_Type EF_Ctrl_Sec_Param_Type, *PEF_Ctrl_Sec_Param_Type;

typedef enum EF_Ctrl_Dbg_Mode_Type {
    EF_CTRL_DBG_PASSWORD=1,
    EF_CTRL_DBG_CLOSE=4,
    EF_CTRL_DBG_OPEN=0
} EF_Ctrl_Dbg_Mode_Type;

struct EF_Ctrl_Sec_Param_Type {
    enum EF_Ctrl_Dbg_Mode_Type ef_dbg_mode;
    uint8_t ef_dbg_jtag_0_dis;
    uint8_t ef_sboot_en;
    uint8_t ef_no_hd_boot_en;
};

typedef struct Efuse_Ana_RC32K_Trim_Type Efuse_Ana_RC32K_Trim_Type, *PEfuse_Ana_RC32K_Trim_Type;

struct Efuse_Ana_RC32K_Trim_Type {
    uint32_t trimRc32kCodeFrExt:10;
    uint32_t trimRc32kCodeFrExtParity:1;
    uint32_t trimRc32kExtCodeEn:1;
    uint32_t reserved:20;
};

typedef struct Efuse_Capcode_Info_Type Efuse_Capcode_Info_Type, *PEfuse_Capcode_Info_Type;

struct Efuse_Capcode_Info_Type {
    uint32_t capCode:6;
    uint32_t parity:1;
    uint32_t en:1;
    uint32_t rsvd:24;
};

typedef enum EF_Ctrl_Sign_Type {
    EF_CTRL_SIGN_ECC=2,
    EF_CTRL_SIGN_RSA=1,
    EF_CTRL_SIGN_NONE=0
} EF_Ctrl_Sign_Type;

typedef struct Efuse_TSEN_Refcode_Corner_Type Efuse_TSEN_Refcode_Corner_Type, *PEfuse_TSEN_Refcode_Corner_Type;

struct Efuse_TSEN_Refcode_Corner_Type {
    uint32_t tsenRefcodeCorner:12;
    uint32_t tsenRefcodeCornerParity:1;
    uint32_t tsenRefcodeCornerEn:1;
    uint32_t tsenRefcodeCornerVersion:1;
    uint32_t reserved:17;
};

typedef struct _TLSDataParams _TLSDataParams, *P_TLSDataParams;

typedef struct _TLSDataParams TLSDataParams;

typedef struct mbedtls_entropy_context mbedtls_entropy_context, *Pmbedtls_entropy_context;

typedef struct mbedtls_ctr_drbg_context mbedtls_ctr_drbg_context, *Pmbedtls_ctr_drbg_context;

typedef struct mbedtls_ssl_context mbedtls_ssl_context, *Pmbedtls_ssl_context;

typedef struct mbedtls_ssl_config mbedtls_ssl_config, *Pmbedtls_ssl_config;

typedef struct mbedtls_ssl_session mbedtls_ssl_session, *Pmbedtls_ssl_session;

typedef struct mbedtls_x509_crt mbedtls_x509_crt, *Pmbedtls_x509_crt;

typedef struct mbedtls_pk_context mbedtls_pk_context, *Pmbedtls_pk_context;

typedef struct mbedtls_net_context mbedtls_net_context, *Pmbedtls_net_context;

typedef struct mbedtls_sha256_context mbedtls_sha256_context, *Pmbedtls_sha256_context;

typedef struct mbedtls_entropy_source_state mbedtls_entropy_source_state, *Pmbedtls_entropy_source_state;

typedef struct mbedtls_aes_context mbedtls_aes_context, *Pmbedtls_aes_context;

typedef struct mbedtls_ssl_config.conflict mbedtls_ssl_config.conflict, *Pmbedtls_ssl_config.conflict;

typedef struct mbedtls_ssl_handshake_params mbedtls_ssl_handshake_params, *Pmbedtls_ssl_handshake_params;

typedef struct mbedtls_ssl_transform mbedtls_ssl_transform, *Pmbedtls_ssl_transform;

typedef struct mbedtls_asn1_buf mbedtls_asn1_buf, *Pmbedtls_asn1_buf;

typedef struct mbedtls_asn1_buf mbedtls_x509_buf;

typedef struct mbedtls_asn1_named_data mbedtls_asn1_named_data, *Pmbedtls_asn1_named_data;

typedef struct mbedtls_asn1_named_data mbedtls_x509_name;

typedef struct mbedtls_x509_time mbedtls_x509_time, *Pmbedtls_x509_time;

typedef struct mbedtls_asn1_sequence mbedtls_asn1_sequence, *Pmbedtls_asn1_sequence;

typedef struct mbedtls_asn1_sequence mbedtls_x509_sequence;

typedef enum mbedtls_md_type_t {
    MBEDTLS_MD_MD2=1,
    MBEDTLS_MD_MD4=2,
    MBEDTLS_MD_SHA512=8,
    MBEDTLS_MD_SHA1=4,
    MBEDTLS_MD_NONE=0,
    MBEDTLS_MD_SHA224=5,
    MBEDTLS_MD_MD5=3,
    MBEDTLS_MD_SHA256=6,
    MBEDTLS_MD_RIPEMD160=9,
    MBEDTLS_MD_SHA384=7
} mbedtls_md_type_t;

typedef enum mbedtls_pk_type_t {
    MBEDTLS_PK_ECKEY=2,
    MBEDTLS_PK_NONE=0,
    MBEDTLS_PK_RSA_ALT=5,
    MBEDTLS_PK_RSASSA_PSS=6,
    MBEDTLS_PK_ECKEY_DH=3,
    MBEDTLS_PK_ECDSA=4,
    MBEDTLS_PK_RSA=1
} mbedtls_pk_type_t;

typedef struct mbedtls_x509_crt_profile mbedtls_x509_crt_profile, *Pmbedtls_x509_crt_profile;

typedef struct mbedtls_ssl_key_cert mbedtls_ssl_key_cert, *Pmbedtls_ssl_key_cert;

typedef struct mbedtls_x509_crl mbedtls_x509_crl, *Pmbedtls_x509_crl;

typedef enum mbedtls_ecp_group_id {
    MBEDTLS_ECP_DP_SECP224R1=2,
    MBEDTLS_ECP_DP_SECP256R1=3,
    MBEDTLS_ECP_DP_SECP192R1=1,
    MBEDTLS_ECP_DP_SECP224K1=11,
    MBEDTLS_ECP_DP_SECP256K1=12,
    MBEDTLS_ECP_DP_BP512R1=8,
    MBEDTLS_ECP_DP_CURVE25519=9,
    MBEDTLS_ECP_DP_BP384R1=7,
    MBEDTLS_ECP_DP_SECP384R1=4,
    MBEDTLS_ECP_DP_SECP521R1=5,
    MBEDTLS_ECP_DP_SECP192K1=10,
    MBEDTLS_ECP_DP_BP256R1=6,
    MBEDTLS_ECP_DP_NONE=0
} mbedtls_ecp_group_id;

typedef struct mbedtls_pk_info_t mbedtls_pk_info_t, *Pmbedtls_pk_info_t;

typedef struct mbedtls_pk_debug_item mbedtls_pk_debug_item, *Pmbedtls_pk_debug_item;

typedef struct mbedtls_ssl_flight_item mbedtls_ssl_flight_item, *Pmbedtls_ssl_flight_item;

typedef struct mbedtls_ssl_ciphersuite_t mbedtls_ssl_ciphersuite_t, *Pmbedtls_ssl_ciphersuite_t;

typedef struct mbedtls_md_context_t mbedtls_md_context_t, *Pmbedtls_md_context_t;

typedef struct mbedtls_cipher_context_t mbedtls_cipher_context_t, *Pmbedtls_cipher_context_t;

typedef struct mbedtls_x509_crl_entry mbedtls_x509_crl_entry, *Pmbedtls_x509_crl_entry;

typedef enum mbedtls_pk_debug_type {
    MBEDTLS_PK_DEBUG_NONE=0,
    MBEDTLS_PK_DEBUG_ECP=2,
    MBEDTLS_PK_DEBUG_MPI=1
} mbedtls_pk_debug_type;

typedef enum mbedtls_cipher_type_t {
    MBEDTLS_CIPHER_CAMELLIA_192_CBC=21,
    MBEDTLS_CIPHER_CAMELLIA_128_CTR=26,
    MBEDTLS_CIPHER_BLOWFISH_CTR=41,
    MBEDTLS_CIPHER_CAMELLIA_256_CBC=22,
    MBEDTLS_CIPHER_AES_192_GCM=15,
    MBEDTLS_CIPHER_DES_ECB=32,
    MBEDTLS_CIPHER_AES_256_CTR=13,
    MBEDTLS_CIPHER_AES_192_CCM=44,
    MBEDTLS_CIPHER_AES_192_ECB=3,
    MBEDTLS_CIPHER_NULL=1,
    MBEDTLS_CIPHER_CAMELLIA_128_CFB128=23,
    MBEDTLS_CIPHER_CAMELLIA_128_ECB=17,
    MBEDTLS_CIPHER_BLOWFISH_ECB=38,
    MBEDTLS_CIPHER_CAMELLIA_256_CCM=48,
    MBEDTLS_CIPHER_CAMELLIA_256_ECB=19,
    MBEDTLS_CIPHER_AES_256_ECB=4,
    MBEDTLS_CIPHER_CAMELLIA_192_CFB128=24,
    MBEDTLS_CIPHER_DES_CBC=33,
    MBEDTLS_CIPHER_AES_128_CTR=11,
    MBEDTLS_CIPHER_CAMELLIA_128_CCM=46,
    MBEDTLS_CIPHER_AES_256_CCM=45,
    MBEDTLS_CIPHER_DES_EDE_CBC=35,
    MBEDTLS_CIPHER_CAMELLIA_128_GCM=29,
    MBEDTLS_CIPHER_DES_EDE3_ECB=36,
    MBEDTLS_CIPHER_AES_192_CTR=12,
    MBEDTLS_CIPHER_CAMELLIA_256_GCM=31,
    MBEDTLS_CIPHER_AES_256_GCM=16,
    MBEDTLS_CIPHER_AES_128_GCM=14,
    MBEDTLS_CIPHER_AES_128_CCM=43,
    MBEDTLS_CIPHER_CAMELLIA_128_CBC=20,
    MBEDTLS_CIPHER_BLOWFISH_CBC=39,
    MBEDTLS_CIPHER_CAMELLIA_192_CTR=27,
    MBEDTLS_CIPHER_AES_256_CBC=7,
    MBEDTLS_CIPHER_CAMELLIA_256_CTR=28,
    MBEDTLS_CIPHER_AES_128_ECB=2,
    MBEDTLS_CIPHER_AES_256_CFB128=10,
    MBEDTLS_CIPHER_DES_EDE_ECB=34,
    MBEDTLS_CIPHER_DES_EDE3_CBC=37,
    MBEDTLS_CIPHER_CAMELLIA_192_GCM=30,
    MBEDTLS_CIPHER_AES_192_CFB128=9,
    MBEDTLS_CIPHER_CAMELLIA_192_CCM=47,
    MBEDTLS_CIPHER_ARC4_128=42,
    MBEDTLS_CIPHER_CAMELLIA_192_ECB=18,
    MBEDTLS_CIPHER_AES_128_CFB128=8,
    MBEDTLS_CIPHER_BLOWFISH_CFB64=40,
    MBEDTLS_CIPHER_NONE=0,
    MBEDTLS_CIPHER_AES_128_CBC=5,
    MBEDTLS_CIPHER_CAMELLIA_256_CFB128=25,
    MBEDTLS_CIPHER_AES_192_CBC=6
} mbedtls_cipher_type_t;

typedef enum mbedtls_key_exchange_type_t {
    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA=4,
    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK=8,
    MBEDTLS_KEY_EXCHANGE_PSK=5,
    MBEDTLS_KEY_EXCHANGE_ECJPAKE=11,
    MBEDTLS_KEY_EXCHANGE_DHE_RSA=2,
    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA=10,
    MBEDTLS_KEY_EXCHANGE_RSA_PSK=7,
    MBEDTLS_KEY_EXCHANGE_ECDH_RSA=9,
    MBEDTLS_KEY_EXCHANGE_ECDHE_RSA=3,
    MBEDTLS_KEY_EXCHANGE_RSA=1,
    MBEDTLS_KEY_EXCHANGE_NONE=0,
    MBEDTLS_KEY_EXCHANGE_DHE_PSK=6
} mbedtls_key_exchange_type_t;

typedef struct mbedtls_md_info_t mbedtls_md_info_t, *Pmbedtls_md_info_t;

typedef struct mbedtls_cipher_info_t mbedtls_cipher_info_t, *Pmbedtls_cipher_info_t;

typedef enum mbedtls_operation_t {
    MBEDTLS_OPERATION_NONE=-1,
    MBEDTLS_DECRYPT=0,
    MBEDTLS_ENCRYPT=1
} mbedtls_operation_t;

typedef enum mbedtls_cipher_mode_t {
    MBEDTLS_MODE_ECB=1,
    MBEDTLS_MODE_CBC=2,
    MBEDTLS_MODE_OFB=4,
    MBEDTLS_MODE_NONE=0,
    MBEDTLS_MODE_CFB=3,
    MBEDTLS_MODE_STREAM=7,
    MBEDTLS_MODE_CCM=8,
    MBEDTLS_MODE_CTR=5,
    MBEDTLS_MODE_GCM=6
} mbedtls_cipher_mode_t;

typedef struct mbedtls_cipher_base_t mbedtls_cipher_base_t, *Pmbedtls_cipher_base_t;

typedef enum mbedtls_cipher_id_t {
    MBEDTLS_CIPHER_ID_NONE=0,
    MBEDTLS_CIPHER_ID_ARC4=7,
    MBEDTLS_CIPHER_ID_3DES=4,
    MBEDTLS_CIPHER_ID_AES=2,
    MBEDTLS_CIPHER_ID_CAMELLIA=5,
    MBEDTLS_CIPHER_ID_BLOWFISH=6,
    MBEDTLS_CIPHER_ID_NULL=1,
    MBEDTLS_CIPHER_ID_DES=3
} mbedtls_cipher_id_t;

struct mbedtls_ssl_config.conflict {
    int * ciphersuite_list[4];
    void (* f_dbg)(void *, int, char *, int, char *);
    void * p_dbg;
    int (* f_rng)(void *, uchar *, size_t);
    void * p_rng;
    int (* f_get_cache)(void *, struct mbedtls_ssl_session *);
    int (* f_set_cache)(void *, struct mbedtls_ssl_session *);
    void * p_cache;
    int (* f_sni)(void *, struct mbedtls_ssl_context *, uchar *, size_t);
    void * p_sni;
    int (* f_vrfy)(void *, struct mbedtls_x509_crt *, int, uint32_t *);
    void * p_vrfy;
    int (* f_ticket_write)(void *, struct mbedtls_ssl_session *, uchar *, uchar *, size_t *, uint32_t *);
    int (* f_ticket_parse)(void *, struct mbedtls_ssl_session *, uchar *, size_t);
    void * p_ticket;
    struct mbedtls_x509_crt_profile * cert_profile;
    struct mbedtls_ssl_key_cert * key_cert;
    struct mbedtls_x509_crt * ca_chain;
    struct mbedtls_x509_crl * ca_crl;
    int * sig_hashes;
    enum mbedtls_ecp_group_id * curve_list;
    char * * alpn_list;
    uint32_t read_timeout;
    uint32_t hs_timeout_min;
    uint32_t hs_timeout_max;
    uchar max_major_ver;
    uchar max_minor_ver;
    uchar min_major_ver;
    uchar min_minor_ver;
    uint endpoint:1;
    uint transport:1;
    uint authmode:2;
    uint allow_legacy_renegotiation:2;
    uint mfl_code:3;
    uint session_tickets:1;
    undefined field_0x76;
    undefined field_0x77;
};

struct mbedtls_asn1_buf {
    int tag;
    size_t len;
    uchar * p;
};

struct mbedtls_asn1_named_data {
    struct mbedtls_asn1_buf oid;
    struct mbedtls_asn1_buf val;
    struct mbedtls_asn1_named_data * next;
    uchar next_merged;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

struct mbedtls_aes_context {
    int nr;
    uint32_t * rk;
    uint32_t buf[68];
};

struct mbedtls_ssl_session {
    int ciphersuite;
    int compression;
    size_t id_len;
    uchar id[32];
    uchar master[48];
    struct mbedtls_x509_crt * peer_cert;
    uint32_t verify_result;
    uchar * ticket;
    size_t ticket_len;
    uint32_t ticket_lifetime;
    uchar mfl_code;
    undefined field_0x71;
    undefined field_0x72;
    undefined field_0x73;
};

struct mbedtls_x509_time {
    int year;
    int mon;
    int day;
    int hour;
    int min;
    int sec;
};

struct mbedtls_x509_crl_entry {
    mbedtls_x509_buf raw;
    mbedtls_x509_buf serial;
    struct mbedtls_x509_time revocation_date;
    mbedtls_x509_buf entry_ext;
    struct mbedtls_x509_crl_entry * next;
};

struct mbedtls_x509_crl {
    mbedtls_x509_buf raw;
    mbedtls_x509_buf tbs;
    int version;
    mbedtls_x509_buf sig_oid;
    mbedtls_x509_buf issuer_raw;
    mbedtls_x509_name issuer;
    struct mbedtls_x509_time this_update;
    struct mbedtls_x509_time next_update;
    struct mbedtls_x509_crl_entry entry;
    mbedtls_x509_buf crl_ext;
    mbedtls_x509_buf sig_oid2;
    mbedtls_x509_buf sig;
    enum mbedtls_md_type_t sig_md;
    enum mbedtls_pk_type_t sig_pk;
    undefined field_0xea;
    undefined field_0xeb;
    void * sig_opts;
    struct mbedtls_x509_crl * next;
};

struct mbedtls_ctr_drbg_context {
    uchar counter[16];
    int reseed_counter;
    int prediction_resistance;
    size_t entropy_len;
    int reseed_interval;
    struct mbedtls_aes_context aes_ctx;
    int (* f_entropy)(void *, uchar *, size_t);
    void * p_entropy;
};

struct mbedtls_ssl_context {
    struct mbedtls_ssl_config.conflict * conf;
    int state;
    int major_ver;
    int minor_ver;
    int (* f_send)(void *, uchar *, size_t);
    int (* f_recv)(void *, uchar *, size_t);
    int (* f_recv_timeout)(void *, uchar *, size_t, uint32_t);
    void * p_bio;
    struct mbedtls_ssl_session * session_in;
    struct mbedtls_ssl_session * session_out;
    struct mbedtls_ssl_session * session;
    struct mbedtls_ssl_session * session_negotiate;
    struct mbedtls_ssl_handshake_params * handshake;
    struct mbedtls_ssl_transform * transform_in;
    struct mbedtls_ssl_transform * transform_out;
    struct mbedtls_ssl_transform * transform;
    struct mbedtls_ssl_transform * transform_negotiate;
    void * p_timer;
    void (* f_set_timer)(void *, uint32_t, uint32_t);
    int (* f_get_timer)(void *);
    uchar * in_buf;
    uchar * in_ctr;
    uchar * in_hdr;
    uchar * in_len;
    uchar * in_iv;
    uchar * in_msg;
    uchar * in_offt;
    int in_msgtype;
    size_t in_msglen;
    size_t in_left;
    uint16_t in_epoch;
    undefined field_0x7a;
    undefined field_0x7b;
    size_t next_record_offset;
    size_t in_hslen;
    int nb_zero;
    int record_read;
    uchar * out_buf;
    uchar * out_ctr;
    uchar * out_hdr;
    uchar * out_len;
    uchar * out_iv;
    uchar * out_msg;
    int out_msgtype;
    size_t out_msglen;
    size_t out_left;
    int client_auth;
    char * hostname;
    char * alpn_chosen;
    int secure_renegotiation;
};

struct mbedtls_md_info_t {
    enum mbedtls_md_type_t type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * name;
    int size;
    int block_size;
    void (* starts_func)(void *);
    void (* update_func)(void *, uchar *, size_t);
    void (* finish_func)(void *, uchar *);
    void (* digest_func)(uchar *, size_t, uchar *);
    void * (* ctx_alloc_func)(void);
    void (* ctx_free_func)(void *);
    void (* clone_func)(void *, void *);
    void (* process_func)(void *, uchar *);
};

struct mbedtls_ssl_config {
    int * ciphersuite_list[4];
    void (* f_dbg)(void *, int, char *, int, char *);
    void * p_dbg;
    int (* f_rng)(void *, uchar *, size_t);
    void * p_rng;
    int (* f_get_cache)(void *, struct mbedtls_ssl_session *);
    int (* f_set_cache)(void *, struct mbedtls_ssl_session *);
    void * p_cache;
    int (* f_sni)(void *, struct mbedtls_ssl_context *, uchar *, size_t);
    void * p_sni;
    int (* f_vrfy)(void *, struct mbedtls_x509_crt *, int, uint32_t *);
    void * p_vrfy;
    int (* f_ticket_write)(void *, struct mbedtls_ssl_session *, uchar *, uchar *, size_t *, uint32_t *);
    int (* f_ticket_parse)(void *, struct mbedtls_ssl_session *, uchar *, size_t);
    void * p_ticket;
    struct mbedtls_x509_crt_profile * cert_profile;
    struct mbedtls_ssl_key_cert * key_cert;
    struct mbedtls_x509_crt * ca_chain;
    struct mbedtls_x509_crl * ca_crl;
    int * sig_hashes;
    enum mbedtls_ecp_group_id * curve_list;
    char * * alpn_list;
    uint32_t read_timeout;
    uint32_t hs_timeout_min;
    uint32_t hs_timeout_max;
    uchar max_major_ver;
    uchar max_minor_ver;
    uchar min_major_ver;
    uchar min_minor_ver;
    uint endpoint:1;
    uint transport:1;
    uint authmode:2;
    uint allow_legacy_renegotiation:2;
    uint mfl_code:3;
    uint session_tickets:1;
    undefined field_0x76;
    undefined field_0x77;
};

struct mbedtls_md_context_t {
    struct mbedtls_md_info_t * md_info;
    void * md_ctx;
    void * hmac_ctx;
};

struct mbedtls_cipher_context_t {
    struct mbedtls_cipher_info_t * cipher_info;
    int key_bitlen;
    enum mbedtls_operation_t operation;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    void (* add_padding)(uchar *, size_t, size_t);
    int (* get_padding)(uchar *, size_t, size_t *);
    uchar unprocessed_data[16];
    size_t unprocessed_len;
    uchar iv[16];
    size_t iv_size;
    void * cipher_ctx;
};

struct mbedtls_ssl_transform {
    struct mbedtls_ssl_ciphersuite_t * ciphersuite_info;
    uint keylen;
    size_t minlen;
    size_t ivlen;
    size_t fixed_ivlen;
    size_t maclen;
    uchar iv_enc[16];
    uchar iv_dec[16];
    struct mbedtls_md_context_t md_ctx_enc;
    struct mbedtls_md_context_t md_ctx_dec;
    struct mbedtls_cipher_context_t cipher_ctx_enc;
    struct mbedtls_cipher_context_t cipher_ctx_dec;
};

struct mbedtls_sha256_context {
    uint32_t total[2];
    uint32_t state[8];
    uchar buffer[64];
    int is224;
    size_t size;
    void * ali_ctx;
};

struct mbedtls_asn1_sequence {
    struct mbedtls_asn1_buf buf;
    struct mbedtls_asn1_sequence * next;
};

struct mbedtls_cipher_base_t {
    enum mbedtls_cipher_id_t cipher;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int (* ecb_func)(void *, enum mbedtls_operation_t, uchar *, uchar *);
    int (* cbc_func)(void *, enum mbedtls_operation_t, size_t, uchar *, uchar *, uchar *);
    int (* cfb_func)(void *, enum mbedtls_operation_t, size_t, size_t *, uchar *, uchar *, uchar *);
    int (* ctr_func)(void *, size_t, size_t *, uchar *, uchar *, uchar *, uchar *);
    int (* setkey_enc_func)(void *, uchar *, uint);
    int (* setkey_dec_func)(void *, uchar *, uint);
    void * (* ctx_alloc_func)(void);
    void (* ctx_free_func)(void *);
};

struct mbedtls_entropy_source_state {
    int (* f_source)(void *, uchar *, size_t, size_t *);
    void * p_source;
    size_t size;
    size_t threshold;
    int strong;
};

struct mbedtls_net_context {
    int fd;
};

struct mbedtls_ssl_ciphersuite_t {
    int id;
    char * name;
    enum mbedtls_cipher_type_t cipher;
    enum mbedtls_md_type_t mac;
    enum mbedtls_key_exchange_type_t key_exchange;
    undefined field_0xb;
    int min_major_ver;
    int min_minor_ver;
    int max_major_ver;
    int max_minor_ver;
    uchar flags;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

struct mbedtls_cipher_info_t {
    enum mbedtls_cipher_type_t type;
    enum mbedtls_cipher_mode_t mode;
    undefined field_0x2;
    undefined field_0x3;
    uint key_bitlen;
    char * name;
    uint iv_size;
    int flags;
    uint block_size;
    struct mbedtls_cipher_base_t * base;
};

struct mbedtls_pk_debug_item {
    enum mbedtls_pk_debug_type type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * name;
    void * value;
};

struct mbedtls_pk_context {
    struct mbedtls_pk_info_t * pk_info;
    void * pk_ctx;
};

struct mbedtls_x509_crt {
    mbedtls_x509_buf raw;
    mbedtls_x509_buf tbs;
    int version;
    mbedtls_x509_buf serial;
    mbedtls_x509_buf sig_oid;
    mbedtls_x509_buf issuer_raw;
    mbedtls_x509_buf subject_raw;
    mbedtls_x509_name issuer;
    mbedtls_x509_name subject;
    struct mbedtls_x509_time valid_from;
    struct mbedtls_x509_time valid_to;
    struct mbedtls_pk_context pk;
    mbedtls_x509_buf issuer_id;
    mbedtls_x509_buf subject_id;
    mbedtls_x509_buf v3_ext;
    mbedtls_x509_sequence subject_alt_names;
    int ext_types;
    int ca_istrue;
    int max_pathlen;
    uint key_usage;
    mbedtls_x509_sequence ext_key_usage;
    uchar ns_cert_type;
    undefined field_0x119;
    undefined field_0x11a;
    undefined field_0x11b;
    mbedtls_x509_buf sig;
    enum mbedtls_md_type_t sig_md;
    enum mbedtls_pk_type_t sig_pk;
    undefined field_0x12a;
    undefined field_0x12b;
    void * sig_opts;
    struct mbedtls_x509_crt * next;
};

struct mbedtls_ssl_flight_item {
    uchar * p;
    size_t len;
    uchar type;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    struct mbedtls_ssl_flight_item * next;
};

struct mbedtls_ssl_key_cert {
    struct mbedtls_x509_crt * cert;
    struct mbedtls_pk_context * key;
    struct mbedtls_ssl_key_cert * next;
};

struct mbedtls_pk_info_t {
    enum mbedtls_pk_type_t type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * name;
    size_t (* get_bitlen)(void *);
    int (* can_do)(enum mbedtls_pk_type_t);
    int (* verify_func)(void *, enum mbedtls_md_type_t, uchar *, size_t, uchar *, size_t);
    int (* sign_func)(void *, enum mbedtls_md_type_t, uchar *, size_t, uchar *, size_t *, int (* )(void *, uchar *, size_t), void *);
    int (* decrypt_func)(void *, uchar *, size_t, uchar *, size_t *, size_t, int (* )(void *, uchar *, size_t), void *);
    int (* encrypt_func)(void *, uchar *, size_t, uchar *, size_t *, size_t, int (* )(void *, uchar *, size_t), void *);
    int (* check_pair_func)(void *, void *);
    void * (* ctx_alloc_func)(void);
    void (* ctx_free_func)(void *);
    void (* debug_func)(void *, struct mbedtls_pk_debug_item *);
};

struct mbedtls_entropy_context {
    struct mbedtls_sha256_context accumulator;
    int source_count;
    struct mbedtls_entropy_source_state source[20];
};

struct mbedtls_x509_crt_profile {
    uint32_t allowed_mds;
    uint32_t allowed_pks;
    uint32_t allowed_curves;
    uint32_t rsa_min_bitlen;
};

struct mbedtls_ssl_handshake_params {
    int sig_alg;
    int verify_sig_alg;
    struct mbedtls_ssl_key_cert * key_cert;
    int sni_authmode;
    struct mbedtls_ssl_key_cert * sni_key_cert;
    struct mbedtls_x509_crt * sni_ca_chain;
    struct mbedtls_x509_crl * sni_ca_crl;
    uint out_msg_seq;
    uint in_msg_seq;
    uchar * verify_cookie;
    uchar verify_cookie_len;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
    uchar * hs_msg;
    uint32_t retransmit_timeout;
    uchar retransmit_state;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
    struct mbedtls_ssl_flight_item * flight;
    struct mbedtls_ssl_flight_item * cur_msg;
    uint in_flight_start_seq;
    struct mbedtls_ssl_transform * alt_transform_out;
    uchar alt_out_ctr[8];
    struct mbedtls_sha256_context fin_sha256;
    void (* update_checksum)(struct mbedtls_ssl_context *, uchar *, size_t);
    void (* calc_verify)(struct mbedtls_ssl_context *, uchar *);
    void (* calc_finished)(struct mbedtls_ssl_context *, uchar *, int);
    int (* tls_prf)(uchar *, size_t, char *, uchar *, size_t, uchar *, size_t);
    size_t pmslen;
    uchar randbytes[64];
    uchar premaster[48];
    int resume;
    int max_major_ver;
    int max_minor_ver;
    int cli_exts;
    int new_session_ticket;
};

struct _TLSDataParams {
    struct mbedtls_entropy_context entropy;
    struct mbedtls_ctr_drbg_context ctr_drbg;
    struct mbedtls_ssl_context ssl;
    struct mbedtls_ssl_config conf;
    uint32_t flags;
    struct mbedtls_x509_crt cacert;
    struct mbedtls_x509_crt clicert;
    struct mbedtls_pk_context pkey;
    struct mbedtls_net_context server_fd;
};

typedef enum anon_enum_16.conflict18251 {
    ROM_API_INDEX_GLB_SW_CPU_Reset=48,
    ROM_API_INDEX_SFlash_Read_Reg=98,
    ROM_API_INDEX_AON_Power_Off_LDO15_RF=15,
    ROM_API_INDEX_System_Core_Clock_Update_From_RC32M=44,
    ROM_API_INDEX_SF_Ctrl_Enable=-118,
    ROM_API_INDEX_SF_Cfg_Init_Flash_Gpio=-120,
    ROM_API_INDEX_SF_Ctrl_GetBusyState=-99,
    ME_CHAN_CONFIG_REQ=5122,
    ROM_API_INDEX_VERSION=0,
    ROM_API_INDEX_SFlash_Reset_Continue_Read=118,
    ROM_API_INDEX_BL602_Delay_MS=22,
    ROM_API_INDEX_EF_Ctrl_Sw_AHB_Clk_0=29,
    ROM_API_INDEX_GLB_Get_HCLK_Div=41,
    ROM_API_INDEX_GLB_GPIO_OUTPUT_Enable=55,
    ROM_API_INDEX_PDS_Power_Off_PLL=93,
    ROM_API_INDEX_SFlash_Erase=108,
    ROM_API_INDEX_HBN_Set_ROOT_CLK_Sel=67,
    ROM_API_INDEX_XIP_SFlash_Read_Need_Lock=-91,
    ROM_API_INDEX_XIP_SFlash_Write_With_Lock=-85,
    ROM_API_INDEX_FUNC_EMPTY_START=-80,
    HAL_RX_TIMER_BIT=64,
    ROM_API_INDEX_SFlash_Cache_Hit_Count_Get=124,
    ROM_API_INDEX_GLB_GPIO_OUTPUT_Disable=56,
    ROM_API_INDEX_GLB_Swap_Flash_Pin=53,
    ROM_API_INDEX_PDS_Select_XTAL_As_PLL_Ref=87,
    ROM_API_INDEX_SEC_Eng_Turn_On_Sec_Ring=94,
    ROM_API_INDEX_XIP_SFlash_Erase_Need_Lock=-93,
    ME_RC_STATS_CFM=5135,
    ROM_API_INDEX_HBN_Power_Off_Xtal_32K=69,
    ROM_API_INDEX_GLB_Set_System_CLK=43,
    ROM_API_INDEX_SFlash_Read_Reg_With_Cmd=-128,
    ROM_API_INDEX_SF_Cfg_Deinit_Ext_Flash_Gpio=-123,
    ROM_API_INDEX_HBN_Trim_RC32K=72,
    ME_CHAN_CONFIG_CFM=5123,
    ROM_API_INDEX_AON_Power_Off_SFReg=17,
    ROM_API_INDEX_HBN_Pin_WakeUp_Mask=74,
    ROM_API_INDEX_AON_LowPower_Exit_PDS0=19,
    ROM_API_INDEX_GLB_Get_BCLK_Div=40,
    ROM_API_INDEX_PDS_Enable_PLL_Clk=91,
    ROM_API_INDEX_SF_Ctrl_Icache2_Set=-100,
    PBUF_POOL=386,
    ROM_API_INDEX_SFlash_Busy=100,
    SCANU_RESULT_IND=4100,
    ROM_API_INDEX_HBN_Hw_Pu_Pd_Cfg=73,
    ME_RC_STATS_REQ=5134,
    ROM_API_INDEX_AON_Power_Off_BG=11,
    ROM_API_INDEX_SF_Ctrl_AES_Enable_BE=-114,
    ROM_API_INDEX_HBN_GPIO7_Dbg_Pull_Cfg=75,
    ROM_API_INDEX_SFlash_GetUniqueId=110,
    ROM_API_INDEX_GLB_Select_Internal_Flash=50,
    ROM_API_INDEX_RSVD_LAST=3,
    ME_TRAFFIC_IND_CFM=5133,
    ROM_API_INDEX_SFlash_SetSPIMode=97,
    ROM_API_INDEX_SFlash_Volatile_Reg_Write_Enable=103,
    HAL_AC2_TIMER_BIT=4,
    ROM_API_INDEX_SF_Ctrl_Is_AES_Enable=-98,
    ROM_API_INDEX_SF_Cfg_Restore_GPIO17_Fun=-122,
    HAL_IDLE_TIMER_BIT=32,
    SCANU_RAW_SEND_CFM=4102,
    ROM_API_INDEX_HBN_Enable=61,
    ROM_API_INDEX_SF_Ctrl_AES_Set_IV=-109,
    ROM_API_INDEX_SFlash_Cache_Read_Disable=126,
    ME_TX_CREDITS_UPDATE_IND=5131,
    ROM_API_INDEX_EF_Ctrl_Read_RC32M_Trim=35,
    ROM_API_INDEX_SF_Ctrl_Select_Clock=-103,
    ME_STA_ADD_CFM=5128,
    ROM_API_INDEX_AON_Power_On_XTAL=6,
    ROM_API_INDEX_GLB_Select_External_Flash=51,
    ROM_API_INDEX_BL602_MemSet4=27,
    ROM_API_INDEX_SF_Ctrl_AES_Set_IV_BE=-108,
    ROM_API_INDEX_SFlash_IDbus_Read_Enable=120,
    HAL_AC3_TIMER_BIT=8,
    ME_SET_CONTROL_PORT_CFM=5125,
    ROM_API_INDEX_BL602_MemCpy4=24,
    ROM_API_INDEX_XIP_SFlash_Read_With_Lock=-86,
    ME_CONFIG_REQ=5120,
    ME_TRAFFIC_IND_REQ=5132,
    ROM_API_INDEX_SF_Cfg_Get_Flash_Cfg_Need_Lock=-121,
    ROM_API_INDEX_L1C_Set_Wrap=77,
    ROM_API_INDEX_AON_Power_Off_LDO11_SOC=13,
    ME_STA_ADD_REQ=5127,
    ROM_API_INDEX_PDS_Select_RC32M_As_PLL_Ref=86,
    ROM_API_INDEX_EF_Ctrl_Program_Efuse_0=30,
    ROM_API_INDEX_SF_Cfg_Flash_Identify=-119,
    ROM_API_INDEX_SF_Ctrl_Set_Flash_Image_Offset=-105,
    ROM_API_INDEX_EF_Ctrl_Load_Efuse_R0=31,
    ME_TKIP_MIC_FAILURE_IND=5126,
    ROM_API_INDEX_SF_Ctrl_Icache_Set=-101,
    ROM_API_INDEX_L1C_IROM_2T_Access_Set=79,
    ROM_API_INDEX_BL602_MemCmp=28,
    ROM_API_INDEX_SF_Ctrl_AES_Set_Key_BE=-110,
    ROM_API_INDEX_SFlash_Cache_Enable_Set=121,
    ROM_API_INDEX_XIP_SFlash_GetDeviceId_Need_Lock=-89,
    ROM_API_INDEX_SF_Ctrl_Set_Clock_Delay=-96,
    PBUF_REF=65,
    ROM_API_INDEX_GLB_Set_System_CLK_Div=39,
    ROM_API_INDEX_GLB_Deswap_Flash_Pin=52,
    ME_RC_SET_RATE_REQ=5136,
    ROM_API_INDEX_SF_Ctrl_AES_Set_Key=-111,
    ROM_API_INDEX_HBN_Set_Ldo11_Aon_Vout=63,
    HAL_KE_TIMER_BIT=256,
    ROM_API_INDEX_AON_Power_On_MBG=4,
    ROM_API_INDEX_GLB_Set_SF_CLK=45,
    ROM_API_INDEX_SF_Ctrl_Get_Flash_Image_Offset=-104,
    PBUF_RAM=640,
    ROM_API_INDEX_BL602_Delay_US=21,
    ROM_API_INDEX_XIP_SFlash_Opt_Enter=-83,
    ROM_API_INDEX_PDS_Enable_PLL_All_Clks=89,
    ROM_API_INDEX_EF_Ctrl_Busy=32,
    ROM_API_INDEX_GLB_SW_System_Reset=47,
    ROM_API_INDEX_AON_Power_On_LDO15_RF=14,
    ROM_API_INDEX_XIP_SFlash_Read_Via_Cache_Need_Lock=-87,
    ROM_API_INDEX_BL602_MemCpy=23,
    SCANU_JOIN_REQ=4098,
    ROM_API_INDEX_XIP_SFlash_Opt_Exit=-82,
    HAL_AC0_TIMER_BIT=1,
    ROM_API_INDEX_SFlash_Program=109,
    ROM_API_INDEX_AON_Power_On_SFReg=16,
    ROM_API_INDEX_SF_Ctrl_AES_Disable=-106,
    ROM_API_INDEX_SF_Ctrl_AES_Enable=-107,
    ROM_API_INDEX_RSVD_1=2,
    ROM_API_INDEX_RSVD_0=1,
    ROM_API_INDEX_GLB_GPIO_Set_HZ=57,
    ROM_API_INDEX_HBN_Power_Off_RC32K=71,
    ROM_API_INDEX_AON_Power_On_BG=10,
    ROM_API_INDEX_HBN_Set_Ldo11_Soc_Vout=65,
    ME_SET_ACTIVE_CFM=5138,
    ME_MAX=5137,
    ROM_API_INDEX_XIP_SFlash_GetUniqueId_Need_Lock=-88,
    HAL_MM_TIMER_BIT=-128,
    ROM_API_INDEX_SFlash_Init=96,
    ROM_API_INDEX_SFlash_SetBurstWrap=115,
    SCANU_RAW_SEND_REQ=4101,
    ROM_API_INDEX_SFlash_Cache_Flush=122,
    ROM_API_INDEX_GLB_GPIO_Get_Fun=58,
    ROM_API_INDEX_SFlash_Restore_From_Powerdown=-126,
    ROM_API_INDEX_BFLB_Soft_CRC32=-81,
    ROM_API_INDEX_XIP_SFlash_GetJedecId_Need_Lock=-90,
    ROM_API_INDEX_SFlash_Powerdown=113,
    ROM_API_INDEX_L1C_Set_Way_Disable=78,
    ROM_API_INDEX_HBN_Power_On_RC32K=70,
    ROM_API_INDEX_AON_Get_Xtal_CapCode=8,
    ROM_API_INDEX_SFlash_GetJedecId=111,
    ROM_API_INDEX_SF_Cfg_Init_Internal_Flash_Gpio=-124,
    ROM_API_INDEX_PDS_Trim_RC32M=85,
    ME_SET_ACTIVE_REQ=5137,
    ME_CONFIG_CFM=5121,
    ROM_API_INDEX_ASM_Delay_Us=20,
    ROM_API_INDEX_SFlash_DisableBurstWrap=116,
    ROM_API_INDEX_GLB_GPIO_Init=54,
    SCANU_JOIN_CFM=4099,
    ME_SET_CONTROL_PORT_REQ=5124,
    ROM_API_INDEX_PDS_Enable=81,
    ROM_API_INDEX_PDS_Force_Config=82,
    ROM_API_INDEX_SFlash_Cache_Read_Enable=123,
    HAL_AC1_TIMER_BIT=2,
    ROM_API_INDEX_SFlash_Software_Reset=117,
    ROM_API_INDEX_XIP_SFlash_Erase_With_Lock=-84,
    SCANU_MAX=4103,
    ROM_API_INDEX_AON_LowPower_Enter_PDS0=18,
    ROM_API_INDEX_EF_Ctrl_Clear=37,
    ROM_API_INDEX_SF_Ctrl_AES_Enable_LE=-113,
    ROM_API_INDEX_XIP_SFlash_Write_Need_Lock=-92,
    ROM_API_INDEX_HBN_Power_Down_Flash=60,
    ROM_API_INDEX_HBN_32K_Sel=66,
    ROM_API_INDEX_Update_SystemCoreClockWith_XTAL=42,
    ROM_API_INDEX_GLB_SW_POR_Reset=49,
    ROM_API_INDEX_SFlash_Blk32_Erase=106,
    ROM_API_INDEX_XIP_SFlash_State_Restore=-94,
    ROM_API_INDEX_PDS_Disable_PLL_Clk=92,
    ROM_API_INDEX_XIP_SFlash_State_Save=-95,
    ROM_API_INDEX_SF_Cfg_Init_Ext_Flash_Gpio=-125,
    ROM_API_INDEX_PDS_Power_On_PLL=88,
    ROM_API_INDEX_SEC_Eng_Turn_Off_Sec_Ring=95,
    ROM_API_INDEX_SFlash_Sector_Erase=105,
    ROM_API_INDEX_SF_Ctrl_Set_Owner=-116,
    ROM_API_INDEX_HBN_Set_Embedded_Flash_Pullup=76,
    ROM_API_INDEX_SFlash_Releae_Powerdown=114,
    ROM_API_INDEX_PDS_RAM_Config=83,
    ROM_API_INDEX_SFlash_Chip_Erase=104,
    ME_STA_DEL_REQ=5129,
    ROM_API_INDEX_SFlash_Write_Reg=99,
    ROM_API_INDEX_EF_Ctrl_AutoLoad_Done=33,
    ROM_API_INDEX_SFlash_Write_Reg_With_Cmd=-127,
    ROM_API_INDEX_AON_Power_On_LDO11_SOC=12,
    ROM_API_INDEX_AON_Power_Off_XTAL=9,
    ROM_API_INDEX_SF_Ctrl_Get_Clock_Delay=-97,
    ROM_API_INDEX_SF_Ctrl_Disable=-115,
    ROM_API_INDEX_HBN_Set_Ldo11_Rt_Vout=64,
    PBUF_ROM=1,
    ME_SET_PS_DISABLE_CFM=5140,
    HAL_BCN_TIMER_BIT=16,
    ROM_API_INDEX_HBN_Reset=62,
    ROM_API_INDEX_SF_Ctrl_AES_Set_Region=-112,
    ROM_API_INDEX_PDS_Default_Level_Config=84,
    ROM_API_INDEX_GLB_Get_Root_CLK_Sel=38,
    ROM_API_INDEX_HBN_Mode_Enter=59,
    SCANU_START_CFM=4097,
    ROM_API_INDEX_EF_Ctrl_Get_Trim_Parity=34,
    ROM_API_INDEX_SFlash_Read=127,
    ROM_API_INDEX_FUNC_EMPTY_END=511,
    ROM_API_INDEX_PDS_Reset=80,
    ROM_API_INDEX_HBN_Power_On_Xtal_32K=68,
    ROM_API_INDEX_BL602_MemCpy_Fast=25,
    ROM_API_INDEX_AON_Power_Off_MBG=5,
    ROM_API_INDEX_SF_Ctrl_SendCmd=-102,
    ROM_API_INDEX_SFlash_Qspi_Enable=102,
    ROM_API_INDEX_SFlash_Blk64_Erase=107,
    ROM_API_INDEX_EF_Ctrl_Read_RC32K_Trim=36,
    ROM_API_INDEX_GLB_Set_PKA_CLK_Sel=46,
    ROM_API_INDEX_AON_Set_Xtal_CapCode=7,
    ROM_API_INDEX_SFlash_Write_Enable=101,
    ROM_API_INDEX_BL602_MemSet=26,
    ROM_API_INDEX_SFlash_GetDeviceId=112,
    ME_SET_PS_DISABLE_REQ=5139,
    ME_STA_DEL_CFM=5130,
    ROM_API_INDEX_SFlash_Cache_Miss_Count_Get=125,
    ROM_API_INDEX_SFlash_Set_IDbus_Cfg=119,
    ROM_API_INDEX_SF_Ctrl_Select_Pad=-117,
    ROM_API_INDEX_PDS_Disable_PLL_All_Clks=90,
    SCANU_START_REQ=4096
} anon_enum_16.conflict18251;

typedef struct stats_mem stats_mem, *Pstats_mem;

typedef u16_t mem_size_t;

struct stats_mem {
    u16_t err;
    mem_size_t avail;
    mem_size_t used;
    mem_size_t max;
    u16_t illegal;
};

typedef struct stats_proto stats_proto, *Pstats_proto;

struct stats_proto {
    u16_t xmit;
    u16_t recv;
    u16_t fw;
    u16_t drop;
    u16_t chkerr;
    u16_t lenerr;
    u16_t memerr;
    u16_t rterr;
    u16_t proterr;
    u16_t opterr;
    u16_t err;
    u16_t cachehit;
};

typedef struct stats_sys stats_sys, *Pstats_sys;

typedef struct stats_syselem stats_syselem, *Pstats_syselem;

struct stats_syselem {
    u16_t used;
    u16_t max;
    u16_t err;
};

struct stats_sys {
    struct stats_syselem sem;
    struct stats_syselem mutex;
    struct stats_syselem mbox;
};

typedef struct stats_ stats_, *Pstats_;

typedef struct stats_igmp stats_igmp, *Pstats_igmp;

struct stats_igmp {
    u16_t xmit;
    u16_t recv;
    u16_t drop;
    u16_t chkerr;
    u16_t lenerr;
    u16_t memerr;
    u16_t proterr;
    u16_t rx_v1;
    u16_t rx_group;
    u16_t rx_general;
    u16_t rx_report;
    u16_t tx_join;
    u16_t tx_leave;
    u16_t tx_report;
};

struct stats_ {
    struct stats_proto link;
    struct stats_proto etharp;
    struct stats_proto ip;
    struct stats_proto icmp;
    struct stats_igmp igmp;
    struct stats_proto udp;
    struct stats_proto tcp;
    struct stats_mem mem;
    undefined field_0xb6;
    undefined field_0xb7;
    struct stats_mem * memp[15];
    struct stats_sys sys;
    undefined field_0x106;
    undefined field_0x107;
};

typedef struct anon_struct.conflict1c95 anon_struct.conflict1c95, *Panon_struct.conflict1c95;

struct anon_struct.conflict1c95 {
    uint8_t priority;
    uint8_t id_dst;
    uint8_t id_msg;
    uint8_t id_src;
};

typedef union anon_union.conflict1cd3 anon_union.conflict1cd3, *Panon_union.conflict1cd3;

union anon_union.conflict1cd3 {
    void * container;
    struct anon_struct.conflict1c95 header;
};

typedef struct loop_timer loop_timer, *Ploop_timer;

typedef struct loop_ctx loop_ctx, *Ploop_ctx;

typedef struct utils_dlist_s utils_dlist_s, *Putils_dlist_s;

typedef struct utils_dlist_s utils_dlist_t;

typedef struct utils_list utils_list, *Putils_list;

typedef struct loop_evt_handler_statistic loop_evt_handler_statistic, *Ploop_evt_handler_statistic;

typedef struct loop_evt_handler loop_evt_handler, *Ploop_evt_handler;

typedef struct loop_msg loop_msg, *Ploop_msg;

typedef struct utils_list_hdr utils_list_hdr, *Putils_list_hdr;

typedef union anon_union.conflict1cd3_for_u anon_union.conflict1cd3_for_u, *Panon_union.conflict1cd3_for_u;

struct utils_dlist_s {
    struct utils_dlist_s * prev;
    struct utils_dlist_s * next;
};

struct utils_list_hdr {
    struct utils_list_hdr * next;
};

struct utils_list {
    struct utils_list_hdr * first;
    struct utils_list_hdr * last;
};

struct loop_evt_handler {
    char * name;
    int (* evt)(struct loop_ctx *, struct loop_evt_handler *, uint32_t *, uint32_t *);
    int (* handle)(struct loop_ctx *, struct loop_evt_handler *, struct loop_msg *);
};

struct loop_timer {
    utils_dlist_t dlist_item;
    uint8_t flags;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    uint time_added;
    uint time_target;
    int idx_task;
    uint32_t evt_type_map;
    void (* cb)(struct loop_ctx *, struct loop_timer *, void *);
    void * arg;
};

struct loop_evt_handler_statistic {
    uint time_max;
    uint time_consumed;
    uint time_accumulated;
    uint count_triggered;
};

struct loop_ctx {
    TaskHandle_t looper;
    uint32_t bitmap_evt_async;
    uint32_t bitmap_evt_sync;
    uint32_t bitmap_msg;
    uint32_t evt_type_map_async[32];
    uint32_t evt_type_map_sync[32];
    struct utils_list list[32];
    struct loop_evt_handler_statistic statistic[32];
    struct loop_evt_handler * handlers[32];
    utils_dlist_t timer_dlist;
    utils_dlist_t timer_dued;
};

union anon_union.conflict1cd3_for_u {
    void * container;
    struct anon_struct.conflict1c95 header;
};

struct loop_msg {
    struct utils_list_hdr item;
    union anon_union.conflict1cd3_for_u u;
    void * arg1;
    void * arg2;
    uint time_added;
    uint time_consumed;
};

typedef struct xSTATIC_QUEUE xSTATIC_QUEUE, *PxSTATIC_QUEUE;

typedef union anon_union.conflict18de60_for_u anon_union.conflict18de60_for_u, *Panon_union.conflict18de60_for_u;

typedef struct xSTATIC_LIST xSTATIC_LIST, *PxSTATIC_LIST;

typedef struct xSTATIC_LIST StaticList_t;

typedef struct xSTATIC_MINI_LIST_ITEM xSTATIC_MINI_LIST_ITEM, *PxSTATIC_MINI_LIST_ITEM;

typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;

struct xSTATIC_MINI_LIST_ITEM {
    TickType_t xDummy2;
    void * pvDummy3[2];
};

struct xSTATIC_LIST {
    UBaseType_t uxDummy2;
    void * pvDummy3;
    StaticMiniListItem_t xDummy4;
};

union anon_union.conflict18de60_for_u {
    void * pvDummy2;
    UBaseType_t uxDummy2;
};

struct xSTATIC_QUEUE {
    void * pvDummy1[3];
    union anon_union.conflict18de60_for_u u;
    StaticList_t xDummy3[2];
    UBaseType_t uxDummy4[3];
    uint8_t ucDummy5[2];
    uint8_t ucDummy6;
    undefined field_0x47;
    UBaseType_t uxDummy8;
    uint8_t ucDummy9;
    undefined field_0x4d;
    undefined field_0x4e;
    undefined field_0x4f;
};

typedef struct xSTATIC_TCB xSTATIC_TCB, *PxSTATIC_TCB;

typedef struct xSTATIC_LIST_ITEM xSTATIC_LIST_ITEM, *PxSTATIC_LIST_ITEM;

typedef struct xSTATIC_LIST_ITEM StaticListItem_t;

struct xSTATIC_LIST_ITEM {
    TickType_t xDummy2;
    void * pvDummy3[4];
};

struct xSTATIC_TCB {
    void * pxDummy1;
    StaticListItem_t xDummy3[2];
    UBaseType_t uxDummy5;
    void * pxDummy6;
    uint8_t ucDummy7[16];
    UBaseType_t uxDummy9;
    UBaseType_t uxDummy10[2];
    UBaseType_t uxDummy12[2];
    uint32_t ulDummy18;
    uint8_t ucDummy19;
    uint8_t uxDummy20;
    undefined field_0x5e;
    undefined field_0x5f;
};

typedef struct xSTATIC_STREAM_BUFFER xSTATIC_STREAM_BUFFER, *PxSTATIC_STREAM_BUFFER;

typedef struct xSTATIC_STREAM_BUFFER StaticStreamBuffer_t;

struct xSTATIC_STREAM_BUFFER {
    size_t uxDummy1[4];
    void * pvDummy2[3];
    uint8_t ucDummy3;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
    UBaseType_t uxDummy4;
};

typedef StaticStreamBuffer_t StaticMessageBuffer_t;

typedef struct xSTATIC_TCB StaticTask_t;

typedef struct xSTATIC_TIMER xSTATIC_TIMER, *PxSTATIC_TIMER;

typedef struct xSTATIC_TIMER StaticTimer_t;

struct xSTATIC_TIMER {
    void * pvDummy1;
    StaticListItem_t xDummy2;
    TickType_t xDummy3;
    void * pvDummy5;
    void (* pvDummy6)(void *);
    UBaseType_t uxDummy7;
    uint8_t ucDummy8;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
};

typedef struct xSTATIC_EVENT_GROUP xSTATIC_EVENT_GROUP, *PxSTATIC_EVENT_GROUP;

typedef struct xSTATIC_EVENT_GROUP StaticEventGroup_t;

struct xSTATIC_EVENT_GROUP {
    TickType_t xDummy1;
    StaticList_t xDummy2;
    UBaseType_t uxDummy3;
    uint8_t ucDummy4;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct xSTATIC_QUEUE StaticQueue_t;

typedef union anon_union.conflict18de60 anon_union.conflict18de60, *Panon_union.conflict18de60;

union anon_union.conflict18de60 {
    void * pvDummy2;
    UBaseType_t uxDummy2;
};

typedef StaticQueue_t StaticSemaphore_t;

typedef uchar uint8;

typedef short SINT16;

typedef char CHAR;

typedef enum Status_e {
    FW_SUCCESS=0,
    FAIL=1
} Status_e;

typedef char SINT8;

typedef void mdev_t;

typedef ulong uint32;

typedef ulonglong UINT64;

typedef int BOOLEAN;

typedef long SINT32;

typedef enum wlan_security_type {
    WLAN_SECURITY_WEP_SHARED=2,
    WLAN_SECURITY_WPA2=4,
    WLAN_SECURITY_EAP_TLS=6,
    WLAN_SECURITY_NONE=0,
    WLAN_SECURITY_WPA=3,
    WLAN_SECURITY_WPA_WPA2_MIXED=5,
    WLAN_SECURITY_WILDCARD=7,
    WLAN_SECURITY_WEP_OPEN=1
} wlan_security_type;

typedef ushort uint16;

typedef struct sm_reason_code sm_reason_code, *Psm_reason_code;

struct sm_reason_code {
    uint16_t reason_code;
    undefined field_0x2;
    undefined field_0x3;
    char * action;
};

typedef struct hw_rxhdr hw_rxhdr, *Phw_rxhdr;

typedef struct hw_vect hw_vect, *Phw_vect;

typedef int32_t s32;

struct hw_vect {
    u32.conflict len:16;
    u32.conflict reserved:8;
    u32.conflict mpdu_cnt:6;
    u32.conflict ampdu_cnt:2;
    __le32 tsf_lo;
    __le32 tsf_hi;
    u32.conflict leg_length:12;
    u32.conflict leg_rate:4;
    u32.conflict ht_length:16;
    u32.conflict _ht_length:4;
    u32.conflict short_gi:1;
    u32.conflict stbc:2;
    u32.conflict smoothing:1;
    u32.conflict mcs:7;
    u32.conflict pre_type:1;
    u32.conflict format_mod:3;
    u32.conflict ch_bw:2;
    u32.conflict n_sts:3;
    u32.conflict lsig_valid:1;
    u32.conflict sounding:1;
    u32.conflict num_extn_ss:2;
    u32.conflict aggregation:1;
    u32.conflict fec_coding:1;
    u32.conflict dyn_bw:1;
    u32.conflict doze_not_allowed:1;
    u32.conflict antenna_set:8;
    u32.conflict partial_aid:9;
    u32.conflict group_id:6;
    u32.conflict reserved_1c:1;
    s32 rssi1:8;
    s32 rssi2:8;
    s32 rssi3:8;
    s32 rssi4:8;
    u32.conflict reserved_1d:8;
    u32.conflict rcpi:8;
    u32.conflict evm1:8;
    u32.conflict evm2:8;
    u32.conflict evm3:8;
    u32.conflict evm4:8;
    u32.conflict reserved2b_1:8;
    u32.conflict reserved2b_2:8;
    u32.conflict reserved2b_3:8;
    u32.conflict rx_vect2_valid:1;
    u32.conflict resp_frame:1;
    u32.conflict decr_status:3;
    u32.conflict rx_fifo_oflow:1;
    u32.conflict undef_err:1;
    u32.conflict phy_err:1;
    u32.conflict fcs_err:1;
    u32.conflict addr_mismatch:1;
    u32.conflict ga_frame:1;
    u32.conflict current_ac:2;
    u32.conflict frm_successful_rx:1;
    u32.conflict desc_done_rx:1;
    u32.conflict key_sram_index:10;
    u32.conflict key_sram_v:1;
    u32.conflict type:2;
    u32.conflict subtype:4;
};

struct hw_rxhdr {
    struct hw_vect hwvect;
    u32.conflict phy_band:8;
    u32.conflict phy_channel_type:8;
    u32.conflict phy_prim20_freq:16;
    u32.conflict phy_center1_freq:16;
    u32.conflict phy_center2_freq:16;
    u32.conflict flags_is_amsdu:1;
    u32.conflict flags_is_80211_mpdu:1;
    u32.conflict flags_is_4addr:1;
    u32.conflict flags_new_peer:1;
    u32.conflict flags_user_prio:3;
    u32.conflict flags_rsvd0:1;
    u32.conflict flags_vif_idx:8;
    u32.conflict flags_sta_idx:8;
    u32.conflict flags_dst_idx:8;
    u32.conflict pattern;
    u32.conflict payl_offset;
    u32.conflict reserved_pad[2];
    u32.conflict wild[8];
};

typedef struct aos_hdl_t aos_hdl_t, *Paos_hdl_t;

typedef struct aos_hdl_t aos_sem_t;

struct aos_hdl_t {
    void * hdl;
};

typedef struct aos_hdl_t aos_task_t;

typedef struct aos_hdl_t aos_timer_t;

typedef struct aos_hdl_t aos_queue_t;

typedef uint aos_task_key_t;

typedef struct aos_hdl_t aos_mutex_t;

typedef struct aos_workqueue_t aos_workqueue_t, *Paos_workqueue_t;

struct aos_workqueue_t {
    void * hdl;
    void * stk;
};

typedef struct aos_hdl_t aos_work_t;

typedef struct sha256_state sha256_state, *Psha256_state;

struct sha256_state {
    UINT64 length;
    UINT32 state[8];
    UINT32 curlen;
    UINT8 buf[64];
    undefined field_0x6c;
    undefined field_0x6d;
    undefined field_0x6e;
    undefined field_0x6f;
};

typedef uint16_t ke_state_t;

typedef uint16_t ke_msg_id_t;

typedef struct ke_msg ke_msg, *Pke_msg;

typedef struct co_list_hdr co_list_hdr, *Pco_list_hdr;

typedef uint16_t ke_task_id_t;

struct co_list_hdr {
    struct co_list_hdr * next;
};

struct ke_msg {
    struct co_list_hdr hdr;
    ke_msg_id_t id;
    ke_task_id_t dest_id;
    ke_task_id_t src_id;
    uint16_t param_len;
    uint32_t[0] param;
};

typedef enum ke_msg_status_tag {
    KE_MSG_SAVED=2,
    KE_MSG_NO_FREE=1,
    KE_MSG_CONSUMED=0
} ke_msg_status_tag;

typedef enum nl80211_iftype {
    NL80211_IFTYPE_WDS=5,
    NL80211_IFTYPE_P2P_GO=9,
    NL80211_IFTYPE_P2P_DEVICE=10,
    NUM_NL80211_IFTYPES=13,
    NL80211_IFTYPE_MESH_POINT=7,
    NL80211_IFTYPE_AP_VLAN=4,
    NL80211_IFTYPE_STATION=2,
    NL80211_IFTYPE_OCB=11,
    NL80211_IFTYPE_NAN=12,
    NL80211_IFTYPE_P2P_CLIENT=8,
    NL80211_IFTYPE_AP=3,
    NL80211_IFTYPE_ADHOC=1,
    NL80211_IFTYPE_MAX=12,
    NL80211_IFTYPE_UNSPECIFIED=0,
    NL80211_IFTYPE_MONITOR=6
} nl80211_iftype;

typedef enum CFG_ELEMENT_TYPE_OPS {
    CFG_ELEMENT_TYPE_OPS_SET=0,
    CFG_ELEMENT_TYPE_OPS_RESET=2,
    CFG_ELEMENT_TYPE_OPS_DUMP_DEBUG=3,
    CFG_ELEMENT_TYPE_OPS_UNKNOWN=4,
    CFG_ELEMENT_TYPE_OPS_GET=1
} CFG_ELEMENT_TYPE_OPS;

typedef enum CFG_ELEMENT_TYPE {
    CFG_ELEMENT_TYPE_UINT8=3,
    CFG_ELEMENT_TYPE_UNKNOWN=0,
    CFG_ELEMENT_TYPE_STRING=8,
    CFG_ELEMENT_TYPE_SINT16=4,
    CFG_ELEMENT_TYPE_UINT32=7,
    CFG_ELEMENT_TYPE_BOOLEAN=1,
    CFG_ELEMENT_TYPE_SINT32=6,
    CFG_ELEMENT_TYPE_SINT8=2,
    CFG_ELEMENT_TYPE_UINT16=5
} CFG_ELEMENT_TYPE;

typedef enum td_status_bit {
    TD_STATUS_TX_PS=2,
    TD_STATUS_RX_PS=3,
    TD_STATUS_RX=1,
    TD_STATUS_TX=0
} td_status_bit;

typedef struct td_env_tag td_env_tag, *Ptd_env_tag;

typedef struct mm_timer_tag mm_timer_tag, *Pmm_timer_tag;

struct mm_timer_tag {
    struct co_list_hdr list_hdr;
    void (* cb)(void *);
    void * env;
    uint32_t time;
};

struct td_env_tag {
    struct mm_timer_tag td_timer;
    uint32_t pck_cnt_tx;
    uint32_t pck_cnt_rx;
    uint32_t pck_cnt_tx_ps;
    uint32_t pck_cnt_rx_ps;
    uint8_t vif_index;
    uint8_t status;
    _Bool is_on;
    _Bool has_active_chan;
};

typedef struct RSNConfig_t RSNConfig_t, *PRSNConfig_t;

typedef struct SecurityMode_t SecurityMode_t, *PSecurityMode_t;

typedef struct Cipher_t Cipher_t, *PCipher_t;

typedef struct AkmSuite_t AkmSuite_t, *PAkmSuite_t;

typedef struct IEEEtypes_RSNCapability_t IEEEtypes_RSNCapability_t, *PIEEEtypes_RSNCapability_t;

typedef enum AkmType_e {
    AKM_NONE=0,
    AKM_CCKM=99,
    AKM_1X=1,
    AKM_SUITE_MAX=5,
    AKM_PSK=2,
    AKM_SHA256_PSK=6,
    AKM_TDLS=7,
    AKM_RSN_MAX=6,
    AKM_SHA256_1X=5,
    AKM_FT_1X=3,
    AKM_WPA_MAX=2,
    AKM_FT_PSK=4
} AkmType_e;

typedef enum AkmType_e AkmTypePacked_e;

struct Cipher_t {
    UINT8 wep40:1;
    UINT8 wep104:1;
    UINT8 tkip:1;
    UINT8 ccmp:1;
    UINT8 rsvd:4;
};

struct AkmSuite_t {
    UINT8 akmOui[3];
    AkmTypePacked_e akmType;
};

struct SecurityMode_t {
    UINT16 noRsn:1;
    UINT16 wepStatic:1;
    UINT16 wepDynamic:1;
    UINT16 wpa:1;
    UINT16 wpaNone:1;
    UINT16 wpa2:1;
    UINT16 cckm:1;
    UINT16 wapi:1;
    UINT16 wpa3:1;
    UINT16 rsvd:7;
};

struct IEEEtypes_RSNCapability_t {
    UINT8 PreAuth:1;
    UINT8 NoPairwise:1;
    UINT8 PtksaReplayCtr:2;
    UINT8 GtksaReplayCtr:2;
    UINT8 MFPR:1;
    UINT8 MFPC:1;
    UINT8 Reserved_8:1;
    UINT8 PeerkeyEnabled:1;
    UINT8 SppAmsduCap:1;
    UINT8 SppAmsduReq:1;
    UINT8 PBAC:1;
    UINT8 Reserved_13_15:3;
};

struct RSNConfig_t {
    UINT8 RSNEnabled:1;
    UINT8 pmkidValid:1;
    UINT8 rsnCapValid:1;
    UINT8 grpMgmtCipherValid:1;
    UINT8 rsvd:4;
    struct SecurityMode_t wpaType;
    struct Cipher_t mcstCipher;
    struct Cipher_t ucstCipher;
    struct AkmSuite_t AKM;
    UINT8 PMKID[16];
    struct IEEEtypes_RSNCapability_t rsnCap;
    struct Cipher_t grpMgmtCipher;
};

typedef enum flag {
    FL_MINUS=2,
    FL_TICK=8,
    FL_SPACE=16,
    FL_UPPER=-128,
    FL_PLUS=4,
    FL_HASH=32,
    FL_ZERO=1,
    FL_SIGNED=64
} flag;

typedef enum ranks {
    rank_char=-2,
    rank_longlong=2,
    rank_long=1,
    rank_int=0,
    rank_short=-1
} ranks;

typedef enum anon_enum_8.conflict25d103 {
    st_prec=3,
    st_modifiers=4,
    st_normal=0,
    st_width=2,
    st_flags=1
} anon_enum_8.conflict25d103;

typedef struct mac_addr.conflict mac_addr.conflict, *Pmac_addr.conflict;

typedef uint8_t u8_l;

struct mac_addr.conflict {
    u8_l array[6];
};

typedef struct tmrTimerControl tmrTimerControl, *PtmrTimerControl;

typedef struct tmrTimerControl * TimerHandle_t;

struct tmrTimerControl {
    char * pcTimerName;
    ListItem_t xTimerListItem;
    TickType_t xTimerPeriodInTicks;
    void * pvTimerID;
    void (* pxCallbackFunction)(TimerHandle_t);
    UBaseType_t uxTimerNumber;
    uint8_t ucStatus;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
};

typedef struct scanu_env_tag scanu_env_tag, *Pscanu_env_tag;

typedef struct scanu_start_req scanu_start_req, *Pscanu_start_req;

typedef struct hal_dma_desc_tag hal_dma_desc_tag, *Phal_dma_desc_tag;

typedef struct mac_scan_result mac_scan_result, *Pmac_scan_result;

typedef struct mac_addr mac_addr, *Pmac_addr;

typedef struct mac_ssid mac_ssid, *Pmac_ssid;

typedef struct scan_chan_tag scan_chan_tag, *Pscan_chan_tag;

typedef uint32_t u32_l;

typedef uint16_t u16_l;

typedef struct dma_desc dma_desc, *Pdma_desc;

struct hal_dma_desc_tag {
    struct co_list_hdr hdr;
    struct dma_desc * dma_desc;
    void (* cb)(void *, int);
    void * env;
};

struct dma_desc {
    uint32_t src;
    uint32_t dest;
    uint16_t length;
    uint16_t ctrl;
    uint32_t next;
};

struct mac_addr {
    uint16_t array[3];
};

struct mac_ssid {
    uint8_t length;
    uint8_t array[32];
    uint8_t array_tail[1];
};

struct scan_chan_tag {
    uint16_t freq;
    uint8_t band;
    uint8_t flags;
    int8_t tx_power;
    undefined field_0x5;
};

struct scanu_start_req {
    struct scan_chan_tag chan[42];
    struct mac_ssid ssid[2];
    struct mac_addr.conflict bssid;
    undefined field_0x146;
    undefined field_0x147;
    u32_l add_ies;
    u16_l add_ie_len;
    u8_l vif_idx;
    u8_l chan_cnt;
    u8_l ssid_cnt;
    _Bool no_cck;
    undefined field_0x152;
    undefined field_0x153;
};

struct mac_scan_result {
    struct mac_addr bssid;
    struct mac_ssid ssid;
    uint16_t bsstype;
    undefined field_0x2a;
    undefined field_0x2b;
    struct scan_chan_tag * chan;
    uint16_t beacon_period;
    uint16_t cap_info;
    _Bool valid_flag;
    int8_t rssi;
    int8_t ppm_rel;
    int8_t ppm_abs;
};

struct scanu_env_tag {
    struct scanu_start_req * param;
    struct hal_dma_desc_tag dma_desc;
    uint16_t result_cnt;
    undefined field_0x16;
    undefined field_0x17;
    struct mac_scan_result scan_result[6];
    ke_task_id_t src_id;
    _Bool joining;
    uint8_t band;
    struct mac_addr bssid;
    struct mac_ssid ssid;
};

typedef struct scanu_add_ie_tag scanu_add_ie_tag, *Pscanu_add_ie_tag;

struct scanu_add_ie_tag {
    struct dma_desc dma_desc;
    uint32_t buf[50];
};

typedef enum HBN_PIR_HPF_Type {
    HBN_PIR_HPF_METHOD1=1,
    HBN_PIR_HPF_METHOD2=2,
    HBN_PIR_HPF_METHOD0=0
} HBN_PIR_HPF_Type;

typedef enum HBN_ROOT_CLK_Type {
    HBN_ROOT_CLK_PLL=2,
    HBN_ROOT_CLK_RC32M=0,
    HBN_ROOT_CLK_XTAL=1
} HBN_ROOT_CLK_Type;

typedef enum HBN_OUT0_INT_Type {
    HBN_OUT0_INT_GPIO8=1,
    HBN_OUT0_INT_GPIO7=0,
    HBN_OUT0_INT_RTC=2
} HBN_OUT0_INT_Type;

typedef enum HBN_LDO_LEVEL_Type {
    HBN_LDO_LEVEL_0P90V=6,
    HBN_LDO_LEVEL_0P80V=4,
    HBN_LDO_LEVEL_1P30V=14,
    HBN_LDO_LEVEL_1P20V=12,
    HBN_LDO_LEVEL_1P10V=10,
    HBN_LDO_LEVEL_1P00V=8,
    HBN_LDO_LEVEL_0P65V=1,
    HBN_LDO_LEVEL_1P35V=15,
    HBN_LDO_LEVEL_1P25V=13,
    HBN_LDO_LEVEL_0P85V=5,
    HBN_LDO_LEVEL_1P15V=11,
    HBN_LDO_LEVEL_0P75V=3,
    HBN_LDO_LEVEL_1P05V=9,
    HBN_LDO_LEVEL_0P95V=7,
    HBN_LDO_LEVEL_0P70V=2,
    HBN_LDO_LEVEL_0P60V=0
} HBN_LDO_LEVEL_Type;

typedef enum HBN_XCLK_CLK_Type {
    HBN_XCLK_CLK_XTAL=1,
    HBN_XCLK_CLK_RC32M=0
} HBN_XCLK_CLK_Type;

typedef enum HBN_BOR_THRES_Type {
    HBN_BOR_THRES_2P0V=0,
    HBN_BOR_THRES_2P4V=1
} HBN_BOR_THRES_Type;

typedef enum HBN_LEVEL_Type {
    HBN_LEVEL_3=3,
    HBN_LEVEL_2=2,
    HBN_LEVEL_1=1,
    HBN_LEVEL_0=0
} HBN_LEVEL_Type;

typedef enum HBN_GPIO_INT_Trigger_Type {
    HBN_GPIO_INT_TRIGGER_ASYNC_RISING_EDGE=5,
    HBN_GPIO_INT_TRIGGER_ASYNC_LOW_LEVEL=6,
    HBN_GPIO_INT_TRIGGER_SYNC_RISING_EDGE=1,
    HBN_GPIO_INT_TRIGGER_ASYNC_FALLING_EDGE=4,
    HBN_GPIO_INT_TRIGGER_SYNC_HIGH_LEVEL=3,
    HBN_GPIO_INT_TRIGGER_SYNC_FALLING_EDGE=0,
    HBN_GPIO_INT_TRIGGER_SYNC_LOW_LEVEL=2,
    HBN_GPIO_INT_TRIGGER_ASYNC_HIGH_LEVEL=7
} HBN_GPIO_INT_Trigger_Type;

typedef enum HBN_UART_CLK_Type {
    HBN_UART_CLK_FCLK=0,
    HBN_UART_CLK_160M=1
} HBN_UART_CLK_Type;

typedef enum HBN_INT_Type {
    HBN_INT_RTC=16,
    HBN_INT_GPIO8=1,
    HBN_INT_GPIO7=0,
    HBN_INT_PIR=17,
    HBN_INT_ACOMP1=22,
    HBN_INT_BOR=18,
    HBN_INT_ACOMP0=20
} HBN_INT_Type;

typedef enum HBN_OUT1_INT_Type {
    HBN_OUT1_INT_PIR=0,
    HBN_OUT1_INT_ACOMP1=3,
    HBN_OUT1_INT_BOR=1,
    HBN_OUT1_INT_ACOMP0=2
} HBN_OUT1_INT_Type;

typedef struct HBN_APP_CFG_Type HBN_APP_CFG_Type, *PHBN_APP_CFG_Type;

typedef struct SPI_Flash_Cfg_Type SPI_Flash_Cfg_Type, *PSPI_Flash_Cfg_Type;

struct HBN_APP_CFG_Type {
    uint8_t useXtal32k;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t sleepTime;
    uint8_t gpioWakeupSrc;
    enum HBN_GPIO_INT_Trigger_Type gpioTrigType;
    undefined field_0xa;
    undefined field_0xb;
    struct SPI_Flash_Cfg_Type * flashCfg;
    enum HBN_LEVEL_Type hbnLevel;
    enum HBN_LDO_LEVEL_Type ldoLevel;
    undefined field_0x12;
    undefined field_0x13;
};

struct SPI_Flash_Cfg_Type {
    uint8_t ioMode;
    uint8_t cReadSupport;
    uint8_t clkDelay;
    uint8_t clkInvert;
    uint8_t resetEnCmd;
    uint8_t resetCmd;
    uint8_t resetCreadCmd;
    uint8_t resetCreadCmdSize;
    uint8_t jedecIdCmd;
    uint8_t jedecIdCmdDmyClk;
    uint8_t qpiJedecIdCmd;
    uint8_t qpiJedecIdCmdDmyClk;
    uint8_t sectorSize;
    uint8_t mid;
    uint16_t pageSize;
    uint8_t chipEraseCmd;
    uint8_t sectorEraseCmd;
    uint8_t blk32EraseCmd;
    uint8_t blk64EraseCmd;
    uint8_t writeEnableCmd;
    uint8_t pageProgramCmd;
    uint8_t qpageProgramCmd;
    uint8_t qppAddrMode;
    uint8_t fastReadCmd;
    uint8_t frDmyClk;
    uint8_t qpiFastReadCmd;
    uint8_t qpiFrDmyClk;
    uint8_t fastReadDoCmd;
    uint8_t frDoDmyClk;
    uint8_t fastReadDioCmd;
    uint8_t frDioDmyClk;
    uint8_t fastReadQoCmd;
    uint8_t frQoDmyClk;
    uint8_t fastReadQioCmd;
    uint8_t frQioDmyClk;
    uint8_t qpiFastReadQioCmd;
    uint8_t qpiFrQioDmyClk;
    uint8_t qpiPageProgramCmd;
    uint8_t writeVregEnableCmd;
    uint8_t wrEnableIndex;
    uint8_t qeIndex;
    uint8_t busyIndex;
    uint8_t wrEnableBit;
    uint8_t qeBit;
    uint8_t busyBit;
    uint8_t wrEnableWriteRegLen;
    uint8_t wrEnableReadRegLen;
    uint8_t qeWriteRegLen;
    uint8_t qeReadRegLen;
    uint8_t releasePowerDown;
    uint8_t busyReadRegLen;
    uint8_t readRegCmd[4];
    uint8_t writeRegCmd[4];
    uint8_t enterQpi;
    uint8_t exitQpi;
    uint8_t cReadMode;
    uint8_t cRExit;
    uint8_t burstWrapCmd;
    uint8_t burstWrapCmdDmyClk;
    uint8_t burstWrapDataMode;
    uint8_t burstWrapData;
    uint8_t deBurstWrapCmd;
    uint8_t deBurstWrapCmdDmyClk;
    uint8_t deBurstWrapDataMode;
    uint8_t deBurstWrapData;
    uint16_t timeEsector;
    uint16_t timeE32k;
    uint16_t timeE64k;
    uint16_t timePagePgm;
    uint16_t timeCe;
    uint8_t pdDelay;
    uint8_t qeData;
};

typedef struct HBN_BOR_CFG_Type HBN_BOR_CFG_Type, *PHBN_BOR_CFG_Type;

struct HBN_BOR_CFG_Type {
    uint8_t enableBor;
    uint8_t enableBorInt;
    uint8_t borThreshold;
    uint8_t enablePorInBor;
};

typedef enum HBN_PIR_LPF_Type {
    HBN_PIR_LPF_DIV1=0,
    HBN_PIR_LPF_DIV2=1
} HBN_PIR_LPF_Type;

typedef struct HBN_PIR_INT_CFG_Type HBN_PIR_INT_CFG_Type, *PHBN_PIR_INT_CFG_Type;

typedef enum BL_Fun_Type {
    DISABLE=0,
    ENABLE=1
} BL_Fun_Type;

struct HBN_PIR_INT_CFG_Type {
    enum BL_Fun_Type lowIntEn;
    enum BL_Fun_Type highIntEn;
};

typedef enum HBN_BOR_MODE_Type {
    HBN_BOR_MODE_POR_INDEPENDENT=0,
    HBN_BOR_MODE_POR_RELEVANT=1
} HBN_BOR_MODE_Type;

typedef enum HBN_RTC_INT_Delay_Type {
    HBN_RTC_INT_DELAY_0T=1,
    HBN_RTC_INT_DELAY_32T=0
} HBN_RTC_INT_Delay_Type;

typedef enum HBN_32K_CLK_Type {
    HBN_32K_XTAL=1,
    HBN_32K_RC=0,
    HBN_32K_DIG=3
} HBN_32K_CLK_Type;

typedef struct tmrTimerQueueMessage tmrTimerQueueMessage, *PtmrTimerQueueMessage;

typedef struct tmrTimerQueueMessage DaemonTaskMessage_t;

typedef int32_t BaseType_t;

typedef union anon_union.conflict196a82_for_u anon_union.conflict196a82_for_u, *Panon_union.conflict196a82_for_u;

typedef struct tmrTimerParameters tmrTimerParameters, *PtmrTimerParameters;

typedef struct tmrTimerParameters TimerParameter_t;

typedef struct tmrCallbackParameters tmrCallbackParameters, *PtmrCallbackParameters;

typedef struct tmrCallbackParameters CallbackParameters_t;

typedef struct tmrTimerControl xTIMER;

typedef xTIMER Timer_t;

struct tmrTimerParameters {
    TickType_t xMessageValue;
    Timer_t * pxTimer;
};

struct tmrCallbackParameters {
    void (* pxCallbackFunction)(void *, uint32_t);
    void * pvParameter1;
    uint32_t ulParameter2;
};

union anon_union.conflict196a82_for_u {
    TimerParameter_t xTimerParameters;
    CallbackParameters_t xCallbackParameters;
};

struct tmrTimerQueueMessage {
    BaseType_t xMessageID;
    union anon_union.conflict196a82_for_u u;
};

typedef union anon_union.conflict196a82 anon_union.conflict196a82, *Panon_union.conflict196a82;

union anon_union.conflict196a82 {
    TimerParameter_t xTimerParameters;
    CallbackParameters_t xCallbackParameters;
};

typedef enum ranks.conflict {
    rank_char=-2,
    rank_longlong=2,
    rank_long=1,
    rank_ptr=2147483647,
    rank_int=0,
    rank_short=-1
} ranks.conflict;

typedef enum flag.conflict {
    FL_MINUS=8,
    FL_SPLAT=1,
    FL_INV=2,
    FL_WIDTH=4
} flag.conflict;

typedef enum bail {
    bail_err=2,
    bail_eof=1,
    bail_none=0
} bail;

typedef enum anon_enum_8.conflict25ef9d {
    st_modifiers=3,
    st_match=5,
    st_match_range=6,
    st_normal=0,
    st_match_init=4,
    st_width=2,
    st_flags=1
} anon_enum_8.conflict25ef9d;

typedef struct ADC_MIC_Type ADC_MIC_Type, *PADC_MIC_Type;

typedef enum ADC_MICBOOST_DB_Type {
    ADC_MICBOOST_DB_32DB=1,
    ADC_MICBOOST_DB_16DB=0
} ADC_MICBOOST_DB_Type;

typedef enum ADC_PGA2_GAIN_Type {
    ADC_PGA2_GAIN_0DB=0,
    ADC_PGA2_GAIN_N6DB=2,
    ADC_PGA2_GAIN_6DB=1,
    ADC_PGA2_GAIN_12DB=3
} ADC_PGA2_GAIN_Type;

typedef enum ADC_MIC_MODE_Type {
    ADC_MIC_MODE_DIFF=1,
    ADC_MIC_MODE_SINGLE=0
} ADC_MIC_MODE_Type;

struct ADC_MIC_Type {
    enum ADC_MICBOOST_DB_Type micboostDb;
    enum ADC_PGA2_GAIN_Type micPga2Gain;
    enum ADC_MIC_MODE_Type mic1Mode;
    enum ADC_MIC_MODE_Type mic2Mode;
    enum BL_Fun_Type dwaEn;
    enum BL_Fun_Type micboostBypassEn;
    enum BL_Fun_Type micPgaEn;
    enum BL_Fun_Type micBiasEn;
};

typedef enum ADC_TSEN_MOD_Type {
    ADC_TSEN_MOD_EXTERNAL_DIODE=1,
    ADC_TSEN_MOD_INTERNAL_DIODE=0
} ADC_TSEN_MOD_Type;

typedef enum ADC_V11_SEL_Type {
    ADC_V11_SEL_1P26V=3,
    ADC_V11_SEL_1P0V=0,
    ADC_V11_SEL_1P18V=2,
    ADC_V11_SEL_1P1V=1
} ADC_V11_SEL_Type;

typedef enum ADC_SIG_INPUT_Type {
    ADC_INPUT_SINGLE_END=0,
    ADC_INPUT_DIFF=1
} ADC_SIG_INPUT_Type;

typedef struct ADC_FIFO_Cfg_Type ADC_FIFO_Cfg_Type, *PADC_FIFO_Cfg_Type;

typedef enum ADC_FIFO_Threshold_Type {
    ADC_FIFO_THRESHOLD_16=3,
    ADC_FIFO_THRESHOLD_8=2,
    ADC_FIFO_THRESHOLD_1=0,
    ADC_FIFO_THRESHOLD_4=1
} ADC_FIFO_Threshold_Type;

struct ADC_FIFO_Cfg_Type {
    enum ADC_FIFO_Threshold_Type fifoThreshold;
    enum BL_Fun_Type dmaEn;
};

typedef enum ADC_Data_Width_Type {
    ADC_DATA_WIDTH_14_WITH_16_AVERAGE=1,
    ADC_DATA_WIDTH_12=0,
    ADC_DATA_WIDTH_16_WITH_64_AVERAGE=2,
    ADC_DATA_WIDTH_16_WITH_128_AVERAGE=3,
    ADC_DATA_WIDTH_16_WITH_256_AVERAGE=4
} ADC_Data_Width_Type;

typedef enum ADC_CLK_Type {
    ADC_CLK_DIV_1=0,
    ADC_CLK_DIV_4=1,
    ADC_CLK_DIV_12=3,
    ADC_CLK_DIV_20=5,
    ADC_CLK_DIV_32=7,
    ADC_CLK_DIV_8=2,
    ADC_CLK_DIV_16=4,
    ADC_CLK_DIV_24=6
} ADC_CLK_Type;

typedef enum ADC_Chan_Type {
    ADC_CHAN0=0,
    ADC_CHAN_SENP3=19,
    ADC_CHAN_SENP2=20,
    ADC_CHAN_GND=23,
    ADC_CHAN_TSEN_P=14,
    ADC_CHAN11=11,
    ADC_CHAN10=10,
    ADC_CHAN_TSEN_N=15,
    ADC_CHAN_VREF=16,
    ADC_CHAN_VABT_HALF=18,
    ADC_CHAN_DAC_OUTA=12,
    ADC_CHAN9=9,
    ADC_CHAN_DAC_OUTB=13,
    ADC_CHAN8=8,
    ADC_CHAN7=7,
    ADC_CHAN6=6,
    ADC_CHAN_DCTEST=17,
    ADC_CHAN5=5,
    ADC_CHAN4=4,
    ADC_CHAN_SENP1=21,
    ADC_CHAN3=3,
    ADC_CHAN_SENP0=22,
    ADC_CHAN2=2,
    ADC_CHAN1=1
} ADC_Chan_Type;

typedef enum ADC_CHOP_MOD_Type {
    ADC_CHOP_MOD_AZ_PGA_ON=2,
    ADC_CHOP_MOD_AZ_ON=1,
    ADC_CHOP_MOD_AZ_PGA_RPC_ON=3,
    ADC_CHOP_MOD_ALL_OFF=0
} ADC_CHOP_MOD_Type;

typedef struct ADC_CFG_Type ADC_CFG_Type, *PADC_CFG_Type;

typedef enum ADC_V18_SEL_Type {
    ADC_V18_SEL_1P72V=1,
    ADC_V18_SEL_1P82V=2,
    ADC_V18_SEL_1P62V=0,
    ADC_V18_SEL_1P92V=3
} ADC_V18_SEL_Type;

typedef enum ADC_PGA_GAIN_Type {
    ADC_PGA_GAIN_32=6,
    ADC_PGA_GAIN_2=2,
    ADC_PGA_GAIN_1=1,
    ADC_PGA_GAIN_16=5,
    ADC_PGA_GAIN_4=3,
    ADC_PGA_GAIN_NONE=0,
    ADC_PGA_GAIN_8=4
} ADC_PGA_GAIN_Type;

typedef enum ADC_BIAS_SEL_Type {
    ADC_BIAS_SEL_AON_BANDGAP=1,
    ADC_BIAS_SEL_MAIN_BANDGAP=0
} ADC_BIAS_SEL_Type;

typedef enum ADC_PGA_VCM_Type {
    ADC_PGA_VCM_1P2V=1,
    ADC_PGA_VCM_1V=0,
    ADC_PGA_VCM_1P4V=2,
    ADC_PGA_VCM_1P6V=3
} ADC_PGA_VCM_Type;

typedef enum ADC_VREF_Type {
    ADC_VREF_3P2V=0,
    ADC_VREF_2V=1
} ADC_VREF_Type;

struct ADC_CFG_Type {
    enum ADC_V18_SEL_Type v18Sel;
    enum ADC_V11_SEL_Type v11Sel;
    enum ADC_CLK_Type clkDiv;
    enum ADC_PGA_GAIN_Type gain1;
    enum ADC_PGA_GAIN_Type gain2;
    enum ADC_CHOP_MOD_Type chopMode;
    enum ADC_BIAS_SEL_Type biasSel;
    enum ADC_PGA_VCM_Type vcm;
    enum ADC_VREF_Type vref;
    enum ADC_SIG_INPUT_Type inputMode;
    enum ADC_Data_Width_Type resWidth;
    enum BL_Fun_Type offsetCalibEn;
    int16_t offsetCalibVal;
};

typedef enum ADC_INT_Type {
    ADC_INT_ADC_READY=4,
    ADC_INT_FIFO_UNDERRUN=2,
    ADC_INT_NEG_SATURATION=1,
    ADC_INT_FIFO_OVERRUN=3,
    ADC_INT_ALL=5,
    ADC_INT_POS_SATURATION=0
} ADC_INT_Type;

typedef struct ADC_Result_Type ADC_Result_Type, *PADC_Result_Type;

struct ADC_Result_Type {
    int8_t posChan;
    int8_t negChan;
    uint16_t value;
    float volt;
};

typedef struct ADC_Gain_Coeff_Type ADC_Gain_Coeff_Type, *PADC_Gain_Coeff_Type;

struct ADC_Gain_Coeff_Type {
    enum BL_Fun_Type adcGainCoeffEnable;
    undefined field_0x1;
    uint16_t adcgainCoeffVal;
    float coe;
};

typedef struct ipc_a2e_msg ipc_a2e_msg, *Pipc_a2e_msg;

struct ipc_a2e_msg {
    uint32_t dummy_word;
    uint32_t msg[127];
};

typedef struct ipc_e2a_msg ipc_e2a_msg, *Pipc_e2a_msg;

struct ipc_e2a_msg {
    u16_l id;
    u16_l dummy_dest_id;
    u16_l dummy_src_id;
    u16_l param_len;
    u32_l param[245];
    u32_l pattern;
};

typedef struct ipc_shared_env_tag ipc_shared_env_tag, *Pipc_shared_env_tag;

typedef struct txdesc_host txdesc_host, *Ptxdesc_host;

typedef struct hostdesc hostdesc, *Phostdesc;

struct hostdesc {
    uint32_t pbuf_addr;
    u32_l packet_addr;
    u16_l packet_len;
    undefined field_0xa;
    undefined field_0xb;
    u32_l status_addr;
    struct mac_addr.conflict eth_dest_addr;
    struct mac_addr.conflict eth_src_addr;
    u16_l ethertype;
    u16_l pn[4];
    u16_l sn;
    u16_l timestamp;
    u8_l tid;
    u8_l vif_idx;
    u8_l staid;
    undefined field_0x2d;
    u16_l flags;
    u32_l pbuf_chained_ptr[4];
    u32_l pbuf_chained_len[4];
};

struct txdesc_host {
    uint32_t ready;
    struct hostdesc host;
    uint32_t pad_txdesc[55];
    uint32_t pad_buf[128];
};

struct ipc_shared_env_tag {
    struct ipc_a2e_msg msg_a2e_buf;
    uint32_t pattern_addr;
    struct txdesc_host txdesc0[4];
};

typedef struct anon_struct.conflict34b4e anon_struct.conflict34b4e, *Panon_struct.conflict34b4e;

struct anon_struct.conflict34b4e {
    uint32_t vbcore;
    uint32_t iet;
    uint32_t vbcore_11n;
    uint32_t iet_11n;
    uint32_t vbcore_11g;
    uint32_t iet_11g;
    uint32_t vbcore_11b;
    uint32_t iet_11b;
    uint32_t lo_fbdv_halfstep_en;
    uint32_t lo_fbdv_halfstep_en_tx;
    uint32_t lo_fbdv_halfstep_en_rx;
    uint32_t clkpll_reset_postdiv;
    uint32_t clkpll_dither_sel;
};

typedef struct regs_to_opti regs_to_opti, *Pregs_to_opti;

struct regs_to_opti {
    uint32_t vbcore;
    uint32_t iet;
    uint32_t vbcore_11n;
    uint32_t iet_11n;
    uint32_t vbcore_11g;
    uint32_t iet_11g;
    uint32_t vbcore_11b;
    uint32_t iet_11b;
    uint32_t lo_fbdv_halfstep_en;
    uint32_t lo_fbdv_halfstep_en_tx;
    uint32_t lo_fbdv_halfstep_en_rx;
    uint32_t clkpll_reset_postdiv;
    uint32_t clkpll_dither_sel;
};

typedef struct tx_pwr_index tx_pwr_index, *Ptx_pwr_index;

struct tx_pwr_index {
    uint32_t index;
    int32_t dvga;
};

typedef struct anon_struct.conflict34ac0 anon_struct.conflict34ac0, *Panon_struct.conflict34ac0;

struct anon_struct.conflict34ac0 {
    uint32_t index;
    int32_t dvga;
};

typedef struct notch_param notch_param, *Pnotch_param;

struct notch_param {
    uint32_t notch_en;
    int32_t spur_freq;
};

typedef struct anon_struct.conflict2d12e6 anon_struct.conflict2d12e6, *Panon_struct.conflict2d12e6;

struct anon_struct.conflict2d12e6 {
    uint frac0:32;
    uint frac1:20;
    uint exp:11;
    uint sign:1;
};

typedef union _FP_UNION_D _FP_UNION_D, *P_FP_UNION_D;

typedef double DFtype;

union _FP_UNION_D {
    DFtype flt;
    struct anon_struct.conflict2d12e6 bits;
};

typedef enum __fdlibm_version {
    __fdlibm_ieee=-1,
    __fdlibm_posix=0
} __fdlibm_version;

typedef struct dump_data_t dump_data_t, *Pdump_data_t;

struct dump_data_t {
    uint32_t time;
    char * func_name;
    uint32_t rc_state;
    uint32_t rf_state;
    uint32_t mac_debugRegHWSM1;
    uint32_t mac_debugRegHWSM2;
    uint16_t mac_debugPortCoex;
    uint16_t mac_debugPortBackoff;
    uint16_t mac_debugPortMacPhyIf;
    uint16_t mac_debugPortMacPhyIf2;
    uint16_t phy_debugPortMainFSM;
    uint16_t phy_debugPortTDTX;
    uint16_t phy_debugPortDSSSCCK1;
    uint16_t phy_debugPortDSSSCCKTx;
};

typedef struct HWStateMachineReg HWStateMachineReg, *PHWStateMachineReg;

struct HWStateMachineReg {
    uint32_t rxControl:6;
    uint32_t reserved_7_6:2;
    uint32_t txControl:9;
    uint32_t reserved_23_17:7;
    uint32_t macControl:8;
};

typedef struct tcal_tag tcal_tag, *Ptcal_tag;

struct tcal_tag {
    int16_t prev_temperature;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t last_action_time[4];
    uint32_t last_action_temperature[4];
    int32_t last_action_out[4];
    _Bool enabled;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
};

typedef struct mem mem, *Pmem;

struct mem {
    mem_size_t next;
    mem_size_t prev;
    u8_t used;
    undefined field_0x5;
};

typedef union _reg_t _reg_t, *P_reg_t;

union _reg_t {
    uint8_t byte[4];
    uint32_t word;
};

typedef struct mbedtls_ecp_keypair mbedtls_ecp_keypair, *Pmbedtls_ecp_keypair;

typedef struct mbedtls_ecp_group mbedtls_ecp_group, *Pmbedtls_ecp_group;

typedef struct mbedtls_mpi mbedtls_mpi, *Pmbedtls_mpi;

typedef struct mbedtls_ecp_point mbedtls_ecp_point, *Pmbedtls_ecp_point;

typedef uint32_t mbedtls_mpi_uint;

struct mbedtls_mpi {
    int s;
    size_t n;
    mbedtls_mpi_uint * p;
};

struct mbedtls_ecp_point {
    struct mbedtls_mpi X;
    struct mbedtls_mpi Y;
    struct mbedtls_mpi Z;
};

struct mbedtls_ecp_group {
    enum mbedtls_ecp_group_id id;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    struct mbedtls_mpi P;
    struct mbedtls_mpi A;
    struct mbedtls_mpi B;
    struct mbedtls_ecp_point G;
    struct mbedtls_mpi N;
    size_t pbits;
    size_t nbits;
    uint h;
    int (* modp)(struct mbedtls_mpi *);
    int (* t_pre)(struct mbedtls_ecp_point *, void *);
    int (* t_post)(struct mbedtls_ecp_point *, void *);
    void * t_data;
    struct mbedtls_ecp_point * T;
    size_t T_size;
};

struct mbedtls_ecp_keypair {
    struct mbedtls_ecp_group grp;
    struct mbedtls_mpi d;
    struct mbedtls_ecp_point Q;
};

typedef struct mbedtls_ecp_curve_info mbedtls_ecp_curve_info, *Pmbedtls_ecp_curve_info;

struct mbedtls_ecp_curve_info {
    enum mbedtls_ecp_group_id grp_id;
    undefined field_0x1;
    uint16_t tls_id;
    uint16_t bit_size;
    undefined field_0x6;
    undefined field_0x7;
    char * name;
};

typedef enum lwip_iana_hwtype {
    LWIP_IANA_HWTYPE_ETHERNET=1
} lwip_iana_hwtype;

typedef enum lwip_iana_port_number {
    LWIP_IANA_PORT_SMTP=25,
    LWIP_IANA_PORT_SNTP=123,
    LWIP_IANA_PORT_TFTP=69,
    LWIP_IANA_PORT_NETBIOS=-119,
    LWIP_IANA_PORT_HTTPS=443,
    LWIP_IANA_PORT_MDNS=5353,
    LWIP_IANA_PORT_DHCP_CLIENT=68,
    LWIP_IANA_PORT_SECURE_MQTT=8883,
    LWIP_IANA_PORT_HTTP=80,
    LWIP_IANA_PORT_DHCP_SERVER=67,
    LWIP_IANA_PORT_SNMP=-95,
    LWIP_IANA_PORT_MQTT=1883,
    LWIP_IANA_PORT_SNMP_TRAP=-94,
    LWIP_IANA_PORT_SMTPS=465
} lwip_iana_port_number;

typedef enum ecp_curve_type {
    ECP_TYPE_NONE=0,
    ECP_TYPE_MONTGOMERY=2,
    ECP_TYPE_SHORT_WEIERSTRASS=1
} ecp_curve_type;

typedef struct event event, *Pevent;

struct event {
    int type;
    void * data;
};

typedef struct state state, *Pstate;

typedef struct transition transition, *Ptransition;

struct state {
    struct state * parentState;
    struct state * entryState;
    struct transition * transitions;
    size_t numTransitions;
    void * data;
    void (* entryAction)(void *, struct event *);
    void (* exitAction)(void *, struct event *);
};

struct transition {
    int eventType;
    void * condition;
    _Bool (* guard)(void *, struct event *);
    void (* action)(void *, struct event *, void *);
    struct state * nextState;
};

typedef struct stateMachine stateMachine, *PstateMachine;

struct stateMachine {
    struct state * currentState;
    struct state * previousState;
    struct state * errorState;
};

typedef enum stateM_handleEventRetVals {
    stateM_noStateChange=2,
    stateM_finalStateReached=3,
    stateM_stateChanged=0,
    stateM_errArg=-2,
    stateM_stateLoopSelf=1,
    stateM_errorStateReached=-1
} stateM_handleEventRetVals;

typedef struct _romfs_file_buf _romfs_file_buf, *P_romfs_file_buf;

struct _romfs_file_buf {
    char * buf;
    uint32_t bufsize;
};

typedef struct _romfs_file_buf romfs_filebuf_t;

typedef enum netifapi_arp_entry {
    NETIFAPI_ARP_PERM=0
} netifapi_arp_entry;

typedef struct rxl_hwdesc_env_tag rxl_hwdesc_env_tag, *Prxl_hwdesc_env_tag;

typedef struct rx_pbd rx_pbd, *Prx_pbd;

struct rxl_hwdesc_env_tag {
    struct rx_pbd * last;
    struct rx_pbd * free;
};

struct rx_pbd {
    uint32_t upattern;
    uint32_t next;
    uint32_t datastartptr;
    uint32_t dataendptr;
    uint16_t bufstatinfo;
    uint16_t reserved;
};

typedef struct sntp_msg sntp_msg, *Psntp_msg;

struct sntp_msg {
    u8_t li_vn_mode;
    u8_t stratum;
    u8_t poll;
    u8_t precision;
    u32_t root_delay;
    u32_t root_dispersion;
    u32_t reference_identifier;
    u32_t reference_timestamp[2];
    u32_t originate_timestamp[2];
    u32_t receive_timestamp[2];
    u32_t transmit_timestamp[2];
};

typedef struct sntp_time sntp_time, *Psntp_time;

struct sntp_time {
    u32_t sec;
    u32_t frac;
};

typedef struct sntp_timestamps sntp_timestamps, *Psntp_timestamps;

struct sntp_timestamps {
    struct sntp_time xmit;
};

typedef struct sntp_server sntp_server, *Psntp_server;

struct sntp_server {
    char * name;
    ip_addr_t addr;
    u8_t reachability;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct KDE_t KDE_t, *PKDE_t;

struct KDE_t {
    UINT8 type;
    UINT8 length;
    UINT8 OUI[3];
    UINT8 dataType;
    UINT8 data[1];
};

typedef struct Hdr_8021x_t Hdr_8021x_t, *PHdr_8021x_t;

typedef enum IEEEtypes_8021x_PacketType_e {
    IEEE_8021X_PACKET_TYPE_EAP_PACKET=0,
    IEEE_8021X_PACKET_TYPE_EAPOL_START=1,
    IEEE_8021X_PACKET_TYPE_EAPOL_KEY=3,
    IEEE_8021X_PACKET_TYPE_EAPOL_LOGOFF=2,
    IEEE_8021X_PACKET_TYPE_ASF_ALERT=4
} IEEEtypes_8021x_PacketType_e;

struct Hdr_8021x_t {
    UINT8 protocol_ver;
    enum IEEEtypes_8021x_PacketType_e pckt_type;
    UINT16 pckt_body_len;
};

typedef struct EAPOL_KeyMsg_t EAPOL_KeyMsg_t, *PEAPOL_KeyMsg_t;

typedef struct key_info_t key_info_t, *Pkey_info_t;

struct key_info_t {
    UINT16 KeyMIC:1;
    UINT16 Secure:1;
    UINT16 Error:1;
    UINT16 Request:1;
    UINT16 EncryptedKeyData:1;
    UINT16 Reserved:3;
    UINT16 KeyDescriptorVersion:3;
    UINT16 KeyType:1;
    UINT16 KeyIndex:2;
    UINT16 Install:1;
    UINT16 KeyAck:1;
};

struct EAPOL_KeyMsg_t {
    struct Hdr_8021x_t hdr_8021x;
    UINT8 desc_type;
    struct key_info_t key_info;
    UINT16 key_length;
    UINT32 replay_cnt[2];
    UINT8 key_nonce[32];
    UINT8 EAPOL_key_IV[16];
    UINT8 key_RSC[8];
    UINT8 key_ID[8];
    UINT8 key_MIC[16];
    UINT16 key_material_len;
    UINT8 key_data[1];
};

typedef struct EAPOL_KeyMsg_Tx_t EAPOL_KeyMsg_Tx_t, *PEAPOL_KeyMsg_Tx_t;

typedef struct ether_hdr_t ether_hdr_t, *Pether_hdr_t;

typedef UINT8 IEEEtypes_Addr_t;

typedef IEEEtypes_Addr_t IEEEtypes_MacAddr_t[6];

struct ether_hdr_t {
    IEEEtypes_MacAddr_t da;
    IEEEtypes_MacAddr_t sa;
    UINT16 type;
};

struct EAPOL_KeyMsg_Tx_t {
    struct ether_hdr_t ethHdr;
    struct EAPOL_KeyMsg_t keyMsg;
};

typedef struct GTK_KDE_t GTK_KDE_t, *PGTK_KDE_t;

struct GTK_KDE_t {
    UINT8 KeyID:2;
    UINT8 Tx:1;
    UINT8 rsvd:5;
    UINT8 rsvd1;
    UINT8 GTK[1];
};

typedef struct EAP_PacketMsg_t EAP_PacketMsg_t, *PEAP_PacketMsg_t;

typedef enum IEEEtypes_8021x_CodeType_e {
    IEEE_8021X_CODE_TYPE_REQUEST=1,
    IEEE_8021X_CODE_TYPE_SUCCESS=3,
    IEEE_8021X_CODE_TYPE_FAILURE=4,
    IEEE_8021X_CODE_TYPE_RESPONSE=2
} IEEEtypes_8021x_CodeType_e;

struct EAP_PacketMsg_t {
    struct Hdr_8021x_t hdr_8021x;
    enum IEEEtypes_8021x_CodeType_e code;
    UINT8 identifier;
    UINT16 length;
    UINT8 data[1];
};

typedef struct Timer Timer, *PTimer;

struct Timer {
    uint32_t start_ticks;
    uint32_t timeout_ticks;
    uint32_t last_polled_ticks;
};

typedef struct event_dev_t event_dev_t, *Pevent_dev_t;

typedef struct pollfd pollfd, *Ppollfd;

typedef struct dlist_s dlist_s, *Pdlist_s;

typedef struct dlist_s dlist_t;

struct dlist_s {
    struct dlist_s * prev;
    struct dlist_s * next;
};

struct pollfd {
    int fd;
    short events;
    short revents;
};

struct event_dev_t {
    aos_mutex_t mutex;
    void (* poll_cb)(struct pollfd *, void *);
    struct pollfd * fd;
    void * poll_data;
    int counter;
    dlist_t bufs;
    int cache_count;
    dlist_t buf_cache;
};

typedef struct dev_event_t dev_event_t, *Pdev_event_t;

struct dev_event_t {
    dlist_t node;
    size_t len;
    char[0] buf;
};

typedef struct BL_ENDECRYPT_t BL_ENDECRYPT_t, *PBL_ENDECRYPT_t;

struct BL_ENDECRYPT_t {
    UINT8 enDeAction;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    UINT8 * pData;
};

typedef struct sta_mgmt_ba_info sta_mgmt_ba_info, *Psta_mgmt_ba_info;

struct sta_mgmt_ba_info {
    uint32_t last_tx_time;
    uint32_t last_ba_add_time;
    uint8_t bam_idx_rx;
    uint8_t bam_idx_tx;
    int8_t credit_oft;
    undefined field_0xb;
};

typedef struct sta_info_tag sta_info_tag, *Psta_info_tag;

typedef enum sta_ps_traffic {
    PS_TRAFFIC=3,
    UAPSD_TRAFFIC_HOST=4,
    UAPSD_TRAFFIC_INT=8,
    PS_TRAFFIC_HOST=1,
    PS_TRAFFIC_INT=2,
    UAPSD_TRAFFIC=12
} sta_ps_traffic;

typedef int sta_ps_sp_t;

typedef struct sta_mgmt_sec_info sta_mgmt_sec_info, *Psta_mgmt_sec_info;

typedef struct mac_sta_info mac_sta_info, *Pmac_sta_info;

typedef struct sta_pol_tbl_cntl sta_pol_tbl_cntl, *Psta_pol_tbl_cntl;

typedef struct co_list co_list, *Pco_list;

typedef struct key_info_tag key_info_tag, *Pkey_info_tag;

typedef struct mac_rateset mac_rateset, *Pmac_rateset;

typedef struct mac_htcapability mac_htcapability, *Pmac_htcapability;

typedef struct mac_vhtcapability mac_vhtcapability, *Pmac_vhtcapability;

typedef struct txl_buffer_control txl_buffer_control, *Ptxl_buffer_control;

typedef struct rc_sta_stats rc_sta_stats, *Prc_sta_stats;

typedef ulonglong __uint64_t;

typedef __uint64_t uint64_t;

typedef union anon_union.conflict97f3_for_u anon_union.conflict97f3_for_u, *Panon_union.conflict97f3_for_u;

typedef union anon_union.conflictbf1b_for_field_0 anon_union.conflictbf1b_for_field_0, *Panon_union.conflictbf1b_for_field_0;

typedef struct rc_rate_stats rc_rate_stats, *Prc_rate_stats;

typedef struct step step, *Pstep;

typedef union anon_union.conflictc3d7_for_rate_map anon_union.conflictc3d7_for_rate_map, *Panon_union.conflictc3d7_for_rate_map;

typedef struct anon_struct.conflict9793 anon_struct.conflict9793, *Panon_struct.conflict9793;

typedef struct anon_struct.conflict97ca anon_struct.conflict97ca, *Panon_struct.conflict97ca;

typedef struct tx_policy_tbl tx_policy_tbl, *Ptx_policy_tbl;

typedef struct tx_compressed_policy_tbl tx_compressed_policy_tbl, *Ptx_compressed_policy_tbl;

struct rc_rate_stats {
    uint16_t attempts;
    uint16_t success;
    uint16_t probability;
    uint16_t rate_config;
    uint8_t sample_skipped;
    _Bool old_prob_available;
    uint8_t n_retry;
    _Bool rate_allowed;
};

struct step {
    uint32_t tp;
    uint16_t idx;
    undefined field_0x6;
    undefined field_0x7;
};

union anon_union.conflictc3d7_for_rate_map {
    uint8_t ht[4];
};

struct rc_sta_stats {
    uint32_t last_rc_time;
    struct rc_rate_stats rate_stats[10];
    struct step retry[4];
    struct step max_tp_2_trial;
    uint16_t ampdu_len;
    uint16_t ampdu_packets;
    uint32_t avg_ampdu_len;
    uint8_t sample_wait;
    uint8_t sample_slow;
    uint8_t trial_status;
    uint8_t info;
    uint8_t sw_retry_step;
    uint8_t format_mod;
    union anon_union.conflictc3d7_for_rate_map rate_map;
    uint16_t rate_map_l;
    uint8_t mcs_max;
    uint8_t r_idx_min;
    uint8_t r_idx_max;
    uint8_t bw_max;
    uint8_t no_ss;
    uint8_t short_gi;
    uint8_t p_type;
    undefined field_0xbf;
    uint16_t no_samples;
    uint16_t max_amsdu_len;
    uint16_t curr_amsdu_len;
    uint16_t fixed_rate_cfg;
};

struct tx_compressed_policy_tbl {
    uint32_t upatterntx;
    uint32_t sec_user_control;
};

struct tx_policy_tbl {
    uint32_t upatterntx;
    uint32_t phycntrlinfo1;
    uint32_t phycntrlinfo2;
    uint32_t maccntrlinfo1;
    uint32_t maccntrlinfo2;
    uint32_t ratecntrlinfo[4];
    uint32_t powercntrlinfo[4];
};

union anon_union.conflictbf1b_for_field_0 {
    struct tx_policy_tbl policy_tbl;
    struct tx_compressed_policy_tbl comp_pol_tbl;
};

struct sta_pol_tbl_cntl {
    struct txl_buffer_control * buf_ctrl;
    struct rc_sta_stats * sta_stats;
    uint32_t prot_cfg;
    uint16_t ppdu_tx_cfg;
    uint8_t upd_field;
    undefined field_0xf;
};

struct mac_rateset {
    uint8_t length;
    uint8_t array[12];
};

struct anon_struct.conflict9793 {
    uint32_t tx_key[2];
    uint32_t rx_key[2];
};

struct anon_struct.conflict97ca {
    uint32_t key[4];
};

union anon_union.conflict97f3_for_u {
    struct anon_struct.conflict9793 mic;
    struct anon_struct.conflict97ca mfp;
};

struct key_info_tag {
    uint64_t rx_pn[9];
    uint64_t tx_pn;
    union anon_union.conflict97f3_for_u u;
    uint8_t cipher;
    uint8_t key_idx;
    uint8_t hw_key_idx;
    _Bool valid;
    undefined field_0x64;
    undefined field_0x65;
    undefined field_0x66;
    undefined field_0x67;
};

struct sta_mgmt_sec_info {
    struct key_info_tag key_info;
    struct key_info_tag * pairwise_key;
    struct key_info_tag * * cur_key;
};

struct co_list {
    struct co_list_hdr * first;
    struct co_list_hdr * last;
};

struct mac_vhtcapability {
    uint32_t vht_capa_info;
    uint16_t rx_mcs_map;
    uint16_t rx_highest;
    uint16_t tx_mcs_map;
    uint16_t tx_highest;
};

struct mac_htcapability {
    uint16_t ht_capa_info;
    uint8_t a_mpdu_param;
    uint8_t mcs_rate[16];
    undefined field_0x13;
    uint16_t ht_extended_capa;
    undefined field_0x16;
    undefined field_0x17;
    uint32_t tx_beamforming_capa;
    uint8_t asel_capa;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

struct mac_sta_info {
    struct mac_rateset rate_set;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    struct mac_htcapability ht_cap;
    struct mac_vhtcapability vht_cap;
    uint32_t capa_flags;
    uint8_t phy_bw_max;
    uint8_t bw_cur;
    uint8_t uapsd_queues;
    uint8_t max_sp_len;
    uint8_t stbc_nss;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
};

struct sta_info_tag {
    struct co_list_hdr list_hdr;
    uint32_t bcn_int;
    uint32_t ampdu_size_max_vht;
    uint16_t ampdu_size_max_ht;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t paid_gid;
    uint8_t ampdu_spacing_min;
    undefined field_0x15;
    uint16_t drift;
    uint16_t aid;
    uint8_t inst_nbr;
    uint8_t staid;
    uint8_t ps_state;
    _Bool valid;
    struct mac_addr mac_addr;
    int8_t rssi;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    uint32_t tsflo;
    uint32_t tsfhi;
    uint8_t data_rate;
    uint8_t ctrl_port_state;
    enum sta_ps_traffic traffic_avail;
    undefined field_0x33;
    sta_ps_sp_t ps_service_period;
    uint16_t ctrl_port_ethertype;
    undefined field_0x3a;
    undefined field_0x3b;
    undefined field_0x3c;
    undefined field_0x3d;
    undefined field_0x3e;
    undefined field_0x3f;
    struct sta_mgmt_sec_info sta_sec_info;
    struct mac_sta_info info;
    uint16_t seq_nbr[9];
    undefined field_0x10a;
    undefined field_0x10b;
    struct sta_pol_tbl_cntl pol_tbl;
    struct sta_mgmt_ba_info ba_info[9];
    uint16_t rx_nqos_last_seqcntl;
    uint16_t rx_qos_last_seqcntl[9];
    struct co_list tx_desc_post;
    void * suppData;
    uint32_t time_last_seen;
    undefined field_0x1ac;
    undefined field_0x1ad;
    undefined field_0x1ae;
    undefined field_0x1af;
};

struct txl_buffer_control {
    union anon_union.conflictbf1b_for_field_0 field_0;
    uint32_t mac_control_info;
    uint32_t phy_control_info;
};

typedef struct sta_info_env_tag sta_info_env_tag, *Psta_info_env_tag;

struct sta_info_env_tag {
    struct co_list free_sta_list;
};

typedef enum sta_ps_sp {
    ANY_SERVICE_PERIOD_INT=3,
    PS_SERVICE_PERIOD=1,
    UAPSD_SERVICE_PERIOD_HOST=4,
    BCN_SERVICE_PERIOD=8,
    UAPSD_SERVICE_PERIOD=6,
    UAPSD_SERVICE_PERIOD_INT=2,
    NO_SERVICE_PERIOD=0
} sta_ps_sp;

typedef enum sta_mgmt_pol_upd {
    STA_MGMT_POL_UPD_RATE=0,
    STA_MGMT_POL_UPD_PPDU_TX=2,
    STA_MGMT_POL_UPD_PROT=1,
    STA_MGMT_POL_UPD_BW=3,
    STA_MGMT_POL_UPD_MAX=5,
    STA_MGMT_POL_UPD_TX_POWER=4
} sta_mgmt_pol_upd;

typedef struct in_addr in_addr, *Pin_addr;

typedef ulong __uint32_t;

typedef __uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

typedef struct in6_addr in6_addr, *Pin6_addr;

typedef union anon_union.conflict1547_for_un anon_union.conflict1547_for_un, *Panon_union.conflict1547_for_un;

union anon_union.conflict1547_for_un {
    u32_t u32_addr[4];
    u8_t u8_addr[16];
};

struct in6_addr {
    union anon_union.conflict1547_for_un un;
};

typedef union anon_union.conflict1547 anon_union.conflict1547, *Panon_union.conflict1547;

union anon_union.conflict1547 {
    u32_t u32_addr[4];
    u8_t u8_addr[16];
};

typedef struct machw_mib_tag machw_mib_tag, *Pmachw_mib_tag;

struct machw_mib_tag {
    uint32_t dot11_wep_excluded_count;
    uint32_t dot11_fcs_error_count;
    uint32_t nx_rx_phy_error_count;
    uint32_t nx_rd_fifo_overflow_count;
    uint32_t nx_tx_underun_count;
    uint32_t reserved_1[7];
    uint32_t nx_qos_utransmitted_mpdu_count[8];
    uint32_t nx_qos_gtransmitted_mpdu_count[8];
    uint32_t dot11_qos_failed_count[8];
    uint32_t dot11_qos_retry_count[8];
    uint32_t dot11_qos_rts_success_count[8];
    uint32_t dot11_qos_rts_failure_count[8];
    uint32_t nx_qos_ack_failure_count[8];
    uint32_t nx_qos_ureceived_mpdu_count[8];
    uint32_t nx_qos_greceived_mpdu_count[8];
    uint32_t nx_qos_ureceived_other_mpdu[8];
    uint32_t dot11_qos_retries_received_count[8];
    uint32_t nx_utransmitted_amsdu_count[8];
    uint32_t nx_gtransmitted_amsdu_count[8];
    uint32_t dot11_failed_amsdu_count[8];
    uint32_t dot11_retry_amsdu_count[8];
    uint32_t dot11_transmitted_octets_in_amsdu[8];
    uint32_t dot11_amsdu_ack_failure_count[8];
    uint32_t nx_ureceived_amsdu_count[8];
    uint32_t nx_greceived_amsdu_count[8];
    uint32_t nx_ureceived_other_amsdu[8];
    uint32_t dot11_received_octets_in_amsdu_count[8];
    uint32_t reserved_2[24];
    uint32_t dot11_transmitted_ampdu_count;
    uint32_t dot11_transmitted_mpdus_in_ampdu_count;
    uint32_t dot11_transmitted_octets_in_ampdu_count;
    uint32_t wnlu_ampdu_received_count;
    uint32_t nx_gampdu_received_count;
    uint32_t nx_other_ampdu_received_count;
    uint32_t dot11_mpdu_in_received_ampdu_count;
    uint32_t dot11_received_octets_in_ampdu_count;
    uint32_t dot11_ampdu_delimiter_crc_error_count;
    uint32_t dot11_implicit_bar_failure_count;
    uint32_t dot11_explicit_bar_failure_count;
    uint32_t reserved_3[5];
    uint32_t dot11_20mhz_frame_transmitted_count;
    uint32_t dot11_40mhz_frame_transmitted_count;
    uint32_t dot11_20mhz_frame_received_count;
    uint32_t dot11_40mhz_frame_received_count;
    uint32_t nx_failed_40mhz_txop;
    uint32_t nx_successful_txops;
    uint32_t reserved_4[4];
    uint32_t dot11_dualcts_success_count;
    uint32_t dot11_stbc_cts_success_count;
    uint32_t dot11_stbc_cts_failure_count;
    uint32_t dot11_non_stbc_cts_success_count;
    uint32_t dot11_non_stbc_cts_failure_count;
};

typedef struct scan_probe_req_ie_tag scan_probe_req_ie_tag, *Pscan_probe_req_ie_tag;

typedef struct tx_pbd tx_pbd, *Ptx_pbd;

struct tx_pbd {
    uint32_t upatterntx;
    uint32_t next;
    uint32_t datastartptr;
    uint32_t dataendptr;
    uint32_t bufctrlinfo;
};

struct scan_probe_req_ie_tag {
    struct dma_desc dma_desc;
    struct tx_pbd pbd;
    uint32_t buf[50];
};

typedef struct scan_env_tag scan_env_tag, *Pscan_env_tag;

typedef struct scan_start_req scan_start_req, *Pscan_start_req;

struct scan_start_req {
    struct scan_chan_tag chan[42];
    struct mac_ssid ssid[2];
    struct mac_addr bssid;
    undefined field_0x146;
    undefined field_0x147;
    uint32_t add_ies;
    uint16_t add_ie_len;
    uint8_t vif_idx;
    uint8_t chan_cnt;
    uint8_t ssid_cnt;
    _Bool no_cck;
    undefined field_0x152;
    undefined field_0x153;
};

struct scan_env_tag {
    struct hal_dma_desc_tag dma_desc;
    struct scan_start_req * param;
    uint32_t ds_ie;
    ke_task_id_t req_id;
    uint8_t chan_idx;
    _Bool abort;
};

typedef uint32_t fdt32_t;

typedef uint64_t fdt64_t;

typedef struct SEC_Eng_SHA256_Link_Ctx SEC_Eng_SHA256_Link_Ctx, *PSEC_Eng_SHA256_Link_Ctx;

struct SEC_Eng_SHA256_Link_Ctx {
    uint32_t total[2];
    uint32_t * shaBuf;
    uint32_t * shaPadding;
    uint32_t linkAddr;
};

typedef enum SEC_ENG_AES_ID_Type {
    SEC_ENG_AES_ID0=0
} SEC_ENG_AES_ID_Type;

typedef enum SEC_ENG_AES_Key_Type {
    SEC_ENG_AES_DOUBLE_KEY_128BITS=3,
    SEC_ENG_AES_KEY_256BITS=1,
    SEC_ENG_AES_KEY_192BITS=2,
    SEC_ENG_AES_KEY_128BITS=0
} SEC_ENG_AES_Key_Type;

typedef struct SEC_Eng_SHA_Link_Config_Type SEC_Eng_SHA_Link_Config_Type, *PSEC_Eng_SHA_Link_Config_Type;

struct SEC_Eng_SHA_Link_Config_Type {
    uint32_t shaMode:3;
    uint32_t shaHashSel:1;
    uint32_t shaIntClr:1;
    uint32_t shaIntSet:1;
    uint32_t shaMsgLen:16;
    uint32_t shaSrcAddr;
    uint32_t result[8];
};

typedef struct SEC_Eng_AES_Link_Config_Type SEC_Eng_AES_Link_Config_Type, *PSEC_Eng_AES_Link_Config_Type;

struct SEC_Eng_AES_Link_Config_Type {
    uint32_t aesMode:2;
    uint32_t aesDecEn:1;
    uint32_t aesDecKeySel:1;
    uint32_t aesHwKeyEn:1;
    uint32_t aesIntClr:1;
    uint32_t aesIntSet:1;
    uint32_t aesBlockMode:2;
    uint32_t aesIVSel:1;
    uint32_t aesMsgLen:16;
    uint32_t aesSrcAddr;
    uint32_t aesDstAddr;
    uint32_t aesIV0;
    uint32_t aesIV1;
    uint32_t aesIV2;
    uint32_t aesIV3;
    uint32_t aesKey0;
    uint32_t aesKey1;
    uint32_t aesKey2;
    uint32_t aesKey3;
    uint32_t aesKey4;
    uint32_t aesKey5;
    uint32_t aesKey6;
    uint32_t aesKey7;
};

typedef struct SEC_Eng_SHA256_Ctx SEC_Eng_SHA256_Ctx, *PSEC_Eng_SHA256_Ctx;

struct SEC_Eng_SHA256_Ctx {
    uint32_t total[2];
    uint32_t * shaBuf;
    uint32_t * shaPadding;
    uint8_t shaFeed;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef enum SEC_ENG_SHA_Type {
    SEC_ENG_SHA224=1,
    SEC_ENG_SHA256=0,
    SEC_ENG_SHA1_RSVD=3,
    SEC_ENG_SHA1=2
} SEC_ENG_SHA_Type;

typedef enum SEC_ENG_PKA_OP_Type {
    SEC_ENG_PKA_OP_CFLIRI_BUFFER=54,
    SEC_ENG_PKA_OP_SLIR=52,
    SEC_ENG_PKA_OP_MSQR=36,
    SEC_ENG_PKA_OP_CFLIR_BUFFER=56,
    SEC_ENG_PKA_OP_LMUL2N=19,
    SEC_ENG_PKA_OP_MOVDAT=50,
    SEC_ENG_PKA_OP_LADD=24,
    SEC_ENG_PKA_OP_MSUB=39,
    SEC_ENG_PKA_OP_PPSEL=0,
    SEC_ENG_PKA_OP_MMUL=37,
    SEC_ENG_PKA_OP_LDIV2N=18,
    SEC_ENG_PKA_OP_MDIV2=33,
    SEC_ENG_PKA_OP_RESIZE=49,
    SEC_ENG_PKA_OP_CTLIR_PLD=57,
    SEC_ENG_PKA_OP_MINV=34,
    SEC_ENG_PKA_OP_LDIV=20,
    SEC_ENG_PKA_OP_LSQR=21,
    SEC_ENG_PKA_OP_NLIR=51,
    SEC_ENG_PKA_OP_LCMP=25,
    SEC_ENG_PKA_OP_CTLIRI_PLD=55,
    SEC_ENG_PKA_OP_MOD2N=17,
    SEC_ENG_PKA_OP_LSUB=23,
    SEC_ENG_PKA_OP_MADD=40,
    SEC_ENG_PKA_OP_LMUL=22,
    SEC_ENG_PKA_OP_MREM=38,
    SEC_ENG_PKA_OP_MEXP=35,
    SEC_ENG_PKA_OP_CLIR=53
} SEC_ENG_PKA_OP_Type;

typedef enum SEC_ENG_AES_Key_Src_Type {
    SEC_ENG_AES_KEY_SW=0,
    SEC_ENG_AES_KEY_HW=1
} SEC_ENG_AES_Key_Src_Type;

typedef struct SEC_Eng_AES_Ctx SEC_Eng_AES_Ctx, *PSEC_Eng_AES_Ctx;

typedef enum SEC_ENG_AES_Type {
    SEC_ENG_AES_CTR=1,
    SEC_ENG_AES_ECB=0,
    SEC_ENG_AES_CBC=2
} SEC_ENG_AES_Type;

struct SEC_Eng_AES_Ctx {
    uint8_t aesFeed;
    enum SEC_ENG_AES_Type mode;
};

typedef enum SEC_ENG_AES_EnDec_Type {
    SEC_ENG_AES_ENCRYPTION=0,
    SEC_ENG_AES_DECRYPTION=1
} SEC_ENG_AES_EnDec_Type;

typedef enum SEC_ENG_SHA_ID_Type {
    SEC_ENG_SHA_ID0=0
} SEC_ENG_SHA_ID_Type;

typedef enum SEC_ENG_AES_Counter_Type {
    SEC_ENG_AES_COUNTER_BYTE_3=3,
    SEC_ENG_AES_COUNTER_BYTE_4=0,
    SEC_ENG_AES_COUNTER_BYTE_1=1,
    SEC_ENG_AES_COUNTER_BYTE_2=2
} SEC_ENG_AES_Counter_Type;

typedef enum SEC_ENG_PKA_REG_SIZE_Type {
    SEC_ENG_PKA_REG_SIZE_512=10,
    SEC_ENG_PKA_REG_SIZE_256=8,
    SEC_ENG_PKA_REG_SIZE_16=2,
    SEC_ENG_PKA_REG_SIZE_192=7,
    SEC_ENG_PKA_REG_SIZE_128=6,
    SEC_ENG_PKA_REG_SIZE_32=3,
    SEC_ENG_PKA_REG_SIZE_8=1,
    SEC_ENG_PKA_REG_SIZE_64=4,
    SEC_ENG_PKA_REG_SIZE_96=5,
    SEC_ENG_PKA_REG_SIZE_384=9
} SEC_ENG_PKA_REG_SIZE_Type;

typedef enum SEC_ENG_INT_Type {
    SEC_ENG_INT_SHA=2,
    SEC_ENG_INT_TRNG=0,
    SEC_ENG_INT_CDET=4,
    SEC_ENG_INT_PKA=3,
    SEC_ENG_INT_GMAC=5,
    SEC_ENG_INT_AES=1,
    SEC_ENG_INT_ALL=6
} SEC_ENG_INT_Type;

typedef ulong fd_mask;

typedef struct _types_fd_set _types_fd_set, *P_types_fd_set;

struct _types_fd_set {
    fd_mask fds_bits[2];
};

typedef struct poll_arg poll_arg, *Ppoll_arg;

struct poll_arg {
    aos_sem_t sem;
};

typedef enum lwip_ip_addr_type {
    IPADDR_TYPE_V6=6,
    IPADDR_TYPE_V4=0,
    IPADDR_TYPE_ANY=46
} lwip_ip_addr_type;

typedef struct MIC_Error_t MIC_Error_t, *PMIC_Error_t;

typedef enum MIC_Fail_State_e {
    FIRST_MIC_FAIL_IN_60_SEC=1,
    SECOND_MIC_FAIL_IN_60_SEC=2,
    NO_MIC_FAILURE=0
} MIC_Fail_State_e;

struct MIC_Error_t {
    enum MIC_Fail_State_e status;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    BOOLEAN MICCounterMeasureEnabled;
    UINT32 disableStaAsso;
};

typedef struct TkipPtk_t TkipPtk_t, *PTkipPtk_t;

struct TkipPtk_t {
    UINT8 kck[16];
    UINT8 kek[16];
    UINT8 tk[16];
    UINT8 rxMicKey[8];
    UINT8 txMicKey[8];
};

typedef struct customMIB_RSNStats_t customMIB_RSNStats_t, *PcustomMIB_RSNStats_t;

struct customMIB_RSNStats_t {
    UINT8 TKIPICVErrors;
    UINT8 TKIPLocalMICFailures;
    UINT8 TKIPCounterMeasuresInvoked;
};

typedef struct keyMgmtInfoSta_t keyMgmtInfoSta_t, *PkeyMgmtInfoSta_t;

typedef struct cm_ConnectionInfo cm_ConnectionInfo, *Pcm_ConnectionInfo;

typedef struct supplicantData supplicantData, *PsupplicantData;

typedef struct CommonMlmeData_t CommonMlmeData_t, *PCommonMlmeData_t;

typedef union anon_union.conflictedae_for_specDat anon_union.conflictedae_for_specDat, *Panon_union.conflictedae_for_specDat;

typedef struct IEEEtypes_SsIdElement_t IEEEtypes_SsIdElement_t, *PIEEEtypes_SsIdElement_t;

typedef struct SecurityParams_t SecurityParams_t, *PSecurityParams_t;

typedef UINT8 IEEEtypes_SsId_t[32];

typedef UINT8 IEEEtypes_Len_t;

typedef UINT8 IEEEtypes_DtimPeriod_t;

typedef UINT16 IEEEtypes_BcnInterval_t;

typedef struct apSpecificData_t apSpecificData_t, *PapSpecificData_t;

typedef enum IEEEtypes_ElementId_e {
    ELEM_ID_DIAG_REQUEST=80,
    ELEM_ID_EXT_FILS_SESSION=4,
    ELEM_ID_TDLS_CS_TIMING=104,
    ELEM_ID_DIAG_REPORT=81,
    SUBELEM_ID_REPORTING_DETAIL=2,
    ELEM_ID_TIMEOUT_INTERVAL=56,
    ELEM_ID_EXT_FILS_REQ_PARAMS=2,
    ELEM_ID_SUPPORTED_REGCLASS=59,
    SUBELEM_ID_PMK_R1_KEY_HOLDER_ID=1,
    ELEM_ID_BSS_AC_ACCESS_DELAY=68,
    ELEM_ID_MOBILITY_DOMAIN=54,
    ELEM_ID_RCPI=53,
    ELEM_ID_SSID_LIST=84,
    ELEM_ID_ERP_INFO=42,
    ELEM_ID_EXT_CAPABILITIES=127,
    ELEM_ID_TCLAS_PROCESS=44,
    ELEM_ID_AID=-59,
    ELEM_ID_EXT_HE_OPERATION=36,
    ELEM_ID_COUNTRY=7,
    ELEM_ID_EXT_EXTENDED_REQUEST=10,
    ELEM_ID_PU_BUFFER_STATUS=106,
    ELEM_ID_EXT_FILS_KEY_CONFIRM=3,
    ELEM_ID_TIME_ZONE=98,
    ELEM_ID_SCHEDULE=15,
    ELEM_ID_POWER_CAPABILITY=33,
    ELEM_ID_RSN=48,
    ELEM_ID_RIC_DATA=57,
    ELEM_ID_HT_CAPABILITY=45,
    ELEM_ID_MEAS_PILOT_TX_INFO=66,
    ELEM_ID_TIM_BCAST_RESPONSE=95,
    ELEM_ID_PTI_CONTROL=105,
    ELEM_ID_NONTRANS_BSSID_CAP=83,
    ELEM_ID_COLLOC_INTF_REPORT=96,
    ELEM_ID_CF_PARAM_SET=4,
    ELEM_ID_HT_INFORMATION=61,
    ELEM_ID_CHALLENGE_TEXT=16,
    ELEM_ID_EXT_FILS_IP_ADDR_ASSIGN=6,
    ELEM_ID_EVENT_REQUEST=78,
    ELEM_ID_EXT_FUTURE_CHANNEL_GUIDANCE=14,
    ELEM_ID_TCLAS=14,
    ELEM_ID_CHANNEL_SWITCH_ANN=37,
    ELEM_ID_IBSS_DFS=41,
    ELEM_ID_DMS_REQUEST=99,
    ELEM_ID_SUPPORTED_RATES=1,
    ELEM_ID_CHANNEL_USAGE=97,
    ELEM_ID_EXT_FILS_NONCE=13,
    ELEM_ID_HOP_TABLE=9,
    ELEM_ID_EXTENSION=-1,
    ELEM_ID_IBSS_PARAM_SET=6,
    ELEM_ID_EXT_ESTIMATED_SERVICE_PARAMS=11,
    ELEM_ID_FMS_RESPONSE=88,
    ELEM_ID_VHT_OPERATION=-64,
    ELEM_ID_MEASUREMENT_RPT=39,
    ELEM_ID_RSNI=65,
    SUBELEM_ID_IGTK=4,
    ELEM_ID_VENDOR_SPECIFIC=-35,
    ELEM_ID_EXT_KEY_DELIVERY=7,
    ELEM_ID_SECONDARY_CHAN_OFFSET=62,
    ELEM_ID_2040_BSS_COEXISTENCE=72,
    ELEM_ID_AP_CHANNEL_REPORT=51,
    ELEM_ID_VHT_OP_MODE_NOTIFICATION=-57,
    ELEM_ID_EXT_FILS_HLP_CONTAINER=5,
    ELEM_ID_FH_PARAM_SET=2,
    ELEM_ID_SUPPORTED_CHANNELS=36,
    ELEM_ID_NEIGHBOR_REPORT=52,
    ELEM_ID_EXT_PASSWORD_IDENTIFIER=33,
    ELEM_ID_TIM=5,
    ELEM_ID_DMS_RESPONSE=100,
    ELEM_ID_BSS_ACCESS_DELAY=63,
    ELEM_ID_OBSS_SCAN_PARAM=74,
    ELEM_ID_EXT_HE_CAPABILITIES=35,
    ELEM_ID_MULTI_BSSID=71,
    ELEM_ID_REQUEST=10,
    ELEM_ID_BSS_AVAIL_ADM_CAP=67,
    ELEM_ID_POWER_CONSTRAINT=32,
    ELEM_ID_LOCATION_PARAM=82,
    ELEM_ID_TFS_REQUEST=91,
    ELEM_ID_MEASUREMENT_REQ=38,
    ELEM_ID_TPC_REPORT=35,
    ELEM_ID_MANAGEMENT_MIC=76,
    ELEM_ID_WAKEUP_SCHEDULE=102,
    ELEM_ID_TS_DELAY=43,
    ELEM_ID_SSID=0,
    ELEM_ID_DS_PARAM_SET=3,
    ELEM_ID_EXT_FILS_WRAPPED_DATA=8,
    ELEM_ID_QOS_TRAFFIC_CAP=89,
    SUBELEM_ID_GTK=2,
    ELEM_ID_TFS_RESPONSE=92,
    ELEM_ID_LINK_ID=101,
    ELEM_ID_EXT_FILS_PUBLIC_KEY=12,
    ELEM_ID_EXT_FTM_SYNC_INFO=9,
    ELEM_ID_BSS_LOAD=11,
    ELEM_ID_RIC_DESCRIPTOR=75,
    ELEM_ID_EXT_SUPPORTED_RATES=50,
    ELEM_ID_EXT_OWE_DH_PARAM=32,
    SUBELEM_ID_PMK_R0_KEY_HOLDER_ID=3,
    ELEM_ID_QOS_CAPABILITY=46,
    ELEM_ID_WNM_SLEEP_MODE=93,
    ELEM_ID_RRM_ENABLED_CAP=70,
    SUBELEM_ID_REPORTED_FRAME_BODY=1,
    ELEM_ID_VHT_CAPABILITIES=-65,
    ELEM_ID_ANTENNA_INFO=64,
    ELEM_ID_MBSSID_INDEX=85,
    ELEM_ID_TPC_REQUEST=34,
    ELEM_ID_DSE_REGISTERED_LOC=58,
    ELEM_ID_QUIET=40,
    ELEM_ID_BSS_MAX_IDLE_PERIOD=90,
    ELEM_ID_HOP_PARAM=8,
    ELEM_ID_WIDE_BAND_CHAN_SW=-63,
    ELEM_ID_EVENT_REPORT=79,
    ELEM_ID_FMS_REQUEST=87,
    ELEM_ID_FAST_BSS_TRANS=55,
    ELEM_ID_EXT_CHAN_SWITCH_ANN=60,
    ELEM_ID_2040_BSS_INTOL_CHRPT=73,
    ELEM_ID_FMS_DESCRIPTOR=86,
    ELEM_ID_TSPEC=13,
    ELEM_ID_EDCA_PARAM_SET=12,
    ELEM_ID_EXT_ASSOC_DELAY_INFO=1,
    ELEM_ID_WAPI=68,
    ELEM_ID_TIM_BCAST_REQUEST=94
} IEEEtypes_ElementId_e;

typedef struct apInfo_t apInfo_t, *PapInfo_t;

typedef struct BufferDesc BufferDesc, *PBufferDesc;

typedef struct BufferDesc BufferDesc_t;

typedef struct ChanBandInfo_t ChanBandInfo_t, *PChanBandInfo_t;

typedef struct staData_t staData_t, *PstaData_t;

typedef struct BssConfig_t BssConfig_t, *PBssConfig_t;

typedef struct BssData_t BssData_t, *PBssData_t;

typedef union anon_union.conflictd321_for_intf anon_union.conflictd321_for_intf, *Panon_union.conflictd321_for_intf;

typedef struct BandConfig_t BandConfig_t, *PBandConfig_t;

typedef struct _txQingInfo_t _txQingInfo_t, *P_txQingInfo_t;

typedef struct _txQingInfo_t txQingInfo_t;

typedef struct apKeyMgmtInfoSta_t apKeyMgmtInfoSta_t, *PapKeyMgmtInfoSta_t;

typedef struct apRsnConfig_t apRsnConfig_t, *PapRsnConfig_t;

typedef enum ChanBand_e {
    Band_5_GHz=1,
    Band_4_GHz=2,
    Band_2_4_GHz=0
} ChanBand_e;

typedef enum ChanWidth_e {
    ChanWidth_10_MHz=1,
    ChanWidth_20_MHz=0,
    ChanWidth_40_MHz=2,
    ChanWidth_80_MHz=3
} ChanWidth_e;

typedef enum Chan2Offset_e {
    SECONDARY_CHAN_ABOVE=1,
    SECONDARY_CHAN_BELOW=3,
    SECONDARY_CHAN_NONE=0
} Chan2Offset_e;

typedef enum ScanMode_e {
    MANUAL_MODE=0,
    ACS_MODE=1
} ScanMode_e;

typedef enum IEEEtypes_PwrMgmtMode_e {
    PWR_MODE_ACTIVE=0,
    PWR_MODE_PWR_SAVE=1
} IEEEtypes_PwrMgmtMode_e;

typedef struct apKeyMgmtInfoStaRom_t apKeyMgmtInfoStaRom_t, *PapKeyMgmtInfoStaRom_t;

typedef struct Operation_t Operation_t, *POperation_t;

typedef enum keyMgmtState_e {
    MSG1_PENDING=1,
    WAITING_4_MSG4=4,
    GRPMSG1_PENDING=5,
    WAITING_4_GRP_REKEY_MSG2=8,
    HSK_DUMMY_STATE=9,
    HSK_NOT_STARTED=0,
    WAITING_4_GRPMSG2=6,
    MSG3_PENDING=3,
    HSK_END=10,
    GRP_REKEY_MSG1_PENDING=7,
    WAITING_4_MSG2=2
} keyMgmtState_e;

struct SecurityParams_t {
    struct SecurityMode_t wpaType;
    struct Cipher_t mcstCipher;
    struct Cipher_t ucstCipher;
};

struct apKeyMgmtInfoStaRom_t {
    UINT16 staRsnCap;
    struct SecurityMode_t staSecType;
    struct Cipher_t staUcstCipher;
    UINT8 staAkmType;
    enum keyMgmtState_e keyMgmtState;
    undefined field_0x7;
};

struct apKeyMgmtInfoSta_t {
    struct apKeyMgmtInfoStaRom_t rom;
    UINT8 numHskTries;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    UINT32 counterLo;
    UINT32 counterHi;
    struct mm_timer_tag HskTimer;
    UINT8 EAPOL_MIC_Key[16];
    UINT8 EAPOL_Encr_Key[16];
    UINT8 EAPOLProtoVersion;
    UINT8 rsvd[3];
};

struct _txQingInfo_t {
    enum IEEEtypes_PwrMgmtMode_e mode;
};

struct staData_t {
    txQingInfo_t pwrSaveInfo;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    struct apKeyMgmtInfoSta_t keyMgmtInfo;
};

struct Operation_t {
    UINT16 keyExchange:1;
    UINT16 authenticate:1;
    UINT16 reserved:14;
};

struct apRsnConfig_t {
    struct Cipher_t mcstCipher;
    UINT8 mcstCipherCount;
    struct Cipher_t wpaUcstCipher;
    UINT8 wpaUcstCipherCount;
    struct Cipher_t wpa2UcstCipher;
    UINT8 wpa2UcstCipherCount;
    UINT16 AuthKey;
    UINT16 AuthKeyCount;
    struct Operation_t Akmp;
    UINT32 GrpReKeyTime;
    UINT8 PSKPassPhrase[64];
    UINT8 PSKPassPhraseLen;
    UINT8 PSKValue[32];
    UINT8 MaxPwsHskRetries;
    UINT8 MaxGrpHskRetries;
    undefined field_0x73;
    UINT32 PwsHskTimeOut;
    UINT32 GrpHskTimeOut;
};

struct CommonMlmeData_t {
    IEEEtypes_SsId_t SsId;
    IEEEtypes_Len_t SsIdLen;
    IEEEtypes_DtimPeriod_t DtimPeriod;
    IEEEtypes_BcnInterval_t BcnPeriod;
    IEEEtypes_MacAddr_t BssId;
    UINT16 RtsThresh;
    UINT16 FragThresh;
    UINT8 ShortRetryLim;
    UINT8 LongRetryLim;
    UINT8 MbssBcnIntFac;
    UINT8 MbssCurBcnIntCnt;
    UINT16 Reserved;
};

struct BssConfig_t {
    UINT32 StaAgeOutTime;
    UINT32 PsStaAgeOutTime;
    struct apRsnConfig_t RsnConfig;
    struct CommonMlmeData_t comData;
};

struct IEEEtypes_SsIdElement_t {
    enum IEEEtypes_ElementId_e ElementId;
    IEEEtypes_Len_t Len;
    IEEEtypes_SsId_t SsId;
};

struct BandConfig_t {
    enum ChanBand_e chanBand:2;
    enum ChanWidth_e chanWidth:2;
    enum Chan2Offset_e chan2Offset:2;
    enum ScanMode_e scanMode:2;
};

struct ChanBandInfo_t {
    struct BandConfig_t bandConfig;
    UINT8 chanNum;
};

struct apSpecificData_t {
    struct apInfo_t * apInfo;
    BufferDesc_t * apInfoBuffDesc;
    struct ChanBandInfo_t chanBandInfo;
    undefined field_0xa;
    undefined field_0xb;
    struct staData_t staData;
};

struct BssData_t {
    BOOLEAN updatePassPhrase;
    struct mm_timer_tag apMicTimer;
    struct KeyData_t grpKeyData;
    UINT8 GNonce[32];
    UINT32 grpRekeyBcnCntConfigured;
    UINT32 grpRekeyBcnCntRemaining;
};

struct apInfo_t {
    struct BssConfig_t bssConfig;
    struct BssData_t bssData;
    UINT8 ApStop_Req_Pending;
    undefined field_0x11d;
    undefined field_0x11e;
    undefined field_0x11f;
};

struct keyMgmtInfoSta_t {
    UINT8 ANonce[32];
    UINT8 SNonce[32];
    UINT8 EAPOL_MIC_Key[16];
    UINT8 EAPOL_Encr_Key[16];
    UINT32 apCounterLo;
    UINT32 apCounterHi;
    UINT32 apCounterZeroDone;
    UINT32 staCounterLo;
    UINT32 staCounterHi;
    BOOLEAN RSNDataTrafficEnabled;
    BOOLEAN RSNSecured;
    BOOLEAN pwkHandshakeComplete;
    struct cipher_key_t * pRxDecryptKey;
    struct KeyData_t PWKey;
    struct KeyData_t GRKey;
    struct KeyData_t newPWKey;
    struct MIC_Error_t sta_MIC_Error;
    struct mm_timer_tag rsnTimer;
    struct cm_ConnectionInfo * connPtr;
    struct KeyData_t IGtk;
};

struct supplicantData {
    BOOLEAN inUse;
    struct IEEEtypes_SsIdElement_t hashSsId;
    IEEEtypes_MacAddr_t localBssid;
    IEEEtypes_MacAddr_t localStaAddr;
    struct customMIB_RSNStats_t customMIB_RSNStats;
    struct RSNConfig_t customMIB_RSNConfig;
    undefined field_0x51;
    undefined field_0x52;
    undefined field_0x53;
    struct keyMgmtInfoSta_t keyMgmtInfoSta;
    struct SecurityParams_t currParams;
};

union anon_union.conflictedae_for_specDat {
    struct apSpecificData_t apData;
};

struct cm_ConnectionInfo {
    UINT8 conType;
    UINT8 staId;
    UINT8 instNbr;
    UINT8 gtkHwKeyId;
    UINT8 ptkHwKeyId;
    UINT8 mfpHwKeyId;
    undefined field_0x6;
    undefined field_0x7;
    struct supplicantData * suppData;
    struct CommonMlmeData_t comData;
    IEEEtypes_MacAddr_t peerMacAddr;
    IEEEtypes_MacAddr_t localMacAddr;
    union anon_union.conflictedae_for_specDat specDat;
    cipher_key_buf_t TxRxCipherKeyBuf;
};

union anon_union.conflictd321_for_intf {
    uint32 Interface;
};

struct BufferDesc {
    union anon_union.conflictd321_for_intf intf;
    uint16 DataLen;
    undefined field_0x6;
    undefined field_0x7;
    void * Buffer;
};

typedef struct pka0_bit_shift_op_cfg pka0_bit_shift_op_cfg, *Ppka0_bit_shift_op_cfg;

typedef union anon_union.conflict2639fb_for_value anon_union.conflict2639fb_for_value, *Panon_union.conflict2639fb_for_value;

typedef struct anon_struct.conflict2639d1 anon_struct.conflict2639d1, *Panon_struct.conflict2639d1;

struct anon_struct.conflict2639d1 {
    uint32_t bit_shift:15;
    uint32_t reserved_24_31:17;
};

union anon_union.conflict2639fb_for_value {
    struct anon_struct.conflict2639d1 BF;
    uint32_t WORD;
};

struct pka0_bit_shift_op_cfg {
    union anon_union.conflict2639fb_for_value value;
};

typedef union anon_union.conflict263803 anon_union.conflict263803, *Panon_union.conflict263803;

typedef struct anon_struct.conflict26379a anon_struct.conflict26379a, *Panon_struct.conflict26379a;

struct anon_struct.conflict26379a {
    uint32_t s0_reg_idx:8;
    uint32_t s0_reg_type:4;
    uint32_t d_reg_idx:8;
    uint32_t d_reg_type:4;
    uint32_t op:7;
    uint32_t last_op:1;
};

union anon_union.conflict263803 {
    struct anon_struct.conflict26379a BF;
    uint32_t WORD;
};

typedef struct pka0_common_op_first_cfg pka0_common_op_first_cfg, *Ppka0_common_op_first_cfg;

typedef union anon_union.conflict263803_for_value anon_union.conflict263803_for_value, *Panon_union.conflict263803_for_value;

union anon_union.conflict263803_for_value {
    struct anon_struct.conflict26379a BF;
    uint32_t WORD;
};

struct pka0_common_op_first_cfg {
    union anon_union.conflict263803_for_value value;
};

typedef union anon_union.conflict263889 anon_union.conflict263889, *Panon_union.conflict263889;

typedef struct anon_struct.conflict26383f anon_struct.conflict26383f, *Panon_struct.conflict26383f;

struct anon_struct.conflict26383f {
    uint32_t reserved_0_11:12;
    uint32_t s1_reg_idx:8;
    uint32_t s1_reg_type:4;
    uint32_t reserved_24_31:8;
};

union anon_union.conflict263889 {
    struct anon_struct.conflict26383f BF;
    uint32_t WORD;
};

typedef struct pka0_pld_cfg pka0_pld_cfg, *Ppka0_pld_cfg;

typedef union anon_union.conflict2636c9_for_value anon_union.conflict2636c9_for_value, *Panon_union.conflict2636c9_for_value;

typedef struct anon_struct.conflict263670 anon_struct.conflict263670, *Panon_struct.conflict263670;

struct anon_struct.conflict263670 {
    uint32_t size:12;
    uint32_t d_reg_index:8;
    uint32_t d_reg_type:4;
    uint32_t op:7;
    uint32_t last_op:1;
};

union anon_union.conflict2636c9_for_value {
    struct anon_struct.conflict263670 BF;
    uint32_t WORD;
};

struct pka0_pld_cfg {
    union anon_union.conflict2636c9_for_value value;
};

typedef union anon_union.conflict2638ff anon_union.conflict2638ff, *Panon_union.conflict2638ff;

typedef struct anon_struct.conflict2638c5 anon_struct.conflict2638c5, *Panon_struct.conflict2638c5;

struct anon_struct.conflict2638c5 {
    uint32_t s2_reg_idx:8;
    uint32_t s2_reg_type:4;
    uint32_t reserved_12_31:20;
};

union anon_union.conflict2638ff {
    struct anon_struct.conflict2638c5 BF;
    uint32_t WORD;
};

typedef union anon_union.conflict2636c9 anon_union.conflict2636c9, *Panon_union.conflict2636c9;

union anon_union.conflict2636c9 {
    struct anon_struct.conflict263670 BF;
    uint32_t WORD;
};

typedef struct pka0_common_op_snd_cfg_S1_only pka0_common_op_snd_cfg_S1_only, *Ppka0_common_op_snd_cfg_S1_only;

typedef union anon_union.conflict263889_for_value anon_union.conflict263889_for_value, *Panon_union.conflict263889_for_value;

union anon_union.conflict263889_for_value {
    struct anon_struct.conflict26383f BF;
    uint32_t WORD;
};

struct pka0_common_op_snd_cfg_S1_only {
    union anon_union.conflict263889_for_value value;
};

typedef union anon_union.conflict263995 anon_union.conflict263995, *Panon_union.conflict263995;

typedef struct anon_struct.conflict26393b anon_struct.conflict26393b, *Panon_struct.conflict26393b;

struct anon_struct.conflict26393b {
    uint32_t s2_reg_idx:8;
    uint32_t s2_reg_type:4;
    uint32_t s1_reg_idx:8;
    uint32_t s1_reg_type:4;
    uint32_t reserved_24_31:8;
};

union anon_union.conflict263995 {
    struct anon_struct.conflict26393b BF;
    uint32_t WORD;
};

typedef union anon_union.conflict2639fb anon_union.conflict2639fb, *Panon_union.conflict2639fb;

union anon_union.conflict2639fb {
    struct anon_struct.conflict2639d1 BF;
    uint32_t WORD;
};

typedef struct pka0_pldi_cfg pka0_pldi_cfg, *Ppka0_pldi_cfg;

typedef union anon_union.conflict26375e_for_value anon_union.conflict26375e_for_value, *Panon_union.conflict26375e_for_value;

union anon_union.conflict26375e_for_value {
    struct anon_struct.conflict263670 BF;
    uint32_t WORD;
};

struct pka0_pldi_cfg {
    union anon_union.conflict26375e_for_value value;
};

typedef struct pka0_common_op_snd_cfg_S2_only pka0_common_op_snd_cfg_S2_only, *Ppka0_common_op_snd_cfg_S2_only;

typedef union anon_union.conflict2638ff_for_value anon_union.conflict2638ff_for_value, *Panon_union.conflict2638ff_for_value;

union anon_union.conflict2638ff_for_value {
    struct anon_struct.conflict2638c5 BF;
    uint32_t WORD;
};

struct pka0_common_op_snd_cfg_S2_only {
    union anon_union.conflict2638ff_for_value value;
};

typedef struct pka0_common_op_snd_cfg_S1_S2 pka0_common_op_snd_cfg_S1_S2, *Ppka0_common_op_snd_cfg_S1_S2;

typedef union anon_union.conflict263995_for_value anon_union.conflict263995_for_value, *Panon_union.conflict263995_for_value;

union anon_union.conflict263995_for_value {
    struct anon_struct.conflict26393b BF;
    uint32_t WORD;
};

struct pka0_common_op_snd_cfg_S1_S2 {
    union anon_union.conflict263995_for_value value;
};

typedef struct _ef_env _ef_env, *P_ef_env;

typedef struct _ef_env ef_env;

struct _ef_env {
    char * key;
    void * value;
    size_t value_len;
};

typedef enum EfErrCode {
    EF_ENV_NAME_EXIST=5,
    EF_ERASE_ERR=1,
    EF_WRITE_ERR=3,
    EF_NO_ERR=0,
    EF_ENV_NAME_ERR=4,
    EF_READ_ERR=2,
    EF_ENV_INIT_FAILED=7,
    EF_ENV_ARG_ERR=8,
    EF_ENV_FULL=6
} EfErrCode;

typedef struct env_node_obj env_node_obj, *Penv_node_obj;

typedef struct env_node_obj * env_node_obj_t;

typedef enum env_status {
    ENV_DELETED=4,
    ENV_UNUSED=0,
    ENV_PRE_DELETE=3,
    ENV_PRE_WRITE=1,
    ENV_ERR_HDR=5,
    ENV_STATUS_NUM=6,
    ENV_WRITE=2
} env_status;

typedef enum env_status env_status_t;

typedef struct anon_struct.conflict185468_for_addr anon_struct.conflict185468_for_addr, *Panon_struct.conflict185468_for_addr;

struct anon_struct.conflict185468_for_addr {
    uint32_t start;
    uint32_t value;
};

struct env_node_obj {
    env_status_t status;
    _Bool crc_is_ok;
    uint8_t name_len;
    undefined field_0x3;
    uint32_t magic;
    uint32_t len;
    uint32_t value_len;
    char name[64];
    struct anon_struct.conflict185468_for_addr addr;
};

typedef struct dbg_mem_write_req dbg_mem_write_req, *Pdbg_mem_write_req;

struct dbg_mem_write_req {
    uint32_t memaddr;
    uint32_t memdata;
};

typedef struct dbg_set_sev_filter_req dbg_set_sev_filter_req, *Pdbg_set_sev_filter_req;

struct dbg_set_sev_filter_req {
    uint32_t sev_filter;
};

typedef struct dbg_mem_write_cfm dbg_mem_write_cfm, *Pdbg_mem_write_cfm;

struct dbg_mem_write_cfm {
    uint32_t memaddr;
    uint32_t memdata;
};

typedef struct dbg_get_sys_stat_cfm dbg_get_sys_stat_cfm, *Pdbg_get_sys_stat_cfm;

struct dbg_get_sys_stat_cfm {
    uint32_t cpu_sleep_time;
    uint32_t doze_time;
    uint32_t stats_time;
};

typedef struct dbg_mem_read_cfm dbg_mem_read_cfm, *Pdbg_mem_read_cfm;

struct dbg_mem_read_cfm {
    uint32_t memaddr;
    uint32_t memdata;
};

typedef struct dbg_set_mod_filter_req dbg_set_mod_filter_req, *Pdbg_set_mod_filter_req;

struct dbg_set_mod_filter_req {
    uint32_t mod_filter;
};

typedef enum dbg_msg_tag {
    DBG_MEM_READ_CFM=1025,
    DBG_SET_SEV_FILTER_REQ=1030,
    DBG_SET_MOD_FILTER_REQ=1028,
    DBG_ERROR_IND=1032,
    DBG_GET_SYS_STAT_CFM=1034,
    DBG_MEM_WRITE_REQ=1026,
    DBG_MEM_READ_REQ=1024,
    DBG_SET_SEV_FILTER_CFM=1031,
    DBG_SYS_STAT_TIMER=1035,
    DBG_MAX=1035,
    DBG_MEM_WRITE_CFM=1027,
    DBG_SET_MOD_FILTER_CFM=1029,
    DBG_GET_SYS_STAT_REQ=1033
} dbg_msg_tag;

typedef struct dbg_mem_read_req dbg_mem_read_req, *Pdbg_mem_read_req;

struct dbg_mem_read_req {
    uint32_t memaddr;
};

typedef struct mbedtls_pk_rsassa_pss_options mbedtls_pk_rsassa_pss_options, *Pmbedtls_pk_rsassa_pss_options;

struct mbedtls_pk_rsassa_pss_options {
    enum mbedtls_md_type_t mgf1_hash_id;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int expected_salt_len;
};

typedef _Bool bool_l;

typedef uint64_t __le64;

typedef int8_t s8_l;

typedef struct targ targ, *Ptarg;

typedef struct AosStaticTask_t AosStaticTask_t, *PAosStaticTask_t;

struct targ {
    struct AosStaticTask_t * task;
    void (* fn)(void *);
    void * arg;
};

struct AosStaticTask_t {
    StaticTask_t fTask;
    uint32_t key_bitmap;
    void * keys[4];
    void * stack;
    char name[32];
    uint32_t magic;
};

typedef struct work work, *Pwork;

struct work {
    void (* fn)(void *);
    void * arg;
    int dly;
};

typedef struct getopt_env getopt_env, *Pgetopt_env;

struct getopt_env {
    char * optarg;
    int optind;
    int opterr;
    int optopt;
    int __optpos;
};

typedef struct getopt_env getopt_env_t;

typedef struct mbedtls_gcm_context mbedtls_gcm_context, *Pmbedtls_gcm_context;

struct mbedtls_gcm_context {
    struct mbedtls_cipher_context_t cipher_ctx;
    uint64_t HL[16];
    uint64_t HH[16];
    uint64_t len;
    uint64_t add_len;
    uchar base_ectr[16];
    uchar y[16];
    uchar buf[16];
    int mode;
    undefined field_0x184;
    undefined field_0x185;
    undefined field_0x186;
    undefined field_0x187;
};

typedef struct TLSConnectParams TLSConnectParams, *PTLSConnectParams;

struct TLSConnectParams {
    char * pRootCALocation;
    char * pDeviceCertLocation;
    char * pDevicePrivateKeyLocation;
    char * pDestinationURL;
    uint16_t DestinationPort;
    undefined field_0x12;
    undefined field_0x13;
    uint32_t timeout_ms;
    _Bool ServerVerificationFlag;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct Network Network, *PNetwork;

typedef enum IoT_Error_t {
    MUTEX_INIT_ERROR=-46,
    NETWORK_X509_ROOT_CRT_PARSE_ERROR=-19,
    MAX_SIZE_ERROR=-50,
    NETWORK_X509_DEVICE_CRT_PARSE_ERROR=-20,
    MQTT_CONNACK_BAD_USERDATA_ERROR=-40,
    NETWORK_MANUALLY_DISCONNECTED=5,
    NETWORK_ALREADY_CONNECTED_ERROR=-15,
    MQTT_CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR=-37,
    MUTEX_DESTROY_ERROR=-49,
    INVALID_TOPIC_TYPE_ERROR=-52,
    NETWORK_SSL_UNKNOWN_ERROR=-17,
    MQTT_CONNACK_UNKNOWN_ERROR=-36,
    NETWORK_SSL_CONNECT_TIMEOUT_ERROR=-6,
    NETWORK_DISCONNECTED_ERROR=-13,
    NETWORK_ERR_NET_CONNECT_FAILED=-24,
    MQTT_RX_BUFFER_TOO_SHORT_ERROR=-32,
    TCP_SETUP_ERROR=-5,
    NETWORK_PHYSICAL_LAYER_CONNECTED=6,
    NETWORK_MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED=-16,
    MQTT_REQUEST_TIMEOUT_ERROR=-28,
    MQTT_RX_MESSAGE_PACKET_TYPE_INVALID_ERROR=-31,
    MUTEX_UNLOCK_ERROR=-48,
    NETWORK_SSL_NOTHING_TO_READ=-25,
    MUTEX_LOCK_ERROR=-47,
    NETWORK_RECONNECT_TIMED_OUT_ERROR=-14,
    NETWORK_ERR_NET_SOCKET_FAILED=-22,
    LIMIT_EXCEEDED_ERROR=-51,
    MQTT_CLIENT_NOT_IDLE_ERROR=-30,
    TCP_CONNECTION_ERROR=-3,
    MQTT_CONNECT_TIMEOUT_ERROR=-27,
    MQTT_TX_BUFFER_TOO_SHORT_ERROR=-33,
    MQTT_MAX_SUBSCRIPTIONS_REACHED_ERROR=-34,
    NETWORK_PK_PRIVATE_KEY_PARSE_ERROR=-21,
    NETWORK_ATTEMPTING_RECONNECT=4,
    SSL_CONNECTION_ERROR=-4,
    NETWORK_SSL_READ_TIMEOUT_ERROR=-11,
    NETWORK_SSL_WRITE_ERROR=-7,
    SHADOW_JSON_ERROR=-45,
    NETWORK_SSL_INIT_ERROR=-8,
    NETWORK_ERR_NET_UNKNOWN_HOST=-23,
    MQTT_DECODE_REMAINING_LENGTH_ERROR=-35,
    MQTT_CONNACK_NOT_AUTHORIZED_ERROR=-41,
    SHADOW_WAIT_FOR_PUBLISH=-43,
    JSON_PARSE_ERROR=-42,
    NETWORK_RECONNECTED=3,
    MQTT_NOTHING_TO_READ=2,
    MQTT_UNEXPECTED_CLIENT_STATE_ERROR=-29,
    SUCCESS=0,
    NULL_VALUE_ERROR=-2,
    NETWORK_SSL_CERT_ERROR=-9,
    NETWORK_PHYSICAL_LAYER_DISCONNECTED=-18,
    NETWORK_SSL_READ_ERROR=-12,
    MQTT_CONNACK_SERVER_UNAVAILABLE_ERROR=-39,
    FAILURE=-1,
    MQTT_CONNECTION_ERROR=-26,
    MQTT_CONNACK_IDENTIFIER_REJECTED_ERROR=-38,
    NETWORK_SSL_WRITE_TIMEOUT_ERROR=-10,
    MQTT_CONNACK_CONNECTION_ACCEPTED=1,
    SHADOW_JSON_BUFFER_TRUNCATED=-44
} IoT_Error_t;

struct Network {
    IoT_Error_t (* connect)(struct Network *, struct TLSConnectParams *);
    IoT_Error_t (* read)(struct Network *, uchar *, size_t, struct Timer *, size_t *);
    IoT_Error_t (* write)(struct Network *, uchar *, size_t, struct Timer *, size_t *);
    IoT_Error_t (* disconnect)(struct Network *);
    IoT_Error_t (* isConnected)(struct Network *);
    IoT_Error_t (* destroy)(struct Network *);
    struct TLSConnectParams tlsConnectParams;
    TLSDataParams tlsDataParams;
};

typedef struct anon_struct.conflictcfd0 anon_struct.conflictcfd0, *Panon_struct.conflictcfd0;

struct anon_struct.conflictcfd0 {
    uint8_t mac[6];
    uint8_t used;
};

typedef struct apm apm, *Papm;

typedef struct apm_start_req apm_start_req, *Papm_start_req;

struct apm {
    struct apm_start_req * param;
    struct co_list bss_config;
    uint8_t aging_sta_idx;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint8_t * bcn_buf;
    _Bool apm_emb_enabled;
    uint8_t hidden_ssid;
    uint8_t assoc_sta_count;
    uint8_t max_sta_supported;
    struct anon_struct.conflictcfd0 aid_list[10];
    undefined field_0x5e;
    undefined field_0x5f;
};

struct apm_start_req {
    struct mac_rateset basic_rates;
    undefined field_0xd;
    struct scan_chan_tag chan;
    uint32_t center_freq1;
    uint32_t center_freq2;
    uint8_t ch_width;
    uint8_t hidden_ssid;
    undefined field_0x1e;
    undefined field_0x1f;
    uint32_t bcn_addr;
    uint16_t bcn_len;
    uint16_t tim_oft;
    uint16_t bcn_int;
    undefined field_0x2a;
    undefined field_0x2b;
    uint32_t flags;
    uint16_t ctrl_port_ethertype;
    uint8_t tim_len;
    uint8_t vif_idx;
    _Bool apm_emb_enabled;
    struct mac_rateset rate_set;
    uint8_t beacon_period;
    uint8_t qos_supported;
    struct mac_ssid ssid;
    uint8_t ap_sec_type;
    uint8_t phrase[64];
    undefined field_0xa7;
};

typedef struct txl_cntrl_env_tag txl_cntrl_env_tag, *Ptxl_cntrl_env_tag;

typedef struct txl_list txl_list, *Ptxl_list;

typedef struct tx_hd tx_hd, *Ptx_hd;

typedef union anon_union.conflict9ef7_for_field_3 anon_union.conflict9ef7_for_field_3, *Panon_union.conflict9ef7_for_field_3;

typedef union anon_union.conflict9f1c_for_field_4 anon_union.conflict9f1c_for_field_4, *Panon_union.conflict9f1c_for_field_4;

typedef union anon_union.conflict9f41_for_field_5 anon_union.conflict9f41_for_field_5, *Panon_union.conflict9f41_for_field_5;

union anon_union.conflict9ef7_for_field_3 {
    uint32_t first_pbd_ptr;
    uint32_t sec_user1_ptr;
};

union anon_union.conflict9f1c_for_field_4 {
    uint32_t datastartptr;
    uint32_t sec_user2_ptr;
};

union anon_union.conflict9f41_for_field_5 {
    uint32_t dataendptr;
    uint32_t sec_user3_ptr;
};

struct tx_hd {
    uint32_t upatterntx;
    uint32_t nextfrmexseq_ptr;
    uint32_t nextmpdudesc_ptr;
    union anon_union.conflict9ef7_for_field_3 field_3;
    union anon_union.conflict9f1c_for_field_4 field_4;
    union anon_union.conflict9f41_for_field_5 field_5;
    uint32_t frmlen;
    uint32_t frmlifetime;
    uint32_t phyctrlinfo;
    uint32_t policyentryaddr;
    uint32_t optlen[3];
    uint32_t macctrlinfo1;
    uint32_t macctrlinfo2;
    uint32_t statinfo;
    uint32_t mediumtimeused;
};

struct txl_list {
    struct tx_hd * last_frame_exch;
    struct co_list transmitting;
    uint16_t bridgedmacnt;
    uint8_t chk_state;
    undefined field_0xf;
};

struct txl_cntrl_env_tag {
    struct txl_list txlist[5];
    uint32_t pck_cnt;
    uint16_t seqnbr;
    _Bool reset;
    undefined field_0x57;
};

typedef ushort __uint16_t;

typedef __uint16_t in_port_t;

typedef int _ssize_t;

typedef _ssize_t ssize_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__uid_t - /types.h/__uid_t

typedef __uid_t uid_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__ino_t - /types.h/__ino_t

typedef __ino_t ino_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__off_t - /types.h/__off_t

typedef __off_t off_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__nlink_t - /types.h/__nlink_t

typedef __nlink_t nlink_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__gid_t - /types.h/__gid_t

typedef __gid_t gid_t;

typedef __blkcnt_t blkcnt_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__mode_t - /types.h/__mode_t

typedef __mode_t mode_t;


// WARNING! conflicting data type names: /DWARF/_types.h/__dev_t - /types.h/__dev_t

typedef __dev_t dev_t;

typedef __blksize_t blksize_t;

typedef struct supplicantData supplicantData_t;

typedef struct wifi_event_data_ind_scan_done wifi_event_data_ind_scan_done, *Pwifi_event_data_ind_scan_done;

struct wifi_event_data_ind_scan_done {
    uint32_t nothing;
};

typedef struct wifi_event_sm_connect_ind wifi_event_sm_connect_ind, *Pwifi_event_sm_connect_ind;

struct wifi_event_sm_connect_ind {
    uint16_t status_code;
    uint8_t bssid[6];
    uint8_t vif_idx;
    uint8_t ap_idx;
    uint8_t ch_idx;
    undefined field_0xb;
    int qos;
    uint16_t aid;
    uint8_t band;
    undefined field_0x13;
    uint16_t center_freq;
    uint8_t width;
    undefined field_0x17;
    uint32_t center_freq1;
    uint32_t center_freq2;
};

typedef struct wifi_event_sm_disconnect_ind wifi_event_sm_disconnect_ind, *Pwifi_event_sm_disconnect_ind;

struct wifi_event_sm_disconnect_ind {
    uint16_t reason_code;
    uint8_t vif_idx;
    undefined field_0x3;
    int ft_over_ds;
};

typedef struct wifi_apm_sta_info wifi_apm_sta_info, *Pwifi_apm_sta_info;

struct wifi_apm_sta_info {
    uint8_t sta_idx;
    uint8_t is_used;
    uint8_t sta_mac[6];
    uint32_t tsfhi;
    uint32_t tsflo;
    int rssi;
    uint8_t data_rate;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct wifi_event_beacon_ind wifi_event_beacon_ind, *Pwifi_event_beacon_ind;

typedef struct wifi_cipher_t wifi_cipher_t, *Pwifi_cipher_t;

typedef struct wifi_secmode_t wifi_secmode_t, *Pwifi_secmode_t;

struct wifi_cipher_t {
    uint8_t wep40:1;
    uint8_t wep104:1;
    uint8_t tkip:1;
    uint8_t ccmp:1;
    uint8_t rsvd:4;
};

struct wifi_secmode_t {
    uint8_t noRsn:1;
    uint8_t wepStatic:1;
    uint8_t wepDynamic:1;
    uint8_t wpa:1;
    uint8_t wpaNone:1;
    uint8_t wpa2:1;
    uint8_t cckm:1;
    uint8_t wapi:1;
    uint8_t rsvd:8;
};

struct wifi_event_beacon_ind {
    uint8_t bssid[6];
    uint8_t ssid[33];
    int8_t rssi;
    int8_t ppm_abs;
    int8_t ppm_rel;
    uint8_t channel;
    uint8_t auth;
    uint8_t cipher;
    struct wifi_cipher_t wpa_mcstCipher;
    struct wifi_cipher_t wpa_ucstCipher;
    struct wifi_cipher_t rsn_mcstCipher;
    struct wifi_cipher_t rsn_ucstCipher;
    struct wifi_secmode_t sec_mode;
    undefined field_0x33;
    int ssid_len;
};

typedef struct wifi_event wifi_event, *Pwifi_event;

struct wifi_event {
    uint32_t id;
    uint8_t[0] data;
};

typedef struct wifi_event_data_ind_channel_switch wifi_event_data_ind_channel_switch, *Pwifi_event_data_ind_channel_switch;

struct wifi_event_data_ind_channel_switch {
    int channel;
};

typedef struct phyif_utils_recvtable_t phyif_utils_recvtable_t, *Pphyif_utils_recvtable_t;

struct phyif_utils_recvtable_t {
    uint32_t recvtable1;
    uint32_t recvtable2;
    uint32_t recvtable3;
    uint32_t recvtable4;
    uint32_t recvtable5;
    uint32_t recvtable6;
};

typedef struct dhcp_msg dhcp_msg, *Pdhcp_msg;

typedef struct ip4_addr_packed ip4_addr_packed, *Pip4_addr_packed;

typedef struct ip4_addr_packed ip4_addr_p_t;

struct ip4_addr_packed {
    u32_t addr;
};

struct dhcp_msg {
    u8_t op;
    u8_t htype;
    u8_t hlen;
    u8_t hops;
    u32_t xid;
    u16_t secs;
    u16_t flags;
    ip4_addr_p_t ciaddr;
    ip4_addr_p_t yiaddr;
    ip4_addr_p_t siaddr;
    ip4_addr_p_t giaddr;
    u8_t chaddr[16];
    u8_t sname[64];
    u8_t file[128];
    u32_t cookie;
    u8_t options[68];
};

typedef struct dhcp dhcp, *Pdhcp;

struct dhcp {
    u32_t xid;
    u8_t pcb_allocated;
    u8_t state;
    u8_t tries;
    u8_t subnet_mask_given;
    u16_t request_timeout;
    u16_t t1_timeout;
    u16_t t2_timeout;
    u16_t t1_renew_time;
    u16_t t2_rebind_time;
    u16_t lease_used;
    u16_t t0_timeout;
    undefined field_0x16;
    undefined field_0x17;
    ip_addr_t server_ip_addr;
    ip4_addr_t offered_ip_addr;
    ip4_addr_t offered_sn_mask;
    ip4_addr_t offered_gw_addr;
    u32_t offered_t0_lease;
    u32_t offered_t1_renew;
    u32_t offered_t2_rebind;
};

typedef enum dhcp_option_idx {
    DHCP_OPTION_IDX_MSG_TYPE=1,
    DHCP_OPTION_IDX_ROUTER=7,
    DHCP_OPTION_IDX_DNS_SERVER_LAST=9,
    DHCP_OPTION_IDX_LEASE_TIME=3,
    DHCP_OPTION_IDX_SUBNET_MASK=6,
    DHCP_OPTION_IDX_T2=5,
    DHCP_OPTION_IDX_MAX=10,
    DHCP_OPTION_IDX_OVERLOAD=0,
    DHCP_OPTION_IDX_SERVER_ID=2,
    DHCP_OPTION_IDX_T1=4,
    DHCP_OPTION_IDX_DNS_SERVER=8
} dhcp_option_idx;

typedef struct phyif_utils_recvtable_priv_t phyif_utils_recvtable_priv_t, *Pphyif_utils_recvtable_priv_t;

struct phyif_utils_recvtable_priv_t {
    uint32_t leg_length:12;
    uint32_t leg_rate:4;
    uint32_t ht_length:16;
    uint32_t _ht_length:4;
    uint32_t short_gi:1;
    uint32_t stbc:2;
    uint32_t smoothing:1;
    uint32_t mcs:7;
    uint32_t pre_type:1;
    uint32_t format_mod:3;
    uint32_t ch_bw:2;
    uint32_t n_sts:3;
    uint32_t lsig_valid:1;
    uint32_t sounding:1;
    uint32_t num_extn_ss:2;
    uint32_t aggregation:1;
    uint32_t fec_coding:1;
    uint32_t dyn_bw:1;
    uint32_t doze_not_allowed:1;
    uint32_t antenna_set:8;
    uint32_t partial_aid:9;
    uint32_t group_id:6;
    uint32_t reserved_1c:1;
    int32_t rssi1:8;
    int32_t rssi2:8;
    int32_t rssi3:8;
    int32_t rssi4:8;
    uint32_t reserved_1d:8;
    uint32_t rcpi:8;
    uint32_t evm1:8;
    uint32_t evm2:8;
    uint32_t evm3:8;
    uint32_t evm4:8;
    uint32_t reserved2b_1:8;
    uint32_t reserved2b_2:8;
    uint32_t reserved2b_3:8;
};

typedef struct ipc_emb_env_tag ipc_emb_env_tag, *Pipc_emb_env_tag;

struct ipc_emb_env_tag {
    struct co_list rx_queue;
    struct co_list cfm_queue;
    uint8_t ipc_rxdesc_idx;
    uint8_t ipc_rxbuf_idx;
    uint8_t ipc_radar_buf_idx;
    uint8_t ipc_msge2a_buf_idx;
    uint8_t ipc_dbg_buf_idx;
    uint8_t ipc_msgacke2a_cnt;
    undefined field_0x16;
    undefined field_0x17;
    uint32_t txdesc_idx;
    struct txdesc_host * txdesc;
};

typedef struct romapi_freertos_map romapi_freertos_map, *Promapi_freertos_map;

struct romapi_freertos_map {
    void * vApplicationIdleHook;
    void * interrupt_entry_ptr;
    void * vApplicationGetIdleTaskMemory;
    void * vApplicationStackOverflowHook;
    void * vApplicationGetTimerTaskMemory;
    void * rtos_sprintf;
    void * vApplicationMallocFailedHook;
    void * rtos_memcpy_ptr;
    void * vAssertCalled;
    void * rtos_strlen_ptr;
    void * rtos_memset_ptr;
    void * rtos_clz;
    void * exception_entry_ptr;
    void * rtos_strcpy_ptr;
    void * xISRStackTop;
};

typedef struct mac_hdr_long mac_hdr_long, *Pmac_hdr_long;

struct mac_hdr_long {
    uint16_t fctl;
    uint16_t durid;
    struct mac_addr addr1;
    struct mac_addr addr2;
    struct mac_addr addr3;
    uint16_t seq;
    struct mac_addr addr4;
};

typedef struct mac_hdr_qos mac_hdr_qos, *Pmac_hdr_qos;

struct mac_hdr_qos {
    uint16_t fctl;
    uint16_t durid;
    struct mac_addr addr1;
    struct mac_addr addr2;
    struct mac_addr addr3;
    uint16_t seq;
    uint16_t qos;
};

typedef struct mac_hdr mac_hdr, *Pmac_hdr;

struct mac_hdr {
    uint16_t fctl;
    uint16_t durid;
    struct mac_addr addr1;
    struct mac_addr addr2;
    struct mac_addr addr3;
    uint16_t seq;
};

typedef struct eth_hdr eth_hdr, *Peth_hdr;

typedef struct eth_addr eth_addr, *Peth_addr;

struct eth_addr {
    u8_t addr[6];
};

struct eth_hdr {
    struct eth_addr dest;
    struct eth_addr src;
    u16_t type;
};

typedef struct mac_hdr_long_qos mac_hdr_long_qos, *Pmac_hdr_long_qos;

struct mac_hdr_long_qos {
    uint16_t fctl;
    uint16_t durid;
    struct mac_addr addr1;
    struct mac_addr addr2;
    struct mac_addr addr3;
    uint16_t seq;
    struct mac_addr addr4;
    uint16_t qos;
};

typedef struct mac_hdr_ctrl mac_hdr_ctrl, *Pmac_hdr_ctrl;

struct mac_hdr_ctrl {
    uint16_t fctl;
    uint16_t durid;
    struct mac_addr addr1;
    struct mac_addr addr2;
};

typedef struct bcn_frame bcn_frame, *Pbcn_frame;

struct bcn_frame {
    struct mac_hdr h;
    uint64_t tsf;
    uint16_t bcnint;
    uint16_t capa;
    uint8_t[0] variable;
};

typedef struct preq_frame preq_frame, *Ppreq_frame;

struct preq_frame {
    struct mac_hdr h;
    uint8_t[0] payload;
};

typedef union byte_array byte_array, *Pbyte_array;

typedef uint uintptr_t;

union byte_array {
    uint8_t bytes[8];
    uintptr_t intx;
    uint64_t int64;
};

typedef enum BL_IRQ_EXCEPTION_TYPE_T {
    BL_IRQ_EXCEPTION_TYPE_ACCESS_ILLEGAL=2,
    BL_IRQ_EXCEPTION_TYPE_STORE_MISALIGN=1,
    BL_IRQ_EXCEPTION_TYPE_LOAD_MISALIGN=0,
    BL_IRQ_EXCEPTION_TYPE_ILLEGAL_INSTRUCTION=3
} BL_IRQ_EXCEPTION_TYPE_T;

typedef struct xTIME_OUT xTIME_OUT, *PxTIME_OUT;

typedef struct xTIME_OUT TimeOut_t;

struct xTIME_OUT {
    BaseType_t xOverflowCount;
    TickType_t xTimeOnEntering;
};

typedef enum eNotifyAction {
    eSetBits=1,
    eIncrement=2,
    eSetValueWithOverwrite=3,
    eNoAction=0,
    eSetValueWithoutOverwrite=4
} eNotifyAction;

typedef struct xTASK_STATUS xTASK_STATUS, *PxTASK_STATUS;

typedef enum eTaskState {
    eReady=1,
    eRunning=0,
    eSuspended=3,
    eDeleted=4,
    eInvalid=5,
    eBlocked=2
} eTaskState;

struct xTASK_STATUS {
    TaskHandle_t xHandle;
    char * pcTaskName;
    UBaseType_t xTaskNumber;
    enum eTaskState eCurrentState;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    UBaseType_t uxCurrentPriority;
    UBaseType_t uxBasePriority;
    uint32_t ulRunTimeCounter;
    StackType_t * pxStackBase;
    uint16_t usStackHighWaterMark;
    undefined field_0x22;
    undefined field_0x23;
};

typedef struct xMEMORY_REGION xMEMORY_REGION, *PxMEMORY_REGION;

typedef struct xMEMORY_REGION MemoryRegion_t;

struct xMEMORY_REGION {
    void * pvBaseAddress;
    uint32_t ulLengthInBytes;
    uint32_t ulParameters;
};

typedef struct xTASK_STATUS TaskStatus_t;

typedef struct dma_env_tag dma_env_tag, *Pdma_env_tag;

struct dma_env_tag {
    struct dma_desc * last_dma[4];
};

typedef struct sm_disconnect_req sm_disconnect_req, *Psm_disconnect_req;

struct sm_disconnect_req {
    uint16_t reason_code;
    uint8_t vif_idx;
    undefined field_0x3;
};

typedef struct sm_disconnect_ind sm_disconnect_ind, *Psm_disconnect_ind;

struct sm_disconnect_ind {
    uint16_t reason_code;
    uint8_t vif_idx;
    _Bool ft_over_ds;
};

typedef struct sm_connect_ind sm_connect_ind, *Psm_connect_ind;

struct sm_connect_ind {
    u16_l status_code;
    struct mac_addr.conflict bssid;
    bool_l roamed;
    u8_l vif_idx;
    u8_l ap_idx;
    u8_l ch_idx;
    bool_l qos;
    u8_l acm;
    u16_l assoc_req_ie_len;
    u16_l assoc_rsp_ie_len;
    undefined field_0x12;
    undefined field_0x13;
    u32_l assoc_ie_buf[200];
    u16_l aid;
    u8_l band;
    undefined field_0x337;
    u16_l center_freq;
    u8_l width;
    undefined field_0x33b;
    u32_l center_freq1;
    u32_l center_freq2;
    u32_l ac_param[4];
};

typedef struct sm_connect_cfm sm_connect_cfm, *Psm_connect_cfm;

struct sm_connect_cfm {
    uint8_t status;
};

typedef struct sm_connect_req sm_connect_req, *Psm_connect_req;

struct sm_connect_req {
    struct mac_ssid ssid;
    struct mac_addr.conflict bssid;
    struct scan_chan_tag chan;
    undefined field_0x2e;
    undefined field_0x2f;
    u32_l flags;
    u16_l ctrl_port_ethertype;
    u16_l ie_len;
    u16_l listen_interval;
    bool_l dont_wait_bcmc;
    u8_l auth_type;
    u8_l uapsd_queues;
    u8_l vif_idx;
    undefined field_0x3e;
    undefined field_0x3f;
    u32_l ie_buf[64];
    _Bool is_supplicant_enabled;
    uint8_t phrase[64];
    uint8_t phrase_pmk[64];
    undefined field_0x1c1;
    undefined field_0x1c2;
    undefined field_0x1c3;
};

typedef enum sm_state_tag {
    SM_DISCONNECTING=8,
    SM_STA_ADDING=3,
    SM_SCANNING=1,
    SM_BSS_PARAM_SETTING=4,
    SM_ACTIVATING=7,
    SM_JOINING=2,
    SM_STATE_MAX=9,
    SM_AUTHENTICATING=5,
    SM_ASSOCIATING=6,
    SM_IDLE=0
} sm_state_tag;

typedef enum sm_msg_tag {
    SM_CONNECT_REQ=6144,
    SM_CONNECT_IND=6146,
    SM_MAX=6151,
    SM_CONNECT_CFM=6145,
    SM_DISCONNECT_IND=6149,
    SM_RSP_TIMEOUT_IND=6150,
    SM_DISCONNECT_REQ=6147,
    SM_DISCONNECT_CFM=6148
} sm_msg_tag;

typedef enum msgTypes {
    CONNACK=2,
    PUBREC=5,
    SUBACK=9,
    UNSUBSCRIBE=10,
    CONNECT=1,
    PUBLISH=3,
    PUBREL=6,
    PUBCOMP=7,
    SUBSCRIBE=8,
    PINGRESP=13,
    UNSUBACK=11,
    UNKNOWN=-1,
    DISCONNECT=14,
    PUBACK=4,
    PINGREQ=12
} msgTypes;

typedef union MQTTHeader MQTTHeader, *PMQTTHeader;

union MQTTHeader {
    uchar byte;
};

typedef enum msgTypes MessageTypes;

typedef struct lwip_select_cb lwip_select_cb, *Plwip_select_cb;

typedef uint nfds_t;

struct lwip_select_cb {
    struct lwip_select_cb * next;
    struct lwip_select_cb * prev;
    struct _types_fd_set * readset;
    struct _types_fd_set * writeset;
    struct _types_fd_set * exceptset;
    struct pollfd * poll_fds;
    nfds_t poll_nfds;
    int sem_signalled;
    sys_sem_t sem;
};

typedef union anon_union.conflict1c7a2c anon_union.conflict1c7a2c, *Panon_union.conflict1c7a2c;

union anon_union.conflict1c7a2c {
    void * p;
    void * pc;
};

typedef struct lwip_setgetsockopt_data lwip_setgetsockopt_data, *Plwip_setgetsockopt_data;

typedef union anon_union.conflict1c7a2c_for_optval anon_union.conflict1c7a2c_for_optval, *Panon_union.conflict1c7a2c_for_optval;

typedef u32_t socklen_t;

union anon_union.conflict1c7a2c_for_optval {
    void * p;
    void * pc;
};

struct lwip_setgetsockopt_data {
    int s;
    int level;
    int optname;
    union anon_union.conflict1c7a2c_for_optval optval;
    socklen_t optlen;
    int err;
    void * completed_sem;
};

typedef struct lwip_sock lwip_sock, *Plwip_sock;

typedef union lwip_sock_lastdata lwip_sock_lastdata, *Plwip_sock_lastdata;

union lwip_sock_lastdata {
    struct netbuf * netbuf;
    struct pbuf * pbuf;
};

struct lwip_sock {
    struct netconn * conn;
    union lwip_sock_lastdata lastdata;
    s16_t rcvevent;
    u16_t sendevent;
    u16_t errevent;
    u8_t select_waiting;
    undefined field_0xf;
};

typedef struct mm_csa_counter_ind mm_csa_counter_ind, *Pmm_csa_counter_ind;

struct mm_csa_counter_ind {
    uint8_t vif_index;
    uint8_t csa_count;
};

typedef struct mm_set_edca_req mm_set_edca_req, *Pmm_set_edca_req;

struct mm_set_edca_req {
    uint32_t ac_param;
    _Bool uapsd;
    uint8_t hw_queue;
    uint8_t inst_nbr;
    undefined field_0x7;
};

typedef struct mm_remain_on_channel_req mm_remain_on_channel_req, *Pmm_remain_on_channel_req;

struct mm_remain_on_channel_req {
    uint8_t op_code;
    uint8_t vif_index;
    uint8_t band;
    uint8_t type;
    uint16_t prim20_freq;
    uint16_t center1_freq;
    uint16_t center2_freq;
    undefined field_0xa;
    undefined field_0xb;
    uint32_t duration_ms;
    int8_t tx_power;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct mm_force_idle_req mm_force_idle_req, *Pmm_force_idle_req;

struct mm_force_idle_req {
    void (* cb)(void);
};

typedef struct mm_set_bssid_req mm_set_bssid_req, *Pmm_set_bssid_req;

struct mm_set_bssid_req {
    struct mac_addr bssid;
    uint8_t inst_nbr;
};

typedef struct mm_key_add_cfm mm_key_add_cfm, *Pmm_key_add_cfm;

struct mm_key_add_cfm {
    uint8_t status;
    uint8_t hw_key_idx;
};

typedef struct mm_monitor_channel_cfm mm_monitor_channel_cfm, *Pmm_monitor_channel_cfm;

struct mm_monitor_channel_cfm {
    uint32_t status;
    uint32_t freq;
    uint32_t data[8];
};

typedef struct mm_remain_on_channel_cfm mm_remain_on_channel_cfm, *Pmm_remain_on_channel_cfm;

struct mm_remain_on_channel_cfm {
    uint8_t op_code;
    uint8_t status;
    uint8_t chan_ctxt_index;
};

typedef struct mm_rssi_status_ind mm_rssi_status_ind, *Pmm_rssi_status_ind;

struct mm_rssi_status_ind {
    uint8_t vif_index;
    _Bool rssi_status;
    int8_t rssi;
};

typedef struct mm_tim_update_req mm_tim_update_req, *Pmm_tim_update_req;

struct mm_tim_update_req {
    uint16_t aid;
    uint8_t tx_avail;
    uint8_t inst_nbr;
};

typedef struct mm_sta_del_req mm_sta_del_req, *Pmm_sta_del_req;

struct mm_sta_del_req {
    uint8_t sta_idx;
};

typedef enum mm_msg_tag {
    MM_BFMER_ENABLE_REQ=80,
    MM_SECONDARY_TBTT_IND=45,
    MM_DENOISE_REQ=48,
    MM_SET_EDCA_CFM=27,
    MM_SET_P2P_NOA_CFM=83,
    MM_SET_VIF_STATE_CFM=31,
    MM_RESET_CFM=1,
    MM_MU_GROUP_UPDATE_CFM=91,
    MM_REMAIN_ON_CHANNEL_CFM=71,
    MM_BA_DEL_CFM=43,
    MM_CHANNEL_SURVEY_IND=79,
    MM_SET_BEACON_INT_CFM=21,
    MM_SET_SLOTTIME_REQ=32,
    MM_REMOVE_IF_REQ=8,
    MM_RSSI_STATUS_IND=87,
    MM_SET_PS_MODE_CFM=50,
    MM_SET_BSSID_CFM=25,
    MM_CHAN_CTXT_ADD_REQ=51,
    MM_P2P_NOA_UPD_IND=85,
    MM_SET_IDLE_REQ=34,
    MM_KEY_ADD_REQ=36,
    MM_SET_P2P_OPPPS_CFM=84,
    MM_MONITOR_CFM=93,
    MM_BA_ADD_REQ=40,
    MM_MONITOR_REQ=92,
    MM_CSA_FINISH_IND=88,
    MM_SET_VIF_STATE_REQ=30,
    MM_CONNECTION_LOSS_IND=67,
    MM_SET_BASIC_RATES_REQ=22,
    MM_CHAN_CTXT_DEL_CFM=54,
    MM_CHAN_CTXT_UNLINK_REQ=57,
    MM_START_CFM=3,
    MM_TIM_UPDATE_CFM=66,
    MM_CHAN_CTXT_SCHED_REQ=61,
    MM_CHAN_CTXT_UNLINK_CFM=58,
    MM_P2P_VIF_PS_CHANGE_IND=77,
    MM_SET_POWER_REQ=46,
    MM_SET_DTIM_REQ=18,
    MM_TRAFFIC_REQ_IND=74,
    MM_BA_ADD_CFM=41,
    MM_CHAN_CTXT_UPDATE_REQ=59,
    MM_FORCE_IDLE_REQ=96,
    MM_KEY_DEL_REQ=38,
    MM_SET_PS_OPTIONS_CFM=76,
    MM_SET_BSSID_REQ=24,
    MM_SET_CHANNEL_CFM=17,
    MM_CHANNEL_PRE_SWITCH_IND=69,
    MM_TIM_UPDATE_REQ=65,
    MM_CHANNEL_SWITCH_IND=68,
    MM_MONITOR_CHANNEL_REQ=94,
    MM_SET_BASIC_RATES_CFM=23,
    MM_BCN_CHANGE_REQ=63,
    MM_REMAIN_ON_CHANNEL_EXP_IND=72,
    MM_CHAN_CTXT_DEL_REQ=53,
    MM_STA_ADD_CFM=11,
    MM_PS_CHANGE_IND=73,
    MM_CHAN_CTXT_LINK_CFM=56,
    MM_SET_PS_OPTIONS_REQ=75,
    MM_START_REQ=2,
    MM_SET_MODE_CFM=29,
    MM_VERSION_CFM=5,
    MM_CHAN_CTXT_UPDATE_CFM=60,
    MM_KEY_DEL_CFM=39,
    MM_SET_MODE_REQ=28,
    MM_CHAN_CTXT_SCHED_CFM=62,
    MM_SET_CHANNEL_REQ=16,
    MM_SET_FILTER_CFM=15,
    MM_MONITOR_CHANNEL_CFM=95,
    MM_PRIMARY_TBTT_IND=44,
    MM_SET_POWER_CFM=47,
    MM_STA_DEL_REQ=12,
    MM_ADD_IF_REQ=6,
    MM_CSA_COUNTER_IND=78,
    MM_SET_DTIM_CFM=19,
    MM_STA_ADD_REQ=10,
    MM_CHAN_CTXT_ADD_CFM=52,
    MM_ADD_IF_CFM=7,
    MM_CFG_RSSI_REQ=86,
    MM_RESET_REQ=0,
    MM_BCN_CHANGE_CFM=64,
    MM_SCAN_CHANNEL_START_IND=97,
    MM_REMOVE_IF_CFM=9,
    MM_SET_P2P_NOA_REQ=81,
    MM_REMAIN_ON_CHANNEL_REQ=70,
    MM_CSA_TRAFFIC_IND=89,
    MM_SCAN_CHANNEL_END_IND=98,
    MM_VERSION_REQ=4,
    MM_SET_FILTER_REQ=14,
    MM_STA_DEL_CFM=13,
    MM_SET_EDCA_REQ=26,
    MM_SET_PS_MODE_REQ=49,
    MM_SET_P2P_OPPPS_REQ=82,
    MM_MAX=99,
    MM_MU_GROUP_UPDATE_REQ=90,
    MM_SET_IDLE_CFM=35,
    MM_SET_BEACON_INT_REQ=20,
    MM_SET_SLOTTIME_CFM=33,
    MM_KEY_ADD_CFM=37,
    MM_CHAN_CTXT_LINK_REQ=55,
    MM_BA_DEL_REQ=42
} mm_msg_tag;

typedef struct mm_monitor_channel_req mm_monitor_channel_req, *Pmm_monitor_channel_req;

struct mm_monitor_channel_req {
    uint32_t freq;
    uint32_t use_40Mhz;
    uint32_t higher_band;
};

typedef struct mm_set_channel_req mm_set_channel_req, *Pmm_set_channel_req;

struct mm_set_channel_req {
    uint8_t band;
    uint8_t type;
    uint16_t prim20_freq;
    uint16_t center1_freq;
    uint16_t center2_freq;
    uint8_t index;
    int8_t tx_power;
};

typedef struct mm_set_filter_req mm_set_filter_req, *Pmm_set_filter_req;

struct mm_set_filter_req {
    uint32_t filter;
};

typedef struct mm_key_add_req mm_key_add_req, *Pmm_key_add_req;

typedef struct mac_sec_key mac_sec_key, *Pmac_sec_key;

struct mac_sec_key {
    uint8_t length;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t array[8];
};

struct mm_key_add_req {
    uint8_t key_idx;
    uint8_t sta_idx;
    undefined field_0x2;
    undefined field_0x3;
    struct mac_sec_key key;
    uint8_t cipher_suite;
    uint8_t inst_nbr;
    uint8_t spp;
    _Bool pairwise;
};

typedef struct mm_sta_add_req mm_sta_add_req, *Pmm_sta_add_req;

struct mm_sta_add_req {
    uint32_t ampdu_size_max_vht;
    uint32_t paid_gid;
    uint16_t ampdu_size_max_ht;
    struct mac_addr mac_addr;
    uint8_t ampdu_spacing_min;
    uint8_t inst_nbr;
    _Bool tdls_sta;
    int8_t rssi;
    uint32_t tsflo;
    uint32_t tsfhi;
    uint8_t data_rate;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct mm_set_ps_mode_req mm_set_ps_mode_req, *Pmm_set_ps_mode_req;

struct mm_set_ps_mode_req {
    uint8_t new_state;
};

typedef struct mm_set_power_cfm mm_set_power_cfm, *Pmm_set_power_cfm;

struct mm_set_power_cfm {
    uint8_t radio_idx;
    int8_t power;
};

typedef struct mm_set_vif_state_req mm_set_vif_state_req, *Pmm_set_vif_state_req;

struct mm_set_vif_state_req {
    uint16_t aid;
    _Bool active;
    uint8_t inst_nbr;
};

typedef struct mm_set_mode_req mm_set_mode_req, *Pmm_set_mode_req;

struct mm_set_mode_req {
    uint8_t abgnmode;
};

typedef struct mm_start_req mm_start_req, *Pmm_start_req;

typedef struct phy_cfg_tag phy_cfg_tag, *Pphy_cfg_tag;

struct phy_cfg_tag {
    uint32_t parameters[16];
};

struct mm_start_req {
    struct phy_cfg_tag phy_cfg;
    uint32_t uapsd_timeout;
    uint16_t lp_clk_accuracy;
    undefined field_0x46;
    undefined field_0x47;
};

typedef enum mm_remain_on_channel_op {
    MM_ROC_OP_MAX=2,
    MM_ROC_OP_CANCEL=1,
    MM_ROC_OP_START=0
} mm_remain_on_channel_op;

typedef struct mm_chan_ctxt_update_req mm_chan_ctxt_update_req, *Pmm_chan_ctxt_update_req;

struct mm_chan_ctxt_update_req {
    uint8_t chan_index;
    uint8_t band;
    uint8_t type;
    undefined field_0x3;
    uint16_t prim20_freq;
    uint16_t center1_freq;
    uint16_t center2_freq;
    int8_t tx_power;
    undefined field_0xb;
};

typedef struct mm_remove_if_req mm_remove_if_req, *Pmm_remove_if_req;

struct mm_remove_if_req {
    uint8_t inst_nbr;
};

typedef struct mm_monitor_req mm_monitor_req, *Pmm_monitor_req;

struct mm_monitor_req {
    uint32_t enable;
};

typedef struct mm_cfg_rssi_req mm_cfg_rssi_req, *Pmm_cfg_rssi_req;

struct mm_cfg_rssi_req {
    uint8_t vif_index;
    int8_t rssi_thold;
    uint8_t rssi_hyst;
};

typedef struct mm_version_cfm mm_version_cfm, *Pmm_version_cfm;

struct mm_version_cfm {
    uint32_t version_lmac;
    uint32_t version_machw_1;
    uint32_t version_machw_2;
    uint32_t version_phy_1;
    uint32_t version_phy_2;
    uint32_t features;
};

typedef struct mm_set_beacon_int_req mm_set_beacon_int_req, *Pmm_set_beacon_int_req;

struct mm_set_beacon_int_req {
    uint16_t beacon_int;
    uint8_t inst_nbr;
    undefined field_0x3;
};

typedef struct mm_add_if_cfm mm_add_if_cfm, *Pmm_add_if_cfm;

struct mm_add_if_cfm {
    uint8_t status;
    uint8_t inst_nbr;
};

typedef struct mm_traffic_req_ind mm_traffic_req_ind, *Pmm_traffic_req_ind;

struct mm_traffic_req_ind {
    uint8_t sta_idx;
    uint8_t pkt_cnt;
    _Bool uapsd;
};

typedef struct mm_set_ps_options_req mm_set_ps_options_req, *Pmm_set_ps_options_req;

struct mm_set_ps_options_req {
    uint8_t vif_index;
    undefined field_0x1;
    uint16_t listen_interval;
    _Bool dont_listen_bc_mc;
    undefined field_0x5;
};

typedef struct mm_set_power_req mm_set_power_req, *Pmm_set_power_req;

struct mm_set_power_req {
    uint8_t inst_nbr;
    int8_t power;
};

typedef struct mm_connection_loss_ind mm_connection_loss_ind, *Pmm_connection_loss_ind;

struct mm_connection_loss_ind {
    uint8_t inst_nbr;
};

typedef struct mm_set_dtim_req mm_set_dtim_req, *Pmm_set_dtim_req;

struct mm_set_dtim_req {
    uint8_t dtim_period;
};

typedef struct mm_bcn_change_req mm_bcn_change_req, *Pmm_bcn_change_req;

struct mm_bcn_change_req {
    uint32_t bcn_ptr;
    uint16_t bcn_len;
    uint16_t tim_oft;
    uint8_t tim_len;
    uint8_t inst_nbr;
    uint8_t csa_oft[2];
    uint8_t[0] bcn_buf;
};

typedef struct mm_key_del_req mm_key_del_req, *Pmm_key_del_req;

struct mm_key_del_req {
    uint8_t hw_key_idx;
};

typedef struct mm_set_channel_cfm mm_set_channel_cfm, *Pmm_set_channel_cfm;

struct mm_set_channel_cfm {
    uint8_t radio_idx;
    int8_t power;
};

typedef struct mm_add_if_req mm_add_if_req, *Pmm_add_if_req;

struct mm_add_if_req {
    u8_l type;
    struct mac_addr.conflict addr;
    bool_l p2p;
};

typedef struct mm_ba_add_req mm_ba_add_req, *Pmm_ba_add_req;

struct mm_ba_add_req {
    uint8_t type;
    uint8_t sta_idx;
    uint8_t tid;
    uint8_t bufsz;
    uint16_t ssn;
};

typedef struct mm_monitor_cfm mm_monitor_cfm, *Pmm_monitor_cfm;

struct mm_monitor_cfm {
    uint32_t status;
    uint32_t enable;
    uint32_t data[8];
};

typedef struct mm_chan_ctxt_add_req mm_chan_ctxt_add_req, *Pmm_chan_ctxt_add_req;

struct mm_chan_ctxt_add_req {
    uint8_t band;
    uint8_t type;
    uint16_t prim20_freq;
    uint16_t center1_freq;
    uint16_t center2_freq;
    int8_t tx_power;
    undefined field_0x9;
};

typedef struct mm_csa_finish_ind mm_csa_finish_ind, *Pmm_csa_finish_ind;

struct mm_csa_finish_ind {
    uint8_t vif_index;
    uint8_t status;
    uint8_t chan_idx;
};

typedef struct mm_csa_traffic_ind mm_csa_traffic_ind, *Pmm_csa_traffic_ind;

struct mm_csa_traffic_ind {
    uint8_t vif_index;
    _Bool enable;
};

typedef struct mm_set_slottime_req mm_set_slottime_req, *Pmm_set_slottime_req;

struct mm_set_slottime_req {
    uint8_t slottime;
};

typedef struct mm_set_basic_rates_req mm_set_basic_rates_req, *Pmm_set_basic_rates_req;

struct mm_set_basic_rates_req {
    uint32_t rates;
    uint8_t inst_nbr;
    uint8_t band;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct mm_set_idle_req mm_set_idle_req, *Pmm_set_idle_req;

struct mm_set_idle_req {
    uint8_t hw_idle;
};

typedef struct mm_sta_add_cfm mm_sta_add_cfm, *Pmm_sta_add_cfm;

struct mm_sta_add_cfm {
    uint8_t status;
    uint8_t sta_idx;
    uint8_t hw_sta_idx;
};

typedef struct mm_ba_add_cfm mm_ba_add_cfm, *Pmm_ba_add_cfm;

struct mm_ba_add_cfm {
    uint8_t sta_idx;
    uint8_t tid;
    uint8_t status;
};

typedef struct mm_ps_change_ind mm_ps_change_ind, *Pmm_ps_change_ind;

struct mm_ps_change_ind {
    uint8_t sta_idx;
    uint8_t ps_state;
};

typedef enum mm_state_tag {
    MM_IDLE=0,
    MM_STATE_MAX=4,
    MM_ACTIVE=1,
    MM_GOING_TO_IDLE=2,
    MM_HOST_BYPASSED=3
} mm_state_tag;

typedef struct ip_globals ip_globals, *Pip_globals;

typedef struct netif netif, *Pnetif;

typedef enum netif_mac_filter_action {
    NETIF_DEL_MAC_FILTER=0,
    NETIF_ADD_MAC_FILTER=1
} netif_mac_filter_action;

typedef struct ip_hdr ip_hdr, *Pip_hdr;

struct netif {
    struct netif * next;
    ip_addr_t ip_addr;
    ip_addr_t netmask;
    ip_addr_t gw;
    err_t (* input)(struct pbuf *, struct netif *);
    err_t (* output)(struct netif *, struct pbuf *, ip4_addr_t *);
    err_t (* linkoutput)(struct netif *, struct pbuf *);
    void (* status_callback)(struct netif *);
    void (* link_callback)(struct netif *);
    void * state;
    void * client_data[3];
    char * hostname;
    u16_t mtu;
    u8_t hwaddr[6];
    u8_t hwaddr_len;
    u8_t flags;
    char name[2];
    u8_t num;
    u8_t rs_count;
    undefined field_0x46;
    undefined field_0x47;
    err_t (* igmp_mac_filter)(struct netif *, ip4_addr_t *, enum netif_mac_filter_action);
};

struct ip_globals {
    struct netif * current_netif;
    struct netif * current_input_netif;
    struct ip_hdr * current_ip4_header;
    u16_t current_ip_header_tot_len;
    undefined field_0xe;
    undefined field_0xf;
    ip_addr_t current_iphdr_src;
    ip_addr_t current_iphdr_dest;
};

struct ip_hdr {
    u8_t _v_hl;
    u8_t _tos;
    u16_t _len;
    u16_t _id;
    u16_t _offset;
    u8_t _ttl;
    u8_t _proto;
    u16_t _chksum;
    ip4_addr_p_t src;
    ip4_addr_p_t dest;
};

typedef struct ke_env_tag ke_env_tag, *Pke_env_tag;

typedef uint32_t evt_field_t;

typedef struct mblock_free mblock_free, *Pmblock_free;

struct mblock_free {
    struct mblock_free * next;
    uint32_t size;
};

struct ke_env_tag {
    evt_field_t evt_field;
    struct co_list queue_sent;
    struct co_list queue_saved;
    struct co_list queue_timer;
    struct mblock_free * mblock_first;
};

typedef struct list_head list_head, *Plist_head;

struct list_head {
    struct list_head * next;
    struct list_head * prev;
};

typedef struct hal_dma_env_tag hal_dma_env_tag, *Phal_dma_env_tag;

struct hal_dma_env_tag {
    struct co_list prog[2];
    struct co_list free_gp_dma_descs;
    uint16_t lli_cnt[2];
};

typedef struct dns_hdr dns_hdr, *Pdns_hdr;

struct dns_hdr {
    u16_t id;
    u8_t flags1;
    u8_t flags2;
    u16_t numquestions;
    u16_t numanswers;
    u16_t numauthrr;
    u16_t numextrarr;
};

typedef struct mbedtls_cipher_definition_t mbedtls_cipher_definition_t, *Pmbedtls_cipher_definition_t;

struct mbedtls_cipher_definition_t {
    enum mbedtls_cipher_type_t type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    struct mbedtls_cipher_info_t * info;
};

typedef struct mblock_used mblock_used, *Pmblock_used;

struct mblock_used {
    uint32_t size;
};

typedef enum lwip_ieee_eth_type {
    ETHTYPE_QINQ=-28416,
    ETHTYPE_PTP=-30473,
    ETHTYPE_PPPOEDISC=-30621,
    ETHTYPE_VLAN=-32512,
    ETHTYPE_IPV6=-31011,
    ETHTYPE_WOL=2114,
    ETHTYPE_JUMBO=-30608,
    ETHTYPE_IP=2048,
    ETHTYPE_SERCOS=-30515,
    ETHTYPE_ARP=2054,
    ETHTYPE_LLDP=-30516,
    ETHTYPE_ETHERCAT=-30556,
    ETHTYPE_MRP=-30493,
    ETHTYPE_RARP=-32715,
    ETHTYPE_PROFINET=-30574,
    ETHTYPE_PPPOE=-30620
} lwip_ieee_eth_type;

typedef struct phy_channel_info phy_channel_info, *Pphy_channel_info;

struct phy_channel_info {
    uint32_t info1;
    uint32_t info2;
};

typedef struct altcp_pcb altcp_pcb, *Paltcp_pcb;

typedef u16_t (* altcp_mss_fn)(struct altcp_pcb *);

typedef struct altcp_functions altcp_functions, *Paltcp_functions;

typedef err_t (* altcp_connected_fn)(void *, struct altcp_pcb *, err_t);

typedef err_t (* altcp_accept_fn)(void *, struct altcp_pcb *, err_t);

typedef void (* altcp_set_poll_fn)(struct altcp_pcb *, u8_t);

typedef void (* altcp_abort_fn)(struct altcp_pcb *);

typedef err_t (* altcp_close_fn)(struct altcp_pcb *);

typedef err_t (* altcp_output_fn)(struct altcp_pcb *);

typedef u16_t (* altcp_sndbuf_fn)(struct altcp_pcb *);

typedef u16_t (* altcp_sndqueuelen_fn)(struct altcp_pcb *);

typedef void (* altcp_nagle_disable_fn)(struct altcp_pcb *);

typedef void (* altcp_nagle_enable_fn)(struct altcp_pcb *);

typedef void (* altcp_setprio_fn)(struct altcp_pcb *, u8_t);

typedef void (* altcp_dealloc_fn)(struct altcp_pcb *);

struct altcp_functions {
    altcp_set_poll_fn set_poll;
    void (* recved)(struct altcp_pcb *, u16_t);
    err_t (* bind)(struct altcp_pcb *, ip_addr_t *, u16_t);
    err_t (* connect)(struct altcp_pcb *, ip_addr_t *, u16_t, altcp_connected_fn);
    altcp_pcb * (* listen)(struct altcp_pcb *, u8_t, err_t *);
    altcp_abort_fn abort;
    altcp_close_fn close;
    err_t (* shutdown)(struct altcp_pcb *, int, int);
    err_t (* write)(struct altcp_pcb *, void *, u16_t, u8_t);
    altcp_output_fn output;
    altcp_mss_fn mss;
    altcp_sndbuf_fn sndbuf;
    altcp_sndqueuelen_fn sndqueuelen;
    altcp_nagle_disable_fn nagle_disable;
    altcp_nagle_enable_fn nagle_enable;
    int (* nagle_disabled)(struct altcp_pcb *);
    altcp_setprio_fn setprio;
    altcp_dealloc_fn dealloc;
    err_t (* addrinfo)(struct altcp_pcb *, int, ip_addr_t *, u16_t *);
    ip_addr_t * (* getip)(struct altcp_pcb *, int);
    u16_t (* getport)(struct altcp_pcb *, int);
};

struct altcp_pcb {
    struct altcp_functions * fns;
    struct altcp_pcb * inner_conn;
    void * arg;
    void * state;
    altcp_accept_fn accept;
    altcp_connected_fn connected;
    err_t (* recv)(void *, struct altcp_pcb *, struct pbuf *, err_t);
    err_t (* sent)(void *, struct altcp_pcb *, u16_t);
    err_t (* poll)(void *, struct altcp_pcb *);
    void (* err)(void *, err_t);
    u8_t pollinterval;
    undefined field_0x29;
    undefined field_0x2a;
    undefined field_0x2b;
};

typedef struct dns_table_entry.conflict dns_table_entry.conflict, *Pdns_table_entry.conflict;

struct dns_table_entry.conflict {
    u32_t ttl;
    ip_addr_t ipaddr;
    u16_t txid;
    u8_t state;
    u8_t server_idx;
    u8_t tmr;
    u8_t retries;
    u8_t seqno;
    char name[256];
    undefined field_0x10f;
};

typedef struct dns_query dns_query, *Pdns_query;

struct dns_query {
    u16_t type;
    u16_t cls;
};

typedef struct dns_req_entry dns_req_entry, *Pdns_req_entry;

struct dns_req_entry {
    void (* found)(char *, ip_addr_t *, void *);
    void * arg;
};

typedef struct dns_answer dns_answer, *Pdns_answer;

struct dns_answer {
    u16_t type;
    u16_t cls;
    u32_t ttl;
    u16_t len;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct memp memp, *Pmemp;

struct memp {
    struct memp * next;
};

typedef struct memp_desc memp_desc, *Pmemp_desc;

struct memp_desc {
    struct stats_mem * stats;
    u16_t size;
    u16_t num;
    u8_t * base;
    struct memp * * tab;
};

typedef struct __sFILE __sFILE, *P__sFILE;

typedef struct _reent _reent, *P_reent;

typedef long _fpos_t;

typedef struct __sFILE __FILE;

typedef struct __sbuf __sbuf, *P__sbuf;


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__locale_t - /xlocale.h/__locale_t

typedef struct _Bigint _Bigint, *P_Bigint;

typedef union anon_union.conflictad7_for__new anon_union.conflictad7_for__new, *Panon_union.conflictad7_for__new;

typedef struct _atexit _atexit, *P_atexit;

typedef struct _glue _glue, *P_glue;

typedef long _off_t;

typedef int _LOCK_RECURSIVE_T;

typedef _LOCK_RECURSIVE_T _flock_t;

typedef struct _mbstate_t _mbstate_t, *P_mbstate_t;

typedef ulong __ULong;

typedef struct anon_struct.conflict94b anon_struct.conflict94b, *Panon_struct.conflict94b;

typedef struct anon_struct.conflicta90 anon_struct.conflicta90, *Panon_struct.conflicta90;

typedef struct _on_exit_args _on_exit_args, *P_on_exit_args;

typedef union anon_union.conflict311_for___value anon_union.conflict311_for___value, *Panon_union.conflict311_for___value;

typedef struct __tm __tm, *P__tm;

typedef struct _rand48 _rand48, *P_rand48;

typedef uint wint_t;

struct _rand48 {
    ushort _seed[3];
    ushort _mult[3];
    ushort _add;
};

struct _glue {
    struct _glue * _next;
    int _niobs;
    __FILE * _iobs;
};

struct __tm {
    int __tm_sec;
    int __tm_min;
    int __tm_hour;
    int __tm_mday;
    int __tm_mon;
    int __tm_year;
    int __tm_wday;
    int __tm_yday;
    int __tm_isdst;
};

union anon_union.conflict311_for___value {
    wint_t __wch;
    uchar __wchb[4];
};

struct _mbstate_t {
    int __count;
    union anon_union.conflict311_for___value __value;
};

struct anon_struct.conflict94b {
    uint _unused_rand;
    char * _strtok_last;
    char _asctime_buf[26];
    undefined field_0x22;
    undefined field_0x23;
    struct __tm _localtime_buf;
    int _gamma_signgam;
    undefined field_0x4c;
    undefined field_0x4d;
    undefined field_0x4e;
    undefined field_0x4f;
    ulonglong _rand_next;
    struct _rand48 _r48;
    undefined field_0x66;
    undefined field_0x67;
    struct _mbstate_t _mblen_state;
    struct _mbstate_t _mbtowc_state;
    struct _mbstate_t _wctomb_state;
    char _l64a_buf[8];
    char _signal_buf[24];
    int _getdate_err;
    struct _mbstate_t _mbrlen_state;
    struct _mbstate_t _mbrtowc_state;
    struct _mbstate_t _mbsrtowcs_state;
    struct _mbstate_t _wcrtomb_state;
    struct _mbstate_t _wcsrtombs_state;
    int _h_errno;
};

struct anon_struct.conflicta90 {
    uchar * _nextf[30];
    uint _nmalloc[30];
};

union anon_union.conflictad7_for__new {
    struct anon_struct.conflict94b _reent;
    struct anon_struct.conflicta90 _unused;
};

struct __sbuf {
    uchar * _base;
    int _size;
};

struct __sFILE {
    uchar * _p;
    int _r;
    int _w;
    short _flags;
    short _file;
    struct __sbuf _bf;
    int _lbfsize;
    void * _cookie;
    _ssize_t (* _read)(struct _reent *, void *, char *, int);
    _ssize_t (* _write)(struct _reent *, void *, char *, int);
    _fpos_t (* _seek)(struct _reent *, void *, _fpos_t, int);
    int (* _close)(struct _reent *, void *);
    struct __sbuf _ub;
    uchar * _up;
    int _ur;
    uchar _ubuf[3];
    uchar _nbuf[1];
    struct __sbuf _lb;
    int _blksize;
    _off_t _offset;
    struct _reent * _data;
    _flock_t _lock;
    struct _mbstate_t _mbstate;
    int _flags2;
};

struct _on_exit_args {
    void * _fnargs[32];
    void * _dso_handle[32];
    __ULong _fntypes;
    __ULong _is_cxa;
};

struct _atexit {
    struct _atexit * _next;
    int _ind;
    void (* _fns[32])(void);
    struct _on_exit_args _on_exit_args;
};

struct _reent {
    int _errno;
    __FILE * _stdin;
    __FILE * _stdout;
    __FILE * _stderr;
    int _inc;
    char _emergency[25];
    undefined field_0x2d;
    undefined field_0x2e;
    undefined field_0x2f;
    int _unspecified_locale_info;
    struct __locale_t * _locale;
    int __sdidinit;
    void (* __cleanup)(struct _reent *);
    struct _Bigint * _result;
    int _result_k;
    struct _Bigint * _p5s;
    struct _Bigint * * _freelist;
    int _cvtlen;
    char * _cvtbuf;
    union anon_union.conflictad7_for__new _new;
    struct _atexit * _atexit;
    struct _atexit _atexit0;
    void (** _sig_func)(int);
    struct _glue __sglue;
    __FILE __sf[3];
    undefined field_0x424;
    undefined field_0x425;
    undefined field_0x426;
    undefined field_0x427;
};

struct _Bigint {
    struct _Bigint * _next;
    int _k;
    int _maxwds;
    int _sign;
    int _wds;
    __ULong _x[1];
};

typedef union anon_union.conflictad7 anon_union.conflictad7, *Panon_union.conflictad7;

union anon_union.conflictad7 {
    struct anon_struct.conflict94b _reent;
    struct anon_struct.conflicta90 _unused;
};

typedef enum hal_uart_flow_control_t {
    FLOW_CONTROL_DISABLED=0,
    FLOW_CONTROL_CTS=1,
    FLOW_CONTROL_RTS=2,
    FLOW_CONTROL_CTS_RTS=3
} hal_uart_flow_control_t;

typedef enum hal_uart_int_t {
    UART_RX_INT=1,
    UART_TX_INT=0
} hal_uart_int_t;

typedef enum hal_uart_parity_t {
    ODD_PARITY=1,
    EVEN_PARITY=2,
    NO_PARITY=0
} hal_uart_parity_t;

typedef struct uart_config_t uart_config_t, *Puart_config_t;

typedef enum hal_uart_data_width_t {
    DATA_WIDTH_6BIT=1,
    DATA_WIDTH_7BIT=2,
    DATA_WIDTH_5BIT=0,
    DATA_WIDTH_9BIT=4,
    DATA_WIDTH_8BIT=3
} hal_uart_data_width_t;

typedef enum hal_uart_stop_bits_t {
    STOP_BITS_2=1,
    STOP_BITS_1=0
} hal_uart_stop_bits_t;

typedef enum hal_uart_mode_t {
    MODE_TX=0,
    MODE_TX_RX=2,
    MODE_RX=1
} hal_uart_mode_t;

struct uart_config_t {
    uint32_t baud_rate;
    enum hal_uart_data_width_t data_width;
    enum hal_uart_parity_t parity;
    enum hal_uart_stop_bits_t stop_bits;
    enum hal_uart_flow_control_t flow_control;
    enum hal_uart_mode_t mode;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct uart_dev_t uart_dev_t, *Puart_dev_t;

struct uart_dev_t {
    uint8_t port;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    struct uart_config_t config;
    void * rx_ringbuf_handle;
    void * tx_ringbuf_handle;
    uint32_t rx_buf_size;
    uint32_t tx_buf_size;
    void * mutex;
    void * poll_cb;
    void * fd;
    void * poll_data;
    void * taskhdl;
    uint8_t read_block_flag;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
    void * priv;
};

typedef struct sha256_link_item sha256_link_item, *Psha256_link_item;

typedef struct sha256_link_item sha256_link_item_t;

struct sha256_link_item {
    struct SEC_Eng_SHA256_Link_Ctx ctx;
    struct SEC_Eng_SHA_Link_Config_Type linkCfg;
    uint32_t tmp[16];
    uint32_t pad[16];
};


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef struct pbuf_rom pbuf_rom, *Ppbuf_rom;

struct pbuf_rom {
    struct pbuf * next;
    void * payload;
};

typedef struct pbuf_custom pbuf_custom, *Ppbuf_custom;

struct pbuf_custom {
    struct pbuf pbuf;
    void (* custom_free_function)(struct pbuf *);
};

typedef enum pbuf_layer {
    PBUF_RAW=0,
    PBUF_IP=-94,
    PBUF_LINK=-114,
    PBUF_TRANSPORT=-74,
    PBUF_RAW_TX=-128
} pbuf_layer;

typedef enum pbuf_type {
    PBUF_ROM=1,
    PBUF_REF=65,
    PBUF_POOL=386,
    PBUF_RAM=640
} pbuf_type;

typedef struct _IoT_Mutex_t _IoT_Mutex_t, *P_IoT_Mutex_t;

struct _IoT_Mutex_t {
    SemaphoreHandle_t mutex;
};

typedef struct ip4_addr_wordaligned ip4_addr_wordaligned, *Pip4_addr_wordaligned;

struct ip4_addr_wordaligned {
    u16_t addrw[2];
};

typedef struct etharp_hdr etharp_hdr, *Petharp_hdr;

struct etharp_hdr {
    u16_t hwtype;
    u16_t proto;
    u8_t hwlen;
    u8_t protolen;
    u16_t opcode;
    struct eth_addr shwaddr;
    struct ip4_addr_wordaligned sipaddr;
    struct eth_addr dhwaddr;
    struct ip4_addr_wordaligned dipaddr;
};

typedef enum etharp_opcode {
    ARP_REPLY=2,
    ARP_REQUEST=1
} etharp_opcode;

typedef struct bl_dma_item bl_dma_item, *Pbl_dma_item;

struct bl_dma_item {
    struct utils_list_hdr item;
    void (* cb)(void *);
    void * arg;
    uint32_t src;
    uint32_t dst;
    uint32_t next;
    uint32_t ctrl;
};

typedef enum SF_Ctrl_Ahb2sif_Type {
    HIGH_SPEED_MODE_CLOCK=0,
    REMOVE_CLOCK_CONSTRAIN=1
} SF_Ctrl_Ahb2sif_Type;

typedef enum SF_Ctrl_Dmy_Mode_Type {
    SF_CTRL_DUMMY_1_LINE=0,
    SF_CTRL_DUMMY_2_LINES=1,
    SF_CTRL_DUMMY_4_LINES=2
} SF_Ctrl_Dmy_Mode_Type;

typedef enum SF_Ctrl_Sahb_Type {
    SF_CTRL_SAHB_CLOCK=0,
    SF_CTRL_FLASH_CLOCK=1
} SF_Ctrl_Sahb_Type;

typedef enum SF_Ctrl_Mode_Type {
    SF_CTRL_QPI_MODE=1,
    SF_CTRL_SPI_MODE=0
} SF_Ctrl_Mode_Type;

typedef struct SF_Ctrl_Cfg_Type SF_Ctrl_Cfg_Type, *PSF_Ctrl_Cfg_Type;

typedef enum SF_Ctrl_Owner_Type {
    SF_CTRL_OWNER_IAHB=1,
    SF_CTRL_OWNER_SAHB=0
} SF_Ctrl_Owner_Type;

struct SF_Ctrl_Cfg_Type {
    enum SF_Ctrl_Owner_Type owner;
    enum SF_Ctrl_Sahb_Type sahbClock;
    enum SF_Ctrl_Ahb2sif_Type ahb2sifMode;
    uint8_t clkDelay;
    uint8_t clkInvert;
    uint8_t rxClkInvert;
    uint8_t doDelay;
    uint8_t diDelay;
    uint8_t oeDelay;
};

typedef enum SF_Ctrl_IO_Type {
    SF_CTRL_DO_MODE=1,
    SF_CTRL_QO_MODE=2,
    SF_CTRL_DIO_MODE=3,
    SF_CTRL_NIO_MODE=0,
    SF_CTRL_QIO_MODE=4
} SF_Ctrl_IO_Type;

typedef enum SF_Ctrl_Data_Mode_Type {
    SF_CTRL_DATA_2_LINES=1,
    SF_CTRL_DATA_4_LINES=2,
    SF_CTRL_DATA_1_LINE=0
} SF_Ctrl_Data_Mode_Type;

typedef struct SF_Ctrl_Cmd_Cfg_Type SF_Ctrl_Cmd_Cfg_Type, *PSF_Ctrl_Cmd_Cfg_Type;

typedef enum SF_Ctrl_Cmd_Mode_Type {
    SF_CTRL_CMD_4_LINES=1,
    SF_CTRL_CMD_1_LINE=0
} SF_Ctrl_Cmd_Mode_Type;

typedef enum SF_Ctrl_Addr_Mode_Type {
    SF_CTRL_ADDR_4_LINES=2,
    SF_CTRL_ADDR_1_LINE=0,
    SF_CTRL_ADDR_2_LINES=1
} SF_Ctrl_Addr_Mode_Type;

struct SF_Ctrl_Cmd_Cfg_Type {
    uint8_t rwFlag;
    enum SF_Ctrl_Cmd_Mode_Type cmdMode;
    enum SF_Ctrl_Addr_Mode_Type addrMode;
    uint8_t addrSize;
    uint8_t dummyClks;
    enum SF_Ctrl_Dmy_Mode_Type dummyMode;
    enum SF_Ctrl_Data_Mode_Type dataMode;
    uint8_t rsv[1];
    uint32_t nbData;
    uint32_t cmdBuf[2];
};

typedef enum SF_Ctrl_Pad_Sel {
    SF_CTRL_EXTERNAL_17TO22_SEL=1,
    SF_CTRL_EXTERNAL_0TO2_20TO22_SEL=2,
    SF_CTRL_EMBEDDED_SEL=0
} SF_Ctrl_Pad_Sel;

typedef enum SF_Ctrl_AES_Key_Type {
    SF_CTRL_AES_256BITS=1,
    SF_CTRL_AES_128BITS=0,
    SF_CTRL_AES_192BITS=2,
    SF_CTRL_AES_128BITS_DOUBLE_KEY=3
} SF_Ctrl_AES_Key_Type;

typedef struct dma_node dma_node, *Pdma_node;

struct dma_node {
    utils_dlist_t dlist_item;
    int channel;
    void * tc_handler;
    void * interr_handler;
    void * ctx;
};

typedef struct dma_ctx dma_ctx, *Pdma_ctx;

struct dma_ctx {
    utils_dlist_t * pstqueue;
};

typedef struct mobility_domain mobility_domain, *Pmobility_domain;

struct mobility_domain {
    uint16_t mdid;
    uint8_t ft_capability_policy;
    undefined field_0x3;
};

typedef struct mac_bss_info mac_bss_info, *Pmac_bss_info;

typedef struct mac_edca_param_set mac_edca_param_set, *Pmac_edca_param_set;

struct mac_edca_param_set {
    uint8_t qos_info;
    uint8_t acm;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t ac_param[4];
};

struct mac_bss_info {
    struct mac_htcapability ht_cap;
    struct mac_addr bssid;
    struct mac_ssid ssid;
    uint16_t bsstype;
    undefined field_0x4a;
    undefined field_0x4b;
    struct scan_chan_tag * chan;
    uint16_t center_freq1;
    uint16_t center_freq2;
    uint16_t beacon_period;
    uint16_t cap_info;
    struct mac_rateset rate_set;
    undefined field_0x65;
    undefined field_0x66;
    undefined field_0x67;
    struct mac_edca_param_set edca_param;
    int8_t rssi;
    int8_t ppm_rel;
    int8_t ppm_abs;
    uint8_t high_11b_rate;
    uint16_t prot_status;
    uint8_t bw;
    uint8_t phy_bw;
    uint8_t power_constraint;
    undefined field_0x85;
    undefined field_0x86;
    undefined field_0x87;
    uint32_t valid_flags;
    struct mobility_domain mde;
    _Bool is_supplicant_enabled;
    struct SecurityMode_t wpa_wpa2_wep;
    struct Cipher_t wpa_mcstCipher;
    struct Cipher_t wpa_ucstCipher;
    struct Cipher_t rsn_mcstCipher;
    struct Cipher_t rsn_ucstCipher;
    _Bool is_pmf_required;
    _Bool is_wpa2_prefered;
    uint8_t rsn_wpa_ie[32];
    uint8_t rsn_wpa_ie_len;
    uint16_t beacon_interval;
    uint16_t aid_bitmap;
    uint16_t max_listen_interval;
    uint8_t sec_type;
    undefined field_0xc1;
    undefined field_0xc2;
    undefined field_0xc3;
};

typedef struct me_env_tag me_env_tag, *Pme_env_tag;

typedef struct me_chan_config_req me_chan_config_req, *Pme_chan_config_req;

struct me_chan_config_req {
    struct scan_chan_tag chan2G4[14];
    struct scan_chan_tag chan5G[28];
    uint8_t chan2G4_cnt;
    uint8_t chan5G_cnt;
};

struct me_env_tag {
    uint32_t active_vifs;
    uint32_t ps_disable_vifs;
    ke_task_id_t requester_id;
    undefined field_0xa;
    undefined field_0xb;
    struct mac_htcapability ht_cap;
    uint16_t tx_lft;
    _Bool ht_supported;
    undefined field_0x2f;
    struct me_chan_config_req chan;
    uint8_t stbc_nss;
    uint8_t phy_bw_max;
    _Bool ps_on;
    undefined field_0x131;
    undefined field_0x132;
    undefined field_0x133;
};

typedef struct anon_struct.conflict14adb1 anon_struct.conflict14adb1, *Panon_struct.conflict14adb1;

struct anon_struct.conflict14adb1 {
    __le64 timestamp;
    __le16 beacon_int;
    __le16 capab_info;
    u8[0] variable;
};

typedef struct anon_struct.conflict14ae7d anon_struct.conflict14ae7d, *Panon_struct.conflict14ae7d;

struct anon_struct.conflict14ae7d {
    u8 action_code;
    u8 dialog_token;
    u8 status_code;
    u8[0] variable;
};

typedef struct anon_struct.conflict14b237 anon_struct.conflict14b237, *Panon_struct.conflict14b237;

struct anon_struct.conflict14b237 {
    u8 action_code;
    u8 dialog_token;
    u8 follow_up;
    u8 tod[6];
    u8 toa[6];
    __le16 tod_error;
    __le16 toa_error;
    u8[0] variable;
};

typedef struct anon_struct.conflict14af7e anon_struct.conflict14af7e, *Panon_struct.conflict14af7e;

struct anon_struct.conflict14af7e {
    u8 action_code;
    u8 dialog_token;
    __le16 capab;
    __le16 timeout;
    __le16 start_seq_num;
};

typedef struct anon_struct.conflict14ac35 anon_struct.conflict14ac35, *Panon_struct.conflict14ac35;

struct anon_struct.conflict14ac35 {
    __le16 auth_alg;
    __le16 auth_transaction;
    __le16 status_code;
    u8[0] variable;
};

typedef union anon_union.conflict14b2c1 anon_union.conflict14b2c1, *Panon_union.conflict14b2c1;

typedef struct anon_struct.conflict14b020 anon_struct.conflict14b020, *Panon_struct.conflict14b020;

typedef struct anon_struct.conflict14b0c1 anon_struct.conflict14b0c1, *Panon_struct.conflict14b0c1;

typedef struct anon_struct.conflict14b0f8 anon_struct.conflict14b0f8, *Panon_struct.conflict14b0f8;

typedef struct anon_struct.conflict14b146 anon_struct.conflict14b146, *Panon_struct.conflict14b146;

typedef struct anon_struct.conflict14b1bf anon_struct.conflict14b1bf, *Panon_struct.conflict14b1bf;

struct anon_struct.conflict14b0f8 {
    u8 action;
    u8 smps_control;
};

struct anon_struct.conflict14b1bf {
    u8 action_code;
    u8 membership[8];
    u8 position[16];
};

struct anon_struct.conflict14b0c1 {
    u8 action;
    u8 trans_id[2];
};

struct anon_struct.conflict14b020 {
    u8 action_code;
    __le16 params;
    __le16 reason_code;
};

struct anon_struct.conflict14b146 {
    u8 action_code;
    u8 dialog_token;
    __le16 capability;
    u8[0] variable;
};

union anon_union.conflict14b2c1 {
    struct anon_struct.conflict14ae7d wme_action;
    struct anon_struct.conflict14aecf chan_switch;
    struct anon_struct.conflict14aecf ext_chan_switch;
    struct anon_struct.conflict1c95 measurement;
    struct anon_struct.conflict14af7e addba_req;
    struct anon_struct.conflict14af7e addba_resp;
    struct anon_struct.conflict14b020 delba;
    struct anon_struct.conflict14aecf self_prot;
    struct anon_struct.conflict14aecf mesh_action;
    struct anon_struct.conflict14b0c1 sa_query;
    struct anon_struct.conflict14b0f8 ht_smps;
    struct anon_struct.conflict14b0f8 ht_notify_cw;
    struct anon_struct.conflict14b146 tdls_discover_resp;
    struct anon_struct.conflict14b0f8 vht_opmode_notif;
    struct anon_struct.conflict14b1bf vht_group_notif;
    struct anon_struct.conflict1c95 tpc_report;
    struct anon_struct.conflict14b237 ftm;
};

typedef struct ieee80211_mgmt ieee80211_mgmt, *Pieee80211_mgmt;

typedef union anon_union.conflict14b3ce_for_u anon_union.conflict14b3ce_for_u, *Panon_union.conflict14b3ce_for_u;

typedef struct anon_struct.conflict14ac87 anon_struct.conflict14ac87, *Panon_struct.conflict14ac87;

typedef struct anon_struct.conflict14aca0 anon_struct.conflict14aca0, *Panon_struct.conflict14aca0;

typedef struct anon_struct.conflict14ad36 anon_struct.conflict14ad36, *Panon_struct.conflict14ad36;

typedef struct anon_struct.conflict14b3a9 anon_struct.conflict14b3a9, *Panon_struct.conflict14b3a9;

typedef union anon_union.conflict14b2c1_for_u anon_union.conflict14b2c1_for_u, *Panon_union.conflict14b2c1_for_u;

union anon_union.conflict14b2c1_for_u {
    struct anon_struct.conflict14ae7d wme_action;
    struct anon_struct.conflict14aecf chan_switch;
    struct anon_struct.conflict14aecf ext_chan_switch;
    struct anon_struct.conflict1c95 measurement;
    struct anon_struct.conflict14af7e addba_req;
    struct anon_struct.conflict14af7e addba_resp;
    struct anon_struct.conflict14b020 delba;
    struct anon_struct.conflict14aecf self_prot;
    struct anon_struct.conflict14aecf mesh_action;
    struct anon_struct.conflict14b0c1 sa_query;
    struct anon_struct.conflict14b0f8 ht_smps;
    struct anon_struct.conflict14b0f8 ht_notify_cw;
    struct anon_struct.conflict14b146 tdls_discover_resp;
    struct anon_struct.conflict14b0f8 vht_opmode_notif;
    struct anon_struct.conflict14b1bf vht_group_notif;
    struct anon_struct.conflict1c95 tpc_report;
    struct anon_struct.conflict14b237 ftm;
};

struct anon_struct.conflict14ac87 {
    __le16 reason_code;
};

struct anon_struct.conflict14b3a9 {
    u8 category;
    union anon_union.conflict14b2c1_for_u u;
};

struct anon_struct.conflict14aca0 {
    __le16 capab_info;
    __le16 listen_interval;
    u8[0] variable;
};

struct anon_struct.conflict14ad36 {
    __le16 capab_info;
    __le16 listen_interval;
    u8 current_ap[6];
    u8[0] variable;
};

union anon_union.conflict14b3ce_for_u {
    struct anon_struct.conflict14ac35 auth;
    struct anon_struct.conflict14ac87 deauth;
    struct anon_struct.conflict14aca0 assoc_req;
    struct anon_struct.conflict14ac35 assoc_resp;
    struct anon_struct.conflict14ac35 reassoc_resp;
    struct anon_struct.conflict14ad36 reassoc_req;
    struct anon_struct.conflict14ac87 disassoc;
    struct anon_struct.conflict14adb1 beacon;
    struct anon_struct.conflict34b4e probe_req;
    struct anon_struct.conflict14adb1 probe_resp;
    struct anon_struct.conflict14b3a9 action;
};

struct ieee80211_mgmt {
    __le16 frame_control;
    __le16 duration;
    u8 da[6];
    u8 sa[6];
    u8 bssid[6];
    __le16 seq_ctrl;
    union anon_union.conflict14b3ce_for_u u;
};

typedef enum ieee80211_reasoncode {
    WLAN_REASON_DISASSOC_STA_HAS_LEFT=8,
    WLAN_REASON_MESH_CONFIRM_TIMEOUT=57,
    WLAN_REASON_MESH_PATH_DEST_UNREACHABLE=63,
    WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE=25,
    WLAN_REASON_PREV_AUTH_NOT_VALID=2,
    WLAN_REASON_INVALID_AKMP=20,
    WLAN_REASON_QSTA_LEAVE_QBSS=36,
    WLAN_REASON_MESH_PATH_NOFORWARD=62,
    WLAN_REASON_MESH_PATH_ERROR=61,
    WLAN_REASON_MESH_CLOSE=55,
    WLAN_REASON_DISASSOC_BAD_SUPP_CHAN=11,
    WLAN_REASON_UNSUPP_RSN_VERSION=21,
    WLAN_REASON_MESH_MAX_RETRIES=56,
    WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA=6,
    WLAN_REASON_MESH_CONFIG=54,
    WLAN_REASON_MESH_PEER_CANCELED=52,
    WLAN_REASON_CIPHER_SUITE_REJECTED=24,
    WLAN_REASON_IE_DIFFERENT=17,
    WLAN_REASON_DISASSOC_BAD_POWER=10,
    WLAN_REASON_DISASSOC_AP_BUSY=5,
    WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED=26,
    WLAN_REASON_MAC_EXISTS_IN_MBSS=64,
    WLAN_REASON_INVALID_GROUP_CIPHER=18,
    WLAN_REASON_MESH_MAX_PEERS=53,
    WLAN_REASON_MESH_INVALID_SECURITY=60,
    WLAN_REASON_INVALID_PAIRWISE_CIPHER=19,
    WLAN_REASON_MESH_INVALID_GTK=58,
    WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA=7,
    WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP=35,
    WLAN_REASON_QSTA_REQUIRE_SETUP=38,
    WLAN_REASON_MESH_CHAN=66,
    WLAN_REASON_DEAUTH_LEAVING=3,
    WLAN_REASON_MIC_FAILURE=14,
    WLAN_REASON_QSTA_TIMEOUT=39,
    WLAN_REASON_DISASSOC_LOW_ACK=34,
    WLAN_REASON_INVALID_IE=13,
    WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT=15,
    WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH=9,
    WLAN_REASON_INVALID_RSN_IE_CAP=22,
    WLAN_REASON_MESH_INCONSISTENT_PARAM=59,
    WLAN_REASON_DISASSOC_UNSPECIFIED_QOS=32,
    WLAN_REASON_QSTA_CIPHER_NOT_SUPP=45,
    WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT=16,
    WLAN_REASON_IEEE8021X_FAILED=23,
    WLAN_REASON_UNSPECIFIED=1,
    WLAN_REASON_QSTA_NOT_USE=37,
    WLAN_REASON_MESH_CHAN_REGULATORY=65,
    WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY=4,
    WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH=33
} ieee80211_reasoncode;

typedef union anon_union.conflict14b3ce anon_union.conflict14b3ce, *Panon_union.conflict14b3ce;

union anon_union.conflict14b3ce {
    struct anon_struct.conflict14ac35 auth;
    struct anon_struct.conflict14ac87 deauth;
    struct anon_struct.conflict14aca0 assoc_req;
    struct anon_struct.conflict14ac35 assoc_resp;
    struct anon_struct.conflict14ac35 reassoc_resp;
    struct anon_struct.conflict14ad36 reassoc_req;
    struct anon_struct.conflict14ac87 disassoc;
    struct anon_struct.conflict14adb1 beacon;
    struct anon_struct.conflict34b4e probe_req;
    struct anon_struct.conflict14adb1 probe_resp;
    struct anon_struct.conflict14b3a9 action;
};

typedef struct ke_msg_handler ke_msg_handler, *Pke_msg_handler;

struct ke_msg_handler {
    ke_msg_id_t id;
    undefined field_0x2;
    undefined field_0x3;
    int (* func)(ke_msg_id_t, void *, ke_task_id_t, ke_task_id_t);
};

typedef struct ke_state_handler ke_state_handler, *Pke_state_handler;

struct ke_state_handler {
    struct ke_msg_handler * msg_table;
    uint16_t msg_cnt;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct ke_task_desc ke_task_desc, *Pke_task_desc;

struct ke_task_desc {
    struct ke_state_handler * state_handler;
    struct ke_state_handler * default_handler;
    ke_state_t * state;
    uint16_t state_max;
    uint16_t idx_max;
};

typedef union anon_union.conflict97f3 anon_union.conflict97f3, *Panon_union.conflict97f3;

union anon_union.conflict97f3 {
    struct anon_struct.conflict9793 mic;
    struct anon_struct.conflict97ca mfp;
};

typedef struct _uart_ioctrl_config _uart_ioctrl_config, *P_uart_ioctrl_config;

typedef struct _uart_ioctrl_config uart_ioc_config_t;

typedef enum ioc_uart_parity_t {
    IO_UART_PARITY_ODD=1,
    IO_UART_PARITY_NONE=0,
    IO_UART_PARITY_EVEN=2
} ioc_uart_parity_t;

struct _uart_ioctrl_config {
    uint32_t baud;
    enum ioc_uart_parity_t parity;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct _uart_ioctrl_wait_read _uart_ioctrl_wait_read, *P_uart_ioctrl_wait_read;

struct _uart_ioctrl_wait_read {
    char * buf;
    int read_size;
    uint32_t timeout;
};

typedef struct _uart_ioctrl_wait_read uart_ioc_waitread_t;

typedef struct aos_dirent_t aos_dirent_t, *Paos_dirent_t;

struct aos_dirent_t { // Missing member d_name : char[1] at offset 0x5 [Unsupported interior flex array: char[1]]
    int d_ino;
    uint8_t d_type;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

typedef struct aos_dir_t aos_dir_t, *Paos_dir_t;

struct aos_dir_t {
    int dd_vfs_fd;
    int dd_rsv;
};

typedef struct statfs statfs, *Pstatfs;

struct statfs {
    long f_type;
    long f_bsize;
    long f_blocks;
    long f_bfree;
    long f_bavail;
    long f_files;
    long f_ffree;
    long f_fsid;
    long f_namelen;
};

typedef struct etharp_entry etharp_entry, *Petharp_entry;

struct etharp_entry {
    struct pbuf * q;
    ip4_addr_t ipaddr;
    struct netif * netif;
    struct eth_addr ethaddr;
    u16_t ctime;
    u8_t state;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef enum etharp_state {
    ETHARP_STATE_PENDING=1,
    ETHARP_STATE_EMPTY=0,
    ETHARP_STATE_STABLE_REREQUESTING_2=4,
    ETHARP_STATE_STABLE=2,
    ETHARP_STATE_STABLE_REREQUESTING_1=3
} etharp_state;

typedef ushort UHWtype;

typedef struct bl_custom_pbuf bl_custom_pbuf, *Pbl_custom_pbuf;

struct bl_custom_pbuf {
    struct pbuf_custom p;
    void * swdesc;
};

typedef struct bl_custom_pbuf bl_custom_pbuf_t;

typedef struct anon_struct.conflict1ae139 anon_struct.conflict1ae139, *Panon_struct.conflict1ae139;

typedef struct PtTable_Stuff_Config PtTable_Stuff_Config, *PPtTable_Stuff_Config;

typedef struct PtTable_Config PtTable_Config, *PPtTable_Config;

typedef struct PtTable_Entry_Config PtTable_Entry_Config, *PPtTable_Entry_Config;

struct PtTable_Config {
    uint32_t magicCode;
    uint16_t version;
    uint16_t entryCnt;
    uint32_t age;
    uint32_t crc32;
};

struct PtTable_Entry_Config {
    uint8_t type;
    uint8_t device;
    uint8_t activeIndex;
    uint8_t name[9];
    uint32_t Address[2];
    uint32_t maxLen[2];
    uint32_t len;
    uint32_t age;
};

struct PtTable_Stuff_Config {
    struct PtTable_Config ptTable;
    struct PtTable_Entry_Config ptEntries[16];
    uint32_t crc32;
};

struct anon_struct.conflict1ae139 {
    uint8_t partition_active_idx;
    uint8_t pad[3];
    struct PtTable_Stuff_Config table;
};

typedef struct la_mem_format la_mem_format, *Pla_mem_format;

struct la_mem_format {
    uint32_t word[4];
};

typedef struct HALPartition_Entry_Config HALPartition_Entry_Config, *PHALPartition_Entry_Config;

struct HALPartition_Entry_Config {
    uint8_t type;
    uint8_t device;
    uint8_t activeIndex;
    uint8_t name[9];
    uint32_t Address[2];
    uint32_t maxLen[2];
    uint32_t len;
    uint32_t age;
};

typedef enum HAL_Err_Type {
    HAL_ERROR=1,
    HAL_SUCCESS=0
} HAL_Err_Type;

typedef struct mbedtls_asn1_bitstring mbedtls_asn1_bitstring, *Pmbedtls_asn1_bitstring;

typedef struct mbedtls_asn1_bitstring mbedtls_x509_bitstring;

struct mbedtls_asn1_bitstring {
    size_t len;
    uchar unused_bits;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    uchar * p;
};

typedef enum bl_dev_flag {
    RWNX_DEV_STACK_RESTARTING=1,
    RWNX_DEV_STARTED=2,
    RWNX_DEV_RESTARTING=0
} bl_dev_flag;

typedef struct NoHostSecurityParams_t NoHostSecurityParams_t, *PNoHostSecurityParams_t;

struct NoHostSecurityParams_t {
    UINT8 CipherType;
    UINT8 MulticastCipher;
    UINT8 UnicastCipher;
    char PSKPassPhrase[64];
};

typedef ulonglong UDItype;

typedef uchar UQItype;

typedef int shift_count_type;

typedef uint USItype;

typedef struct DWstruct DWstruct, *PDWstruct;

typedef int SItype;

struct DWstruct {
    SItype low;
    SItype high;
};

typedef longlong DItype;

typedef union DWunion DWunion, *PDWunion;

union DWunion {
    struct DWstruct s;
    DItype ll;
};

typedef float SFtype;

typedef struct phy_hal_tag phy_hal_tag, *Pphy_hal_tag;

struct phy_hal_tag {
    int16_t temperature;
    uint8_t capcode;
    undefined field_0x3;
};

typedef struct QueueDefinition xQUEUE;

typedef struct QUEUE_REGISTRY_ITEM QUEUE_REGISTRY_ITEM, *PQUEUE_REGISTRY_ITEM;

typedef struct QUEUE_REGISTRY_ITEM xQueueRegistryItem;

typedef xQueueRegistryItem QueueRegistryItem_t;

struct QUEUE_REGISTRY_ITEM {
    char * pcQueueName;
    QueueHandle_t xHandle;
};

typedef xQUEUE Queue_t;

typedef union anon_union.conflict18e1c3 anon_union.conflict18e1c3, *Panon_union.conflict18e1c3;

union anon_union.conflict18e1c3 {
    QueuePointers_t xQueue;
    SemaphoreData_t xSemaphore;
};

typedef struct event_list_node_t event_list_node_t, *Pevent_list_node_t;

typedef struct input_event_t input_event_t, *Pinput_event_t;

struct event_list_node_t {
    dlist_t node;
    void (* cb)(struct input_event_t *, void *);
    void * priv;
    uint16_t type_filter;
    undefined field_0x12;
    undefined field_0x13;
};

struct input_event_t {
    uint32_t time;
    uint16_t type;
    uint16_t code;
    ulong value;
    ulong extra;
};

typedef struct anon_struct.conflict235c05 anon_struct.conflict235c05, *Panon_struct.conflict235c05;

struct anon_struct.conflict235c05 {
    void * handle;
    int fd;
};

typedef enum ehttpc_parse_state {
    HTTPC_PARSE_WAIT_HEADERS=1,
    HTTPC_PARSE_WAIT_FIRST_LINE=0,
    HTTPC_PARSE_RX_DATA=2
} ehttpc_parse_state;

typedef enum ehttpc_parse_state httpc_parse_state_t;

typedef struct _httpc_state _httpc_state, *P_httpc_state;

typedef struct _httpc_connection.conflict _httpc_connection.conflict, *P_httpc_connection.conflict;

typedef enum ehttpc_result {
    HTTPC_RESULT_ERR_MEM=7,
    HTTPC_RESULT_ERR_CLOSED=4,
    HTTPC_RESULT_OK=0,
    HTTPC_RESULT_ERR_CONNECT=2,
    HTTPC_RESULT_ERR_UNKNOWN=1,
    HTTPC_RESULT_ERR_TIMEOUT=5,
    HTTPC_RESULT_LOCAL_ABORT=8,
    HTTPC_RESULT_ERR_CONTENT_LEN=9,
    HTTPC_RESULT_ERR_HOSTNAME=3,
    HTTPC_RESULT_ERR_SVR_RESP=6
} ehttpc_result;

typedef enum ehttpc_result httpc_result_t;

typedef struct _httpc_state httpc_state_t;

typedef struct _httpc_connection.conflict httpc_connection_t.conflict;

typedef struct altcp_allocator_s altcp_allocator_s, *Paltcp_allocator_s;

typedef struct altcp_allocator_s altcp_allocator_t;

struct _httpc_connection.conflict {
    ip_addr_t proxy_addr;
    u16_t proxy_port;
    u8_t use_proxy;
    u8_t req_type;
    u8_t * data;
    u8_t content_type;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    altcp_allocator_t * altcp_allocator;
    void (* result_fn)(void *, httpc_result_t, u32_t, u32_t, err_t);
    err_t (* headers_done_fn)(httpc_state_t *, void *, struct pbuf *, u16_t, u32_t);
};

struct altcp_allocator_s {
    altcp_pcb * (* alloc)(void *, u8_t);
    void * arg;
};

struct _httpc_state {
    struct altcp_pcb * pcb;
    ip_addr_t remote_addr;
    u16_t remote_port;
    undefined field_0xa;
    undefined field_0xb;
    int timeout_ticks;
    struct pbuf * request;
    struct pbuf * rx_hdrs;
    u16_t rx_http_version;
    u16_t rx_status;
    err_t (* recv_fn)(void *, struct altcp_pcb *, struct pbuf *, err_t);
    httpc_connection_t.conflict * conn_settings;
    void * callback_arg;
    u32_t rx_content_len;
    u32_t hdr_content_len;
    httpc_parse_state_t parse_state;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

typedef enum BL_AHB_Slave1_Type {
    BL_AHB_SLAVE1_RF=1,
    BL_AHB_SLAVE1_DBG=3,
    BL_AHB_SLAVE1_CCI=8,
    BL_AHB_SLAVE1_IRR=22,
    BL_AHB_SLAVE1_TZ1=5,
    BL_AHB_SLAVE1_CKS=23,
    BL_AHB_SLAVE1_SDU=13,
    BL_AHB_SLAVE1_MAX=24,
    BL_AHB_SLAVE1_EFUSE=7,
    BL_AHB_SLAVE1_PWM=20,
    BL_AHB_SLAVE1_UART0=16,
    BL_AHB_SLAVE1_UART1=17,
    BL_AHB_SLAVE1_GPIP=2,
    BL_AHB_SLAVE1_GLB=0,
    BL_AHB_SLAVE1_WRAM=15,
    BL_AHB_SLAVE1_L1C=9,
    BL_AHB_SLAVE1_DMA=12,
    BL_AHB_SLAVE1_TMR=21,
    BL_AHB_SLAVE1_I2C=19,
    BL_AHB_SLAVE1_PDSHBN=14,
    BL_AHB_SLAVE1_SFC=11,
    BL_AHB_SLAVE1_SEC=4,
    BL_AHB_SLAVE1_TZ2=6,
    BL_AHB_SLAVE1_SPI=18
} BL_AHB_Slave1_Type;

typedef struct Bl_MD5_CTX Bl_MD5_CTX, *PBl_MD5_CTX;

struct Bl_MD5_CTX {
    ulong state[4];
    ulong count[2];
    ulong scratch[16];
    uchar buffer[64];
};

typedef struct mbedtls_md5_context mbedtls_md5_context, *Pmbedtls_md5_context;

struct mbedtls_md5_context {
    uint32_t total[2];
    uint32_t state[4];
    uchar buffer[64];
};

typedef struct _httpc_connection _httpc_connection, *P_httpc_connection;

typedef struct _httpc_connection httpc_connection_t;

struct _httpc_connection {
    ip_addr_t proxy_addr;
    u16_t proxy_port;
    u8_t use_proxy;
    u8_t req_type;
    u8_t * data;
    u8_t content_type;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    altcp_allocator_t * altcp_allocator;
    void (* result_fn)(void *, httpc_result_t, u32_t, u32_t, err_t);
    err_t (* headers_done_fn)(httpc_state_t *, void *, struct pbuf *, u16_t, u32_t);
};

typedef struct rvec_t rvec_t, *Prvec_t;

struct rvec_t {
    uint32_t leg_length:12;
    uint32_t leg_rate:4;
    uint32_t ht_length:16;
    uint32_t _ht_length:4;
    uint32_t short_gi:1;
    uint32_t stbc:2;
    uint32_t smoothing:1;
    uint32_t mcs:7;
    uint32_t pre_type:1;
    uint32_t format_mod:3;
    uint32_t ch_bw:2;
    uint32_t n_sts:3;
    uint32_t lsig_valid:1;
    uint32_t sounding:1;
    uint32_t num_extn_ss:2;
    uint32_t aggregation:1;
    uint32_t fec_coding:1;
    uint32_t dyn_bw:1;
    uint32_t doze_not_allowed:1;
    uint32_t antenna_set:8;
    uint32_t partial_aid:9;
    uint32_t group_id:6;
    uint32_t reserved_1c:1;
    int32_t rssi1:8;
    int32_t rssi2:8;
    int32_t agc_lna:4;
    int32_t agc_rbb1:5;
    int32_t agc_dg:7;
    uint32_t reserved_1d:8;
    uint32_t rcpi:8;
    uint32_t evm1:8;
    uint32_t evm2:8;
    uint32_t freqoff_lo:8;
    uint32_t freqoff_hi:8;
    uint32_t reserved2b_1:8;
    uint32_t reserved2b_2:8;
    uint32_t reserved2b_3:8;
};

typedef struct input_t input_t, *Pinput_t;

struct input_t {
    int8_t rssi;
    int8_t lna;
    undefined field_0x2;
    undefined field_0x3;
    float ppm;
    uint8_t new;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct pa_state_t pa_state_t, *Ppa_state_t;

struct pa_state_t {
    uint8_t used;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t vif_tag;
    struct input_t input_buffer[8];
    int8_t input_buffer_ptr;
    undefined field_0x69;
    undefined field_0x6a;
    undefined field_0x6b;
    uint32_t last_update;
    int8_t rss;
    int8_t rss_acq;
    int8_t rss_trk;
    int8_t rss_state;
    uint8_t rss_hit_count;
    undefined field_0x75;
    undefined field_0x76;
    undefined field_0x77;
    uint32_t rss_count;
    int8_t ris;
    undefined field_0x7d;
    undefined field_0x7e;
    undefined field_0x7f;
    float ce;
    int8_t ce_in;
    int8_t ce_acq;
    int8_t ce_trk;
    int8_t ce_state;
    int8_t ce_num_up_cmds;
    int8_t ce_num_dn_cmds;
    undefined field_0x8a;
    undefined field_0x8b;
};

typedef struct sm_env_tag sm_env_tag, *Psm_env_tag;

struct sm_env_tag {
    struct sm_connect_req * connect_param;
    struct sm_connect_ind * connect_ind;
    struct co_list bss_config;
    _Bool join_passive;
    _Bool ft_over_ds;
    undefined field_0x12;
    undefined field_0x13;
    int exist_ssid_idx;
    struct mac_addr ft_old_bssid;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct dns_api_msg dns_api_msg, *Pdns_api_msg;

struct dns_api_msg {
    char * name;
    ip_addr_t * addr;
    sys_sem_t * sem;
    err_t * err;
};

typedef union anon_union.conflict202275 anon_union.conflict202275, *Panon_union.conflict202275;

union anon_union.conflict202275 {
    struct netbuf * b;
    struct anon_struct.conflict14aecf n;
    struct anon_struct.conflict202123 bc;
    struct anon_struct.conflict202154 ad;
    struct anon_struct.conflict202191 w;
    struct anon_struct.conflict2021fc r;
    struct anon_struct.conflict202213 sd;
    struct anon_struct.conflict202237 jl;
};

typedef union anon_union.conflict1c5cf5 anon_union.conflict1c5cf5, *Panon_union.conflict1c5cf5;

typedef struct anon_struct.conflict1c5c54 anon_struct.conflict1c5c54, *Panon_struct.conflict1c5c54;

typedef struct anon_struct.conflict1c5cab anon_struct.conflict1c5cab, *Panon_struct.conflict1c5cab;

typedef struct anon_struct.conflict1c5ccf anon_struct.conflict1c5ccf, *Panon_struct.conflict1c5ccf;

typedef err_t (* netif_init_fn)(struct netif *);

typedef void (* netifapi_void_fn)(struct netif *);

typedef err_t (* netifapi_errt_fn)(struct netif *);

struct anon_struct.conflict1c5c54 {
    ip4_addr_t * ipaddr;
    ip4_addr_t * netmask;
    ip4_addr_t * gw;
    void * state;
    netif_init_fn init;
    err_t (* input)(struct pbuf *, struct netif *);
};

struct anon_struct.conflict1c5cab {
    netifapi_void_fn voidfunc;
    netifapi_errt_fn errtfunc;
};

struct anon_struct.conflict1c5ccf {
    char * name;
    u8_t index;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
};

union anon_union.conflict1c5cf5 {
    struct anon_struct.conflict1c5c54 add;
    struct anon_struct.conflict1c5cab common;
    struct anon_struct.conflict1c5ccf ifs;
};

typedef struct netifapi_msg netifapi_msg, *Pnetifapi_msg;

typedef struct tcpip_api_call_data tcpip_api_call_data, *Ptcpip_api_call_data;

typedef union anon_union.conflict1c5cf5_for_msg anon_union.conflict1c5cf5_for_msg, *Panon_union.conflict1c5cf5_for_msg;

union anon_union.conflict1c5cf5_for_msg {
    struct anon_struct.conflict1c5c54 add;
    struct anon_struct.conflict1c5cab common;
    struct anon_struct.conflict1c5ccf ifs;
};

struct tcpip_api_call_data {
    err_t err;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    sys_sem_t sem;
};

struct netifapi_msg {
    struct tcpip_api_call_data call;
    struct netif * netif;
    union anon_union.conflict1c5cf5_for_msg msg;
};

typedef struct jsonStruct jsonStruct, *PjsonStruct;

typedef struct jsonStruct jsonStruct_t;

typedef enum JsonPrimitiveType {
    SHADOW_JSON_DOUBLE=7,
    SHADOW_JSON_UINT32=3,
    SHADOW_JSON_INT16=1,
    SHADOW_JSON_UINT16=4,
    SHADOW_JSON_INT8=2,
    SHADOW_JSON_BOOL=8,
    SHADOW_JSON_OBJECT=10,
    SHADOW_JSON_UINT8=5,
    SHADOW_JSON_FLOAT=6,
    SHADOW_JSON_INT32=0,
    SHADOW_JSON_STRING=9
} JsonPrimitiveType;

struct jsonStruct {
    char * pKey;
    void * pData;
    size_t dataLength;
    enum JsonPrimitiveType type;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    void (* cb)(char *, uint32_t, jsonStruct_t *);
};

typedef struct utils_memp_node utils_memp_node, *Putils_memp_node;

struct utils_memp_node {
    struct utils_memp_node * next;
};

typedef struct pool pool, *Ppool;

typedef struct pool utils_memp_pool_t;

struct pool {
    uint32_t node_size;
    uint32_t pool_cap;
    uint32_t pool_size;
    uint8_t align_req;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t padded_node_size;
    void * first_node;
    void * last_node;
    struct utils_memp_node * mem;
};

typedef struct ke_timer ke_timer, *Pke_timer;

struct ke_timer {
    struct ke_timer * next;
    ke_msg_id_t id;
    ke_task_id_t task;
    uint32_t time;
};

typedef struct anon_struct.conflict1ba5ac anon_struct.conflict1ba5ac, *Panon_struct.conflict1ba5ac;

struct anon_struct.conflict1ba5ac {
    uint32_t magic;
    struct SPI_Flash_Cfg_Type flashCfg;
};

typedef struct igmp_group igmp_group, *Pigmp_group;

struct igmp_group {
    struct igmp_group * next;
    ip4_addr_t group_address;
    u8_t last_reporter_flag;
    u8_t group_state;
    u16_t timer;
    u8_t use;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef struct igmp_msg igmp_msg, *Pigmp_msg;

struct igmp_msg {
    u8_t igmp_msgtype;
    u8_t igmp_maxresp;
    u16_t igmp_checksum;
    ip4_addr_p_t igmp_group_address;
};

typedef struct _rom_dir_t _rom_dir_t, *P_rom_dir_t;

typedef struct _rom_dir_t romfs_dir_t;

struct _rom_dir_t {
    struct aos_dir_t dir;
    char * dir_start_addr;
    char * dir_end_addr;
    char * dir_cur_addr;
    struct aos_dirent_t cur_dirent;
};

typedef struct romfh romfh, *Promfh;

struct romfh {
    int32_t nextfh;
    int32_t spec;
    int32_t size;
    int32_t checksum;
};

typedef struct anon_struct.conflict1855c3 anon_struct.conflict1855c3, *Panon_struct.conflict1855c3;

struct anon_struct.conflict1855c3 {
    uint8_t store[3];
    uint8_t dirty[3];
};

typedef struct anon_struct.conflict185639 anon_struct.conflict185639, *Panon_struct.conflict185639;

typedef enum sector_store_status {
    SECTOR_STORE_FULL=3,
    SECTOR_STORE_STATUS_NUM=4,
    SECTOR_STORE_UNUSED=0,
    SECTOR_STORE_EMPTY=1,
    SECTOR_STORE_USING=2
} sector_store_status;

typedef enum sector_store_status sector_store_status_t;

typedef enum sector_dirty_status {
    SECTOR_DIRTY_STATUS_NUM=4,
    SECTOR_DIRTY_UNUSED=0,
    SECTOR_DIRTY_FALSE=1,
    SECTOR_DIRTY_TRUE=2,
    SECTOR_DIRTY_GC=3
} sector_dirty_status;

typedef enum sector_dirty_status sector_dirty_status_t;

struct anon_struct.conflict185639 {
    sector_store_status_t store;
    sector_dirty_status_t dirty;
};

typedef struct env_hdr_data env_hdr_data, *Penv_hdr_data;

struct env_hdr_data {
    uint8_t status_table[5];
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    uint32_t magic;
    uint32_t len;
    uint32_t crc32;
    uint8_t name_len;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
    uint32_t value_len;
};

typedef struct env_hdr_data * env_hdr_data_t;

typedef struct sector_meta_data sector_meta_data, *Psector_meta_data;

typedef struct anon_struct.conflict185639_for_status anon_struct.conflict185639_for_status, *Panon_struct.conflict185639_for_status;

struct anon_struct.conflict185639_for_status {
    sector_store_status_t store;
    sector_dirty_status_t dirty;
};

struct sector_meta_data {
    _Bool check_ok;
    struct anon_struct.conflict185639_for_status status;
    undefined field_0x3;
    uint32_t addr;
    uint32_t magic;
    uint32_t combined;
    size_t remain;
    uint32_t empty_env;
};

typedef struct sector_cache_node sector_cache_node, *Psector_cache_node;

struct sector_cache_node {
    uint32_t addr;
    uint32_t empty_addr;
};

typedef struct env_cache_node env_cache_node, *Penv_cache_node;

struct env_cache_node {
    uint16_t name_crc;
    uint16_t active;
    uint32_t addr;
};

typedef struct sector_hdr_data sector_hdr_data, *Psector_hdr_data;

typedef struct anon_struct.conflict1855c3_for_status_table anon_struct.conflict1855c3_for_status_table, *Panon_struct.conflict1855c3_for_status_table;

struct anon_struct.conflict1855c3_for_status_table {
    uint8_t store[3];
    uint8_t dirty[3];
};

struct sector_hdr_data {
    struct anon_struct.conflict1855c3_for_status_table status_table;
    undefined field_0x6;
    undefined field_0x7;
    uint32_t magic;
    uint32_t combined;
    uint32_t reserved;
};

typedef struct sector_meta_data * sector_meta_data_t;

typedef struct StreamBufferDef_t StreamBufferDef_t, *PStreamBufferDef_t;

typedef struct StreamBufferDef_t * StreamBufferHandle_t;

struct StreamBufferDef_t {
    size_t xTail;
    size_t xHead;
    size_t xLength;
    size_t xTriggerLevelBytes;
    TaskHandle_t xTaskWaitingToReceive;
    TaskHandle_t xTaskWaitingToSend;
    uint8_t * pucBuffer;
    uint8_t ucFlags;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
    UBaseType_t uxStreamBufferNumber;
};

typedef struct txdesc txdesc, *Ptxdesc;

typedef struct umacdesc umacdesc, *Pumacdesc;

typedef struct lmacdesc lmacdesc, *Plmacdesc;

typedef struct tx_hw_desc tx_hw_desc, *Ptx_hw_desc;

typedef struct tx_cfm_tag tx_cfm_tag, *Ptx_cfm_tag;

typedef struct tx_agg_desc tx_agg_desc, *Ptx_agg_desc;

typedef struct txl_buffer_tag txl_buffer_tag, *Ptxl_buffer_tag;

struct txl_buffer_tag {
    uint32_t length;
    uint32_t lenheader;
    uint32_t lenpad;
    uint32_t flags;
    struct txl_buffer_tag * next;
    struct txdesc * txdesc;
    struct dma_desc dma_desc[1];
    struct dma_desc dma_desc_pat;
    struct tx_pbd tbd;
    struct tx_pbd tbd_body[8];
    uint8_t user_idx;
    undefined field_0xed;
    undefined field_0xee;
    undefined field_0xef;
    struct txl_buffer_control buffer_control;
    struct tx_pbd tkip_mic_icv_pbd;
    uint8_t tkip_mic_icv[12];
    uint32_t[0] payload;
};

struct umacdesc {
    struct txl_buffer_control * buf_control;
    uint32_t buff_offset;
    uint16_t payl_len;
    uint8_t head_len;
    uint8_t hdr_len_802_2;
    uint8_t tail_len;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

struct lmacdesc {
    struct tx_agg_desc * agg_desc;
    struct txl_buffer_tag * buffer;
    struct tx_hw_desc * hw_desc;
};

struct tx_cfm_tag {
    uint16_t pn[4];
    uint16_t sn;
    uint16_t timestamp;
    int8_t credits;
    uint8_t ampdu_size;
    uint8_t pad[2];
    uint32_t status;
};

struct tx_hw_desc {
    struct tx_cfm_tag * cfm_ptr;
    struct tx_hd thd;
};

struct txdesc {
    struct co_list_hdr list_hdr;
    struct hostdesc host;
    struct umacdesc umac;
    struct lmacdesc lmac;
    struct tx_hw_desc hw_desc;
    struct tx_cfm_tag hw_cfm;
    uint32_t buf[128];
};

struct tx_agg_desc {
    uint8_t reserved;
};

typedef long __suseconds_t;

typedef __suseconds_t suseconds_t;

typedef struct timeval timeval, *Ptimeval;

typedef longlong __int_least64_t;

typedef __int_least64_t time_t;

struct timeval {
    time_t tv_sec;
    suseconds_t tv_usec;
    undefined field_0xc;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum bl_cmd_mgr_state {
    RWNX_CMD_MGR_STATE_INITED=1,
    RWNX_CMD_MGR_STATE_CRASHED=2,
    RWNX_CMD_MGR_STATE_DEINIT=0
} bl_cmd_mgr_state;

typedef struct bl_cmd_mgr bl_cmd_mgr, *Pbl_cmd_mgr;

typedef struct bl_cmd bl_cmd, *Pbl_cmd;

typedef struct bl_hw bl_hw, *Pbl_hw;

typedef SemaphoreHandle_t os_mutex_t;

typedef u16 lmac_msg_id_t;

typedef struct lmac_msg lmac_msg, *Plmac_msg;

typedef StaticEventGroup_t os_event_t;

typedef struct ipc_host_env_tag ipc_host_env_tag, *Pipc_host_env_tag;

typedef struct bl_stats bl_stats, *Pbl_stats;

typedef struct bl_vif bl_vif, *Pbl_vif;

typedef struct bl_sta bl_sta, *Pbl_sta;

typedef struct bl_mod_params bl_mod_params, *Pbl_mod_params;

typedef enum RWNX_INTERFACE_STATUS {
    RWNX_INTERFACE_STATUS_DOWN=0,
    RWNX_INTERFACE_STATUS_UP=1
} RWNX_INTERFACE_STATUS;

typedef u16 lmac_task_id_t;

typedef struct ipc_host_cb_tag ipc_host_cb_tag, *Pipc_host_cb_tag;

typedef struct ipc_hostbuf ipc_hostbuf, *Pipc_hostbuf;

typedef struct net_device_stats net_device_stats, *Pnet_device_stats;

typedef union anon_union.conflict13e08d_for_field_13 anon_union.conflict13e08d_for_field_13, *Panon_union.conflict13e08d_for_field_13;

typedef struct anon_struct.conflict13def8 anon_struct.conflict13def8, *Panon_struct.conflict13def8;

typedef struct anon_struct.conflict13df24 anon_struct.conflict13df24, *Panon_struct.conflict13df24;

typedef struct anon_struct.conflict13df9f anon_struct.conflict13df9f, *Panon_struct.conflict13df9f;

typedef struct bl_bcn bl_bcn, *Pbl_bcn;

struct bl_bcn {
    u8 * head;
    u8 * tail;
    u8 * ies;
    size_t head_len;
    size_t tail_len;
    size_t ies_len;
    size_t tim_len;
    size_t len;
    u8 dtim;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
};

struct bl_mod_params {
    _Bool ht_on;
    _Bool vht_on;
    undefined field_0x2;
    undefined field_0x3;
    int mcs_map;
    _Bool ldpc_on;
    _Bool vht_stbc;
    undefined field_0xa;
    undefined field_0xb;
    int phy_cfg;
    int uapsd_timeout;
    _Bool ap_uapsd_on;
    _Bool sgi;
    _Bool sgi80;
    _Bool use_2040;
    _Bool use_80;
    _Bool custregd;
    undefined field_0x1a;
    undefined field_0x1b;
    int nss;
    _Bool bfmee;
    _Bool bfmer;
    _Bool mesh;
    _Bool murx;
    _Bool mutx;
    _Bool mutx_on;
    undefined field_0x26;
    undefined field_0x27;
    uint roc_dur_max;
    int listen_itv;
    _Bool listen_bcmc;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
    int lp_clk_ppm;
    _Bool ps_on;
    undefined field_0x39;
    undefined field_0x3a;
    undefined field_0x3b;
    int tx_lft;
    int amsdu_maxnb;
    int uapsd_queues;
    _Bool tdls;
    undefined field_0x49;
    undefined field_0x4a;
    undefined field_0x4b;
};

struct net_device_stats {
    ulong rx_packets;
    ulong tx_packets;
    ulong rx_bytes;
    ulong tx_bytes;
    ulong rx_errors;
    ulong tx_errors;
    ulong rx_dropped;
    ulong tx_dropped;
    ulong multicast;
    ulong collisions;
    ulong rx_length_errors;
    ulong rx_over_errors;
    ulong rx_crc_errors;
    ulong rx_frame_errors;
    ulong rx_fifo_errors;
    ulong rx_missed_errors;
    ulong tx_aborted_errors;
    ulong tx_carrier_errors;
    ulong tx_fifo_errors;
    ulong tx_heartbeat_errors;
    ulong tx_window_errors;
    ulong rx_compressed;
    ulong tx_compressed;
};

struct anon_struct.conflict13df9f {
    struct bl_vif * master;
    struct bl_sta * sta_4a;
};

struct anon_struct.conflict13def8 {
    struct bl_sta * ap;
    struct bl_sta * tdls_sta;
};

struct anon_struct.conflict13df24 {
    u16 flags;
    undefined field_0x2;
    undefined field_0x3;
    struct list_head sta_list;
    struct bl_bcn bcn;
    u8 bcmc_index;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
    struct list_head mpath_list;
    struct list_head proxy_list;
    _Bool create_path;
    undefined field_0x45;
    undefined field_0x46;
    undefined field_0x47;
    int generation;
};

union anon_union.conflict13e08d_for_field_13 {
    struct anon_struct.conflict13def8 sta;
    struct anon_struct.conflict13df24 ap;
    struct anon_struct.conflict13df9f ap_vlan;
};

struct bl_vif {
    struct list_head list;
    struct netif * dev;
    struct bl_hw * bl_hw;
    struct net_device_stats net_stats;
    u8 drv_vif_index;
    u8 vif_index;
    u8 ch_index;
    _Bool up;
    _Bool use_4addr;
    _Bool is_resending;
    _Bool user_mpm;
    _Bool roc_tdls;
    u8 tdls_status;
    undefined field_0x75;
    undefined field_0x76;
    undefined field_0x77;
    union anon_union.conflict13e08d_for_field_13 field_13;
};

struct lmac_msg {
    lmac_msg_id_t id;
    lmac_task_id_t dest_id;
    lmac_task_id_t src_id;
    u16 param_len;
    u32.conflict[0] param;
};

struct bl_stats {
    int cfm_balance;
    ulong last_rx;
    ulong last_tx;
    int ampdus_tx[64];
    int ampdus_rx[64];
    int ampdus_rx_map[4];
    int ampdus_rx_miss;
    int amsdus_rx[64];
};

struct ipc_host_cb_tag {
    int (* send_data_cfm)(void *, void *);
    uint8_t (* recv_data_ind)(void *, void *);
    uint8_t (* recv_radar_ind)(void *, void *);
    uint8_t (* recv_msg_ind)(void *, void *);
    uint8_t (* recv_msgack_ind)(void *, void *);
    uint8_t (* recv_dbg_ind)(void *, void *);
    void (* prim_tbtt_ind)(void *);
    void (* sec_tbtt_ind)(void *);
};

struct ipc_hostbuf {
    void * hostid;
    uint32_t dma_addr;
};

struct bl_cmd {
    struct list_head list;
    lmac_msg_id_t id;
    lmac_msg_id_t reqid;
    struct lmac_msg * a2e_msg;
    char * e2a_msg;
    u32.conflict tkn;
    u16 flags;
    undefined field_0x1a;
    undefined field_0x1b;
    os_event_t complete;
    u32.conflict result;
};

struct bl_cmd_mgr {
    enum bl_cmd_mgr_state state;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    u32.conflict next_tkn;
    u32.conflict queue_sz;
    u32.conflict max_queue_sz;
    struct list_head cmds;
    os_mutex_t lock;
    int (* queue)(struct bl_cmd_mgr *, struct bl_cmd *);
    int (* llind)(struct bl_cmd_mgr *, struct bl_cmd *);
    int (* msgind)(struct bl_cmd_mgr *, struct ipc_e2a_msg *, int (* )(struct bl_hw *, struct bl_cmd *, struct ipc_e2a_msg *));
    void (* print)(struct bl_cmd_mgr *);
    void (* drain)(struct bl_cmd_mgr *);
};

struct ipc_host_env_tag {
    struct ipc_host_cb_tag cb;
    struct ipc_shared_env_tag * shared;
    struct ipc_hostbuf ipc_host_rxdesc_array[2];
    uint8_t ipc_host_rxdesc_idx;
    uint8_t rxdesc_nb;
    uint8_t ipc_host_rxbuf_idx;
    undefined field_0x37;
    uint32_t rx_bufnb;
    uint32_t rx_bufsz;
    uint32_t txdesc_free_idx;
    uint32_t txdesc_used_idx;
    void * tx_host_id0[4];
    void * * tx_host_id;
    struct txdesc_host * txdesc;
    struct ipc_hostbuf ipc_host_msgbuf_array[8];
    uint8_t ipc_host_msge2a_idx;
    undefined field_0xa1;
    undefined field_0xa2;
    undefined field_0xa3;
    uint32_t ipc_e2amsg_bufnb;
    uint32_t ipc_e2amsg_bufsz;
    uint8_t msga2e_cnt;
    undefined field_0xad;
    undefined field_0xae;
    undefined field_0xaf;
    void * msga2e_hostid;
    struct ipc_hostbuf ipc_host_dbgbuf_array[4];
    uint8_t ipc_host_dbg_idx;
    undefined field_0xd5;
    undefined field_0xd6;
    undefined field_0xd7;
    uint32_t ipc_dbg_bufnb;
    uint32_t ipc_dbg_bufsz;
    void * pthis;
};

struct bl_sta {
    struct mac_addr.conflict sta_addr;
    u16 aid;
    u8 is_used;
    u8 sta_idx;
    u8 vif_idx;
    u8 vlan_idx;
    int8_t rssi;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t tsflo;
    uint32_t tsfhi;
    uint8_t data_rate;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct bl_hw {
    int is_up;
    struct bl_cmd_mgr cmd_mgr;
    struct ipc_host_env_tag * ipc_env;
    struct bl_stats stats;
    struct list_head vifs;
    struct bl_vif vif_table[12];
    struct bl_sta sta_table[12];
    ulong drv_flags;
    struct mm_version_cfm version_cfm;
    struct bl_mod_params * mod_params;
    enum wiphy_flags flags;
    struct ieee80211_sta_ht_cap ht_cap;
    u8 vif_started;
    undefined field_0xe1b;
    int vif_index_sta;
    int vif_index_ap;
    int sta_idx;
    int ap_bcmc_idx;
    struct phy_cfg_tag phy_config;
    enum RWNX_INTERFACE_STATUS status;
    undefined field_0xe6d;
    undefined field_0xe6e;
    undefined field_0xe6f;
};

typedef struct uart_priv_data uart_priv_data, *Puart_priv_data;

typedef struct uart_priv_data uart_priv_data_t;

struct uart_priv_data {
    aos_mutex_t mutex;
};

typedef struct _feature_pin _feature_pin, *P_feature_pin;

struct _feature_pin {
    char * featue_name;
    char * pin_name;
    uint8_t value;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
};

typedef struct bl_uart_notify bl_uart_notify, *Pbl_uart_notify;

struct bl_uart_notify {
    void (* rx_cb)(void *);
    void * rx_cb_arg;
    void (* tx_cb)(void *);
    void * tx_cb_arg;
};

typedef struct bl_uart_notify bl_uart_notify_t;

typedef struct StreamBufferDef_t StreamBuffer_t;

typedef struct apm_conf_max_sta_req apm_conf_max_sta_req, *Papm_conf_max_sta_req;

struct apm_conf_max_sta_req {
    uint8_t max_sta_supported;
};

typedef struct apm_sta_del_ind apm_sta_del_ind, *Papm_sta_del_ind;

struct apm_sta_del_ind {
    uint8_t sta_idx;
};

typedef struct apm_sta_del_req apm_sta_del_req, *Papm_sta_del_req;

struct apm_sta_del_req {
    uint8_t vif_idx;
    uint8_t sta_idx;
};

typedef struct apm_start_cac_req apm_start_cac_req, *Papm_start_cac_req;

struct apm_start_cac_req {
    struct scan_chan_tag chan;
    undefined field_0x6;
    undefined field_0x7;
    uint32_t center_freq1;
    uint32_t center_freq2;
    uint8_t ch_width;
    uint8_t vif_idx;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct apm_start_cfm apm_start_cfm, *Papm_start_cfm;

struct apm_start_cfm {
    uint8_t status;
    uint8_t vif_idx;
    uint8_t ch_idx;
    uint8_t bcmc_idx;
};

typedef struct apm_sta_add_ind apm_sta_add_ind, *Papm_sta_add_ind;

struct apm_sta_add_ind {
    uint32_t flags;
    struct mac_addr.conflict sta_addr;
    uint8_t vif_idx;
    uint8_t sta_idx;
    int8_t rssi;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t tsflo;
    uint32_t tsfhi;
    uint8_t data_rate;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct apm_sta_del_cfm apm_sta_del_cfm, *Papm_sta_del_cfm;

struct apm_sta_del_cfm {
    uint8_t status;
    uint8_t vif_idx;
    uint8_t sta_idx;
};

typedef struct apm_stop_req apm_stop_req, *Papm_stop_req;

struct apm_stop_req {
    uint8_t vif_idx;
};

typedef enum apm_msg_tag {
    APM_STA_DEL_REQ=7179,
    APM_STA_DEL_IND=7177,
    APM_MAX=7183,
    APM_STOP_CAC_CFM=7175,
    APM_STA_CONNECT_TIMEOUT_IND=7178,
    APM_START_CAC_REQ=7172,
    APM_CONF_MAX_STA_CFM=7182,
    APM_STOP_CFM=7171,
    APM_STOP_CAC_REQ=7174,
    APM_CONF_MAX_STA_REQ=7181,
    APM_STA_ADD_IND=7176,
    APM_START_REQ=7168,
    APM_START_CFM=7169,
    APM_STOP_REQ=7170,
    APM_STA_DEL_CFM=7180,
    APM_START_CAC_CFM=7173
} apm_msg_tag;

typedef enum apm_state_tag {
    APM_BCN_SETTING=2,
    APM_IDLE=0,
    APM_BSS_PARAM_SETTING=1,
    APM_STATE_MAX=3
} apm_state_tag;

typedef struct apm_start_cac_cfm apm_start_cac_cfm, *Papm_start_cac_cfm;

struct apm_start_cac_cfm {
    uint8_t status;
    uint8_t ch_idx;
};

typedef struct apm_stop_cac_req apm_stop_cac_req, *Papm_stop_cac_req;

struct apm_stop_cac_req {
    uint8_t vif_idx;
};

typedef struct UART_CFG_Type UART_CFG_Type, *PUART_CFG_Type;

typedef enum UART_DataBits_Type {
    UART_DATABITS_5=0,
    UART_DATABITS_7=2,
    UART_DATABITS_6=1,
    UART_DATABITS_8=3
} UART_DataBits_Type;

typedef enum UART_StopBits_Type {
    UART_STOPBITS_1=0,
    UART_STOPBITS_2=2,
    UART_STOPBITS_1_5=1
} UART_StopBits_Type;

typedef enum UART_Parity_Type {
    UART_PARITY_ODD=1,
    UART_PARITY_EVEN=2,
    UART_PARITY_NONE=0
} UART_Parity_Type;

typedef enum UART_ByteBitInverse_Type {
    UART_LSB_FIRST=0,
    UART_MSB_FIRST=1
} UART_ByteBitInverse_Type;

struct UART_CFG_Type {
    uint32_t uartClk;
    uint32_t baudRate;
    enum UART_DataBits_Type dataBits;
    enum UART_StopBits_Type stopBits;
    enum UART_Parity_Type parity;
    enum BL_Fun_Type ctsFlowControl;
    enum BL_Fun_Type rxDeglitch;
    enum BL_Fun_Type rtsSoftwareControl;
    enum UART_ByteBitInverse_Type byteBitInverse;
    undefined field_0xf;
};

typedef enum UART_Overflow_Type {
    UART_TX_UNDERFLOW=1,
    UART_TX_OVERFLOW=0,
    UART_RX_OVERFLOW=2,
    UART_RX_UNDERFLOW=3
} UART_Overflow_Type;

typedef struct UART_IrCfg_Type UART_IrCfg_Type, *PUART_IrCfg_Type;

struct UART_IrCfg_Type {
    enum BL_Fun_Type txIrEnable;
    enum BL_Fun_Type rxIrEnable;
    enum BL_Fun_Type txIrInverse;
    enum BL_Fun_Type rxIrInverse;
    uint16_t txIrPulseStart;
    uint16_t txIrPulseStop;
    uint16_t rxIrPulseStart;
};

typedef struct UART_FifoCfg_Type UART_FifoCfg_Type, *PUART_FifoCfg_Type;

struct UART_FifoCfg_Type {
    uint8_t txFifoDmaThreshold;
    uint8_t rxFifoDmaThreshold;
    enum BL_Fun_Type txFifoDmaEnable;
    enum BL_Fun_Type rxFifoDmaEnable;
};

typedef enum UART_ID_Type {
    UART0_ID=0,
    UART1_ID=1,
    UART_ID_MAX=2
} UART_ID_Type;

typedef enum UART_INT_Type {
    UART_INT_RX_FER=7,
    UART_INT_TX_FIFO_REQ=2,
    UART_INT_ALL=8,
    UART_INT_TX_END=0,
    UART_INT_PCE=5,
    UART_INT_RTO=4,
    UART_INT_RX_END=1,
    UART_INT_RX_FIFO_REQ=3,
    UART_INT_TX_FER=6
} UART_INT_Type;

typedef enum UART_AutoBaudDetection_Type {
    UART_AUTOBAUD_0X55=0,
    UART_AUTOBAUD_STARTBIT=1
} UART_AutoBaudDetection_Type;

typedef enum UART_Direction_Type {
    UART_RX=1,
    UART_TX=0,
    UART_TXRX=2
} UART_Direction_Type;

typedef union anon_union.conflict13e08d anon_union.conflict13e08d, *Panon_union.conflict13e08d;

union anon_union.conflict13e08d {
    struct anon_struct.conflict13def8 sta;
    struct anon_struct.conflict13df24 ap;
    struct anon_struct.conflict13df9f ap_vlan;
};

typedef struct ethhdr ethhdr, *Pethhdr;

struct ethhdr {
    uchar h_dest[6];
    uchar h_source[6];
    __be16 h_proto;
};

typedef enum ieee80211_vht_mcs_support {
    IEEE80211_VHT_MCS_SUPPORT_0_8=1,
    IEEE80211_VHT_MCS_SUPPORT_0_7=0,
    IEEE80211_VHT_MCS_SUPPORT_0_9=2,
    IEEE80211_VHT_MCS_NOT_SUPPORTED=3
} ieee80211_vht_mcs_support;

typedef struct txl_frame_desc_tag txl_frame_desc_tag, *Ptxl_frame_desc_tag;

typedef struct txl_frame_cfm_tag txl_frame_cfm_tag, *Ptxl_frame_cfm_tag;

struct txl_frame_cfm_tag {
    void (* cfm_func)(void *, uint32_t);
    void * env;
};

struct txl_frame_desc_tag {
    struct txdesc txdesc;
    struct txl_frame_cfm_tag cfm;
    uint8_t type;
    _Bool postponed;
    _Bool keep_desc;
    undefined field_0x2d7;
};

typedef struct txl_frame_env_tag txl_frame_env_tag, *Ptxl_frame_env_tag;

struct txl_frame_env_tag {
    struct co_list desc_free;
    struct co_list desc_done;
};

typedef struct chan_ctxt_tag chan_ctxt_tag, *Pchan_ctxt_tag;

struct chan_ctxt_tag {
    struct co_list_hdr list_hdr;
    struct mm_chan_ctxt_add_req channel;
    ke_task_id_t taskid;
    uint16_t nb_slots;
    uint16_t nb_rem_slots;
    uint16_t nb_res_slots;
    uint8_t status;
    uint8_t idx;
    uint8_t nb_linked_vif;
    uint8_t vif_index;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef enum chan_tbtt_status {
    CHAN_TBTT_NOT_PROG=0,
    CHAN_TBTT_STATUS_MAX=3,
    CHAN_TBTT_PRESENCE=2,
    CHAN_TBTT_PROG=1
} chan_tbtt_status;

typedef struct chan_env_tag chan_env_tag, *Pchan_env_tag;

struct chan_env_tag {
    struct co_list list_free_ctxt;
    struct co_list list_sched_ctxt;
    struct co_list list_tbtt;
    struct co_list list_tbtt_delay;
    struct chan_ctxt_tag * current_channel;
    struct chan_ctxt_tag * chan_switch;
    struct mm_timer_tag tmr_tbtt_switch;
    struct mm_timer_tag tmr_cde;
    struct mm_timer_tag tmr_ctxt_op;
    struct mm_timer_tag tmr_conn_less;
    uint32_t cde_dur_us;
    uint32_t cde_time;
    uint8_t status;
    uint8_t cfm_cnt;
    uint8_t nb_sched_ctxt;
    uint8_t pm;
};

typedef enum chan_env_status_bit {
    CHAN_ENV_SCAN_BIT=3,
    CHAN_ENV_ROC_BIT=2,
    CHAN_ENV_TIMEOUT_BIT=5,
    CHAN_ENV_ROC_WAIT_BIT=0,
    CHAN_ENV_BIT_MAX=7,
    CHAN_ENV_SCAN_WAIT_BIT=1,
    CHAN_ENV_BCN_DETECT_BIT=6,
    CHAN_ENV_DELAY_PROG_BIT=4
} chan_env_status_bit;

typedef struct chan_tbtt_tag chan_tbtt_tag, *Pchan_tbtt_tag;

struct chan_tbtt_tag {
    struct co_list_hdr list_hdr;
    uint32_t time;
    uint8_t vif_index;
    uint8_t priority;
    uint8_t status;
    undefined field_0xb;
};

typedef enum chan_ctxt_status {
    CHAN_WAIT_NOA_CFM=3,
    CHAN_SENDING_NOA=6,
    CHAN_CTXT_STATUS_MAX=7,
    CHAN_NOT_PROG=1,
    CHAN_NOT_SCHEDULED=0,
    CHAN_WAITING_END=4,
    CHAN_PRESENT=5,
    CHAN_GOTO_IDLE=2
} chan_ctxt_status;

typedef struct txl_cfm_env_tag txl_cfm_env_tag, *Ptxl_cfm_env_tag;

struct txl_cfm_env_tag {
    struct co_list cfmlist[5];
};

typedef struct icmp_echo_hdr icmp_echo_hdr, *Picmp_echo_hdr;

struct icmp_echo_hdr {
    u8_t type;
    u8_t code;
    u16_t chksum;
    u16_t id;
    u16_t seqno;
};

typedef enum icmp_dur_type {
    ICMP_DUR_HOST=1,
    ICMP_DUR_NET=0,
    ICMP_DUR_PROTO=2,
    ICMP_DUR_FRAG=4,
    ICMP_DUR_PORT=3,
    ICMP_DUR_SR=5
} icmp_dur_type;

typedef enum rxu_msg_tag {
    RXU_MGT_IND=11264,
    RXU_NULL_DATA=11265
} rxu_msg_tag;

typedef struct rxu_mgt_ind rxu_mgt_ind, *Prxu_mgt_ind;

struct rxu_mgt_ind {
    uint16_t length;
    uint16_t framectrl;
    uint16_t center_freq;
    uint8_t band;
    uint8_t sta_idx;
    uint8_t inst_nbr;
    uint8_t sa[6];
    undefined field_0xf;
    uint32_t tsflo;
    uint32_t tsfhi;
    int8_t rssi;
    int8_t ppm_abs;
    int8_t ppm_rel;
    uint8_t data_rate;
    uint32_t[0] payload;
};

typedef struct ota_header ota_header, *Pota_header;

typedef union anon_union.conflict17c8f7_for_u anon_union.conflict17c8f7_for_u, *Panon_union.conflict17c8f7_for_u;

typedef struct anon_struct.conflict17c862 anon_struct.conflict17c862, *Panon_struct.conflict17c862;

struct anon_struct.conflict17c862 {
    uint8_t header[16];
    uint8_t type[4];
    uint32_t len;
    uint8_t pad0[8];
    uint8_t ver_hardware[16];
    uint8_t ver_software[16];
    uint8_t sha256[32];
};

union anon_union.conflict17c8f7_for_u {
    struct anon_struct.conflict17c862 s;
    uint8_t _pad[512];
};

struct ota_header {
    union anon_union.conflict17c8f7_for_u u;
};

typedef struct ota_header ota_header_t;

typedef union anon_union.conflict17c8f7 anon_union.conflict17c8f7, *Panon_union.conflict17c8f7;

union anon_union.conflict17c8f7 {
    struct anon_struct.conflict17c862 s;
    uint8_t _pad[512];
};

typedef struct wifi_pkt wifi_pkt, *Pwifi_pkt;

struct wifi_pkt {
    uint32_t pkt[4];
    void * pbuf[4];
    uint16_t len[4];
};

typedef struct llc_snap llc_snap, *Pllc_snap;

struct llc_snap {
    uint16_t dsap_ssap;
    uint16_t control_oui0;
    uint16_t oui1_2;
    uint16_t proto_id;
};

typedef struct llc_snap_short llc_snap_short, *Pllc_snap_short;

struct llc_snap_short {
    uint16_t dsap_ssap;
    uint16_t control_oui0;
    uint16_t oui1_2;
};

typedef struct yloop_ctx_t yloop_ctx_t, *Pyloop_ctx_t;

typedef struct yloop_sock_t yloop_sock_t, *Pyloop_sock_t;

struct yloop_ctx_t {
    dlist_t timeouts;
    struct pollfd * pollfds;
    struct yloop_sock_t * readers;
    int eventfd;
    uint16_t max_sock;
    uint8_t reader_count;
    _Bool pending_terminate;
    _Bool terminate;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

struct yloop_sock_t {
    int sock;
    void * private_data;
    void (* cb)(int, void *);
};

typedef void * aos_loop_t;

typedef struct wifi_mgmr_ap_item wifi_mgmr_ap_item, *Pwifi_mgmr_ap_item;

typedef struct wifi_mgmr_ap_item wifi_mgmr_ap_item_t;

struct wifi_mgmr_ap_item {
    char ssid[32];
    char ssid_tail[1];
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    uint32_t ssid_len;
    uint8_t bssid[6];
    uint8_t channel;
    uint8_t auth;
    int8_t rssi;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

typedef enum WIFI_STATE_ENUM_LIST {
    WIFI_STATE_WITH_AP_DISCONNECT=21,
    WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING=19,
    WIFI_STATE_CONNECTED_IP_GOT=4,
    WIFI_STATE_IDLE=1,
    WIFI_STATE_IFDOWN=6,
    WIFI_STATE_CONNECTED_IP_GETTING=3,
    WIFI_STATE_DISCONNECT=5,
    WIFI_STATE_CONNECTING=2,
    WIFI_STATE_WITH_AP_CONNECTED_IP_GOT=20,
    WIFI_STATE_NO_AP_FOUND=9,
    WIFI_STATE_PSK_ERROR=8,
    WIFI_STATE_WITH_AP_CONNECTING=18,
    WIFI_STATE_UNKNOWN=0,
    WIFI_STATE_WITH_AP_IDLE=17,
    WIFI_STATE_SNIFFER=7
} WIFI_STATE_ENUM_LIST;

typedef struct wifi_sta_basic_info wifi_sta_basic_info, *Pwifi_sta_basic_info;

struct wifi_sta_basic_info {
    uint8_t sta_idx;
    uint8_t is_used;
    uint8_t sta_mac[6];
    uint32_t tsfhi;
    uint32_t tsflo;
    int rssi;
    uint8_t data_rate;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct wifi_conf wifi_conf, *Pwifi_conf;

typedef struct wifi_conf wifi_conf_t;

struct wifi_conf {
    char country_code[3];
    undefined field_0x3;
    int channel_nums;
};

typedef struct wifi_mgmr_sta_connect_ind_stat_info wifi_mgmr_sta_connect_ind_stat_info, *Pwifi_mgmr_sta_connect_ind_stat_info;

typedef struct wifi_mgmr_sta_connect_ind_stat_info wifi_mgmr_sta_connect_ind_stat_info_t;

struct wifi_mgmr_sta_connect_ind_stat_info {
    uint16_t status_code;
    uint8_t type_ind;
    char ssid[32];
    char psk[65];
    char pmk[64];
    uint8_t bssid[6];
    uint16_t chan_freq;
    uint8_t chan_band;
    undefined field_0xad;
};

typedef void * wifi_interface_t;

typedef enum WIFI_SCAN_DONE_EVENT_TYPE {
    WIFI_SCAN_DONE_EVENT_BUSY=1,
    WIFI_SCAN_DONE_EVENT_OK=0
} WIFI_SCAN_DONE_EVENT_TYPE;

typedef struct rx_cntrl_pm_mon rx_cntrl_pm_mon, *Prx_cntrl_pm_mon;

struct rx_cntrl_pm_mon {
    struct mac_addr addr;
    uint8_t pm_state;
    _Bool mon;
};

typedef struct rx_cntrl_ipcdesc rx_cntrl_ipcdesc, *Prx_cntrl_ipcdesc;

struct rx_cntrl_ipcdesc {
    uint32_t host_id;
};

typedef struct rxu_cntrl_env_tag rxu_cntrl_env_tag, *Prxu_cntrl_env_tag;

typedef struct rx_cntrl_rx_status rx_cntrl_rx_status, *Prx_cntrl_rx_status;

typedef struct rx_cntrl_dupli rx_cntrl_dupli, *Prx_cntrl_dupli;

struct rx_cntrl_dupli {
    struct mac_addr last_src_addr;
    uint16_t last_seq_cntl;
};

struct rx_cntrl_rx_status {
    uint16_t frame_cntl;
    uint16_t seq_cntl;
    uint16_t sn;
    uint8_t fn;
    uint8_t tid;
    uint8_t machdr_len;
    uint8_t sta_idx;
    uint8_t vif_idx;
    uint8_t dst_idx;
    undefined field_0xc;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint64_t pn;
    uint32_t statinfo;
    uint32_t host_buf_addr;
    struct key_info_tag * key;
    struct mac_addr da;
    struct mac_addr sa;
    uint8_t frame_info;
    _Bool eth_len_present;
    uint8_t payl_offset;
    undefined field_0x33;
    undefined field_0x34;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
};

struct rxu_cntrl_env_tag {
    struct rx_cntrl_rx_status rx_status;
    struct co_list rxdesc_pending;
    struct co_list rxdesc_ready;
    struct rx_cntrl_ipcdesc rx_ipcdesc_stat;
    struct co_list rxu_defrag_free;
    struct co_list rxu_defrag_used;
    struct rx_cntrl_dupli rxu_dupli;
    struct mac_addr * mac_addr_ptr;
    struct rx_cntrl_pm_mon pm_mon;
    uint32_t ttr;
    undefined field_0x74;
    undefined field_0x75;
    undefined field_0x76;
    undefined field_0x77;
};

typedef enum rx_status_bits {
    RX_STAT_LEN_UPDATE=8,
    RX_STAT_DELETE=4,
    RX_STAT_FORWARD=1,
    RX_STAT_ALLOC=2,
    RX_STAT_COPY=32,
    RX_STAT_ETH_LEN_UPDATE=16
} rx_status_bits;

typedef struct rxu_mic_calc rxu_mic_calc, *Prxu_mic_calc;

typedef struct mic_calc mic_calc, *Pmic_calc;

struct mic_calc {
    uint32_t mic_key_least;
    uint32_t mic_key_most;
    uint32_t last_m_i;
    uint8_t last_m_i_len;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

struct rxu_mic_calc {
    struct mic_calc mic_calc;
    uint32_t last_bytes[2];
};

typedef enum rxu_cntrl_frame_info_pos {
    RXU_CNTRL_MIC_CHECK_NEEDED=1,
    RXU_CNTRL_PN_CHECK_NEEDED=2,
    RXU_CNTRL_NEW_MESH_PEER=4
} rxu_cntrl_frame_info_pos;

typedef struct A_BLOCK_LINK A_BLOCK_LINK, *PA_BLOCK_LINK;

struct A_BLOCK_LINK {
    struct A_BLOCK_LINK * pxNextFreeBlock;
    size_t xBlockSize;
};

typedef struct A_BLOCK_LINK BlockLink_t;

typedef struct fdt_header fdt_header, *Pfdt_header;

struct fdt_header {
    fdt32_t magic;
    fdt32_t totalsize;
    fdt32_t off_dt_struct;
    fdt32_t off_dt_strings;
    fdt32_t off_mem_rsvmap;
    fdt32_t version;
    fdt32_t last_comp_version;
    fdt32_t boot_cpuid_phys;
    fdt32_t size_dt_strings;
    fdt32_t size_dt_struct;
};

typedef struct fdt_reserve_entry fdt_reserve_entry, *Pfdt_reserve_entry;

struct fdt_reserve_entry {
    fdt64_t address;
    fdt64_t size;
};

typedef struct fdt_property fdt_property, *Pfdt_property;

struct fdt_property {
    fdt32_t tag;
    fdt32_t len;
    fdt32_t nameoff;
    char[0] data;
};

typedef struct fdt_node_header fdt_node_header, *Pfdt_node_header;

struct fdt_node_header {
    fdt32_t tag;
    char[0] name;
};

typedef struct yloop_timeout_s yloop_timeout_s, *Pyloop_timeout_s;

typedef struct yloop_timeout_s yloop_timeout_t;

struct yloop_timeout_s {
    dlist_t next;
    longlong timeout_ms;
    void * private_data;
    void (* cb)(void *);
    int ms;
    undefined field_0x1c;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct mbedtls_rsa_context mbedtls_rsa_context, *Pmbedtls_rsa_context;

struct mbedtls_rsa_context {
    int ver;
    size_t len;
    struct mbedtls_mpi N;
    struct mbedtls_mpi E;
    struct mbedtls_mpi D;
    struct mbedtls_mpi P;
    struct mbedtls_mpi Q;
    struct mbedtls_mpi DP;
    struct mbedtls_mpi DQ;
    struct mbedtls_mpi QP;
    struct mbedtls_mpi RN;
    struct mbedtls_mpi RP;
    struct mbedtls_mpi RQ;
    struct mbedtls_mpi Vi;
    struct mbedtls_mpi Vf;
    int padding;
    int hash_id;
};

typedef struct anon_struct.conflict1227f3 anon_struct.conflict1227f3, *Panon_struct.conflict1227f3;

struct anon_struct.conflict1227f3 {
    uint32_t task;
    uint32_t element;
};

typedef struct cfg_start_cfm cfg_start_cfm, *Pcfg_start_cfm;

struct cfg_start_cfm {
    uint8_t status;
};

typedef struct anon_struct.conflict89a93 anon_struct.conflict89a93, *Panon_struct.conflict89a93;

struct anon_struct.conflict89a93 {
    uint32_t task;
    uint32_t element;
    uint32_t length;
    uint32_t[0] buf;
};

typedef union anon_union.conflict122886 anon_union.conflict122886, *Panon_union.conflict122886;

union anon_union.conflict122886 {
    undefined1 get; // Data type larger than union's declared size: anon_struct.conflict1227f3[1]
    undefined1 reset; // Data type larger than union's declared size: anon_struct.conflict122817[1]
    undefined1 set; // Data type larger than union's declared size: anon_struct.conflict12283b[1]
};

typedef enum cfg_msg_tag {
    CFG_MAX=12290,
    CFG_START_REQ=12288,
    CFG_START_CFM=12289
} cfg_msg_tag;

typedef struct cfg_start_req cfg_start_req, *Pcfg_start_req;

struct cfg_start_req { // Missing member u : anon_union.conflict122886_for_u at offset 0x4 [exceeds parent struct len]
    uint32_t ops;
};

typedef struct anon_struct.conflict12283b anon_struct.conflict12283b, *Panon_struct.conflict12283b;

struct anon_struct.conflict12283b {
    uint32_t task;
    uint32_t element;
    uint32_t type;
    uint32_t length;
    uint32_t[0] buf;
};

typedef enum cfg_state_tag {
    CFG_IDLE=0,
    CFG_STATE_MAX=1
} cfg_state_tag;

typedef void (* altcp_err_fn.conflict)(void *, err_t);

typedef enum bam_state_tag {
    BAM_IDLE=0,
    BAM_STATE_MAX=5,
    BAM_WAIT_RSP=2,
    BAM_CHECK_ADMISSION=3,
    BAM_ACTIVE=1,
    BAM_RESET=4
} bam_state_tag;

typedef union tcp_listen_pcbs_t tcp_listen_pcbs_t, *Ptcp_listen_pcbs_t;

union tcp_listen_pcbs_t {
    struct tcp_pcb_listen * listen_pcbs;
    struct tcp_pcb * pcbs;
};

typedef struct co_read16_struct co_read16_struct, *Pco_read16_struct;

struct co_read16_struct {
    uint16_t val;
};

typedef struct co_read32_struct co_read32_struct, *Pco_read32_struct;

struct co_read32_struct {
    uint32_t val;
};

typedef union anon_union.conflictd321 anon_union.conflictd321, *Panon_union.conflictd321;

union anon_union.conflictd321 {
    uint32 Interface;
    struct cm_ConnectionInfo * connPtr;
};

typedef struct TIMER_CFG_Type TIMER_CFG_Type, *PTIMER_CFG_Type;

typedef enum TIMER_Chan_Type {
    TIMER_CH_MAX=2,
    TIMER_CH0=0,
    TIMER_CH1=1
} TIMER_Chan_Type;

typedef enum TIMER_ClkSrc_Type {
    TIMER_CLKSRC_32K=1,
    TIMER_CLKSRC_XTAL=3,
    TIMER_CLKSRC_1K=2,
    TIMER_CLKSRC_FCLK=0
} TIMER_ClkSrc_Type;

typedef enum TIMER_PreLoad_Trig_Type {
    TIMER_PRELOAD_TRIG_COMP0=1,
    TIMER_PRELOAD_TRIG_COMP1=2,
    TIMER_PRELOAD_TRIG_COMP2=3,
    TIMER_PRELOAD_TRIG_NONE=0
} TIMER_PreLoad_Trig_Type;

typedef enum TIMER_CountMode_Type {
    TIMER_COUNT_FREERUN=1,
    TIMER_COUNT_PRELOAD=0
} TIMER_CountMode_Type;

struct TIMER_CFG_Type {
    enum TIMER_Chan_Type timerCh;
    enum TIMER_ClkSrc_Type clkSrc;
    enum TIMER_PreLoad_Trig_Type plTrigSrc;
    enum TIMER_CountMode_Type countMode;
    uint8_t clockDivision;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    uint32_t matchVal0;
    uint32_t matchVal1;
    uint32_t matchVal2;
    uint32_t preLoadVal;
};

typedef enum WDT_INT_Type {
    WDT_INT_ALL=1,
    WDT_INT=0
} WDT_INT_Type;

typedef enum TIMER_INT_Type {
    TIMER_INT_COMP_1=1,
    TIMER_INT_COMP_0=0,
    TIMER_INT_ALL=3,
    TIMER_INT_COMP_2=2
} TIMER_INT_Type;

typedef enum TIMER_Comp_ID_Type {
    TIMER_COMP_ID_0=0,
    TIMER_COMP_ID_1=1,
    TIMER_COMP_ID_2=2
} TIMER_Comp_ID_Type;

typedef struct DMA_LLI_Ctrl_Type DMA_LLI_Ctrl_Type, *PDMA_LLI_Ctrl_Type;

typedef struct DMA_Control_Reg DMA_Control_Reg, *PDMA_Control_Reg;

struct DMA_Control_Reg {
    uint32_t TransferSize:12;
    uint32_t SBSize:3;
    uint32_t DBSize:3;
    uint32_t SWidth:3;
    uint32_t DWidth:3;
    uint32_t SLargerD:1;
    uint32_t reserved_25:1;
    uint32_t SI:1;
    uint32_t DI:1;
    uint32_t Prot:3;
    uint32_t I:1;
};

struct DMA_LLI_Ctrl_Type {
    uint32_t srcDmaAddr;
    uint32_t destDmaAddr;
    uint32_t nextLLI;
    struct DMA_Control_Reg dmaCtrl;
};

typedef struct DMA_LLI_Cfg_Type DMA_LLI_Cfg_Type, *PDMA_LLI_Cfg_Type;

typedef enum DMA_Trans_Dir_Type {
    DMA_TRNS_P2P=3,
    DMA_TRNS_M2P=1,
    DMA_TRNS_P2M=2,
    DMA_TRNS_M2M=0
} DMA_Trans_Dir_Type;

typedef enum DMA_Periph_Req_Type {
    DMA_REQ_UART1_TX=3,
    DMA_REQ_SPI_TX=11,
    DMA_REQ_GPADC0=22,
    DMA_REQ_UART1_RX=2,
    DMA_REQ_GPADC1=23,
    DMA_REQ_I2C_TX=7,
    DMA_REQ_I2C_RX=6,
    DMA_REQ_NONE=0,
    DMA_REQ_UART0_RX=0,
    DMA_REQ_UART0_TX=1,
    DMA_REQ_SPI_RX=10
} DMA_Periph_Req_Type;

struct DMA_LLI_Cfg_Type {
    enum DMA_Trans_Dir_Type dir;
    enum DMA_Periph_Req_Type srcPeriph;
    enum DMA_Periph_Req_Type dstPeriph;
};

typedef enum DMA_INT_Type {
    DMA_INT_ALL=2,
    DMA_INT_TCOMPLETED=0,
    DMA_INT_ERR=1
} DMA_INT_Type;

typedef enum DMA_Burst_Size_Type {
    DMA_BURST_SIZE_8=2,
    DMA_BURST_SIZE_1=0,
    DMA_BURST_SIZE_16=3,
    DMA_BURST_SIZE_4=1
} DMA_Burst_Size_Type;

typedef enum DMA_Chan_Type {
    DMA_CH1=1,
    DMA_CH0=0,
    DMA_CH3=3,
    DMA_CH_MAX=4,
    DMA_CH2=2
} DMA_Chan_Type;

typedef struct DMA_Channel_Cfg_Type DMA_Channel_Cfg_Type, *PDMA_Channel_Cfg_Type;

typedef enum DMA_Trans_Width_Type {
    DMA_TRNS_WIDTH_32BITS=2,
    DMA_TRNS_WIDTH_16BITS=1,
    DMA_TRNS_WIDTH_8BITS=0
} DMA_Trans_Width_Type;

struct DMA_Channel_Cfg_Type {
    uint32_t srcDmaAddr;
    uint32_t destDmaAddr;
    uint32_t transfLength;
    enum DMA_Trans_Dir_Type dir;
    enum DMA_Chan_Type ch;
    enum DMA_Trans_Width_Type srcTransfWidth;
    enum DMA_Trans_Width_Type dstTransfWidth;
    enum DMA_Burst_Size_Type srcBurstSzie;
    enum DMA_Burst_Size_Type dstBurstSzie;
    uint8_t srcAddrInc;
    uint8_t destAddrInc;
    enum DMA_Periph_Req_Type srcPeriph;
    enum DMA_Periph_Req_Type dstPeriph;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct DMA_LLI_PP_Buf DMA_LLI_PP_Buf, *PDMA_LLI_PP_Buf;

struct DMA_LLI_PP_Buf {
    uint8_t idleIndex;
    uint8_t dmaChan;
    undefined field_0x2;
    undefined field_0x3;
    struct DMA_LLI_Ctrl_Type * lliListHeader[2];
    void (* onTransCompleted)(struct DMA_LLI_Ctrl_Type *);
};

typedef struct DMA_LLI_PP_Struct DMA_LLI_PP_Struct, *PDMA_LLI_PP_Struct;

struct DMA_LLI_PP_Struct {
    uint8_t trans_index;
    uint8_t dmaChan;
    undefined field_0x2;
    undefined field_0x3;
    struct DMA_Control_Reg dmaCtrlRegVal;
    struct DMA_LLI_Cfg_Type * DMA_LLI_Cfg;
    uint32_t operatePeriphAddr;
    uint32_t chache_buf_addr[2];
    enum BL_Fun_Type is_single_mode;
    undefined field_0x19;
    undefined field_0x1a;
    undefined field_0x1b;
};

typedef struct tskTaskControlBlock tskTCB;

typedef tskTCB TCB_t;

typedef union _FP_UNION_S _FP_UNION_S, *P_FP_UNION_S;

typedef struct anon_struct.conflict2d3f15 anon_struct.conflict2d3f15, *Panon_struct.conflict2d3f15;

struct anon_struct.conflict2d3f15 {
    uint frac:23;
    uint exp:8;
    uint sign:1;
};

union _FP_UNION_S {
    SFtype flt;
    struct anon_struct.conflict2d3f15 bits;
};

typedef SemaphoreHandle_t sys_mutex_t;

typedef TaskHandle_t sys_thread_t;

typedef int sys_prot_t;

typedef enum BL_Mask_Type {
    UNMASK=0,
    MASK=1
} BL_Mask_Type;

typedef enum BL_Sts_Type {
    SET=1,
    RESET=0
} BL_Sts_Type;

typedef enum BL_Err_Type {
    SUCCESS=0,
    ERROR=1,
    TIMEOUT=2
} BL_Err_Type;

typedef struct scan_cancel_cfm scan_cancel_cfm, *Pscan_cancel_cfm;

struct scan_cancel_cfm {
    uint8_t status;
};

typedef struct scan_start_cfm scan_start_cfm, *Pscan_start_cfm;

struct scan_start_cfm {
    uint8_t status;
};

typedef enum scan_state_tag {
    SCAN_STATE_MAX=4,
    SCAN_WAIT_BEACON_PROBE_RSP=3,
    SCAN_WAIT_IE_DWNLD=1,
    SCAN_IDLE=0,
    SCAN_WAIT_CHANNEL=2
} scan_state_tag;

typedef enum scan_msg_tag {
    SCAN_START_REQ=2048,
    SCAN_START_CFM=2049,
    SCAN_CANCEL_CFM=2052,
    SCAN_MAX=2054,
    SCAN_CANCEL_REQ=2051,
    SCAN_TIMER=2053,
    SCAN_DONE_IND=2050
} scan_msg_tag;

typedef struct rfc_status_tag rfc_status_tag, *Prfc_status_tag;

struct rfc_status_tag {
    uint32_t pkdet_out_raw:1;
    uint32_t dig_xtal_clk_dbg:1;
    uint32_t clk_ble_16m_dbg:1;
    uint32_t clk_rc_dbg0:1;
    uint32_t clk_adcpow_dbg:1;
    uint32_t clk_fetx_dbg:1;
    uint32_t clk_ferx_dbg:1;
    uint32_t clkpll_postdiv_outclk_dbg:1;
    uint32_t clk_soc_480m_dbg:1;
    uint32_t clk_soc_240m_dbg:1;
    uint32_t clk_soc_192m_dbg:1;
    uint32_t clk_soc_160m_dbg:1;
    uint32_t clk_soc_120m_dbg:1;
    uint32_t clk_soc_96m_dbg:1;
    uint32_t clk_soc_80m_dbg:1;
    uint32_t clk_soc_48m_dbg:1;
    uint32_t clk_soc_32m_dbg:1;
    uint32_t pad_pkdet_out:1;
    uint32_t pad_agc_ctrl:10;
    uint32_t rf_pkdet_rst_hw:1;
    uint32_t rf_cbw_wifi:2;
    uint32_t lo_unlocked:1;
    uint32_t fsm_pu_txbuf:1;
    uint32_t fsm_pu_rxbuf:1;
    uint32_t fsm_pu_tosdac:1;
    uint32_t fsm_pu_dac:1;
    uint32_t fsm_trsw_en:1;
    uint32_t fsm_pu_adc:1;
    uint32_t fsm_pu_pkdet:1;
    uint32_t fsm_pu_rbb:1;
    uint32_t fsm_pu_rmx:1;
    uint32_t fsm_pu_rmxgm:1;
    uint32_t fsm_pu_lna:1;
    uint32_t clk_rc_dbg2:1;
    uint32_t rf_lna_ind_hw:4;
    uint32_t rf_rbb_ind_hw:4;
    uint32_t rf_tx_pow_lvl_hw:4;
    uint32_t rf_rc_lo_rdy:1;
    uint32_t rf_fsm_state:3;
    uint32_t rf_rc_state:3;
    uint32_t clk_rc_dbg:1;
};

typedef struct utils_time_date_t utils_time_date_t, *Putils_time_date_t;

struct utils_time_date_t {
    uchar ntp_hour;
    uchar ntp_minute;
    uchar ntp_second;
    uchar ntp_week_day;
    uchar ntp_date;
    uchar ntp_month;
    uchar leap_days;
    uchar leap_year_ind;
    uint ntp_year;
    uint days_since_epoch;
    uint day_of_year;
};

typedef enum mm_msg_tag.conflict {
    MM_BFMER_ENABLE_REQ=80,
    MM_SECONDARY_TBTT_IND=45,
    MM_DENOISE_REQ=48,
    MM_SET_EDCA_CFM=27,
    MM_SET_P2P_NOA_CFM=83,
    MM_SET_VIF_STATE_CFM=31,
    MM_RESET_CFM=1,
    MM_MU_GROUP_UPDATE_CFM=91,
    MM_REMAIN_ON_CHANNEL_CFM=71,
    MM_BA_DEL_CFM=43,
    MM_CHANNEL_SURVEY_IND=79,
    MM_SET_BEACON_INT_CFM=21,
    MM_SET_SLOTTIME_REQ=32,
    MM_REMOVE_IF_REQ=8,
    MM_RSSI_STATUS_IND=87,
    MM_SET_PS_MODE_CFM=50,
    MM_SET_BSSID_CFM=25,
    MM_CHAN_CTXT_ADD_REQ=51,
    MM_P2P_NOA_UPD_IND=85,
    MM_SET_IDLE_REQ=34,
    MM_KEY_ADD_REQ=36,
    MM_SET_P2P_OPPPS_CFM=84,
    MM_MONITOR_CFM=93,
    MM_BA_ADD_REQ=40,
    MM_MONITOR_REQ=92,
    MM_CSA_FINISH_IND=88,
    MM_SET_VIF_STATE_REQ=30,
    MM_CONNECTION_LOSS_IND=67,
    MM_SET_BASIC_RATES_REQ=22,
    MM_CHAN_CTXT_DEL_CFM=54,
    MM_CHAN_CTXT_UNLINK_REQ=57,
    MM_START_CFM=3,
    MM_TIM_UPDATE_CFM=66,
    MM_CHAN_CTXT_SCHED_REQ=61,
    MM_CHAN_CTXT_UNLINK_CFM=58,
    MM_P2P_VIF_PS_CHANGE_IND=77,
    MM_SET_POWER_REQ=46,
    MM_SET_DTIM_REQ=18,
    MM_TRAFFIC_REQ_IND=74,
    MM_BA_ADD_CFM=41,
    MM_CHAN_CTXT_UPDATE_REQ=59,
    MM_KEY_DEL_REQ=38,
    MM_SET_PS_OPTIONS_CFM=76,
    MM_SET_BSSID_REQ=24,
    MM_SET_CHANNEL_CFM=17,
    MM_CHANNEL_PRE_SWITCH_IND=69,
    MM_TIM_UPDATE_REQ=65,
    MM_CHANNEL_SWITCH_IND=68,
    MM_MONITOR_CHANNEL_REQ=94,
    MM_SET_BASIC_RATES_CFM=23,
    MM_BCN_CHANGE_REQ=63,
    MM_REMAIN_ON_CHANNEL_EXP_IND=72,
    MM_CHAN_CTXT_DEL_REQ=53,
    MM_STA_ADD_CFM=11,
    MM_PS_CHANGE_IND=73,
    MM_CHAN_CTXT_LINK_CFM=56,
    MM_SET_PS_OPTIONS_REQ=75,
    MM_START_REQ=2,
    MM_SET_MODE_CFM=29,
    MM_VERSION_CFM=5,
    MM_CHAN_CTXT_UPDATE_CFM=60,
    MM_KEY_DEL_CFM=39,
    MM_SET_MODE_REQ=28,
    MM_CHAN_CTXT_SCHED_CFM=62,
    MM_SET_CHANNEL_REQ=16,
    MM_SET_FILTER_CFM=15,
    MM_MONITOR_CHANNEL_CFM=95,
    MM_PRIMARY_TBTT_IND=44,
    MM_SET_POWER_CFM=47,
    MM_STA_DEL_REQ=12,
    MM_ADD_IF_REQ=6,
    MM_CSA_COUNTER_IND=78,
    MM_SET_DTIM_CFM=19,
    MM_STA_ADD_REQ=10,
    MM_CHAN_CTXT_ADD_CFM=52,
    MM_ADD_IF_CFM=7,
    MM_CFG_RSSI_REQ=86,
    MM_RESET_REQ=0,
    MM_BCN_CHANGE_CFM=64,
    MM_REMOVE_IF_CFM=9,
    MM_SET_P2P_NOA_REQ=81,
    MM_REMAIN_ON_CHANNEL_REQ=70,
    MM_CSA_TRAFFIC_IND=89,
    MM_VERSION_REQ=4,
    MM_SET_FILTER_REQ=14,
    MM_STA_DEL_CFM=13,
    MM_SET_EDCA_REQ=26,
    MM_SET_PS_MODE_REQ=49,
    MM_SET_P2P_OPPPS_REQ=82,
    MM_MAX=96,
    MM_MU_GROUP_UPDATE_REQ=90,
    MM_SET_IDLE_CFM=35,
    MM_SET_BEACON_INT_REQ=20,
    MM_SET_SLOTTIME_CFM=33,
    MM_KEY_ADD_CFM=37,
    MM_CHAN_CTXT_LINK_REQ=55,
    MM_BA_DEL_REQ=42
} mm_msg_tag.conflict;

typedef struct mm_set_denoise_req mm_set_denoise_req, *Pmm_set_denoise_req;

struct mm_set_denoise_req {
    u8_l denoise_mode;
};

typedef struct scanu_result_ind scanu_result_ind, *Pscanu_result_ind;

struct scanu_result_ind {
    uint16_t length;
    uint16_t framectrl;
    uint16_t center_freq;
    uint8_t band;
    uint8_t sta_idx;
    uint8_t inst_nbr;
    uint8_t sa[6];
    undefined field_0xf;
    uint32_t tsflo;
    uint32_t tsfhi;
    int8_t rssi;
    int8_t ppm_abs;
    int8_t ppm_rel;
    uint8_t data_rate;
    uint32_t[0] payload;
};

typedef enum tdls_msg_tag {
    TDLS_PEER_TRAFFIC_IND_REQ=3079,
    TDLS_CHAN_SWITCH_REQ=3072,
    TDLS_CHAN_SWITCH_IND=3074,
    TDLS_CANCEL_CHAN_SWITCH_CFM=3077,
    TDLS_PEER_PS_IND=3078,
    TDLS_MAX=3081,
    TDLS_PEER_TRAFFIC_IND_CFM=3080,
    TDLS_CHAN_SWITCH_BASE_IND=3075,
    TDLS_CHAN_SWITCH_CFM=3073,
    TDLS_CANCEL_CHAN_SWITCH_REQ=3076
} tdls_msg_tag;

typedef struct mm_channel_switch_ind mm_channel_switch_ind, *Pmm_channel_switch_ind;

struct mm_channel_switch_ind {
    u8_l chan_index;
    bool_l roc;
    u8_l vif_index;
    bool_l roc_tdls;
};

typedef enum mesh_msg_tag {
    MESH_PATH_UPDATE_CFM=9227,
    MESH_PEER_UPDATE_IND=9229,
    MESH_PEER_UPDATE_NTF=9229,
    MESH_START_CFM=9217,
    MESH_PEER_INFO_REQ=9222,
    MESH_UPDATE_REQ=9220,
    MESH_PATH_UPDATE_REQ=9226,
    MESH_PATH_UPDATE_IND=9230,
    MESH_PROXY_UPDATE_IND=9231,
    MESH_STOP_CFM=9219,
    MESH_PATH_CREATE_CFM=9225,
    MESH_UPDATE_CFM=9221,
    MESH_PEER_INFO_RSP=9223,
    MESH_PROXY_ADD_REQ=9228,
    MESH_START_REQ=9216,
    MESH_STOP_REQ=9218,
    MESH_PATH_CREATE_REQ=9224,
    MESH_MAX=9232
} mesh_msg_tag;

typedef struct adc_ctx adc_ctx, *Padc_ctx;

typedef struct adc_ctx adc_ctx_t;

struct adc_ctx {
    int mode;
    uint32_t * channel_data;
    void * adc_lli;
    int lli_flag;
    uint32_t chan_init_table;
    uint32_t data_size;
    void (* cb)(int, uint32_t *, uint32_t);
};

typedef enum _ClientState {
    CLIENT_STATE_CONNECTED_IDLE=3,
    CLIENT_STATE_CONNECTED_YIELD_IN_PROGRESS=4,
    CLIENT_STATE_DISCONNECTED_ERROR=11,
    CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS=8,
    CLIENT_STATE_PENDING_RECONNECT=13,
    CLIENT_STATE_INVALID=0,
    CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS=7,
    CLIENT_STATE_INITIALIZED=1,
    CLIENT_STATE_DISCONNECTED_MANUALLY=12,
    CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN=9,
    CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS=5,
    CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS=6,
    CLIENT_STATE_CONNECTING=2,
    CLIENT_STATE_DISCONNECTING=10
} _ClientState;

typedef enum _ClientState ClientState;

typedef struct _MessageHandlers _MessageHandlers, *P_MessageHandlers;

typedef struct _Client _Client, *P_Client;

typedef struct _Client AWS_IoT_Client;

typedef struct IoT_Publish_Message_Params IoT_Publish_Message_Params, *PIoT_Publish_Message_Params;

typedef enum QoS {
    QOS1=1,
    QOS0=0
} QoS;

typedef struct _ClientStatus _ClientStatus, *P_ClientStatus;

typedef struct _ClientStatus ClientStatus;

typedef struct _ClientData _ClientData, *P_ClientData;

typedef struct _ClientData ClientData;

typedef struct _IoT_Mutex_t IoT_Mutex_t;

typedef struct IoT_Client_Connect_Params IoT_Client_Connect_Params, *PIoT_Client_Connect_Params;

typedef struct _MessageHandlers MessageHandlers;

typedef enum MQTT_Ver_t {
    MQTT_3_1_1=4
} MQTT_Ver_t;

typedef struct IoT_MQTT_Will_Options IoT_MQTT_Will_Options, *PIoT_MQTT_Will_Options;

struct _MessageHandlers {
    char * topicName;
    uint16_t topicNameLen;
    enum QoS qos;
    undefined field_0x7;
    void (* pApplicationHandler)(AWS_IoT_Client *, char *, uint16_t, struct IoT_Publish_Message_Params *, void *);
    void * pApplicationHandlerData;
};

struct IoT_MQTT_Will_Options {
    char struct_id[4];
    char * pTopicName;
    uint16_t topicNameLen;
    undefined field_0xa;
    undefined field_0xb;
    char * pMessage;
    uint16_t msgLen;
    _Bool isRetained;
    enum QoS qos;
};

struct IoT_Client_Connect_Params {
    char struct_id[4];
    enum MQTT_Ver_t MQTTVersion;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    char * pClientID;
    uint16_t clientIDLen;
    uint16_t keepAliveIntervalInSec;
    _Bool isCleanSession;
    _Bool isWillMsgPresent;
    undefined field_0x12;
    undefined field_0x13;
    struct IoT_MQTT_Will_Options will;
    char * pUsername;
    uint16_t usernameLen;
    undefined field_0x2e;
    undefined field_0x2f;
    char * pPassword;
    uint16_t passwordLen;
    undefined field_0x36;
    undefined field_0x37;
};

struct _ClientData {
    uint16_t nextPacketId;
    undefined field_0x2;
    undefined field_0x3;
    uint32_t packetTimeoutMs;
    uint32_t commandTimeoutMs;
    uint16_t keepAliveInterval;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t currentReconnectWaitInterval;
    uint32_t counterNetworkDisconnected;
    size_t writeBufSize;
    size_t readBufSize;
    size_t readBufIndex;
    uchar writeBuf[512];
    uchar readBuf[512];
    _Bool isBlockOnThreadLockEnabled;
    undefined field_0x425;
    undefined field_0x426;
    undefined field_0x427;
    IoT_Mutex_t state_change_mutex;
    IoT_Mutex_t tls_read_mutex;
    IoT_Mutex_t tls_write_mutex;
    struct IoT_Client_Connect_Params options;
    MessageHandlers messageHandlers[5];
    void (* disconnectHandler)(AWS_IoT_Client *, void *);
    void * disconnectHandlerData;
};

struct IoT_Publish_Message_Params {
    enum QoS qos;
    uint8_t isRetained;
    uint8_t isDup;
    undefined field_0x3;
    uint16_t id;
    undefined field_0x6;
    undefined field_0x7;
    void * payload;
    size_t payloadLen;
};

struct _ClientStatus {
    ClientState clientState;
    _Bool isPingOutstanding;
    _Bool isAutoReconnectEnabled;
};

struct _Client {
    struct Timer pingTimer;
    struct Timer reconnectDelayTimer;
    ClientStatus clientStatus;
    undefined field_0x1b;
    ClientData clientData;
    struct Network networkStack;
};

typedef struct IoT_Client_Init_Params IoT_Client_Init_Params, *PIoT_Client_Init_Params;

struct IoT_Client_Init_Params {
    _Bool enableAutoReconnect;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * pHostURL;
    uint16_t port;
    undefined field_0xa;
    undefined field_0xb;
    char * pRootCALocation;
    char * pDeviceCertLocation;
    char * pDevicePrivateKeyLocation;
    uint32_t mqttPacketTimeout_ms;
    uint32_t mqttCommandTimeout_ms;
    uint32_t tlsHandshakeTimeout_ms;
    _Bool isSSLHostnameVerify;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    void (* disconnectHandler)(AWS_IoT_Client *, void *);
    void * disconnectHandlerData;
    _Bool isBlockOnThreadLockEnabled;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

typedef struct iot_sha256_context iot_sha256_context, *Piot_sha256_context;

struct iot_sha256_context {
    uint32_t total[2];
    uint32_t state[8];
    uchar buffer[64];
    int is224;
};

typedef enum task_mm_cfg {
    TASK_MM_CFG_KEEP_ALIVE_TIME_LAST_RECEIVED=1,
    TASK_MM_CFG_KEEP_ALIVE_PACKET_COUNTER=2,
    TASK_MM_CFG_KEEP_ALIVE_STATUS_ENABLED=0
} task_mm_cfg;

typedef struct anon_struct.conflict181dab anon_struct.conflict181dab, *Panon_struct.conflict181dab;

struct anon_struct.conflict181dab {
    uint inArg:1;
    uint inQuote:1;
    uint done:1;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
};

typedef int ptrdiff_t;

typedef struct cli_command cli_command, *Pcli_command;

struct cli_command {
    char * name;
    char * help;
    void (* function)(char *, int, int, char * *);
};

typedef struct cli_st cli_st, *Pcli_st;

struct cli_st {
    int initialized;
    int echo_disabled;
    struct cli_command * static_cmds;
    struct cli_command * dynamic_cmds[8];
    uint num_static_cmds;
    uint num_commands;
    uint bp;
    char inbuf[256];
    char * outbuf;
    int his_idx;
    int his_cur;
    char history[256];
};

typedef struct file_ops file_ops, *Pfile_ops;

typedef struct inode_t inode_t, *Pinode_t;

typedef struct file_t file_t, *Pfile_t;

typedef union inode_ops_t inode_ops_t, *Pinode_ops_t;

typedef struct file_ops file_ops_t;

typedef struct fs_ops fs_ops, *Pfs_ops;

typedef struct fs_ops fs_ops_t;

struct file_ops {
    int (* open)(struct inode_t *, struct file_t *);
    int (* close)(struct file_t *);
    ssize_t (* read)(struct file_t *, void *, size_t);
    ssize_t (* write)(struct file_t *, void *, size_t);
    int (* ioctl)(struct file_t *, int, ulong);
    int (* poll)(struct file_t *, _Bool, void (* )(struct pollfd *, void *), struct pollfd *, void *);
    int (* sync)(struct file_t *);
};

union inode_ops_t {
    file_ops_t * i_ops;
    fs_ops_t * i_fops;
};

struct inode_t {
    union inode_ops_t ops;
    void * i_arg;
    char * i_name;
    int i_flags;
    uint8_t type;
    uint8_t refs;
    undefined field_0x12;
    undefined field_0x13;
};

struct fs_ops {
    int (* open)(struct file_t *, char *, int);
    int (* close)(struct file_t *);
    ssize_t (* read)(struct file_t *, char *, size_t);
    ssize_t (* write)(struct file_t *, char *, size_t);
    off_t (* lseek)(struct file_t *, off_t, int);
    int (* sync)(struct file_t *);
    int (* stat)(struct file_t *, char *, struct stat *);
    int (* unlink)(struct file_t *, char *);
    int (* rename)(struct file_t *, char *, char *);
    aos_dir_t * (* opendir)(struct file_t *, char *);
    aos_dirent_t * (* readdir)(struct file_t *, struct aos_dir_t *);
    int (* closedir)(struct file_t *, struct aos_dir_t *);
    int (* mkdir)(struct file_t *, char *);
    int (* rmdir)(struct file_t *, char *);
    void (* rewinddir)(struct file_t *, struct aos_dir_t *);
    long (* telldir)(struct file_t *, struct aos_dir_t *);
    void (* seekdir)(struct file_t *, struct aos_dir_t *, long);
    int (* ioctl)(struct file_t *, int, ulong);
    int (* statfs)(struct file_t *, char *, struct statfs *);
    int (* access)(struct file_t *, char *, int);
};

struct file_t {
    struct inode_t * node;
    void * f_arg;
    size_t offset;
};

typedef struct pmkElement_t pmkElement_t, *PpmkElement_t;

typedef union anon_union.conflicte6b1_for_key anon_union.conflicte6b1_for_key, *Panon_union.conflicte6b1_for_key;

union anon_union.conflicte6b1_for_key {
    IEEEtypes_MacAddr_t Bssid;
    char Ssid[32];
};

struct pmkElement_t {
    union anon_union.conflicte6b1_for_key key;
    UINT8 PMK[32];
    UINT8 length;
    UINT8 psk_length;
    SINT8 replacementRank;
};

typedef union anon_union.conflicte6b1 anon_union.conflicte6b1, *Panon_union.conflicte6b1;

union anon_union.conflicte6b1 {
    IEEEtypes_MacAddr_t Bssid;
    char Ssid[32];
};

typedef struct net_device net_device, *Pnet_device;

struct net_device {
    struct bl_hw * bl_hw;
};

typedef struct mm_timer_env_tag mm_timer_env_tag, *Pmm_timer_env_tag;

struct mm_timer_env_tag {
    struct co_list prog;
};

typedef struct rx_swdesc rx_swdesc, *Prx_swdesc;

typedef struct rx_dmadesc rx_dmadesc, *Prx_dmadesc;

typedef struct rx_payloaddesc rx_payloaddesc, *Prx_payloaddesc;

typedef struct rx_hd rx_hd, *Prx_hd;

struct rx_hd {
    uint32_t upatternrx;
    uint32_t next;
    uint32_t first_pbd_ptr;
    struct rx_swdesc * swdesc;
    uint32_t datastartptr;
    uint32_t dataendptr;
    uint32_t headerctrlinfo;
    uint16_t frmlen;
    uint16_t ampdu_stat_info;
    uint32_t tsflo;
    uint32_t tsfhi;
    uint32_t recvec1a;
    uint32_t recvec1b;
    uint32_t recvec1c;
    uint32_t recvec1d;
    uint32_t recvec2a;
    uint32_t recvec2b;
    uint32_t statinfo;
};

struct rx_dmadesc {
    struct rx_hd hd;
    struct phy_channel_info phy_info;
    uint32_t flags;
    uint32_t pattern;
    uint32_t payl_offset;
    uint32_t reserved_pad[2];
    uint32_t use_in_tcpip;
};

struct rx_swdesc {
    struct co_list_hdr list_hdr;
    struct rx_dmadesc * dma_hdrdesc;
    struct rx_payloaddesc * pd;
    struct rx_pbd * last_pbd;
    struct rx_pbd * spare_pbd;
    uint32_t host_id;
    uint32_t frame_len;
    uint8_t status;
    uint8_t pbd_count;
    uint8_t use_in_tcpip;
    undefined field_0x1f;
};

struct rx_payloaddesc {
    struct rx_pbd pbd;
    uint32_t pd_status;
    uint32_t * buffer_rx;
    void * pbuf_holder[6];
};

typedef enum dbg_sev_tag {
    DBG_SEV_IDX_INF=4,
    DBG_SEV_IDX_NONE=0,
    DBG_SEV_ALL=7,
    DBG_SEV_IDX_WRN=3,
    DBG_SEV_IDX_MAX=6,
    DBG_SEV_IDX_CRT=1,
    DBG_SEV_IDX_ERR=2,
    DBG_SEV_IDX_VRB=5
} dbg_sev_tag;

typedef struct debug_env_tag debug_env_tag, *Pdebug_env_tag;

struct debug_env_tag {
    uint32_t filter_module;
    uint32_t filter_severity;
};

typedef enum dbg_mod_tag {
    DBG_MOD_IDX_MAX=8,
    DBG_MOD_IDX_PHY=7,
    DBG_MOD_IDX_MM=4,
    DBG_MOD_IDX_RX=6,
    DBG_MOD_IDX_IPC=2,
    DBG_MOD_IDX_DBG=1,
    DBG_MOD_IDX_TX=5,
    DBG_MOD_IDX_KE=0,
    DBG_MOD_IDX_DMA=3
} dbg_mod_tag;

typedef struct bl_wifi_ap_info bl_wifi_ap_info, *Pbl_wifi_ap_info;

typedef struct bl_wifi_ap_info bl_wifi_ap_info_t;

struct bl_wifi_ap_info {
    uint8_t ssid[33];
    uint8_t psk[65];
    uint8_t chan;
};

typedef enum mbedtls_cipher_padding_t {
    MBEDTLS_PADDING_PKCS7=0,
    MBEDTLS_PADDING_NONE=4,
    MBEDTLS_PADDING_ZEROS=3,
    MBEDTLS_PADDING_ONE_AND_ZEROS=1,
    MBEDTLS_PADDING_ZEROS_AND_LEN=2
} mbedtls_cipher_padding_t;

typedef struct ShadowInitParameters_t ShadowInitParameters_t, *PShadowInitParameters_t;

struct ShadowInitParameters_t {
    char * pHost;
    uint16_t port;
    undefined field_0x6;
    undefined field_0x7;
    char * pRootCA;
    char * pClientCRT;
    char * pClientKey;
    _Bool enableAutoReconnect;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
    void (* disconnectHandler)(AWS_IoT_Client *, void *);
};

typedef enum ShadowActions_t {
    SHADOW_UPDATE=1,
    SHADOW_DELETE=2,
    SHADOW_GET=0
} ShadowActions_t;

typedef struct ShadowConnectParameters_t ShadowConnectParameters_t, *PShadowConnectParameters_t;

struct ShadowConnectParameters_t {
    char * pMyThingName;
    char * pMqttClientId;
    uint16_t mqttClientIdLen;
    undefined field_0xa;
    undefined field_0xb;
    void (* deleteActionHandler)(AWS_IoT_Client *, char *, uint16_t, struct IoT_Publish_Message_Params *, void *);
};

typedef enum Shadow_Ack_Status_t {
    SHADOW_ACK_ACCEPTED=2,
    SHADOW_ACK_TIMEOUT=0,
    SHADOW_ACK_REJECTED=1
} Shadow_Ack_Status_t;

typedef struct anon_struct.conflictcb0a anon_struct.conflictcb0a, *Panon_struct.conflictcb0a;

struct anon_struct.conflictcb0a {
    uint32_t dummy;
    struct txl_frame_desc_tag bcn_desc;
    uint16_t bcn_len;
    uint16_t tim_len;
    uint16_t tim_bitmap_set;
    uint16_t bcn_int;
    uint8_t bcn_tbtt_ratio;
    uint8_t bcn_tbtt_cnt;
    _Bool bcn_configured;
    uint8_t dtim_count;
    uint8_t tim_n1;
    uint8_t tim_n2;
    uint8_t bc_mc_status;
    uint8_t csa_count;
    uint8_t csa_oft[2];
    uint8_t ps_sta_cnt;
    undefined field_0x2ef;
    uint16_t ctrl_port_ethertype;
    undefined field_0x2f2;
    undefined field_0x2f3;
};

typedef struct vif_info_tag vif_info_tag, *Pvif_info_tag;

typedef union anon_union.conflictcc05_for_u anon_union.conflictcc05_for_u, *Panon_union.conflictcc05_for_u;

typedef struct anon_struct.conflictca3d anon_struct.conflictca3d, *Panon_struct.conflictca3d;

struct anon_struct.conflictca3d {
    uint16_t listen_interval;
    _Bool dont_wait_bcmc;
    uint8_t ps_retry;
    uint8_t ap_id;
    undefined field_0x5;
    undefined field_0x6;
    undefined field_0x7;
    uint32_t uapsd_last_rxtx;
    uint8_t uapsd_queues;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
    uint32_t mon_last_tx;
    uint32_t mon_last_crc;
    uint8_t beacon_loss_cnt;
    int8_t rssi;
    int8_t rssi_thold;
    uint8_t rssi_hyst;
    _Bool rssi_status;
    uint8_t csa_count;
    _Bool csa_occured;
    undefined field_0x1f;
};

union anon_union.conflictcc05_for_u {
    struct anon_struct.conflictca3d sta;
    struct anon_struct.conflictcb0a ap;
};

struct vif_info_tag {
    struct co_list_hdr list_hdr;
    uint32_t prevent_sleep;
    uint32_t txq_params[4];
    struct mm_timer_tag tbtt_timer;
    struct mm_timer_tag tmr_bcn_to;
    struct mac_addr bssid;
    undefined field_0x3e;
    undefined field_0x3f;
    struct chan_ctxt_tag * chan_ctxt;
    struct chan_tbtt_tag tbtt_switch;
    struct mac_addr mac_addr;
    uint8_t type;
    uint8_t index;
    _Bool active;
    int8_t tx_power;
    int8_t user_tx_power;
    undefined field_0x5b;
    union anon_union.conflictcc05_for_u u;
    struct co_list sta_list;
    struct mac_bss_info bss_info;
    undefined field_0x41c;
    undefined field_0x41d;
    undefined field_0x41e;
    undefined field_0x41f;
    struct key_info_tag key_info[4];
    struct key_info_tag * default_key;
    uint32_t flags;
    struct mm_chan_ctxt_add_req csa_channel;
    undefined field_0x5d2;
    undefined field_0x5d3;
    undefined field_0x5d4;
    undefined field_0x5d5;
    undefined field_0x5d6;
    undefined field_0x5d7;
};

typedef struct vif_mgmt_env_tag vif_mgmt_env_tag, *Pvif_mgmt_env_tag;

struct vif_mgmt_env_tag {
    struct co_list free_list;
    struct co_list used_list;
    uint8_t vif_sta_cnt;
    uint8_t vif_ap_cnt;
    uint8_t low_bcn_int_idx;
    undefined field_0x13;
};

typedef enum VIF_AP_BCMC_STATUS {
    VIF_AP_BCMC_MOREDATA=2,
    VIF_AP_BCMC_BUFFERED=1
} VIF_AP_BCMC_STATUS;

typedef union anon_union.conflictcc05 anon_union.conflictcc05, *Panon_union.conflictcc05;

union anon_union.conflictcc05 {
    struct anon_struct.conflictca3d sta;
    struct anon_struct.conflictcb0a ap;
};

typedef struct tcpip_msg tcpip_msg, *Ptcpip_msg;

typedef enum tcpip_msg_type {
    TCPIP_MSG_API_CALL=1,
    TCPIP_MSG_CALLBACK_STATIC=4,
    TCPIP_MSG_CALLBACK=3,
    TCPIP_MSG_API=0,
    TCPIP_MSG_INPKT=2
} tcpip_msg_type;

typedef union anon_union.conflict1cd63e_for_msg anon_union.conflict1cd63e_for_msg, *Panon_union.conflict1cd63e_for_msg;

typedef struct anon_struct.conflict1cd590 anon_struct.conflict1cd590, *Panon_struct.conflict1cd590;

typedef struct anon_struct.conflict1cd5b4 anon_struct.conflict1cd5b4, *Panon_struct.conflict1cd5b4;

typedef struct anon_struct.conflict1cd5eb anon_struct.conflict1cd5eb, *Panon_struct.conflict1cd5eb;

typedef void (* tcpip_callback_fn)(void *);

struct anon_struct.conflict1cd5b4 {
    err_t (* function)(struct tcpip_api_call_data *);
    struct tcpip_api_call_data * arg;
    sys_sem_t * sem;
};

struct anon_struct.conflict1cd590 {
    tcpip_callback_fn function;
    void * msg;
};

struct anon_struct.conflict1cd5eb {
    struct pbuf * p;
    struct netif * netif;
    err_t (* input_fn)(struct pbuf *, struct netif *);
};

union anon_union.conflict1cd63e_for_msg {
    struct anon_struct.conflict1cd590 api_msg;
    struct anon_struct.conflict1cd5b4 api_call;
    struct anon_struct.conflict1cd5eb inp;
    struct anon_struct.conflict1cd590 cb;
};

struct tcpip_msg {
    enum tcpip_msg_type type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    union anon_union.conflict1cd63e_for_msg msg;
};

typedef union anon_union.conflict1cd63e anon_union.conflict1cd63e, *Panon_union.conflict1cd63e;

union anon_union.conflict1cd63e {
    struct anon_struct.conflict1cd590 api_msg;
    struct anon_struct.conflict1cd5b4 api_call;
    struct anon_struct.conflict1cd5eb inp;
    struct anon_struct.conflict1cd590 cb;
};

typedef struct IEEEtypes_InfoElementHdr_t IEEEtypes_InfoElementHdr_t, *PIEEEtypes_InfoElementHdr_t;

struct IEEEtypes_InfoElementHdr_t {
    enum IEEEtypes_ElementId_e ElementId;
    IEEEtypes_Len_t Len;
};

typedef struct IEEEtypes_WPAElement_t IEEEtypes_WPAElement_t, *PIEEEtypes_WPAElement_t;

struct IEEEtypes_WPAElement_t {
    enum IEEEtypes_ElementId_e ElementId;
    IEEEtypes_Len_t Len;
    UINT8 OuiType[4];
    UINT16 Ver;
    UINT8 GrpKeyCipher[4];
    UINT16 PwsKeyCnt;
    UINT8 PwsKeyCipherList[4];
    UINT16 AuthKeyCnt;
    UINT8 AuthKeyList[4];
};

typedef enum IEEEtypes_KDEDataType_e {
    KDE_DATA_TYPE_MACADDR=3,
    KDE_DATA_TYPE_SMK=5,
    KDE_DATA_TYPE_LIFETIME=7,
    KDE_DATA_TYPE_ERROR=8,
    KDE_DATA_TYPE_GTK=1,
    KDE_DATA_TYPE_IGTK=9,
    KDE_DATA_TYPE_RESERVED2=2,
    KDE_DATA_TYPE_PMKID=4,
    KDE_DATA_TYPE_RESERVED=0,
    KDE_DATA_TYPE_NONCE=6
} IEEEtypes_KDEDataType_e;

typedef struct IEEEtypes_RSNElement_t IEEEtypes_RSNElement_t, *PIEEEtypes_RSNElement_t;

struct IEEEtypes_RSNElement_t {
    enum IEEEtypes_ElementId_e ElementId;
    IEEEtypes_Len_t Len;
    UINT16 Ver;
    UINT8 GrpKeyCipher[4];
    UINT16 PwsKeyCnt;
    UINT8 PwsKeyCipherList[4];
    UINT16 AuthKeyCnt;
    UINT8 AuthKeyList[4];
    struct IEEEtypes_RSNCapability_t RsnCap;
    UINT16 PMKIDCnt;
    UINT8 PMKIDList[16];
    UINT8 GrpMgmtCipher[4];
};

typedef struct dns_ans_ans dns_ans_ans, *Pdns_ans_ans;

struct dns_ans_ans {
    uint16_t typ;
    uint16_t cls;
    uint16_t point;
    uint16_t antyp;
    uint16_t antypp;
    uint16_t len;
    uint32_t time;
    uint32_t addr;
};

typedef struct dns_ans_hdr dns_ans_hdr, *Pdns_ans_hdr;

struct dns_ans_hdr {
    uint16_t id;
    uint16_t flag;
    uint16_t numquestions;
    uint16_t numanswers;
    uint16_t numauthrr;
    uint16_t numextrarr;
};

typedef struct dns_server_ctx dns_server_ctx, *Pdns_server_ctx;

struct dns_server_ctx {
    uint8_t name[256];
    uint16_t txid;
    uint16_t nquestions;
    uint16_t nanswers;
    undefined field_0x106;
    undefined field_0x107;
    struct udp_pcb * upcb1;
    ip_addr_t * addr1;
    u16_t port1;
    undefined field_0x112;
    undefined field_0x113;
};

typedef struct dns_table_entry dns_table_entry, *Pdns_table_entry;

struct dns_table_entry {
    uint16_t txid;
    uint16_t flags;
    uint16_t numque;
    uint16_t ansrrs;
    uint16_t autrrs;
    uint16_t addrrs;
    uint16_t type;
    uint16_t class;
    uint16_t poiname;
    uint16_t anstype;
    uint16_t anstypee;
    uint16_t datalen;
    uint32_t anstime;
    uint32_t adress;
};

typedef struct _bl_wifi_env _bl_wifi_env, *P_bl_wifi_env;

struct _bl_wifi_env {
    uint8_t sta_mac_addr_board[6];
    uint8_t sta_mac_addr_usr[6];
    uint8_t ap_mac_addr_board[6];
    uint8_t ap_mac_addr_usr[6];
    uint8_t country_code;
    bl_wifi_ap_info_t ap_info;
    uint8_t ap_info_en;
    bl_wifi_ap_info_t sta_info;
    uint8_t sta_info_en;
};

typedef struct _bl_wifi_env bl_wifi_env_t;

typedef struct dhcp_server dhcp_server, *Pdhcp_server;

typedef struct dhcp_client_node dhcp_client_node, *Pdhcp_client_node;

struct dhcp_server {
    struct dhcp_server * next;
    struct netif * netif;
    struct udp_pcb * pcb;
    struct dhcp_client_node * node_list;
    ip4_addr_t start;
    ip4_addr_t end;
    ip4_addr_t current;
};

struct dhcp_client_node {
    struct dhcp_client_node * next;
    u8_t chaddr[6];
    undefined field_0xa;
    undefined field_0xb;
    ip4_addr_t ipaddr;
    u32_t lease_end;
};

typedef struct tsen_reload_data tsen_reload_data, *Ptsen_reload_data;

typedef struct tsen_reload_data tsen_reload_data_t;

typedef StaticTimer_t os_timer_t;

struct tsen_reload_data {
    char name[32];
    os_timer_t timer;
};

typedef struct disconnectData disconnectData, *PdisconnectData;

typedef struct wifi_mgmr_profile_msg wifi_mgmr_profile_msg, *Pwifi_mgmr_profile_msg;

typedef struct wifi_mgmr_profile_msg wifi_mgmr_profile_msg_t;

struct wifi_mgmr_profile_msg {
    char ssid[32];
    char ssid_tail[1];
    uint32_t ssid_len;
    char psk[64];
    char psk_tail[1];
    char pmk[64];
    char pmk_tail[1];
    uint32_t psk_len;
    uint32_t pmk_len;
    uint8_t mac[6];
    uint8_t band;
    uint16_t freq;
    uint8_t dhcp_use;
};

struct disconnectData {
    char name[32];
    os_timer_t timer;
    uint8_t timer_started;
    wifi_mgmr_profile_msg_t profile_msg;
    undefined field_0x106;
    undefined field_0x107;
};

typedef struct connectedIPNoData connectedIPNoData, *PconnectedIPNoData;

typedef struct connectedIPNoData connectedIPNoData_t;

struct connectedIPNoData {
    char name[32];
    os_timer_t timer;
};

typedef struct disconnectData disconnectData_t;

typedef enum ps_dpsm_state_bit_pos {
    PS_DPSM_STATE_RESUMING=2,
    PS_DPSM_STATE_SET_MODE_REQ=4,
    PS_DPSM_STATE_ON=0,
    PS_DPSM_STATE_PAUSING=1,
    PS_DPSM_STATE_PAUSE=3
} ps_dpsm_state_bit_pos;

typedef struct ps_env_tag ps_env_tag, *Pps_env_tag;

struct ps_env_tag {
    _Bool ps_on;
    undefined field_0x1;
    ke_task_id_t taskid;
    uint32_t prevent_sleep;
    uint8_t cfm_cnt;
    undefined field_0x9;
    undefined field_0xa;
    undefined field_0xb;
    struct mm_timer_tag uapsd_timer;
    _Bool uapsd_tmr_on;
    _Bool uapsd_on;
    undefined field_0x1e;
    undefined field_0x1f;
    uint32_t uapsd_timeout;
    uint8_t dpsm_state;
    uint8_t next_mode;
    undefined field_0x26;
    undefined field_0x27;
};

typedef struct mbedtls_oid_descriptor_t mbedtls_oid_descriptor_t, *Pmbedtls_oid_descriptor_t;

struct mbedtls_oid_descriptor_t {
    char * asn1;
    size_t asn1_len;
    char * name;
    char * description;
};

typedef void (* tcp_err_fn.conflict)(void *, err_t);

typedef struct HeapRegion HeapRegion, *PHeapRegion;

struct HeapRegion {
    uint8_t * pucStartAddress;
    size_t xSizeInBytes;
};

typedef struct HeapRegion HeapRegion_t;

typedef struct _IEEEtypes_Wpa_t _IEEEtypes_Wpa_t, *P_IEEEtypes_Wpa_t;

typedef struct _IEEEtypes_Wpa_t IEEEtypes_Wpa_t;

typedef struct _wpa_suite_t _wpa_suite_t, *P_wpa_suite_t;

typedef struct _wpa_suite_t wpa_suite_mcast_t;

typedef struct anon_struct.conflict943c6 anon_struct.conflict943c6, *Panon_struct.conflict943c6;

typedef struct anon_struct.conflict943c6 wpa_suite_ucast_t;

typedef struct anon_struct.conflict943c6 wpa_suite_auth_key_mgmt_t;

typedef struct _wpa_suite_t wpa_suite;

struct _wpa_suite_t {
    uint8_t oui[3];
    uint8_t type;
};

struct anon_struct.conflict943c6 {
    uint16_t count;
    wpa_suite list[2];
};

struct _IEEEtypes_Wpa_t {
    uint8_t element_id;
    uint8_t len;
    uint8_t oui[4];
    uint16_t version;
    wpa_suite_mcast_t group_cipher;
    wpa_suite_ucast_t pairwise_cipher;
    wpa_suite_auth_key_mgmt_t auth_key_mgmt;
};

typedef struct _IEEEtypes_Rsn_t _IEEEtypes_Rsn_t, *P_IEEEtypes_Rsn_t;

typedef struct _IEEEtypes_Rsn_t IEEEtypes_Rsn_t;

struct _IEEEtypes_Rsn_t {
    uint8_t element_id;
    uint8_t len;
    uint16_t version;
    wpa_suite_mcast_t group_cipher;
    wpa_suite_ucast_t pairwise_cipher;
    wpa_suite_auth_key_mgmt_t auth_key_mgmt;
};

typedef struct UDP_datagram UDP_datagram, *PUDP_datagram;

struct UDP_datagram {
    uint32_t id;
    uint32_t tv_sec;
    uint32_t tv_usec;
};

typedef struct iperf_server_udp_ctx iperf_server_udp_ctx, *Piperf_server_udp_ctx;

struct iperf_server_udp_ctx {
    int exit_flag;
    uint32_t datagram_cnt;
    int32_t packet_id;
    uint32_t out_of_order_cnt;
    uint32_t error_cnt;
    uint32_t out_of_order_curr;
    uint32_t receive_start;
    uint32_t period_start;
    uint32_t current;
    undefined field_0x24;
    undefined field_0x25;
    undefined field_0x26;
    undefined field_0x27;
    uint64_t recv_total_len;
    uint64_t recv_now;
    float f_min;
    float f_max;
};

typedef struct server_hdr_v1 server_hdr_v1, *Pserver_hdr_v1;

struct server_hdr_v1 {
    int32_t flags;
    int32_t total_len1;
    int32_t total_len2;
    int32_t stop_sec;
    int32_t stop_usec;
    int32_t error_cnt;
    int32_t outorder_cnt;
    int32_t datagrams;
    int32_t jitter1;
    int32_t jitter2;
};

typedef struct server_hdr_v1 server_hdr;

typedef struct bam_baw bam_baw, *Pbam_baw;

struct bam_baw {
    uint (* idx_compute)(struct bam_baw *, uint);
    uint16_t fsn;
    uint8_t states[64];
    uint8_t fsn_idx;
    uint8_t buf_size;
    uint8_t mask;
    undefined field_0x49;
    undefined field_0x4a;
    undefined field_0x4b;
};

typedef struct bam_env_tag bam_env_tag, *Pbam_env_tag;

struct bam_env_tag {
    uint32_t pkt_cnt;
    uint32_t last_activity_time;
    uint16_t ssn;
    uint16_t ba_timeout;
    uint8_t sta_idx;
    uint8_t dev_type;
    uint8_t ba_policy;
    uint8_t buffer_size;
    uint8_t tid;
    uint8_t dialog_token;
    uint8_t amsdu;
    uint8_t delba_count;
    struct bam_baw baw;
};

typedef struct cm_ConnectionInfo cm_ConnectionInfo_t;

typedef union anon_union.conflictedae anon_union.conflictedae, *Panon_union.conflictedae;

union anon_union.conflictedae {
    struct apSpecificData_t apData;
};

typedef struct wifi_ap_data_rate wifi_ap_data_rate, *Pwifi_ap_data_rate;

struct wifi_ap_data_rate {
    uint8_t data_rate;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    char * val;
};

typedef uintptr_t mem_ptr_t;

typedef uint64_t u64_t;

typedef struct rc4_key rc4_key, *Prc4_key;

struct rc4_key {
    uchar state[256];
    uchar x;
    uchar y;
};

typedef void (* netif_status_callback_fn.conflict)(struct netif *);

typedef enum lwip_internal_netif_client_data_index {
    LWIP_NETIF_CLIENT_DATA_INDEX_MAX=2,
    LWIP_NETIF_CLIENT_DATA_INDEX_DHCP=0,
    LWIP_NETIF_CLIENT_DATA_INDEX_IGMP=1
} lwip_internal_netif_client_data_index;

typedef u8_t netif_addr_idx_t;

typedef struct me_set_ps_disable_req me_set_ps_disable_req, *Pme_set_ps_disable_req;

struct me_set_ps_disable_req {
    _Bool ps_disable;
    uint8_t vif_idx;
};

typedef struct me_rc_stats_cfm me_rc_stats_cfm, *Pme_rc_stats_cfm;

struct me_rc_stats_cfm {
    uint8_t sta_idx;
    undefined field_0x1;
    uint16_t no_samples;
    uint16_t ampdu_len;
    uint16_t ampdu_packets;
    uint32_t avg_ampdu_len;
    uint8_t sw_retry_step;
    uint8_t sample_wait;
    undefined field_0xe;
    undefined field_0xf;
    struct step retry[4];
    struct rc_rate_stats rate_stats[10];
    uint32_t tp[10];
};

typedef struct me_set_control_port_req me_set_control_port_req, *Pme_set_control_port_req;

struct me_set_control_port_req {
    uint8_t sta_idx;
    _Bool control_port_open;
};

typedef struct me_sta_del_req me_sta_del_req, *Pme_sta_del_req;

struct me_sta_del_req {
    uint8_t sta_idx;
    _Bool tdls_sta;
};

typedef struct me_traffic_ind_req me_traffic_ind_req, *Pme_traffic_ind_req;

struct me_traffic_ind_req {
    uint8_t sta_idx;
    uint8_t tx_avail;
    _Bool uapsd;
};

typedef struct me_set_active_req me_set_active_req, *Pme_set_active_req;

struct me_set_active_req {
    _Bool active;
    uint8_t vif_idx;
};

typedef struct me_sta_add_cfm me_sta_add_cfm, *Pme_sta_add_cfm;

struct me_sta_add_cfm {
    uint8_t sta_idx;
    uint8_t status;
    uint8_t pm_state;
};

typedef struct me_rc_stats_req me_rc_stats_req, *Pme_rc_stats_req;

struct me_rc_stats_req {
    uint8_t sta_idx;
};

typedef struct me_tkip_mic_failure_ind me_tkip_mic_failure_ind, *Pme_tkip_mic_failure_ind;

struct me_tkip_mic_failure_ind {
    struct mac_addr addr;
    undefined field_0x6;
    undefined field_0x7;
    uint64_t tsc;
    _Bool ga;
    uint8_t keyid;
    uint8_t vif_idx;
    undefined field_0x13;
    undefined field_0x14;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct me_rc_set_rate_req me_rc_set_rate_req, *Pme_rc_set_rate_req;

struct me_rc_set_rate_req {
    uint8_t sta_idx;
    undefined field_0x1;
    uint16_t fixed_rate_cfg;
};

typedef struct me_sta_add_req me_sta_add_req, *Pme_sta_add_req;

struct me_sta_add_req {
    struct mac_addr mac_addr;
    struct mac_rateset rate_set;
    undefined field_0x13;
    struct mac_htcapability ht_cap;
    struct mac_vhtcapability vht_cap;
    uint32_t flags;
    uint16_t aid;
    uint8_t uapsd_queues;
    uint8_t max_sp_len;
    uint8_t opmode;
    uint8_t vif_idx;
    _Bool tdls_sta;
    undefined field_0x4b;
    uint32_t tsflo;
    uint32_t tsfhi;
    int8_t rssi;
    uint8_t data_rate;
    undefined field_0x56;
    undefined field_0x57;
};

typedef struct me_config_req me_config_req, *Pme_config_req;

struct me_config_req {
    struct mac_htcapability ht_cap;
    struct mac_vhtcapability vht_cap;
    uint16_t tx_lft;
    _Bool ht_supp;
    _Bool vht_supp;
    _Bool ps_on;
    undefined field_0x31;
    undefined field_0x32;
    undefined field_0x33;
};

typedef longlong __int64_t;

typedef __int64_t int64_t;

typedef int __intptr_t;

typedef __intptr_t intptr_t;

typedef struct wifi_mgmr wifi_mgmr, *Pwifi_mgmr;

typedef struct wifi_mgmr wifi_mgmr_t;

typedef struct wlan_netif wlan_netif, *Pwlan_netif;

typedef enum WIFI_MGMR_CONNECTION_STATUS {
    WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_NO=3,
    WIFI_MGMR_CONNECTION_STATUS_CONNECTING=1,
    WIFI_MGMR_CONNECTION_STATUS_DISCONNECTED=4,
    WIFI_MGMR_CONNECTION_STATUS_IDLE=0,
    WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_YES=2
} WIFI_MGMR_CONNECTION_STATUS;

typedef enum WIFI_MGMR_CONNECTION_STATUS WIFI_MGMR_CONNECTION_STATUS_T;

typedef struct wifi_mgmr_profile wifi_mgmr_profile, *Pwifi_mgmr_profile;

typedef struct wifi_mgmr_profile wifi_mgmr_profile_t;

typedef struct wifi_mgmr_scan_item wifi_mgmr_scan_item, *Pwifi_mgmr_scan_item;

typedef struct wifi_mgmr_scan_item wifi_mgmr_scan_item_t;

typedef StaticMessageBuffer_t os_messagequeue_t;

typedef struct wifi_mgmr_connect_ind_stat_info wifi_mgmr_connect_ind_stat_info, *Pwifi_mgmr_connect_ind_stat_info;

typedef struct wifi_mgmr_connect_ind_stat_info wifi_mgmr_connect_ind_stat_info_t;

typedef struct anon_struct.conflict156399_for_ipv4 anon_struct.conflict156399_for_ipv4, *Panon_struct.conflict156399_for_ipv4;

typedef union anon_union.conflict1563f9_for_field_5 anon_union.conflict1563f9_for_field_5, *Panon_union.conflict1563f9_for_field_5;

typedef struct anon_struct.conflict1563e2 anon_struct.conflict1563e2, *Panon_struct.conflict1563e2;

struct wifi_mgmr_connect_ind_stat_info {
    uint16_t status_code;
    uint8_t type_ind;
    char ssid[32];
    char psk[65];
    uint8_t bssid[6];
    uint16_t chan_freq;
    uint8_t chan_band;
    undefined field_0x6d;
};

struct wifi_mgmr_profile {
    char ssid[33];
    uint8_t no_autoconnect;
    undefined field_0x22;
    undefined field_0x23;
    uint32_t ssid_len;
    char psk[65];
    undefined field_0x69;
    undefined field_0x6a;
    undefined field_0x6b;
    uint32_t psk_len;
    char pmk[65];
    undefined field_0xb1;
    undefined field_0xb2;
    undefined field_0xb3;
    uint32_t pmk_len;
    uint8_t mac[6];
    uint8_t dhcp_use;
    uint8_t priority;
    uint8_t isActive;
    uint8_t isUsed;
    undefined field_0xc2;
    undefined field_0xc3;
};

struct anon_struct.conflict1563e2 {
    int8_t rssi;
};

struct anon_struct.conflict156399_for_ipv4 {
    uint32_t ip;
    uint32_t mask;
    uint32_t gw;
    uint32_t dns1;
    uint32_t dns2;
};

union anon_union.conflict1563f9_for_field_5 {
    struct anon_struct.conflict1563e2 sta;
};

struct wlan_netif {
    int mode;
    uint8_t vif_index;
    uint8_t mac[6];
    undefined field_0xb;
    struct anon_struct.conflict156399_for_ipv4 ipv4;
    struct netif netif;
    union anon_union.conflict1563f9_for_field_5 field_5;
    undefined field_0x6d;
    undefined field_0x6e;
    undefined field_0x6f;
};

struct wifi_mgmr_scan_item {
    char ssid[32];
    char ssid_tail[1];
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
    uint32_t ssid_len;
    uint8_t bssid[6];
    uint8_t channel;
    int8_t rssi;
    int8_t ppm_abs;
    int8_t ppm_rel;
    uint8_t auth;
    uint8_t cipher;
    uint8_t is_used;
    undefined field_0x35;
    undefined field_0x36;
    undefined field_0x37;
    uint32_t timestamp_lastseen;
};

struct wifi_mgmr {
    uint8_t ready;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int channel;
    int inf_ap_enabled;
    struct wlan_netif wlan_sta;
    struct wlan_netif wlan_ap;
    WIFI_MGMR_CONNECTION_STATUS_T status;
    undefined field_0xed;
    undefined field_0xee;
    undefined field_0xef;
    wifi_mgmr_profile_t profiles[2];
    int profile_active_index;
    wifi_mgmr_scan_item_t scan_items[50];
    os_messagequeue_t mq;
    uint8_t mq_pool[2240];
    struct stateMachine m;
    os_timer_t timer;
    wifi_mgmr_connect_ind_stat_info_t wifi_mgmr_stat_info;
    char country_code[3];
    uint8_t disable_autoreconnect;
    undefined field_0x17c2;
    undefined field_0x17c3;
    int channel_nums;
    uint32_t pending_task;
    uint32_t features;
    int scan_item_timeout;
};

typedef enum EVENT_TYPE {
    EVENT_TYPE_APP=1,
    EVENT_TYPE_FW=0,
    EVENT_TYPE_GLB=2
} EVENT_TYPE;

typedef union anon_union.conflict1563f9 anon_union.conflict1563f9, *Panon_union.conflict1563f9;

union anon_union.conflict1563f9 {
    struct anon_struct.conflict1563e2 sta;
};

typedef struct wifi_mgmr_sta_basic_info wifi_mgmr_sta_basic_info, *Pwifi_mgmr_sta_basic_info;

typedef struct wifi_mgmr_sta_basic_info wifi_mgmr_sta_basic_info_t;

struct wifi_mgmr_sta_basic_info {
    uint8_t sta_idx;
    uint8_t is_used;
    uint8_t sta_mac[6];
    uint32_t tsfhi;
    uint32_t tsflo;
    int rssi;
    uint8_t data_rate;
    undefined field_0x15;
    undefined field_0x16;
    undefined field_0x17;
};

typedef struct wifi_mgmr_cfg_element_msg wifi_mgmr_cfg_element_msg, *Pwifi_mgmr_cfg_element_msg;

struct wifi_mgmr_cfg_element_msg {
    uint32_t ops;
    uint32_t task;
    uint32_t element;
    uint32_t type;
    uint32_t length;
    uint32_t[0] buf;
};

typedef enum WIFI_MGMR_EVENT {
    WIFI_MGMR_EVENT_APP_SNIFFER=2,
    WIFI_MGMR_EVENT_MAXAPP_MINIFW=14,
    WIFI_MGMR_EVENT_GLB_AP_IND_STA_DEL=27,
    WIFI_MGMR_EVENT_APP_CONNECTED=3,
    WIFI_MGMR_EVENT_APP_CONNECT=1,
    WIFI_MGMR_EVENT_APP_RC_CONFIG=11,
    WIFI_MGMR_EVENT_APP_IP_GOT=4,
    WIFI_MGMR_EVENT_APP_DENOISE=12,
    WIFI_MGMR_EVENT_FW_CHANNEL_SET=17,
    WIFI_MGMR_EVENT_MAXFW_MINI_GLOBAL=23,
    WIFI_MGMR_EVENT_FW_DATA_RAW_SEND=21,
    WIFI_MGMR_EVENT_FW_IND_DISCONNECT=19,
    WIFI_MGMR_EVENT_FW_CFG_REQ=22,
    WIFI_MGMR_EVENT_APP_CONF_MAX_STA=10,
    WIFI_MGMR_EVENT_APP_AP_STOP=9,
    WIFI_MGMR_EVENT_APP_RELOAD_TSEN=13,
    WIFI_MGMR_EVENT_APP_PHY_UP=7,
    WIFI_MGMR_EVENT_FW_SCAN=18,
    WIFI_MGMR_EVENT_APP_DISCONNECT=5,
    WIFI_MGMR_EVENT_FW_IND_CONNECTED=20,
    WIFI_MGMR_EVENT_FW_DISCONNECT=15,
    WIFI_MGMR_EVENT_GLB_IP_UPDATE=30,
    WIFI_MGMR_EVENT_FW_POWERSAVING=16,
    WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON=24,
    WIFI_MGMR_EVENT_GLB_AP_IND_STA_NEW=26,
    WIFI_MGMR_EVENT_GLB_SCAN_IND_PROBE_RESP=25,
    WIFI_MGMR_EVENT_APP_IDLE=0,
    WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT=28,
    WIFI_MGMR_EVENT_APP_RECONNECT=6,
    WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT=29,
    WIFI_MGMR_EVENT_APP_AP_START=8
} WIFI_MGMR_EVENT;

typedef struct wifi_mgmr_msg wifi_mgmr_msg, *Pwifi_mgmr_msg;

typedef enum WIFI_MGMR_EVENT WIFI_MGMR_EVENT_T;

struct wifi_mgmr_msg {
    WIFI_MGMR_EVENT_T ev;
    void * data1;
    void * data2;
    uint32_t len;
    uint8_t[0] data;
};

typedef struct anon_struct.conflict156399 anon_struct.conflict156399, *Panon_struct.conflict156399;

struct anon_struct.conflict156399 {
    uint32_t ip;
    uint32_t mask;
    uint32_t gw;
    uint32_t dns1;
    uint32_t dns2;
};

typedef struct wifi_mgmr_ipgot_msg wifi_mgmr_ipgot_msg, *Pwifi_mgmr_ipgot_msg;

struct wifi_mgmr_ipgot_msg {
    uint32_t ip;
    uint32_t mask;
    uint32_t gw;
    uint32_t dns1;
    uint32_t dns2;
};

typedef struct wifi_mgmr_ap_msg wifi_mgmr_ap_msg, *Pwifi_mgmr_ap_msg;

struct wifi_mgmr_ap_msg {
    int32_t channel;
    char ssid[32];
    char ssid_tail[1];
    uint8_t hidden_ssid;
    uint32_t ssid_len;
    char psk[64];
    char psk_tail[1];
    uint32_t psk_len;
};

typedef struct wifi_mgmr_msg wifi_mgmr_msg_t;

typedef struct wifi_mgmr_ap_msg wifi_mgmr_ap_msg_t;

typedef struct wifi_mgmr_cfg_element_msg wifi_mgmr_cfg_element_msg_t;

typedef struct wifi_mgmr_ipgot_msg wifi_mgmr_ipgot_msg_t;

typedef struct mm_bcn_env_tag mm_bcn_env_tag, *Pmm_bcn_env_tag;

struct mm_bcn_env_tag {
    struct mm_bcn_change_req * param;
    int tx_cfm;
    _Bool tx_pending;
    _Bool update_ongoing;
    _Bool update_pending;
    undefined field_0xb;
    struct hal_dma_desc_tag dma;
    struct co_list tim_list;
};

typedef struct loop_evt_handler_holder loop_evt_handler_holder, *Ploop_evt_handler_holder;

typedef struct led_trigger_ctx led_trigger_ctx, *Pled_trigger_ctx;

struct loop_evt_handler_holder {
    struct loop_evt_handler handler;
    struct led_trigger_ctx * ctx;
};

struct led_trigger_ctx {
    utils_dlist_t trigger_queue;
    utils_dlist_t waiting_queue;
};

typedef struct led_trigger_item led_trigger_item, *Pled_trigger_item;

struct led_trigger_item {
    utils_dlist_t dlist_item;
    struct loop_timer timer;
    int type;
    int pin;
    int active;
    int current_val;
};

typedef union anon_union.conflict311 anon_union.conflict311, *Panon_union.conflict311;

union anon_union.conflict311 {
    wint_t __wch;
    uchar __wchb[4];
};

typedef struct rijndael_ctx rijndael_ctx, *Prijndael_ctx;

typedef uint u32;

struct rijndael_ctx {
    int decrypt;
    int Nr;
    u32 key[60];
};

typedef struct rf_para_flash_tag rf_para_flash_tag, *Prf_para_flash_tag;

typedef struct rf_para_flash_tag rf_para_flash_t;

struct rf_para_flash_tag {
    uint32_t magic;
    uint8_t capcode_valid;
    uint8_t capcode;
    uint8_t poweroffset_valid;
    int8_t poweroffset[3];
    uint8_t mac_valid;
    uint8_t mac[6];
    uint8_t rsvd[3];
    uint32_t crc32;
};

typedef struct anon_struct.conflict34e5c anon_struct.conflict34e5c, *Panon_struct.conflict34e5c;

typedef struct rf_calib1_tag rf_calib1_tag, *Prf_calib1_tag;

typedef struct rf_calib2_tag rf_calib2_tag, *Prf_calib2_tag;

typedef struct rf_calib3_tag rf_calib3_tag, *Prf_calib3_tag;

typedef struct rf_calib4_tag rf_calib4_tag, *Prf_calib4_tag;

struct rf_calib3_tag {
    uint32_t rosdac_i:6;
    uint32_t rosdac_q:6;
    uint32_t rx_iq_gain_comp:11;
    undefined field_0x3;
    uint32_t rx_iq_phase_comp:10;
    undefined field_0x6;
    undefined field_0x7;
};

struct rf_calib2_tag {
    uint16_t fcal:8;
    uint16_t acal:5;
};

struct rf_calib4_tag {
    uint32_t tosdac_i:6;
    uint32_t tosdac_q:6;
    uint32_t tx_iq_gain_comp:11;
    undefined field_0x3;
    uint32_t tx_iq_phase_comp:10;
    undefined field_0x6;
    undefined field_0x7;
};

struct rf_calib1_tag {
    uint32_t gpadc_oscode:12;
    uint32_t rx_offset_i:10;
    uint32_t rx_offset_q:10;
    uint32_t rbb_cap1_fc_i:6;
    uint32_t rbb_cap1_fc_q:6;
    uint32_t rbb_cap2_fc_i:6;
    uint32_t rbb_cap2_fc_q:6;
    undefined field_0x7;
    uint32_t tx_dc_comp_i:12;
    uint32_t tx_dc_comp_q:12;
    uint32_t tmx_cs:3;
    uint32_t txpwr_att_rec:3;
    uint32_t pa_pwrmx_osdac:4;
    uint32_t tmx_csh:3;
    uint32_t tmx_csl:3;
    uint32_t tsen_refcode_rfcal:12;
    undefined field_0xf;
    uint32_t tsen_refcode_corner:12;
    uint32_t rc32k_code_fr_ext:10;
    uint32_t rc32m_code_fr_ext:8;
    uint32_t saradc_oscode:10;
    uint16_t fcal_4osmx:4;
    undefined field_0x16;
    undefined field_0x17;
};

struct anon_struct.conflict34e5c {
    uint32_t inited;
    struct rf_calib1_tag cal;
    struct rf_calib2_tag lo[21];
    undefined field_0x46;
    undefined field_0x47;
    struct rf_calib3_tag rxcal[4];
    struct rf_calib4_tag txcal[8];
};

typedef struct rf_calib_data_tag rf_calib_data_tag, *Prf_calib_data_tag;

struct rf_calib_data_tag {
    uint32_t inited;
    struct rf_calib1_tag cal;
    struct rf_calib2_tag lo[21];
    undefined field_0x46;
    undefined field_0x47;
    struct rf_calib3_tag rxcal[4];
    struct rf_calib4_tag txcal[8];
};

typedef struct mbedtls_pem_context mbedtls_pem_context, *Pmbedtls_pem_context;

struct mbedtls_pem_context {
    uchar * buf;
    size_t buflen;
    uchar * info;
};

typedef struct rxl_cntrl_env_tag rxl_cntrl_env_tag, *Prxl_cntrl_env_tag;

struct rxl_cntrl_env_tag {
    struct co_list ready;
    struct rx_dmadesc * first;
    struct rx_dmadesc * last;
    struct rx_dmadesc * free;
    uint32_t packet_stack_cnt;
};

typedef struct jsmn_parser jsmn_parser, *Pjsmn_parser;

struct jsmn_parser {
    uint pos;
    uint toknext;
    int toksuper;
};

typedef struct jsmntok_t jsmntok_t, *Pjsmntok_t;

typedef enum jsmntype_t {
    JSMN_STRING=3,
    JSMN_PRIMITIVE=4,
    JSMN_UNDEFINED=0,
    JSMN_ARRAY=2,
    JSMN_OBJECT=1
} jsmntype_t;

struct jsmntok_t {
    enum jsmntype_t type;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int start;
    int end;
    int size;
};

typedef enum jsmnerr {
    JSMN_ERROR_NOMEM=-1,
    JSMN_ERROR_PART=-3,
    JSMN_ERROR_INVAL=-2
} jsmnerr;

typedef void * MessageBufferHandle_t;

typedef enum hostapd_state_tag {
    HOSTAPD_STATE_IDLE=0,
    HOSTAPD_STATE_MAX=1
} hostapd_state_tag;

typedef void (* tcpip_init_done_fn)(void *);

typedef struct _gpio_ctx_desc _gpio_ctx_desc, *P_gpio_ctx_desc;

typedef struct _gpio_ctx_desc gpio_ctx_t;

struct _gpio_ctx_desc {
    struct _gpio_ctx_desc * next;
    void (* gpio_handler)(void *);
    void * arg;
    uint8_t gpioPin;
    uint8_t intCtrlMod;
    uint8_t intTrgMod;
    undefined field_0xf;
};

typedef struct gpio_feature_config gpio_feature_config, *Pgpio_feature_config;

struct gpio_feature_config {
    int pin;
    uint8_t valid;
    uint8_t feature;
    uint8_t active;
    uint8_t mode;
    uint time;
};

typedef struct GLB_GPIO_Cfg_Type GLB_GPIO_Cfg_Type, *PGLB_GPIO_Cfg_Type;

struct GLB_GPIO_Cfg_Type {
    uint8_t gpioPin;
    uint8_t gpioFun;
    uint8_t gpioMode;
    uint8_t pullType;
    uint8_t drive;
    uint8_t smtCtrl;
};

typedef enum GLB_GPIO_FUNC_Type {
    GPIO_FUN_EXT_PA=9,
    GPIO_FUN_PWM=8,
    GPIO_FUN_ANALOG=10,
    GPIO_FUN_SDIO=1,
    GPIO_FUN_I2C=6,
    GPIO_FUN_FLASH=2,
    GPIO_FUN_JTAG=14,
    GPIO_FUN_UART=7,
    GPIO_FUN_SWGPIO=11,
    GPIO_FUN_SPI=4
} GLB_GPIO_FUNC_Type;

typedef enum GLB_GPIO_Type {
    GLB_GPIO_PIN_5=5,
    GLB_GPIO_PIN_4=4,
    GLB_GPIO_PIN_7=7,
    GLB_GPIO_PIN_6=6,
    GLB_GPIO_PIN_1=1,
    GLB_GPIO_PIN_0=0,
    GLB_GPIO_PIN_19=19,
    GLB_GPIO_PIN_3=3,
    GLB_GPIO_PIN_2=2,
    GLB_GPIO_PIN_MAX=23,
    GLB_GPIO_PIN_10=10,
    GLB_GPIO_PIN_21=21,
    GLB_GPIO_PIN_20=20,
    GLB_GPIO_PIN_16=16,
    GLB_GPIO_PIN_15=15,
    GLB_GPIO_PIN_18=18,
    GLB_GPIO_PIN_17=17,
    GLB_GPIO_PIN_9=9,
    GLB_GPIO_PIN_12=12,
    GLB_GPIO_PIN_8=8,
    GLB_GPIO_PIN_11=11,
    GLB_GPIO_PIN_22=22,
    GLB_GPIO_PIN_14=14,
    GLB_GPIO_PIN_13=13
} GLB_GPIO_Type;

typedef struct txl_buffer_list_tag txl_buffer_list_tag, *Ptxl_buffer_list_tag;

struct txl_buffer_list_tag {
    struct txl_buffer_tag * first;
    struct txl_buffer_tag * last;
};

typedef struct txl_buffer_hw_desc_tag txl_buffer_hw_desc_tag, *Ptxl_buffer_hw_desc_tag;

struct txl_buffer_hw_desc_tag {
    struct dma_desc dma_desc;
    struct tx_pbd pbd;
};

typedef union anon_union.conflictbf1b anon_union.conflictbf1b, *Panon_union.conflictbf1b;

union anon_union.conflictbf1b {
    struct tx_policy_tbl policy_tbl;
    struct tx_compressed_policy_tbl comp_pol_tbl;
};

typedef struct txl_buffer_env_tag txl_buffer_env_tag, *Ptxl_buffer_env_tag;

typedef struct txl_buffer_idx_tag txl_buffer_idx_tag, *Ptxl_buffer_idx_tag;

struct txl_buffer_idx_tag {
    uint32_t used_area;
    uint32_t free;
    uint32_t free_size;
    uint32_t last;
    uint32_t next_needed;
    uint32_t buf_size;
    uint32_t * pool;
    struct txl_buffer_hw_desc_tag * desc;
    uint8_t count;
    undefined field_0x21;
    undefined field_0x22;
    undefined field_0x23;
};

struct txl_buffer_env_tag {
    struct txl_buffer_idx_tag buf_idx[5][1];
    struct txl_buffer_list_tag list[5];
};

typedef struct oid_sig_alg_t oid_sig_alg_t, *Poid_sig_alg_t;

struct oid_sig_alg_t {
    struct mbedtls_oid_descriptor_t descriptor;
    enum mbedtls_md_type_t md_alg;
    enum mbedtls_pk_type_t pk_alg;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct oid_cipher_alg_t oid_cipher_alg_t, *Poid_cipher_alg_t;

struct oid_cipher_alg_t {
    struct mbedtls_oid_descriptor_t descriptor;
    enum mbedtls_cipher_type_t cipher_alg;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct oid_x520_attr_t oid_x520_attr_t, *Poid_x520_attr_t;

struct oid_x520_attr_t {
    struct mbedtls_oid_descriptor_t descriptor;
    char * short_name;
};

typedef struct oid_x509_ext_t oid_x509_ext_t, *Poid_x509_ext_t;

struct oid_x509_ext_t {
    struct mbedtls_oid_descriptor_t descriptor;
    int ext_type;
};

typedef struct oid_md_alg_t oid_md_alg_t, *Poid_md_alg_t;

struct oid_md_alg_t {
    struct mbedtls_oid_descriptor_t descriptor;
    enum mbedtls_md_type_t md_alg;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct oid_ecp_grp_t oid_ecp_grp_t, *Poid_ecp_grp_t;

struct oid_ecp_grp_t {
    struct mbedtls_oid_descriptor_t descriptor;
    enum mbedtls_ecp_group_id grp_id;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef struct oid_pk_alg_t oid_pk_alg_t, *Poid_pk_alg_t;

struct oid_pk_alg_t {
    struct mbedtls_oid_descriptor_t descriptor;
    enum mbedtls_pk_type_t pk_alg;
    undefined field_0x11;
    undefined field_0x12;
    undefined field_0x13;
};

typedef enum riscv_code_model {
    CM_MEDANY=1,
    CM_MEDLOW=0,
    CM_PIC=2
} riscv_code_model;

typedef enum riscv_abi_type {
    ABI_ILP32E=1,
    ABI_ILP32F=2,
    ABI_LP64F=5,
    ABI_ILP32D=3,
    ABI_ILP32=0,
    ABI_LP64=4,
    ABI_LP64D=6
} riscv_abi_type;

typedef enum riscv_microarchitecture_type {
    sifive_7=1,
    generic=0
} riscv_microarchitecture_type;

typedef struct PDS_CTL2_Type PDS_CTL2_Type, *PPDS_CTL2_Type;

struct PDS_CTL2_Type {
    uint32_t forceCpuPwrOff:1;
    uint32_t rsv1:1;
    uint32_t forceWbPwrOff:1;
    uint32_t rsv3:1;
    uint32_t forceCpuIsoPwrOff:1;
    uint32_t rsv5:1;
    uint32_t forceWbIsoPwrOff:1;
    uint32_t rsv7:1;
    uint32_t forceCpuPdsRst:1;
    uint32_t rsv9:1;
    uint32_t forceWbPdsRst:1;
    uint32_t rsv11:1;
    uint32_t forceCpuMemStby:1;
    uint32_t rsv13:1;
    uint32_t forceWbMemStby:1;
    uint32_t rsv15:1;
    uint32_t forceCpuGateClk:1;
    uint32_t rsv17:1;
    uint32_t forceWbGateClk:1;
    uint32_t rsv19_31:12;
};

typedef enum PDS_PLL_CLK_Type {
    PDS_PLL_CLK_96M=5,
    PDS_PLL_CLK_32M=8,
    PDS_PLL_CLK_160M=3,
    PDS_PLL_CLK_192M=2,
    PDS_PLL_CLK_480M=0,
    PDS_PLL_CLK_48M=7,
    PDS_PLL_CLK_120M=4,
    PDS_PLL_CLK_240M=1,
    PDS_PLL_CLK_80M=6
} PDS_PLL_CLK_Type;

typedef struct PDS_DEFAULT_LV_CFG_Type PDS_DEFAULT_LV_CFG_Type, *PPDS_DEFAULT_LV_CFG_Type;

typedef struct PDS_CTL_Type PDS_CTL_Type, *PPDS_CTL_Type;

typedef struct PDS_CTL3_Type PDS_CTL3_Type, *PPDS_CTL3_Type;

typedef struct PDS_CTL4_Type PDS_CTL4_Type, *PPDS_CTL4_Type;

struct PDS_CTL3_Type {
    uint32_t rsv0:1;
    uint32_t forceMiscPwrOff:1;
    uint32_t rsv2_3:2;
    uint32_t forceMiscIsoEn:1;
    uint32_t rsv5_6:2;
    uint32_t forceMiscPdsRst:1;
    uint32_t rsv8_9:2;
    uint32_t forceMiscMemStby:1;
    uint32_t rsv11_12:2;
    uint32_t forceMiscGateClk:1;
    uint32_t rsv14_23:10;
    uint32_t CpuIsoEn:1;
    uint32_t rsv25_26:2;
    uint32_t WbIsoEn:1;
    uint32_t rsv28_29:2;
    uint32_t MiscIsoEn:1;
    uint32_t rsv31:1;
};

struct PDS_CTL4_Type {
    uint32_t cpuPwrOff:1;
    uint32_t cpuRst:1;
    uint32_t cpuMemStby:1;
    uint32_t cpuGateClk:1;
    uint32_t rsv4_11:8;
    uint32_t WbPwrOff:1;
    uint32_t WbRst:1;
    uint32_t WbMemStby:1;
    uint32_t WbGateClk:1;
    uint32_t rsv16_23:8;
    uint32_t MiscPwrOff:1;
    uint32_t MiscRst:1;
    uint32_t MiscMemStby:1;
    uint32_t MiscGateClk:1;
    uint32_t rsv28_31:4;
};

struct PDS_CTL_Type {
    uint32_t pdsStart:1;
    uint32_t sleepForever:1;
    uint32_t xtalForceOff:1;
    uint32_t saveWiFiState:1;
    uint32_t dcdc18Off:1;
    uint32_t bgSysOff:1;
    uint32_t rsv6_7:2;
    uint32_t clkOff:1;
    uint32_t memStby:1;
    uint32_t rsv10:1;
    uint32_t isolation:1;
    uint32_t waitXtalRdy:1;
    uint32_t pdsPwrOff:1;
    uint32_t xtalOff:1;
    uint32_t socEnbForceOn:1;
    uint32_t pdsRstSocEn:1;
    uint32_t pdsRC32mOn:1;
    uint32_t pdsLdoVselEn:1;
    uint32_t rsv19_20:2;
    uint32_t wfiMask:1;
    uint32_t ldo11Off:1;
    uint32_t rsv23:1;
    uint32_t pdsLdoVol:4;
    uint32_t pdsCtlRfSel:2;
    uint32_t pdsCtlPllSel:2;
};

struct PDS_DEFAULT_LV_CFG_Type {
    struct PDS_CTL_Type pdsCtl;
    struct PDS_CTL2_Type pdsCtl2;
    struct PDS_CTL3_Type pdsCtl3;
    struct PDS_CTL4_Type pdsCtl4;
};

typedef enum PDS_PLL_XTAL_Type {
    PDS_PLL_XTAL_40M=4,
    PDS_PLL_XTAL_RC32M=6,
    PDS_PLL_XTAL_38P4M=3,
    PDS_PLL_XTAL_NONE=0,
    PDS_PLL_XTAL_26M=5,
    PDS_PLL_XTAL_24M=1,
    PDS_PLL_XTAL_32M=2
} PDS_PLL_XTAL_Type;

typedef struct PDS_RAM_CFG_Type PDS_RAM_CFG_Type, *PPDS_RAM_CFG_Type;

struct PDS_RAM_CFG_Type {
    uint32_t PDS_RAM_CFG_0KB_16KB_CPU_RAM_RET:1;
    uint32_t PDS_RAM_CFG_16KB_32KB_CPU_RAM_RET:1;
    uint32_t PDS_RAM_CFG_32KB_48KB_CPU_RAM_RET:1;
    uint32_t PDS_RAM_CFG_48KB_64KB_CPU_RAM_RET:1;
    uint32_t PDS_RAM_CFG_0KB_16KB_CPU_RAM_SLP:1;
    uint32_t PDS_RAM_CFG_16KB_32KB_CPU_RAM_SLP:1;
    uint32_t PDS_RAM_CFG_32KB_48KB_CPU_RAM_SLP:1;
    uint32_t PDS_RAM_CFG_48KB_64KB_CPU_RAM_SLP:1;
    uint32_t PDS_RAM_CFG_RSV:24;
};

typedef struct x509_crt_verify_string x509_crt_verify_string, *Px509_crt_verify_string;

struct x509_crt_verify_string {
    int code;
    char * string;
};

typedef uintptr_t insn_t;

typedef struct cfg_element_entry cfg_element_entry, *Pcfg_element_entry;

struct cfg_element_entry {
    uint32_t task;
    uint16_t element;
    uint16_t type;
    char * name;
    void * val;
    int (* set)(struct cfg_element_entry *, void *, void *);
    int (* get)(struct cfg_element_entry *, void *, void *);
    int (* notify)(struct cfg_element_entry *, void *, void *, enum CFG_ELEMENT_TYPE_OPS);
};

typedef void * bl_mtd_handle_t;

typedef struct bl_mtd_info_t bl_mtd_info_t, *Pbl_mtd_info_t;

struct bl_mtd_info_t {
    char name[16];
    uint offset;
    uint size;
    void * xip_addr;
};

typedef struct bl_txhdr bl_txhdr, *Pbl_txhdr;

typedef union bl_hw_txstatus bl_hw_txstatus, *Pbl_hw_txstatus;

typedef struct anon_struct.conflict14eb3b anon_struct.conflict14eb3b, *Panon_struct.conflict14eb3b;

struct anon_struct.conflict14eb3b {
    u32.conflict tx_done:1;
    u32.conflict retry_required:1;
    u32.conflict sw_retry_required:1;
    u32.conflict reserved:29;
};

union bl_hw_txstatus {
    struct anon_struct.conflict14eb3b field_0;
    u32.conflict value;
};

struct bl_txhdr {
    struct utils_list_hdr item;
    union bl_hw_txstatus status;
    uint32_t * p;
    struct hostdesc host;
};

typedef enum lwip_pollscan_opts {
    LWIP_POLLSCAN_CLEAR=1,
    LWIP_POLLSCAN_INC_WAIT=2,
    LWIP_POLLSCAN_DEC_WAIT=4
} lwip_pollscan_opts;

typedef union sockaddr_aligned sockaddr_aligned, *Psockaddr_aligned;

typedef struct sockaddr sockaddr, *Psockaddr;

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

typedef u8_t sa_family_t;

struct sockaddr {
    u8_t sa_len;
    sa_family_t sa_family;
    char sa_data[14];
};

struct sockaddr_in {
    u8_t sin_len;
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

union sockaddr_aligned {
    struct sockaddr sa;
    struct sockaddr_in sin;
};

typedef struct lwip_socket_multicast_pair lwip_socket_multicast_pair, *Plwip_socket_multicast_pair;

struct lwip_socket_multicast_pair {
    struct lwip_sock * sock;
    ip4_addr_t if_addr;
    ip4_addr_t multi_addr;
};

typedef struct key_MgtMaterial_t key_MgtMaterial_t, *Pkey_MgtMaterial_t;

typedef union anon_union.conflictdf11_for_keyEncypt anon_union.conflictdf11_for_keyEncypt, *Panon_union.conflictdf11_for_keyEncypt;

typedef struct key_Type_TKIP_t key_Type_TKIP_t, *Pkey_Type_TKIP_t;

typedef struct key_Type_AES_t key_Type_AES_t, *Pkey_Type_AES_t;

typedef struct key_Type_WEP_t key_Type_WEP_t, *Pkey_Type_WEP_t;

typedef struct key_Type_WAPI_t key_Type_WAPI_t, *Pkey_Type_WAPI_t;

typedef struct key_Type_AES_CMAC_t key_Type_AES_CMAC_t, *Pkey_Type_AES_CMAC_t;

struct key_Type_AES_t {
    UINT8 key[16];
};

struct key_Type_TKIP_t {
    UINT8 key[16];
    UINT8 txMicKey[8];
    UINT8 rxMicKey[8];
};

struct key_Type_WEP_t {
    UINT8 keyIndex;
    UINT8 isDefaultTx;
    UINT8 key[13];
};

struct key_Type_WAPI_t {
    UINT8 keyIndex;
    UINT8 isDefKey;
    UINT8 key[16];
    UINT8 mickey[16];
    UINT8 rxPN[16];
};

struct key_Type_AES_CMAC_t {
    UINT8 ipn[6];
    UINT8 reserved[2];
    UINT8 key[16];
};

union anon_union.conflictdf11_for_keyEncypt {
    struct key_Type_TKIP_t TKIP;
    struct key_Type_AES_t AES1;
    struct key_Type_WEP_t WEP;
    struct key_Type_WAPI_t WAPI;
    struct key_Type_AES_CMAC_t iGTK;
};

struct key_MgtMaterial_t {
    UINT16 keyType;
    UINT16 keyInfo;
    UINT16 keyLen;
    union anon_union.conflictdf11_for_keyEncypt keyEncypt;
};

typedef union anon_union.conflictdf11 anon_union.conflictdf11, *Panon_union.conflictdf11;

union anon_union.conflictdf11 {
    struct key_Type_TKIP_t TKIP;
    struct key_Type_AES_t AES1;
    struct key_Type_WEP_t WEP;
    struct key_Type_WAPI_t WAPI;
    struct key_Type_AES_CMAC_t iGTK;
};

typedef uint hashval_t;

typedef struct scanu_raw_send_cfm scanu_raw_send_cfm, *Pscanu_raw_send_cfm;

struct scanu_raw_send_cfm {
    uint32_t status;
};

typedef struct scanu_raw_send_req scanu_raw_send_req, *Pscanu_raw_send_req;

struct scanu_raw_send_req {
    void * pkt;
    uint32_t len;
};

typedef struct scanu_start_cfm scanu_start_cfm, *Pscanu_start_cfm;

struct scanu_start_cfm {
    uint8_t status;
};

typedef struct notifier_block notifier_block, *Pnotifier_block;

struct notifier_block {
    int (* cb)(struct notifier_block *, int, void *);
    struct notifier_block * next;
    int priority;
};

typedef struct rd_env_tag rd_env_tag, *Prd_env_tag;

struct rd_env_tag {
    struct co_list event_free_list;
};

typedef struct Bl_SHA1_CTX Bl_SHA1_CTX, *PBl_SHA1_CTX;

struct Bl_SHA1_CTX {
    UINT32 Intermediate_Hash[5];
    UINT32 Length_Low;
    UINT32 Length_High;
    UINT32 Scratch[16];
    UINT8 Message_Block[64];
    SINT16 Message_Block_Index;
    UINT8 Computed;
    UINT8 Corrupted;
};

typedef struct mbedtls_sha1_context mbedtls_sha1_context, *Pmbedtls_sha1_context;

struct mbedtls_sha1_context {
    uint32_t total[2];
    uint32_t state[5];
    uchar buffer[64];
};

typedef struct tcpip_callback_msg tcpip_callback_msg, *Ptcpip_callback_msg;

struct tcpip_callback_msg {
};

typedef union anon_union.conflict202275_for_msg anon_union.conflict202275_for_msg, *Panon_union.conflict202275_for_msg;

union anon_union.conflict202275_for_msg {
    struct netbuf * b;
    struct anon_struct.conflict14aecf n;
    struct anon_struct.conflict202123 bc;
    struct anon_struct.conflict202123 ad;
    struct anon_struct.conflict202123 w;
    struct anon_struct.conflict2021fc r;
    struct anon_struct.conflict202123 sd;
    struct anon_struct.conflict202123 jl;
};

typedef union anon_union.conflict anon_union.conflict, *Panon_union.conflict;

union anon_union.conflict {
    struct netbuf * b;
    struct anon_struct.conflict14aecf n;
    struct anon_struct.conflict202123 bc;
    struct anon_struct.conflict202154 ad;
    struct anon_struct.conflict202154 w;
    struct anon_struct.conflict2021fc r;
    struct anon_struct.conflict202154 sd;
    struct anon_struct.conflict202154 jl;
};

typedef struct ip_mreq ip_mreq, *Pip_mreq;

struct ip_mreq {
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
};

typedef struct msghdr msghdr, *Pmsghdr;

typedef struct iovec iovec, *Piovec;

struct msghdr {
    void * msg_name;
    socklen_t msg_namelen;
    struct iovec * msg_iov;
    int msg_iovlen;
    void * msg_control;
    socklen_t msg_controllen;
    int msg_flags;
};

struct iovec {
    void * iov_base;
    size_t iov_len;
};

typedef struct ifreq ifreq, *Pifreq;

struct ifreq {
    char ifr_name[6];
};

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

struct sockaddr_storage {
    u8_t s2_len;
    sa_family_t ss_family;
    char s2_data1[2];
    u32_t s2_data2[3];
};

typedef TimerHandle_t timer_cb_arg_t;

typedef enum GLB_DIG_CLK_Type {
    GLB_DIG_CLK_XCLK=1,
    GLB_DIG_CLK_PLL_32M=0
} GLB_DIG_CLK_Type;

typedef enum BMX_BUS_ERR_Type {
    BMX_BUS_ERR_ADDR_DECODE=1,
    BMX_BUS_ERR_TRUSTZONE_DECODE=0
} BMX_BUS_ERR_Type;

typedef enum GLB_SPI_PAD_ACT_AS_Type {
    GLB_SPI_PAD_ACT_AS_SLAVE=0,
    GLB_SPI_PAD_ACT_AS_MASTER=1
} GLB_SPI_PAD_ACT_AS_Type;

typedef enum GLB_SFLASH_CLK_Type {
    GLB_SFLASH_CLK_96M=5,
    GLB_SFLASH_CLK_120M=0,
    GLB_SFLASH_CLK_XTAL=1,
    GLB_SFLASH_CLK_80M=3,
    GLB_SFLASH_CLK_BCLK=4,
    GLB_SFLASH_CLK_48M=2
} GLB_SFLASH_CLK_Type;

typedef enum GLB_EM_Type {
    GLB_EM_16KB=15,
    GLB_EM_0KB=0,
    GLB_EM_8KB=3
} GLB_EM_Type;

typedef enum BMX_ERR_INT_Type {
    BMX_ERR_INT_ALL=1,
    BMX_ERR_INT_ERR=0
} BMX_ERR_INT_Type;

typedef struct BMX_Cfg_Type BMX_Cfg_Type, *PBMX_Cfg_Type;

typedef enum BMX_ARB_Type {
    BMX_ARB_FIX=0,
    BMX_ARB_RANDOM=2,
    BMX_ARB_ROUND_ROBIN=1
} BMX_ARB_Type;

struct BMX_Cfg_Type {
    uint8_t timeoutEn;
    enum BL_Fun_Type errEn;
    enum BMX_ARB_Type arbMod;
};

typedef enum GLB_PLL_XTAL_Type {
    GLB_PLL_XTAL_RC32M=6,
    GLB_PLL_XTAL_NONE=0,
    GLB_PLL_XTAL_40M=4,
    GLB_PLL_XTAL_38P4M=3,
    GLB_PLL_XTAL_26M=5,
    GLB_PLL_XTAL_24M=1,
    GLB_PLL_XTAL_32M=2
} GLB_PLL_XTAL_Type;

typedef enum GLB_SYS_CLK_Type {
    GLB_SYS_CLK_PLL160M=4,
    GLB_SYS_CLK_PLL192M=5,
    GLB_SYS_CLK_XTAL=1,
    GLB_SYS_CLK_PLL48M=2,
    GLB_SYS_CLK_PLL120M=3,
    GLB_SYS_CLK_RC32M=0
} GLB_SYS_CLK_Type;

typedef enum GLB_BT_BANDWIDTH_Type {
    GLB_BT_BANDWIDTH_2M=1,
    GLB_BT_BANDWIDTH_1M=0
} GLB_BT_BANDWIDTH_Type;

typedef enum BMX_TO_INT_Type {
    BMX_TO_INT_TIMEOUT=0,
    BMX_TO_INT_ALL=1
} BMX_TO_INT_Type;

typedef enum GLB_GPIO_INT_TRIG_Type {
    GLB_GPIO_INT_TRIG_NEG_PULSE=0,
    GLB_GPIO_INT_TRIG_POS_LEVEL=3,
    GLB_GPIO_INT_TRIG_NEG_LEVEL=2,
    GLB_GPIO_INT_TRIG_POS_PULSE=1
} GLB_GPIO_INT_TRIG_Type;

typedef enum GLB_DAC_CLK_Type {
    GLB_DAC_CLK_32M=0,
    GLB_DAC_CLK_XCLK=1
} GLB_DAC_CLK_Type;

typedef enum GLB_IR_CLK_SRC_Type {
    GLB_IR_CLK_SRC_XCLK=0
} GLB_IR_CLK_SRC_Type;

typedef enum GLB_DMA_CLK_ID_Type {
    GLB_DMA_CLK_DMA0_CH0=0,
    GLB_DMA_CLK_DMA0_CH1=1,
    GLB_DMA_CLK_DMA0_CH2=2,
    GLB_DMA_CLK_DMA0_CH3=3
} GLB_DMA_CLK_ID_Type;

typedef enum GLB_ADC_CLK_Type {
    GLB_ADC_CLK_96M=0,
    GLB_ADC_CLK_XCLK=1
} GLB_ADC_CLK_Type;

typedef enum GLB_GPIO_INT_CONTROL_Type {
    GLB_GPIO_INT_CONTROL_ASYNC=1,
    GLB_GPIO_INT_CONTROL_SYNC=0
} GLB_GPIO_INT_CONTROL_Type;

typedef enum GLB_MTIMER_CLK_Type {
    GLB_MTIMER_CLK_BCLK=0,
    GLB_MTIMER_CLK_32K=1
} GLB_MTIMER_CLK_Type;

typedef enum GLB_GPIO_REAL_MODE_Type {
    GLB_GPIO_REAL_MODE_SDIO=1,
    GLB_GPIO_REAL_MODE_CCI=15,
    GLB_GPIO_REAL_MODE_JTAG=14,
    GLB_GPIO_REAL_MODE_RF=12,
    GLB_GPIO_REAL_MODE_REG=0
} GLB_GPIO_REAL_MODE_Type;

typedef enum GLB_PKA_CLK_Type {
    GLB_PKA_CLK_PLL120M=1,
    GLB_PKA_CLK_HCLK=0
} GLB_PKA_CLK_Type;

typedef enum GLB_UART_SIG_FUN_Type {
    GLB_UART_SIG_FUN_UART1_TXD=6,
    GLB_UART_SIG_FUN_UART0_CTS=1,
    GLB_UART_SIG_FUN_UART1_RXD=7,
    GLB_UART_SIG_FUN_UART0_RXD=3,
    GLB_UART_SIG_FUN_UART0_RTS=0,
    GLB_UART_SIG_FUN_UART1_CTS=5,
    GLB_UART_SIG_FUN_UART0_TXD=2,
    GLB_UART_SIG_FUN_UART1_RTS=4
} GLB_UART_SIG_FUN_Type;

typedef enum GLB_UART_SIG_Type {
    GLB_UART_SIG_0=0,
    GLB_UART_SIG_3=3,
    GLB_UART_SIG_4=4,
    GLB_UART_SIG_1=1,
    GLB_UART_SIG_2=2,
    GLB_UART_SIG_7=7,
    GLB_UART_SIG_5=5,
    GLB_UART_SIG_6=6
} GLB_UART_SIG_Type;

typedef enum GLB_PLL_CLK_Type {
    GLB_PLL_CLK_48M=7,
    GLB_PLL_CLK_160M=3,
    GLB_PLL_CLK_192M=2,
    GLB_PLL_CLK_480M=0,
    GLB_PLL_CLK_96M=5,
    GLB_PLL_CLK_240M=1,
    GLB_PLL_CLK_120M=4,
    GLB_PLL_CLK_32M=8,
    GLB_PLL_CLK_80M=6
} GLB_PLL_CLK_Type;

typedef enum GLB_ROOT_CLK_Type {
    GLB_ROOT_CLK_RC32M=0,
    GLB_ROOT_CLK_XTAL=1,
    GLB_ROOT_CLK_PLL=2
} GLB_ROOT_CLK_Type;

typedef struct mm_env_tag mm_env_tag, *Pmm_env_tag;

struct mm_env_tag {
    uint32_t rx_filter_umac;
    uint32_t rx_filter_lmac_enable;
    uint16_t ampdu_max_dur[5];
    uint8_t prev_mm_state;
    uint8_t prev_hw_state;
    uint32_t basic_rates[2];
    uint32_t uapsd_timeout;
    uint16_t lp_clk_accuracy;
    uint8_t host_idle;
    _Bool keep_alive_status_enabled;
    uint32_t keep_alive_packet_counter;
    uint32_t keep_alive_time_last_received;
};

typedef enum mm_features {
    MM_FEAT_P2P_BIT=13,
    MM_FEAT_MROLE_BIT=4,
    MM_FEAT_AUTOBCN_BIT=1,
    MM_FEAT_UMAC_BIT=15,
    MM_FEAT_MFP_BIT=20,
    MM_FEAT_REORD_BIT=12,
    MM_FEAT_P2P_GO_BIT=14,
    MM_FEAT_BCN_BIT=0,
    MM_FEAT_UAPSD_BIT=7,
    MM_FEAT_MU_MIMO_TX_BIT=22,
    MM_FEAT_HWSCAN_BIT=2,
    MM_FEAT_CHNL_CTXT_BIT=11,
    MM_FEAT_MESH_BIT=23,
    MM_FEAT_TDLS_BIT=24,
    MM_FEAT_RADAR_BIT=5,
    MM_FEAT_DPSM_BIT=8,
    MM_FEAT_WAPI_BIT=19,
    MM_FEAT_MU_MIMO_RX_BIT=21,
    MM_FEAT_CMON_BIT=3,
    MM_FEAT_AMPDU_BIT=9,
    MM_FEAT_BFMEE_BIT=17,
    MM_FEAT_PS_BIT=6,
    MM_FEAT_BFMER_BIT=18,
    MM_FEAT_VHT_BIT=16,
    MM_FEAT_AMSDU_BIT=10
} mm_features;

typedef int32_t mbedtls_mpi_sint;

typedef uint64_t mbedtls_t_udbl;

typedef struct phy_env_tag phy_env_tag, *Pphy_env_tag;

typedef struct phy_bl602_cfg_tag phy_bl602_cfg_tag, *Pphy_bl602_cfg_tag;

struct phy_bl602_cfg_tag {
    uint32_t reserved;
};

struct phy_env_tag {
    struct phy_bl602_cfg_tag cfg;
    uint16_t chnl_prim20_freq;
    uint16_t chnl_center1_freq;
    uint16_t chnl_center2_freq;
    uint8_t band;
    uint8_t chnl_type;
};

typedef struct lwip_cyclic_timer lwip_cyclic_timer, *Plwip_cyclic_timer;

typedef void (* lwip_cyclic_timer_handler)(void);

struct lwip_cyclic_timer {
    u32_t interval_ms;
    lwip_cyclic_timer_handler handler;
};

typedef struct sys_timeo sys_timeo, *Psys_timeo;

struct sys_timeo {
    struct sys_timeo * next;
    u32_t time;
    void (* h)(void *);
    void * arg;
};

typedef enum raw_input_state {
    RAW_INPUT_DELIVERED=2,
    RAW_INPUT_NONE=0,
    RAW_INPUT_EATEN=1
} raw_input_state;

typedef enum raw_input_state raw_input_state_t;

typedef enum memp_t {
    MEMP_MAX=15,
    MEMP_TCP_SEG=4,
    MEMP_NETCONN=7,
    MEMP_UDP_PCB=1,
    MEMP_RAW_PCB=0,
    MEMP_NETDB=12,
    MEMP_TCP_PCB_LISTEN=3,
    MEMP_SYS_TIMEOUT=11,
    MEMP_PBUF=13,
    MEMP_IGMP_GROUP=10,
    MEMP_TCPIP_MSG_API=8,
    MEMP_PBUF_POOL=14,
    MEMP_ALTCP_PCB=5,
    MEMP_NETBUF=6,
    MEMP_TCP_PCB=2,
    MEMP_TCPIP_MSG_INPKT=9
} memp_t;

typedef struct bl_mtd_handle_priv bl_mtd_handle_priv, *Pbl_mtd_handle_priv;

struct bl_mtd_handle_priv {
    char name[16];
    int id;
    uint offset;
    uint size;
    void * xip_addr;
};

typedef struct bl_mtd_handle_priv * bl_mtd_handle_priv_t;

typedef enum LOG_BUF_OUT_DATA_TYPE {
    LOG_BUF_OUT_DATA_TYPE_HEX=0,
    LOG_BUF_OUT_DATA_TYPE_UNT8=2,
    LOG_BUF_OUT_DATA_TYPE_INT8=1
} LOG_BUF_OUT_DATA_TYPE;

typedef enum LOG_BUF_OUT_DATA_TYPE LOG_BUF_OUT_DATA_TYPE_T;

typedef int __gcc_CMPtype;

typedef TickType_t EventBits_t;

typedef struct EventGroupDef_t EventGroupDef_t, *PEventGroupDef_t;

typedef struct EventGroupDef_t * EventGroupHandle_t;

struct EventGroupDef_t {
    EventBits_t uxEventBits;
    List_t xTasksWaitingForBits;
    UBaseType_t uxEventGroupNumber;
    uint8_t ucStaticallyAllocated;
    undefined field_0x1d;
    undefined field_0x1e;
    undefined field_0x1f;
};

typedef struct gethostbyname_r_helper gethostbyname_r_helper, *Pgethostbyname_r_helper;

struct gethostbyname_r_helper {
    ip_addr_t * addr_list[2];
    ip_addr_t addr;
    char * aliases;
};

typedef ulonglong uintmax_t;

typedef longlong intmax_t;

typedef struct addrinfo addrinfo, *Paddrinfo;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct EventGroupDef_t EventGroup_t;

typedef struct Ring_Buffer_Type Ring_Buffer_Type, *PRing_Buffer_Type;

struct Ring_Buffer_Type {
    uint8_t * pointer;
    uint8_t readMirror;
    undefined field_0x5;
    uint16_t readIndex;
    uint8_t writeMirror;
    undefined field_0x9;
    uint16_t writeIndex;
    uint16_t size;
    undefined field_0xe;
    undefined field_0xf;
    void (* lock)(void);
    void (* unlock)(void);
};

typedef enum anon_enum_8.conflictcde {
    MSOFT_IRQn=3,
    PBUF_LINK=-114,
    SEC_ENG_AES_CBC=2,
    E_RF_CHANNEL_2460M=14,
    E_RF_CHANNEL_2484M=20,
    E_RF_CHANNEL_2472M=17,
    IRTX_IRQn=35,
    SEC_ENG_PKA_REG_SIZE_512=10,
    E_RF_XTAL_26M=1,
    PHY_CHNL_BW_160=3,
    ME_BUSY=1,
    eIncrement=2,
    PBUF_RAW_TX=-128,
    SPI_IRQn=43,
    SEC_ENG_AES_DECRYPTION=1,
    E_RF_MODE_RCCAL=4,
    HW_RESERVED=1,
    DHCP_STATE_INFORMING=7,
    HW_RATE_18MBPS=7,
    S_PRECIS=5,
    C_DIGIT=4,
    HAL_AC1_TIMER=1,
    GPADC_DMA_IRQn=41,
    TIMER_COMP_ID_0=0,
    WDT_INT_ALL=1,
    MOD_CLASS_INFRA=1,
    TIMER_COMP_ID_1=1,
    BL_AHB_SLAVE1_PDSHBN=14,
    API_AC_BK=0,
    MM_MESH_POINT=3,
    TIMER_COMP_ID_2=2,
    PT_ENTRY_MAX=16,
    GLB_SYS_CLK_PLL48M=2,
    RFC_PC_WLAN_11N=3,
    TIMER_CH1_IRQn=53,
    RFC_PC_WLAN_11B=1,
    SEC_ENG_PKA_REG_SIZE_8=1,
    GLB_PLL_XTAL_26M=5,
    RFC_PC_WLAN_11G=2,
    DMA_INT_ERR=1,
    RFC_PC_BT_BLE=4,
    FLAG_SIGN=8,
    ERR_IF=-12,
    VFS_TYPE_CHAR_DEV=1,
    AC_VI=2,
    HW_RATE_11MBPS=3,
    SET=1,
    AC_VO=3,
    IPC_DMA_LLI_GP_UL=11,
    MEMP_TCP_PCB_LISTEN=3,
    INFRASTRUCTURE_MODE=1,
    RFC_RC_IDLE=0,
    EF_CTRL_PARA_DFT=0,
    SCANU_IDLE=0,
    DHCP_STATE_RELEASING=11,
    SEC_ENG_INT_TRNG=0,
    BA_AGMT_ESTABLISHED=0,
    BA_AGMT_DOESNT_EXIST=3,
    MACBYP_ON=1,
    BA_AGMT_DELETED=2,
    TX_DEFAULT_5G=1,
    KE_EVT_GP_DMA_DL=25,
    SUCCESS=0,
    ERR_TIMEOUT=-3,
    DHCP_STATE_RENEWING=5,
    PT_ENTRY_FW_CPU0=0,
    PT_ENTRY_FW_CPU1=1,
    RFC_FSM_FORCE_OFF=15,
    IPC_DMA_LLI_DATA_AC0_TX=0,
    TASK_BAM=8,
    CONNECTION_TYPE_WFD=3,
    RFC_FSM_TX=4,
    MEMP_ALTCP_PCB=5,
    IPC_DMA_CHANNEL_DATA_TX=3,
    BL_SHA256=0,
    CONTROL_PORT_NO_ENC=2,
    UNMASK=0,
    TASK_SM=6,
    MEMP_MAX=15,
    MBEDTLS_SSL_HELLO_REQUEST=0,
    E_RF_CHANNEL_2480M=19,
    MBEDTLS_SSL_SERVER_KEY_EXCHANGE=4,
    CONNECTION_TYPE_AP=2,
    CO_NOT_FOUND=5,
    C_MAX=8,
    RFC_RC_RX2ON=1,
    SEC_ENG_INT_CDET=4,
    ERR_WOULDBLOCK=-7,
    PING_INDEX=0,
    HBN_ROOT_CLK_XTAL=1,
    WIFI_IPC_PUBLIC_IRQn=79,
    TID_1=1,
    RESERVED3=37,
    TID_0=0,
    E_RF_RXCAL_GAIN_CNT=4,
    FLAG_LEAD_ZERO=64,
    RESERVED2=34,
    TID_3=3,
    MOD_CLASS_HR_DSSS=3,
    S_TYPE=7,
    RESERVED1=33,
    TID_2=2,
    RESERVED0=32,
    TID_5=5,
    RESERVED7=47,
    TID_4=4,
    RESERVED6=44,
    TID_7=7,
    RESERVED5=40,
    TID_6=6,
    RESERVED4=38,
    DHCP_STATE_REBINDING=4,
    MAC_RATE_12MBPS=24,
    HW_RATE_48MBPS=10,
    STA_VHT_CAPA=4,
    RFC_FSM_RX=3,
    HW_DOZE=2,
    PHY_CHNL_BW_OTHER=5,
    RFC_FSM_SB=1,
    RESERVED9=51,
    RESERVED8=49,
    MEMP_TCP_PCB=2,
    shaSuccess=0,
    IPC_DMA_CHANNEL_DATA_RX=1,
    HW_ACTIVE=3,
    KE_EVT_MAX=27,
    BL_AHB_SLAVE1_TZ1=5,
    GLB_SYS_CLK_XTAL=1,
    HAL_AC3_TIMER=3,
    TASK_CFG=12,
    MOD_CLASS_DSSS_OFDM=5,
    MAC_RATE_11MBPS=22,
    CONNACK_NOT_AUTHORIZED_ERROR=5,
    TASK_TDLS=3,
    BL_SHA224=1,
    ANY_BSS_MODE=3,
    WPA_WPA2_IN_USE=8,
    HW_RATE_12MBPS=6,
    IRRX_IRQn=36,
    KE_EVT_IRQ_USR=2,
    eNoAction=0,
    HBN_32K_XTAL=1,
    WMM_AC_VO=3,
    PORT_CLOSED=0,
    CONNECTION_TYPE_BTAMP=4,
    E_RF_MODE_LO_ACAL=6,
    WMM_AC_VI=2,
    C_PERCENT=1,
    AP_ENC_WPA2=1,
    RFC_FSM_PD=0,
    SEC_ENG_AES_ECB=0,
    DNS_STATE_DONE=3,
    HBN_32K_DIG=3,
    MBEDTLS_SSL_SERVER_FINISHED=13,
    TCAL_NUM_CALS=4,
    C_DOT=2,
    GPIO_FUN_EXT_PA=9,
    MBEDTLS_SSL_CLIENT_KEY_EXCHANGE=8,
    UART_INT_PCE=5,
    MACBYP_IDLE=0,
    DMA_INT_ALL=2,
    BL_AHB_SLAVE1_TZ2=6,
    L1C_BMX_TO_IRQn=19,
    RFC_RC_RXON=3,
    VIF_UNKNOWN=4,
    BA_AGMT_ALREADY_EXISTS=1,
    PHY_CHNL_BW_80P80=4,
    IPC_DMA_CHANNEL_MAX=4,
    E_RF_CHANNEL_2420M=4,
    ERR_MEM=-1,
    DMA_MAX=2,
    SEC_AES_IRQn=29,
    FW_SUCCESS=0,
    GLB_SYS_CLK_PLL192M=5,
    MBEDTLS_SSL_HANDSHAKE_OVER=16,
    MAC_RATE_6MBPS=12,
    RFC_BBMODE_BLE=1,
    GPIO_FUN_SDIO=1,
    ERR_ISCONN=-10,
    PS_MODE_OFF=0,
    VIF_AP=2,
    PORT_OPEN=2,
    S_COPY=0,
    E_RF_TXPWR_TBL_CNT=16,
    SF_CTRL_OWNER_IAHB=1,
    UART_INT_RX_FER=7,
    UART_RX_INT=1,
    E_RF_TXCAL_GAIN_CNT=8,
    GPIO_FUN_ANALOG=10,
    DMA_DL=0,
    S_PERCENT=1,
    C_OTHER=0,
    GPIO_FUN_FLASH=2,
    MOD_CLASS_FHSS=2,
    GLB_ADC_CLK_XCLK=1,
    VIF_MESH_POINT=3,
    MM_STA=0,
    E_RF_CHANNEL_2444M=10,
    E_RF_CHANNEL_2432M=7,
    KE_EVT_KE_MESSAGE=7,
    E_RF_CHANNEL_2468M=16,
    E_RF_MODE_IDLE=0,
    E_RF_CHANNEL_2456M=13,
    eSetBits=1,
    TCAL_TXGAIN=0,
    TIMEOUT=2,
    MEMP_NETBUF=6,
    MAC_TX_TRG_IRQn=76,
    HW_RATE_36MBPS=9,
    E_RF_GAIN=2,
    BL_AHB_SLAVE1_CCI=8,
    KE_EVT_RXUPLOADED=11,
    DMA_TRNS_WIDTH_8BITS=0,
    MAC_RATE_36MBPS=72,
    DNS_STATE_ASKING=2,
    MACBYP_TX_SINGLE=2,
    E_RF_XTAL_32M=2,
    SEC_ENG_AES_USE_OLD=1,
    CO_OK=0,
    TIMER_CLKSRC_FCLK=0,
    AC_MAX=4,
    PONG_INDEX=1,
    CO_BAD_PARAM=4,
    BL_AHB_SLAVE1_GLB=0,
    BL_IRQ_EXCEPTION_TYPE_ILLEGAL_INSTRUCTION=3,
    EF_CTRL_EF_CLK=0,
    RF_TOP_INT0_IRQn=21,
    MBEDTLS_SSL_CLIENT_HELLO=1,
    MBEDTLS_SSL_FLUSH_BUFFERS=14,
    TID_MAX=9,
    RFC_FSM_LO=2,
    RFC_RC_TXPAON=7,
    MAC_RX_TRG_IRQn=75,
    PHY_CHNL_BW_80=2,
    UART_INT_TX_FER=6,
    ERR_OK=0,
    GLB_PLL_XTAL_32M=2,
    BA_RESPONDER=0,
    RESERVED19=64,
    UART_PARITY_ODD=1,
    GLB_PLL_XTAL_RC32M=6,
    ERR_CLSD=-15,
    UART_INT_ALL=8,
    CO_BUSY=8,
    BL_AHB_SLAVE1_PWM=20,
    E_RF_BRANCH_I=0,
    DISABLE_HT=4,
    DBG_PROF_MAX=0,
    BL_AHB_SLAVE1_UART0=16,
    BL_AHB_SLAVE1_UART1=17,
    EF_CTRL_SAHB_CLK=1,
    RFC_BBMODE_WLAN=0,
    RESET=0,
    E_RF_CHANNEL_2440M=9,
    MAC_PORT_TRG_IRQn=78,
    MOD_CLASS_VHT=9,
    E_RF_CHANNEL_2464M=15,
    E_RF_CHANNEL_2452M=12,
    INDEPENDENT_BSS_MODE=2,
    GLB_SYS_CLK_PLL160M=4,
    RESERVED10=55,
    UART0_IRQn=45,
    BL_SHA1=2,
    RESERVED12=57,
    RESERVED11=56,
    RESERVED14=59,
    TIMER_WDT_IRQn=54,
    RESERVED13=58,
    RESERVED16=61,
    TX_EXT=1,
    RESERVED18=63,
    RESERVED17=62,
    IRQn_LAST=80,
    BL_IRQ_EXCEPTION_TYPE_STORE_MISALIGN=1,
    ME_STATE_MAX=2,
    RFC_BW_20M=0,
    WDT_INT=0,
    UART_PARITY_EVEN=2,
    BL_AHB_SLAVE1_EFUSE=7,
    GLB_EM_8KB=3,
    TASK_MM=0,
    E_RF_CHANNEL_2476M=18,
    E_RF_MODE_ROSCAL=3,
    E_RF_MODE_TX=1,
    MTIME_IRQn=7,
    RESERVED20=65,
    HW_RATE_6MBPS=4,
    TASK_ME=5,
    CONNECTION_TYPE_PSEUDO=5,
    IPC_DMA_LLI_MAX=12,
    BA_DEV_NONE=2,
    E_RF_BRANCH_Q=1,
    SEC_ENG_AES_USE_NEW=0,
    CONNECTION_TYPE_ADHOC=1,
    MOD_CLASS_HT=8,
    ERR_USE=-8,
    HBN_OUT1_IRQn=68,
    KE_EVT_IPC_EMB_TXDESC_AC3=21,
    C_SIZE=6,
    HBN_32K_RC=0,
    CONNACK_IDENTIFIER_REJECTED_ERROR=2,
    TASK_MAX=14,
    API_AC_BE=1,
    GLB_PLL_XTAL_NONE=0,
    KE_EVT_IPC_EMB_TXDESC_AC2=22,
    KE_EVT_IPC_EMB_TXDESC_AC1=23,
    E_RF_XTAL_24M=0,
    KE_EVT_IPC_EMB_TXDESC_AC0=24,
    SF_CTRL_OWNER_SAHB=0,
    KE_EVT_TXFRAME_CFM=14,
    GPIO_FUN_I2C=6,
    DHCP_STATE_REQUESTING=1,
    DMA_BMX_ERR_IRQn=24,
    GPIO_FUN_JTAG=14,
    BL_AHB_SLAVE1_DBG=3,
    FLAG_LONG=2,
    MEMP_NETCONN=7,
    RFC_BW_10M=1,
    E_RF_MODE_RX=2,
    BL_IRQ_EXCEPTION_TYPE_LOAD_MISALIGN=0,
    TX_DEFAULT_NDPA_BRP=2,
    MACBYP_OFF=0,
    BL_AHB_SLAVE1_L1C=9,
    SCANU_STATE_MAX=2,
    MACBYP_RX=1,
    KE_EVT_IRQ_UP_BH=1,
    GLB_MTIMER_CLK_BCLK=0,
    TX_CUSTOM=4,
    MBEDTLS_PADDING_ONE_AND_ZEROS=1,
    RFC_RC_TX2ON=2,
    MEMP_TCPIP_MSG_INPKT=9,
    GLB_PLL_XTAL_24M=1,
    TASK_HOSTAPD_U=10,
    C_TYPE=7,
    HAL_MM_TIMER=7,
    SEC_ENG_AES_DOUBLE_KEY_128BITS=3,
    TASK_APM=7,
    MBEDTLS_SSL_SERVER_HELLO_DONE=6,
    KE_EVT_KE_TIMER=5,
    TASK_API=13,
    DHCP_STATE_BOUND=10,
    MOD_CLASS_ERP_OFDM=6,
    MBEDTLS_SSL_HANDSHAKE_WRAPUP=15,
    GPIO_INT0_IRQn=60,
    VIF_IBSS=1,
    TX_DEFAULT_NDP=3,
    ERROR=1,
    MAC_RATE_5_5MBPS=11,
    BA_ORIGINATOR=1,
    PS_MODE_ON=1,
    KE_EVT_SECONDARY_TBTT=10,
    SEC_ENG_PKA_REG_SIZE_192=7,
    MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC=12,
    MAC_TXRX_MISC_IRQn=74,
    BLE_IRQn=72,
    DMA_TRNS_WIDTH_16BITS=1,
    IPC_DMA_CHANNEL_CTRL_RX=0,
    TID_MGT=8,
    BL_AHB_SLAVE1_WRAM=15,
    CONNECTION_TYPE_TDLS=6,
    MBEDTLS_SSL_CERTIFICATE_VERIFY=9,
    THD_CHK_STATE=0,
    AC_BE=1,
    shaNull=1,
    E_RF_CHANNEL_2404M=0,
    I2C_IRQn=48,
    AC_BK=0,
    E_RF_CHANNEL_2428M=6,
    MAC_TXRX_TIMER_IRQn=73,
    MEMP_PBUF_POOL=14,
    KE_EVT_IPC_EMB_TXDESC_BCN=20,
    E_RF_CHANNEL_2416M=3,
    DMA_TRNS_WIDTH_32BITS=2,
    ME_IDLE=0,
    SEC_ENG_AES_CTR=1,
    shaStateError=3,
    BL_AHB_SLAVE1_CKS=23,
    KE_EVT_TXCFM_AC1=18,
    VIF_STA=0,
    HW_RATE_54MBPS=11,
    API_AC_VO=3,
    KE_EVT_TXCFM_AC0=19,
    KE_EVT_TXCFM_AC3=16,
    KE_EVT_TXCFM_AC2=17,
    UART_INT_RTO=4,
    AP_ENC_WPA2_WPA=2,
    UART_RX=1,
    BL_AHB_SLAVE1_DMA=12,
    HBN_ROOT_CLK_RC32M=0,
    SEC_CDET_IRQn=26,
    TASK_SCAN=2,
    KE_EVT_DUMP_STATISTIC=26,
    BROADCAST_STA_IDX_MAX=11,
    C_FLAG=5,
    MBEDTLS_PADDING_ZEROS=3,
    FLAG_NEGATIVE=-128,
    HAL_AC0_TIMER=0,
    API_AC_VI=2,
    eSetValueWithoutOverwrite=4,
    DHCP_STATE_OFF=0,
    BL_AHB_SLAVE1_RF=1,
    KE_EVT_TXCFM_BCN=15,
    HAL_IDLE_TIMER=5,
    ATHD_CHK_STATE=1,
    ADC_TSEN_MOD_EXTERNAL_DIODE=1,
    CONNECTION_TYPE_MAX=7,
    IPC_DMA_CHANNEL_CTRL_TX=2,
    UART1_ID=1,
    ERR_ABRT=-13,
    HW_RATE_9MBPS=5,
    FLAG_LEFT=32,
    shaInputTooLong=2,
    BL_AHB_SLAVE1_TMR=21,
    WMM_AC_BK=1,
    MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT=18,
    WMM_AC_BE=0,
    HW_RATE_2MBPS=1,
    KE_EVT_GP_DMA_UL=3,
    MM_IBSS=1,
    IPC_DMA_LLI_DBG_DUMP=10,
    PBUF_TRANSPORT=-74,
    SEC_ENG_AES_ENCRYPTION=0,
    L1C_BMX_ERR_IRQn=18,
    HBN_UART_CLK_160M=1,
    E_RF_MODE_11N=2,
    BL_AHB_SLAVE1_SDU=13,
    MODE_802_11AC_5=6,
    UART0_ID=0,
    VFS_TYPE_FS_DEV=3,
    TIMER_CLKSRC_XTAL=3,
    ERR_RST=-14,
    UART_TX=0,
    MAC_RATE_9MBPS=18,
    MBEDTLS_PADDING_PKCS7=0,
    HAL_AC2_TIMER=2,
    ERR_ARG=-16,
    BA_AGMT_NOT_SUPPORTED=5,
    SEC_TRNG_IRQn=28,
    SEC_PKA_IRQn=27,
    EFUSE_IRQn=42,
    UART_INT_RX_END=1,
    SEC_ENG_PKA_REG_SIZE_32=3,
    PHY_PRIM=0,
    SEC_ENG_INT_PKA=3,
    CO_EMPTY=2,
    C_ZERO=3,
    MBEDTLS_SSL_CERTIFICATE_REQUEST=5,
    RFC_SG_SINGLE_TONE=0,
    E_RF_PHASE=3,
    BL_AHB_SLAVE1_IRR=22,
    SEC_SHA_IRQn=30,
    GLB_ADC_CLK_96M=0,
    DNS_STATE_UNUSED=0,
    MODE_RESERVED=5,
    BL_AHB_SLAVE1_GPIP=2,
    IPC_DMA_LLI_DATA_RX0=5,
    STA_MFP_CAPA=8,
    MODE_802_11N_2_4=3,
    MODE_802_11G=2,
    E_RF_CHANNEL_2424M=5,
    E_RF_CHANNEL_2412M=2,
    PHY_CHNL_BW_20=0,
    E_RF_CHANNEL_2448M=11,
    TIMER_INT_ALL=3,
    E_RF_CHANNEL_2436M=8,
    MODE_802_11B=0,
    MODE_802_11A=1,
    BL_AHB_SLAVE1_SEC=4,
    SEC_GMAC_IRQn=25,
    SEC_ENG_PKA_REG_SIZE_384=9,
    GPIO_FUN_UART=7,
    SEC_ENG_INT_ALL=6,
    SEC_ENG_PKA_REG_SIZE_16=2,
    ERR_INPROGRESS=-5,
    KE_EVT_PRIMARY_TBTT=9,
    UART_TXRX=2,
    TASK_MESH=9,
    CONNACK_CONNECTION_ACCEPTED=0,
    DHCP_STATE_CHECKING=8,
    MASK=1,
    DNS_STATE_NEW=1,
    DHCP_STATE_SELECTING=6,
    MAC_RATE_54MBPS=108,
    SEC_ENG_PKA_REG_SIZE_256=8,
    BL_AHB_SLAVE1_I2C=19,
    E_RF_XTAL_52M=5,
    BL_AHB_SLAVE1_SFC=11,
    PHY_BAND_2G4=0,
    E_RF_XTAL_40M=4,
    CONNECTION_TYPE_INFRA=0,
    CONNACK_UNACCEPTABLE_PROTOCOL_VERSION_ERROR=1,
    ERR_RTE=-4,
    TIMER_INT_COMP_1=1,
    TIMER_INT_COMP_0=0,
    TIMER_INT_COMP_2=2,
    SEC_ENG_AES_KEY_256BITS=1,
    CLIC_SOFT_PEND_IRQn=12,
    SEC_ENG_AES_KEY_128BITS=0,
    GLB_SYS_CLK_PLL120M=3,
    CO_FULL=3,
    GPIO_FUN_SPI=4,
    IPC_DMA_LLI_DATA_BCN_TX=4,
    ERR_BUF=-2,
    MAC_GEN_IRQn=77,
    GLB_PLL_XTAL_40M=4,
    TX_DEFAULT_24G=0,
    FLAG_SHORT=1,
    PHY_CHNL_BW_40=1,
    E_RF_MODE_11B=0,
    SEC_ENG_PKA_REG_SIZE_128=6,
    CO_OP_IN_PROGRESS=9,
    TIMER_CLKSRC_1K=2,
    E_RF_MODE_LO_FCAL=7,
    API_AC_MAX=4,
    MAC_RATE_48MBPS=96,
    SDIO_IRQn=23,
    E_RF_MODE_11G=1,
    E_RF_CHANNEL_NUM=21,
    PBUF_RAW=0,
    KE_EVT_RXUREADY=12,
    MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET=17,
    KE_EVT_RXREADY=13,
    GPIO_FUN_PWM=8,
    GLB_EM_16KB=15,
    MEMP_NETDB=12,
    CONNACK_BAD_USERDATA_ERROR=4,
    HW_RATE_24MBPS=8,
    UART_TX_INT=0,
    TASK_LAST_EMB=12,
    MFP_IN_USE=16,
    PHY_BAND_MAX=2,
    TASK_NONE=-1,
    S_WIDTH=3,
    TCAL_RXGAIN=2,
    TCAL_TXIQ=1,
    BL_AHB_SLAVE1_SPI=18,
    IPC_DMA_LLI_DATA_AC3_TX=3,
    GPIO_FUN_SWGPIO=11,
    PORT_CONTROLED=1,
    MEMP_TCP_SEG=4,
    MBEDTLS_PADDING_NONE=4,
    MEMP_UDP_PCB=1,
    MEMP_SYS_TIMEOUT=11,
    HAL_TIMER_MAX=9,
    FLAG_SIGNED=4,
    BROADCAST_STA_IDX_MIN=10,
    MEMP_IGMP_GROUP=10,
    DMA_ALL_IRQn=31,
    MOD_CLASS_OFDM=7,
    PHY_BAND_5G=1,
    STA_MAX=12,
    SEC_ENG_PKA_REG_SIZE_64=4,
    DMA_UL=1,
    KE_EVT_MM_TIMER=4,
    DMA_INT_TCOMPLETED=0,
    KE_EVT_HW_IDLE=8,
    UART_INT_RX_FIFO_REQ=3,
    MBEDTLS_SSL_SERVER_HELLO=2,
    FAIL=1,
    DHCP_STATE_INIT=2,
    BMX_TO_IRQn=17,
    TIMER_CH0_IRQn=52,
    STA_HT_CAPA=2,
    MEMP_RAW_PCB=0,
    AP_ENC_OPEN=0,
    WIFI_IRQn=70,
    MM_AP=2,
    GLB_SYS_CLK_RC32M=0,
    ERR_ALREADY=-9,
    ERR_CONN=-11,
    TASK_RXU=11,
    HAL_KE_TIMER=8,
    MAC_RATE_2MBPS=4,
    BA_AGMT_TX=0,
    RFC_RC_FORCE_OFF=15,
    KE_EVT_RESET=0,
    MOD_CLASS_ERP_PBCC=4,
    HAL_RX_TIMER=6,
    EF_CTRL_OP_MODE_AUTO=0,
    PS_MODE_ON_DYN=2,
    GLB_PLL_XTAL_38P4M=3,
    FLAG_SIGN_SPACE=16,
    DHCP_STATE_PERMANENT=9,
    S_SIZE=6,
    VFS_TYPE_BLOCK_DEV=2,
    SF_CTRL_IRQn=39,
    HAL_BCN_TIMER=4,
    CO_FAIL=1,
    HBN_UART_CLK_FCLK=0,
    CONTROL_PORT_HOST=1,
    S_DOT=4,
    BA_AGMT_NO_MORE_BA_AGMT=4,
    PBUF_IP=-94,
    UART_INT_TX_FIFO_REQ=2,
    KE_EVT_IPC_EMB_MSG=6,
    RFC_FORMATMOD_11G=1,
    CONNACK_SERVER_UNAVAILABLE_ERROR=3,
    MBEDTLS_SSL_CLIENT_FINISHED=11,
    TASK_SCANU=4,
    BMX_ERR_IRQn=16,
    TASK_DBG=1,
    RFC_FORMATMOD_11N=2,
    MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC=10,
    SEC_ENG_INT_AES=1,
    EF_CTRL_OP_MODE_MANUAL=1,
    RFC_SG_RAMP=2,
    DHCP_STATE_REBOOTING=3,
    STA_OPMOD_NOTIF=16,
    MBEDTLS_SSL_SERVER_CERTIFICATE=3,
    IPC_DMA_LLI_CFM_TX=8,
    PDS_WAKEUP_IRQn=66,
    HW_IDLE=0,
    BA_AGMT_RX=1,
    RF_TOP_INT1_IRQn=22,
    DMA_BURST_SIZE_16=3,
    MAC_RATE_24MBPS=48,
    RFC_PC_AUTO=0,
    BL_AHB_SLAVE1_MAX=24,
    GLB_EM_0KB=0,
    EF_CTRL_PARA_MANUAL=1,
    UART1_IRQn=46,
    ERR_VAL=-6,
    E_RF_MODE_TXCAL=5,
    DHCP_STATE_BACKING_OFF=12,
    CO_NO_ELT_IN_USE=7,
    SEC_ENG_INT_SHA=2,
    HBN_ROOT_CLK_PLL=2,
    PHY_SEC=1,
    IPC_DMA_LLI_DATA_AC2_TX=2,
    IPC_DMA_LLI_GP_DL=9,
    RFC_RC_TX2PAON=4,
    MEMP_TCPIP_MSG_API=8,
    MBEDTLS_SSL_CLIENT_CERTIFICATE=7,
    E_RF_CHANNEL_2408M=1,
    MBEDTLS_PADDING_ZEROS_AND_LEN=2,
    ADC_TSEN_MOD_INTERNAL_DIODE=0,
    BL_IRQ_EXCEPTION_TYPE_ACCESS_ILLEGAL=2,
    PWM_IRQn=50,
    AC_MAX_TYPES=4,
    BZ_PHY_IRQn=71,
    TIMER_CLKSRC_32K=1,
    S_FLAGS=2,
    UART_INT_TX_END=0,
    HW_RATE_5_5MBPS=2,
    E_RF_XTAL_38M4=3,
    MODE_802_11N_5=4,
    VFS_TYPE_NOT_INIT=0,
    STA_QOS_CAPA=1,
    SEC_BMX_ERR_IRQn=20,
    TX_INT=0,
    IPC_DMA_LLI_DATA_AC1_TX=1,
    HBN_OUT0_IRQn=67,
    IPC_DMA_LLI_MSG=6,
    MAC_RATE_1MBPS=2,
    TCAL_RXIQ=3,
    DMA_BURST_SIZE_1=0,
    SEC_ENG_PKA_REG_SIZE_96=5,
    SEC_ENG_INT_GMAC=5,
    GLB_MTIMER_CLK_32K=1,
    RFC_SG_TWO_TONE=1,
    DMA_BURST_SIZE_4=1,
    MACBYP_TX_CONT=4,
    DMA_BURST_SIZE_8=2,
    BOR_IRQn=69,
    INVALID_STA_IDX=-1,
    S_MAX=8,
    SEC_ENG_AES_KEY_192BITS=2,
    eSetValueWithOverwrite=3,
    MEMP_PBUF=13,
    MEXT_IRQn=11,
    IPC_DMA_LLI_DBG=7,
    MACBYP_TX_BURST=3,
    PHY_FORMATMOD_11N=2,
    MAC_RATE_18MBPS=36,
    SCANU_SCANNING=1,
    PHY_FORMATMOD_11B=0,
    HW_RATE_1MBPS=0,
    UART_PARITY_NONE=0,
    PHY_FORMATMOD_11G=1,
    RFC_FORMATMOD_11B=0,
    UART_ID_MAX=2,
    CO_NO_MORE_ELT_AVAILABLE=6
} anon_enum_8.conflictcde;

typedef union anon_union.conflictc3d7 anon_union.conflictc3d7, *Panon_union.conflictc3d7;

union anon_union.conflictc3d7 {
    uint8_t ht[4];
};

typedef long __int32_t;

typedef uint __uintptr_t;

typedef uchar __uint8_t;

typedef char __int8_t;

typedef struct udp_hdr udp_hdr, *Pudp_hdr;

struct udp_hdr {
    u16_t src;
    u16_t dest;
    u16_t len;
    u16_t chksum;
};

typedef struct bl_env_tag bl_env_tag, *Pbl_env_tag;

struct bl_env_tag {
    uint8_t prev_hw_state;
    undefined field_0x1;
    undefined field_0x2;
    undefined field_0x3;
    int hw_in_doze;
};

typedef union anon_union.conflict9f1c anon_union.conflict9f1c, *Panon_union.conflict9f1c;

union anon_union.conflict9f1c {
    uint32_t datastartptr;
    uint32_t sec_user2_ptr;
};

typedef union anon_union.conflict9ef7 anon_union.conflict9ef7, *Panon_union.conflict9ef7;

union anon_union.conflict9ef7 {
    uint32_t first_pbd_ptr;
    uint32_t sec_user1_ptr;
};

typedef union anon_union.conflict9f41 anon_union.conflict9f41, *Panon_union.conflict9f41;

union anon_union.conflict9f41 {
    uint32_t dataendptr;
    uint32_t sec_user3_ptr;
};

typedef enum PtTable_ID_Type {
    PT_TABLE_ID_INVALID=2,
    PT_TABLE_ID_0=0,
    PT_TABLE_ID_1=1
} PtTable_ID_Type;

typedef enum PtTable_Entry_Type {
    PT_ENTRY_MAX=16,
    PT_ENTRY_FW_CPU0=0,
    PT_ENTRY_FW_CPU1=1
} PtTable_Entry_Type;

typedef enum PtTable_Error_Type {
    PT_ERROR_SUCCESS=0,
    PT_ERROR_PARAMETER=5,
    PT_ERROR_ENTRY_NOT_FOUND=2,
    PT_ERROR_TABLE_NOT_VALID=1,
    PT_ERROR_ENTRY_UPDATE_FAIL=3,
    PT_ERROR_FALSH_ERASE=8,
    PT_ERROR_FALSH_WRITE=7,
    PT_ERROR_FALSH_READ=6,
    PT_ERROR_CRC32=4
} PtTable_Error_Type;

typedef struct t_hdr t_hdr, *Pt_hdr;

struct t_hdr {
    struct t_hdr * next;
    u16_t ping_seq;
    undefined field_0x6;
    undefined field_0x7;
    u32_t send_time;
};

typedef struct ping_var ping_var, *Pping_var;

struct ping_var {
    u32_t total_count;
    u32_t requests_count;
    u16_t interval;
    u16_t data_size;
    u16_t seq_num;
    u16_t id;
    u16_t timeout;
    u8_t node_num;
    undefined field_0x13;
    ip_addr_t dest;
    utils_memp_pool_t * pool;
    struct raw_pcb * pcb;
    struct utils_list req_list;
};

typedef struct SubscriptionRecord_t SubscriptionRecord_t, *PSubscriptionRecord_t;

struct SubscriptionRecord_t {
    char Topic[80];
    uint8_t count;
    _Bool isFree;
    _Bool isSticky;
};

typedef struct ToBeReceivedAckRecord_t ToBeReceivedAckRecord_t, *PToBeReceivedAckRecord_t;

struct ToBeReceivedAckRecord_t {
    char clientTokenID[90];
    char thingName[20];
    enum ShadowActions_t action;
    undefined field_0x6f;
    void (* callback)(char *, enum ShadowActions_t, enum Shadow_Ack_Status_t, char *, void *);
    void * pCallbackContext;
    _Bool isFree;
    undefined field_0x79;
    undefined field_0x7a;
    undefined field_0x7b;
    struct Timer timer;
};

typedef struct JsonTokenTable_t JsonTokenTable_t, *PJsonTokenTable_t;

struct JsonTokenTable_t {
    char * pKey;
    void * pStruct;
    void (* callback)(char *, uint32_t, jsonStruct_t *);
    _Bool isFree;
    undefined field_0xd;
    undefined field_0xe;
    undefined field_0xf;
};

typedef enum ShadowAckTopicTypes_t {
    SHADOW_REJECTED=1,
    SHADOW_ACCEPTED=0,
    SHADOW_ACTION=2
} ShadowAckTopicTypes_t;

typedef enum _blog_leve {
    BLOG_LEVEL_ASSERT=5,
    BLOG_LEVEL_NEVER=6,
    BLOG_LEVEL_ERROR=4,
    BLOG_LEVEL_DEBUG=1,
    BLOG_LEVEL_INFO=2,
    BLOG_LEVEL_ALL=0,
    BLOG_LEVEL_WARN=3
} _blog_leve;

typedef enum _blog_leve blog_level_t;

typedef struct _blog_info _blog_info, *P_blog_info;

typedef struct _blog_info blog_info_t;

struct _blog_info {
    blog_level_t * level;
    char * name;
};

typedef enum Elf_ProgramHeaderType_RISCV {
    PT_GNU_STACK=1685382481,
    PT_NOTE=4,
    PT_INTERP=3,
    PT_PHDR=6,
    PT_LOAD=1,
    PT_NULL=0,
    PT_DYNAMIC=2,
    PT_SHLIB=5,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_RELRO=1685382482,
    PT_TLS=7
} Elf_ProgramHeaderType_RISCV;

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_RISCV {
    SHT_SYMTAB=2,
    SHT_GNU_versym=1879048191,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_LIBLIST=1879048183,
    SHT_FINI_ARRAY=15,
    SHT_GROUP=17,
    SHT_CHECKSUM=1879048184,
    SHT_SHLIB=10,
    SHT_ANDROID_RELA=1610612738,
    SHT_NOBITS=8,
    SHT_GNU_HASH=1879048182,
    SHT_REL=9,
    SHT_SYMTAB_SHNDX=18,
    SHT_HASH=5,
    SHT_PROGBITS=1,
    SHT_ANDROID_REL=1610612737,
    SHT_NULL=0,
    SHT_GNU_verneed=1879048190,
    SHT_INIT_ARRAY=14,
    SHT_NOTE=7,
    SHT_PREINIT_ARRAY=16,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_SUNW_COMDAT=1879048187,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_DYNSYM=11,
    SHT_SUNW_syminfo=1879048188,
    SHT_DYNAMIC=6,
    SHT_SUNW_move=1879048186
} Elf_SectionHeaderType_RISCV;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_RISCV sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_RISCV p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




// WARNING: Removing unreachable block (ram,0x230000d8)

void bl602_start(void)

{
  undefined4 *puVar1;
  uint32_t *puVar2;
  int *piVar3;
  ipc_shared_env_tag *piVar4;
  anon_struct_conflict1ae139 *paVar5;
  anon_struct_conflict1ba5ac *paVar6;
  code *pcVar7;
  
  puVar1 = (undefined4 *)(ram_heap + 0x1c40);
  paVar5 = &boot2_partition_table;
  do {
    *(undefined4 *)paVar5 = *puVar1;
    puVar1 = puVar1 + 1;
    paVar5 = (anon_struct_conflict1ae139 *)&paVar5->table;
  } while (paVar5 < &boot2_flashCfg);
  puVar2 = (uint32_t *)hal_boot2_get_flash_addr();
  paVar6 = &boot2_flashCfg;
  do {
    paVar6->magic = *puVar2;
    puVar2 = puVar2 + 1;
    paVar6 = (anon_struct_conflict1ba5ac *)&paVar6->flashCfg;
  } while (paVar6 < &cb_altcp_recv_fn::count);
  puVar1 = (undefined4 *)&_bl_static_blogfile_code_end;
  pcVar7 = AON_Power_On_BG;
  do {
    *(undefined4 *)pcVar7 = *puVar1;
    puVar1 = puVar1 + 1;
    pcVar7 = (code *)((int)pcVar7 + 4);
  } while (pcVar7 < &boot2_partition_table);
  piVar3 = &cb_altcp_recv_fn::count;
  do {
    *piVar3 = 0;
    piVar3 = piVar3 + 1;
  } while (piVar3 < &__bss_end);
  piVar4 = &ipc_shared_env;
  do {
    (piVar4->msg_a2e_buf).dummy_word = 0;
    piVar4 = (ipc_shared_env_tag *)(piVar4->msg_a2e_buf).msg;
  } while (piVar4 < (ipc_shared_env_tag *)&_heap_wifi_start);
  DAT_42041ff8 = 0x230000e8;
  bfl_main();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



err_t cb_httpc_headers_done_fn
                (httpc_state_t *connection,void *arg,pbuf *hdr,u16_t hdr_len,u32_t content_len)

{
  undefined2 in_register_00002036;
  
  printf("[HTTPC] hdr_len is %u, content_len is %lu\r\n",CONCAT22(in_register_00002036,hdr_len),
         content_len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void cb_httpc_result(void *arg,httpc_result_t httpc_result,u32_t rx_content_len,u32_t srv_res,
                    err_t err)

{
  printf("[HTTPC] Transfer finished. rx_content_len is %lu\r\n",rx_content_len);
  *(undefined4 *)arg = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t cb_altcp_recv_fn(void *arg,altcp_pcb *conn,pbuf *p,err_t err)

{
  int iVar1;
  uint uVar2;
  
  puts(".");
  iVar1 = cb_altcp_recv_fn::count + 1;
  uVar2 = cb_altcp_recv_fn::count & 0x3f;
  cb_altcp_recv_fn::count = iVar1;
  if (uVar2 == 0) {
    puts("\r\n");
  }
  altcp_recved(conn,p->tot_len);
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void cmd_stack_wifi(char *buf,int len,int argc,char **argv)

{
  uint32_t uVar1;
  
  if (cmd_stack_wifi::stack_wifi_init == '\x01') {
    puts("Wi-Fi Stack Started already!!!\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  cmd_stack_wifi::stack_wifi_init = '\x01';
  uVar1 = bl_timer_now_us();
  printf("Start Wi-Fi fw @%lums\r\n",uVar1 / 1000);
  hal_wifi_start_firmware_task();
  uVar1 = bl_timer_now_us();
  printf("Start Wi-Fi fw is Done @%lums\r\n",uVar1 / 1000);
  aos_post_event(2,1,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_exception_illegal_ins(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_ILLEGAL_INSTRUCTION,(void *)0x22008001);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_exception_store(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_STORE_MISALIGN,(void *)0x22008001);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_exception_l_illegal(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_ACCESS_ILLEGAL,(void *)0x200000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_exception_load(char *buf,int len,int argc,char **argv)

{
  bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_LOAD_MISALIGN,(void *)0x22008001);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_dma(void)

{
  bl_dma_item *first;
  void *__s;
  void *__s_00;
  TickType_t TVar1;
  
  first = (bl_dma_item *)pvPortMalloc(0x1c);
  __s = pvPortMalloc(0x44);
  __s_00 = pvPortMalloc(0x44);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [TEST] [DMA] first %p, src %p, dst %p\r\n",TVar1,&DAT_2307f16c,
              "bl_dma.c",0x1af,first,__s,__s_00);
  }
  memset(first,0,0x1c);
  memset(__s,1,0x44);
  memset(__s_00,0xff,0x44);
  first->ctrl = 0x8c49b011;
  first->src = (uint32_t)__s;
  first->dst = (uint32_t)__s_00;
  first->next = 0;
  first->cb = _cb_cmd;
  first->arg = first;
  bl_dma_copy(first);
  while (first->arg != (void *)0x0) {
    vTaskDelay(2);
  }
  vPortFree((void *)first->src);
  vPortFree((void *)first->dst);
  vPortFree(first);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int cmd_cks(void)

{
  TickType_t TVar1;
  char *pcVar2;
  undefined *puVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  undefined2 uStack128;
  ushort uStack126;
  undefined4 uStack124;
  undefined4 uStack120;
  bl_dma_item bStack116;
  undefined auStack88 [4];
  undefined4 uStack84;
  undefined4 uStack80;
  undefined2 *puStack76;
  undefined *puStack72;
  undefined **ppuStack68;
  undefined4 uStack64;
  undefined auStack60 [4];
  undefined4 uStack56;
  undefined4 uStack52;
  undefined *puStack48;
  ushort *puStack44;
  undefined4 uStack40;
  undefined4 uStack36;
  
  puStack76 = &uStack128;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case1 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x137);
  }
  DAT_4000a700 = 1;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with LE is %04x, should be %02x%02x\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0x40,uVar6,0x61,0xb8);
  }
  DAT_4000a700 = 2;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with BE is %04x, should be %02x%02x\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0x48,uVar6,0x61,0xb8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case2 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x139);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0x61,uVar6,0xc0e0);
  }
  DAT_4000a700 = 2;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
                0x73,uVar6,0xc0e0);
      if (uVar6 != 0xc0e0) goto LAB_2303332e;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032c88;
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc0e0;
      uVar4 = 0x75;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_23032c7a:
      bl_printk(pcVar2,TVar1,&DAT_2307f16c,"bl_cks.c",uVar4,uVar6);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case3 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13b);
      }
    }
    else {
      if (uVar6 != 0xc0e0) goto LAB_23033338;
    }
  }
  else {
    if (uVar6 != 0xc0e0) {
LAB_2303332e:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23033338:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar1 = xTaskGetTickCount();
          }
          else {
            TVar1 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0x77;
          pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_23032c7a;
        }
      }
    }
  }
LAB_23032c88:
  DAT_4000a700 = 1;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0x91,uVar7,~uVar6 & 0xffff);
  }
  DAT_4000a700 = 2;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0xa3,uVar7,~uVar6 & 0xffff);
  }
  if (uVar7 == (~uVar6 & 0xffff)) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa5;
      puVar3 = &DAT_2307f16c;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230330f0:
      bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,uVar7);
      goto LAB_230330f4;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa7;
      puVar3 = &DAT_23072bcc;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
      goto LAB_230330f0;
    }
LAB_230330f4:
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case4 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13d);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0xc4,uVar6,0xc03f);
  }
  DAT_4000a700 = 2;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
                0xd8,uVar6,0xc03f);
      if (uVar6 != 0xc03f) goto LAB_230332da;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032ef6;
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc03f;
      uVar4 = 0xda;
      puVar3 = &DAT_2307f16c;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230331c2:
      bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,uVar6);
LAB_230331c6:
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case5 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13f);
      }
    }
    else {
      if (uVar6 != 0xc03f) goto LAB_230332e4;
    }
  }
  else {
    if (uVar6 != 0xc03f) {
LAB_230332da:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
LAB_230332e4:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT) {
          if (TrapNetCounter == 0) {
            TVar1 = xTaskGetTickCount();
          }
          else {
            TVar1 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0xdc;
          puVar3 = &DAT_23072bcc;
          pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_230331c2;
        }
      }
      goto LAB_230331c6;
    }
  }
LAB_23032ef6:
  bStack116.arg = &bStack116;
  uStack128 = 0x3f1f;
  uStack124 = 1;
  uStack120 = 2;
  uStack126 = 0;
  memset(bStack116.arg,0,0x1c);
  memset(auStack88,0,0x1c);
  memset(auStack60,0,0x1c);
  bStack116.src = (uint32_t)&uStack124;
  bStack116.dst = (uint32_t)&DAT_4000a700;
  bStack116.next = (uint32_t)&puStack76;
  bStack116.ctrl = 0x4480002;
  bStack116.cb = _cb_cmd;
  puStack72 = &DAT_4000a704;
  puStack48 = &DAT_4000a708;
  ppuStack68 = &puStack48;
  puStack44 = &uStack126;
  uStack64 = 0x403e8;
  uStack84 = 0;
  uStack80 = 0;
  uStack40 = 0;
  uStack36 = 0x80240001;
  uStack56 = 0;
  uStack52 = 0;
  bl_dma_copy((bl_dma_item *)bStack116.arg);
  while ((bl_dma_item *)bStack116.arg != (bl_dma_item *)0x0) {
    vTaskDelay(2);
  }
  if (uStack126 == 0x6df1) {
    if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks))
    goto LAB_23032fea;
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    uVar4 = 0x12f;
    puVar3 = &DAT_2307f16c;
    pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
  }
  else {
    if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) || (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_cks)
       ) goto LAB_23032fea;
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    uVar4 = 0x131;
    puVar3 = &DAT_23072bcc;
    pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
  }
  bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,(uint)uStack126);
LAB_23032fea:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int cmd_aes(void)

{
  bl_irq_register(0x1d,bl_sec_aes_IRQHandler);
  bl_irq_enable(0x1d);
  bl_printk(
           "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n"
           );
  Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID0);
  bl_printk(
           "------------------------------------------------------------------------------------\r\n"
           );
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int cmd_trng(void)

{
  int iVar1;
  
  bl_printk("------------------TRNG TEST---------------------------------\r\n");
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  bl_printk("------------------------------------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int cmd_sha(void)

{
  puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  puts("^^^^^^^^^^^^^^^^^^^^^^^SHA256 TEST CASE^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  sha256_test_case0();
  puts("------------------------------------------------------------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wifi(void)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  
  uVar1 = _DAT_44b000d8;
  puts("==========================  Keyram Config ========================\r\n");
  printf("  start %02u -->> end %02u; nVAP %02u; max %02u\r\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,
         uVar1 >> 0x10 & 0xff,uVar1 >> 0x18);
  puts("==========================  Keyram Dump =========================\r\n");
  uVar1 = _DAT_44b000d8 >> 8;
  puts("[id]   MAC Address     Key Len  VLan ID  Default      \tKey Hexdump(16Bytes MAX)\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uVar1 & 0xff)) {
    blmac_encr_cntrl_pack('\x01','\0',(uint16_t)iVar3,'\0','\0','\0','\0','\0');
    do {
    } while ((int)_DAT_44b000c4 < 0);
    printf("[%02d] %02X:%02X:%02X:%02X:%02X:%02X",iVar3,_DAT_44b000bc & 0xff,
           _DAT_44b000bc >> 8 & 0xff,_DAT_44b000bc >> 0x10 & 0xff,_DAT_44b000bc >> 0x18,
           _DAT_44b000c0 & 0xff,_DAT_44b000c0 >> 8 & 0xff);
    puVar2 = &UNK_230743ec;
    if ((_DAT_44b000c4 & 1) == 0) {
      puVar2 = &UNK_230743f4;
    }
    printf(" %s",puVar2);
    iVar3 = iVar3 + 1;
    printf("    %02u",_DAT_44b000c4 >> 4 & 0xf);
    printf("        %u",_DAT_44b000c4 >> 1 & 1);
    printf("     %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
           _DAT_44b000ac & 0xff,_DAT_44b000ac >> 8 & 0xff,_DAT_44b000ac >> 0x10 & 0xff,
           _DAT_44b000ac >> 0x18,_DAT_44b000b0 & 0xff,_DAT_44b000b0 >> 8 & 0xff,
           _DAT_44b000b0 >> 0x10 & 0xff);
    puts("\r\n");
  }
  puts("==========================  MAC Address =========================\r\n");
  printf("    MAC %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00010 & 0xff,_DAT_44b00010 >> 8 & 0xff,
         _DAT_44b00010 >> 0x10 & 0xff,_DAT_44b00010 >> 0x18,_DAT_44b00014 & 0xff,
         _DAT_44b00014 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00018 & 0xff,_DAT_44b00018 >> 8 & 0xff,
         _DAT_44b00018 >> 0x10 & 0xff,_DAT_44b00018 >> 0x18,_DAT_44b0001c & 0xff,
         _DAT_44b0001c >> 8 & 0xff);
  puts("\r\n");
  printf("  BSSID %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00020 & 0xff,_DAT_44b00020 >> 8 & 0xff,
         _DAT_44b00020 >> 0x10 & 0xff,_DAT_44b00020 >> 0x18,_DAT_44b00024 & 0xff,
         _DAT_44b00024 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00028 >> 8 & 0xff,
         _DAT_44b00028 >> 0x10 & 0xff,_DAT_44b00028 >> 0x18,_DAT_44b0002c & 0xff,
         _DAT_44b0002c >> 8 & 0xff);
  puts("\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int cmd_pka(void)

{
  bl_irq_register(0x1b,bl_sec_pka_IRQHandler);
  bl_irq_enable(0x1b);
  _pka_test_case2(DAT_00000010);
  _pka_test_case_xgcd();
  _pka_test_case2(DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cmd_aws(char *buf,int len,int argc,char **argv)

{
  xTaskCreate(aws_main_entry,"aws_iot",0x1000,(void *)0x0,10,(TaskHandle_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void proc_hellow_entry(void *pvParameters)

{
  vTaskDelay(500);
  do {
    printf("%s: RISC-V rv32imafc\r\n","proc_hellow_entry");
    vTaskDelay(10000);
  } while( true );
}



uchar char_to_hex(char asccode)

{
  byte bVar1;
  
  bVar1 = asccode - 0x30;
  if (9 < bVar1) {
    if ((byte)(asccode + 0x9fU) < 6) {
      bVar1 = asccode + 0xa9;
    }
    else {
      bVar1 = 0;
      if ((byte)(asccode + 0xbfU) < 6) {
        bVar1 = asccode - 0x37;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uchar)bVar1;
}



void cmd_httpc_test(char *buf,int len,int argc,char **argv)

{
  if (req_12703 != 0) {
    printf("[CLI] req is on-going...\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memset(settings_12702,0,0x1c);
  settings_12702._20_4_ = cb_httpc_result;
  settings_12702._24_4_ = cb_httpc_headers_done_fn;
  settings_12702[6] = 0;
  httpc_get_file_dns("nf.cr.dandanman.com",0x50,"/ddm/ContentResource/music/204.mp3",
                     (httpc_connection_t_conflict *)settings_12702,cb_altcp_recv_fn,&req_12703,
                     (httpc_state_t **)&req_12703);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int get_dts_addr(char *name)

{
  TickType_t TVar1;
  
  if (TrapNetCounter == 0) {
    TVar1 = xTaskGetTickCount();
  }
  else {
    TVar1 = xTaskGetTickCountFromISR();
  }
  bl_printk("[%10u][%s: %s:%4d] %s NULL.\r\n",TVar1,&DAT_23072bcc,&UNK_23072bc4,0x322,name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

int client_demo(void)

{
  uint uVar1;
  hostent *phVar2;
  char *pcVar3;
  int s;
  int iVar4;
  TickType_t TVar5;
  void *mem;
  uint uVar6;
  TickType_t TVar7;
  char cVar8;
  ip4_addr_t iStack308;
  uint32_t address;
  sockaddr_in dest;
  char wbuf [111];
  char buffer [128];
  
  phVar2 = lwip_gethostbyname("nf.cr.dandanman.com");
  if (phVar2 == (hostent *)0x0) {
    pcVar3 = "gethostbyname Failed\r\n";
  }
  else {
    s = lwip_socket(2,1,0);
    if (s < 0) {
      pcVar3 = "Error in socket\r\n";
    }
    else {
      memset(&address,0,0x10);
      address._1_1_ = '\x02';
      address._2_2_ = lwip_htons(0x50);
      iStack308 = ((ip4_addr_t *)((ip4_addr_t *)phVar2->h_addr_list)->addr)->addr;
      dest._0_4_ = (ip4_addr_t)iStack308;
      pcVar3 = ip4addr_ntoa(&iStack308);
      printf("Server ip Address : %s\r\n",pcVar3);
      iVar4 = lwip_connect(s,(sockaddr *)&address,0x10);
      if (iVar4 == 0) {
        memset(wbuf + 0x6c,0,0x80);
        memcpy(dest.sin_zero + 4,
                              
               "GET /ddm/ContentResource/music/204.mp3 HTTP/1.1\r\nHost: nf.cr.dandanman.com\r\nUser-Agent: wmsdk\r\nAccept: */*\r\n\r\n"
               ,0x6f);
        lwip_write(s,dest.sin_zero + 4,0x6e);
        TVar5 = xTaskGetTickCount();
        mem = pvPortMalloc(0x3000);
        if (mem != (void *)0x0) {
          uVar1 = 0;
          cVar8 = '\0';
          do {
            uVar6 = lwip_read(s,mem,0x3000);
            if (uVar6 == 0) {
              printf("eof\n\r",0);
              goto LAB_230006f2;
            }
            if ((int)uVar6 < 0) {
              pcVar3 = "ret = %d, err = %d\n\r";
              uVar1 = errno;
              goto LAB_23000718;
            }
            uVar1 = uVar1 + uVar6;
            if (cVar8 == '\0') {
              printf("total = %d, ret = %d\n\r",uVar1,uVar6);
            }
            cVar8 = cVar8 + '\x01';
          } while ((int)uVar1 < 0x4e3fbd1);
          TVar7 = xTaskGetTickCount();
          uVar6 = (TVar7 - TVar5) / 1000;
          pcVar3 = "Download comlete, total time %u s, speed %u Kbps\r\n";
          uVar1 = (uVar1 / uVar6 << 3) / 1000;
LAB_23000718:
          printf(pcVar3,uVar6,uVar1);
LAB_230006f2:
          vPortFree(mem);
        }
        lwip_close(s);
        return 0;
      }
      pcVar3 = "Error in connect\r\n";
    }
  }
  printf(pcVar3);
  return -1;
}



// WARNING: Type propagation algorithm not settling

int http_test_cmd(void)

{
  uint uVar1;
  hostent *phVar2;
  char *pcVar3;
  int s;
  TickType_t TVar4;
  void *mem;
  uint uVar5;
  TickType_t TVar6;
  int iVar7;
  char cVar8;
  ip4_addr_t iStack308;
  undefined auStack304 [4];
  ip4_addr_t iStack300;
  undefined auStack288 [112];
  undefined auStack176 [136];
  
  phVar2 = lwip_gethostbyname("nf.cr.dandanman.com");
  if (phVar2 == (hostent *)0x0) {
    pcVar3 = "gethostbyname Failed\r\n";
  }
  else {
    s = lwip_socket(2,1,0);
    if (s < 0) {
      pcVar3 = "Error in socket\r\n";
    }
    else {
      memset(auStack304,0,0x10);
      auStack304[1] = '\x02';
      auStack304._2_2_ = lwip_htons(0x50);
      iStack308 = ((ip4_addr_t *)((ip4_addr_t *)phVar2->h_addr_list)->addr)->addr;
      iStack300 = iStack308;
      pcVar3 = ip4addr_ntoa(&iStack308);
      printf("Server ip Address : %s\r\n",pcVar3);
      iVar7 = lwip_connect(s,(sockaddr *)auStack304,0x10);
      if (iVar7 == 0) {
        memset(auStack176,0,0x80);
        memcpy(auStack288,
                              
               "GET /ddm/ContentResource/music/204.mp3 HTTP/1.1\r\nHost: nf.cr.dandanman.com\r\nUser-Agent: wmsdk\r\nAccept: */*\r\n\r\n"
               ,0x6f);
        lwip_write(s,auStack288,0x6e);
        TVar4 = xTaskGetTickCount();
        mem = pvPortMalloc(0x3000);
        if (mem != (void *)0x0) {
          uVar1 = 0;
          cVar8 = '\0';
          do {
            uVar5 = lwip_read(s,mem,0x3000);
            if (uVar5 == 0) {
              printf("eof\n\r",0);
              goto LAB_230006f2;
            }
            if ((int)uVar5 < 0) {
              pcVar3 = "ret = %d, err = %d\n\r";
              uVar1 = errno;
              goto LAB_23000718;
            }
            uVar1 = uVar1 + uVar5;
            if (cVar8 == '\0') {
              printf("total = %d, ret = %d\n\r",uVar1,uVar5);
            }
            cVar8 = cVar8 + '\x01';
          } while ((int)uVar1 < 0x4e3fbd1);
          TVar6 = xTaskGetTickCount();
          uVar5 = (TVar6 - TVar4) / 1000;
          pcVar3 = "Download comlete, total time %u s, speed %u Kbps\r\n";
          uVar1 = (uVar1 / uVar5 << 3) / 1000;
LAB_23000718:
          printf(pcVar3,uVar5,uVar1);
LAB_230006f2:
          vPortFree(mem);
        }
        lwip_close(s);
        goto LAB_230005f2;
      }
      pcVar3 = "Error in connect\r\n";
    }
  }
  printf(pcVar3);
  iVar7 = -1;
LAB_230005f2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar7;
}



void aos_loop_proc(void *pvParameters)

{
  void *fdt;
  void *pvVar1;
  int iVar2;
  void *dtb_offset;
  aos_poll_call_t *cb;
  yloop_sock_t *pyVar3;
  void *pvVar4;
  
  looprt_start(aos_loop_proc::proc_stack_looprt,0x200,&aos_loop_proc::proc_task_looprt);
  loopset_led_hook_on_looprt();
  easyflash_init();
  vfs_init();
  vfs_device_init();
  fdt = (void *)hal_board_get_factory_addr();
  pvVar1 = (void *)fdt_subnode_offset(fdt,0,"uart");
  if (pvVar1 == (void *)0x0) {
    iVar2 = get_dts_addr("uart");
    fdt = pvVar1;
    pvVar4 = (void *)0x0;
    if (iVar2 != 0) goto LAB_230007c6;
    fdt = (void *)0x0;
  }
  vfs_uart_init((uint32_t)fdt,(uint32_t)pvVar1);
  pvVar4 = pvVar1;
LAB_230007c6:
  pvVar1 = (void *)hal_board_get_factory_addr();
  dtb_offset = (void *)fdt_subnode_offset(pvVar1,0,"gpio");
  if ((dtb_offset != (void *)0x0) ||
     (iVar2 = get_dts_addr("gpio"), pvVar1 = fdt, dtb_offset = pvVar4, iVar2 == 0)) {
    hal_gpio_init_from_dts((uint32_t)pvVar1,(uint32_t)dtb_offset);
  }
  romfs_register();
  aos_loop_init();
  iVar2 = aos_open("/dev/ttyS0",0);
  if (-1 < iVar2) {
    printf("Init CLI with event Driven\r\n");
    aos_cli_init(0);
    cb = (aos_poll_call_t *)aos_cli_event_cb_read_get();
    aos_poll_read_fd(iVar2,cb,(void *)0x12345678);
    codex_debug_cli_init();
    easyflash_cli_init();
    network_netutils_iperf_cli_register();
    network_netutils_tcpserver_cli_register();
    network_netutils_tcpclinet_cli_register();
    network_netutils_netstat_cli_register();
    network_netutils_ping_cli_register();
    sntp_cli_init();
    bl_sys_time_cli_init();
    bl_sys_ota_cli_init();
    blfdt_cli_init();
    wifi_mgmr_cli_init();
    bl_wdt_cli_init();
    bl_gpio_cli_init();
    looprt_test_cli_init();
  }
  aos_register_event_filter(2,event_cb_wifi_event,(void *)0x0);
  pyVar3 = (yloop_sock_t *)0x0;
  cmd_stack_wifi((char *)0x0,0,0,(char **)0x0);
  aos_loop_run(pyVar3);
  puts("------------------------------------------\r\n");
  puts("+++++++++Critical Exit From Loop++++++++++\r\n");
  puts("******************************************\r\n");
  vTaskDelete((TaskHandle_t)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vApplicationStackOverflowHook(TaskHandle_t xTask,char *pcTaskName)

{
  puts("Stack Overflow checked\r\n");
  printf("Task Name %s\r\n",pcTaskName);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationMallocFailedHook(void)

{
  size_t sVar1;
  
  sVar1 = xPortGetFreeHeapSize();
  printf("Memory Allocate Failed. Current left size is %d bytes\r\n",sVar1);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void vApplicationIdleHook(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: sta_info

int check_dts_config(char *ssid,char *password)

{
  int iVar1;
  int iVar2;
  undefined auStack116 [4];
  bl_wifi_ap_info_t sta_info;
  
  iVar2 = bl_wifi_sta_info_get((bl_wifi_ap_info_t *)auStack116);
  iVar1 = -1;
  if (iVar2 == 0) {
    strncpy(ssid,auStack116,0x20);
    ssid[0x1f] = '\0';
    strncpy(password,(char *)(sta_info.ssid + 0x1d),0x40);
    password[0x3f] = '\0';
    iVar1 = iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void _connect_wifi(undefined4 param_1)

{
  bool bVar1;
  int iVar2;
  uint8_t *puVar3;
  char *__dest;
  uchar uVar4;
  uchar uVar5;
  wifi_interface_t pvVar6;
  char *pcVar7;
  size_t sVar8;
  size_t sVar9;
  size_t sVar10;
  undefined3 extraout_var;
  char *__src;
  uint16_t freq;
  int iVar11;
  uint uVar12;
  int iVar13;
  char *__dest_00;
  longlong lVar14;
  byte abStack340 [4];
  uint8_t mac [6];
  char chan [10];
  char bssid [32];
  char ssid [33];
  char pmk [66];
  char password [66];
  char val_buf [66];
  
  pvVar6 = wifi_mgmr_sta_enable();
  wifi_interface = pvVar6;
  lVar14 = aos_now_ms();
  __dest = ssid + 0x20;
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]   Get STA %p from Wi-Fi Mgmr, pmk ptr %p, ssid ptr %p, password %p\r\n"
         ,pvVar6,param_1,wifi_interface,__dest,bssid + 0x1c,pmk + 0x40,(int)lVar14);
  memset(__dest,0,0x42);
  memset(bssid + 0x1c,0,0x21);
  memset(pmk + 0x40,0,0x42);
  __dest_00 = chan + 8;
  memset(__dest_00,0,0x20);
  memset(abStack340,0,6);
  memset(mac + 4,0,10);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_ssid",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] == '\0') {
    pcVar7 = pmk + 0x40;
    sVar9 = check_dts_config(bssid + 0x1c,pcVar7);
    freq = 0;
    if (sVar9 != 0) {
      puts("[APP]    Empty Config\r\n");
      puts("[APP]    Try to set the following ENV with psm_set command, then reboot\r\n");
      puts("[APP]    NOTE: conf_ap_pmk MUST be psm_unset when conf is changed\r\n");
      puts("[APP]    env: conf_ap_ssid\r\n");
      puts("[APP]    env: conf_ap_psk\r\n");
      puts("[APP]    env(optinal): conf_ap_pmk\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    goto LAB_23000b88;
  }
  strncpy(bssid + 0x1c,password + 0x40,0x20);
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_psk",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    strncpy(pmk + 0x40,password + 0x40,0x41);
  }
  memset(password + 0x40,0,0x42);
  __src = password + 0x40;
  pcVar7 = (char *)ef_get_env_blob("conf_ap_pmk",__src,0x41,(size_t *)0x0);
  if (password[64] != '\0') {
    __src = password + 0x40;
    pcVar7 = strncpy(__dest,__src,0x41);
  }
  if (ssid[32] == '\0') {
    lVar14 = aos_now_ms();
    printf("[APP] [WIFI] [T] %lld\r\n",pcVar7,__src,(int)lVar14);
    puts("[APP]    Re-cal pmk\r\n");
    sVar8 = strlen(bssid + 0x1c);
    wifi_mgmr_psk_cal(pmk + 0x40,bssid + 0x1c,sVar8,__dest);
    ef_set_env("conf_ap_pmk",__dest);
    ef_save_env();
  }
  memset(password + 0x40,0,0x42);
  ef_get_env_blob("conf_ap_channel",password + 0x40,0x41,(size_t *)0x0);
  if (password[64] == '\0') {
LAB_23000b00:
    freq = 0;
    uVar4 = '\0';
  }
  else {
    strncpy((char *)(mac + 4),password + 0x40,9);
    printf("connect wifi channel = %s\r\n",mac + 4);
    pcVar7 = strchr((char *)(mac + 4),0x7c);
    if (pcVar7 + 1 == (char *)0x0) goto LAB_23000b00;
    iVar13 = 1;
    iVar11 = 0;
    uVar4 = char_to_hex(pcVar7[1]);
    sVar8 = strlen((char *)(mac + 4));
    sVar10 = strlen(pcVar7 + 1);
    iVar2 = sVar8 - sVar10;
    mac[iVar2 + 3] = '\0';
    uVar12 = 0;
    puVar3 = mac + iVar2 + 4;
    while( true ) {
      freq = (uint16_t)uVar12;
      if (iVar2 + -1 <= iVar11) break;
      iVar11 = iVar11 + 1;
      uVar5 = char_to_hex(puVar3[-2]);
      uVar12 = uVar12 + CONCAT31(extraout_var,uVar5) * iVar13 & 0xffff;
      iVar13 = iVar13 * 10;
      puVar3 = puVar3 + -1;
    }
  }
  memset(password + 0x40,0,0x42);
  pcVar7 = password + 0x40;
  sVar9 = ef_get_env_blob("conf_ap_bssid",pcVar7,0x41,(size_t *)0x0);
  bVar1 = password[64] != '\0';
  password[64] = uVar4;
  if (bVar1) {
    strncpy(__dest_00,password + 0x40,0x1f);
    printf("connect wifi bssid = %s\r\n",__dest_00);
    sVar8 = strlen(__dest_00);
    if ((sVar8 & 1) != 0) {
      sVar8 = sVar8 - (int)sVar8 % 2;
    }
    if (sVar8 != 0) {
      uVar12 = 0;
      while ((int)uVar12 < (int)sVar8) {
        uVar4 = char_to_hex(*__dest_00);
        uVar5 = char_to_hex(__dest_00[1]);
        abStack340[uVar12 >> 1] = uVar4 * '\x10' + uVar5;
        uVar12 = uVar12 + 2;
        __dest_00 = __dest_00 + 2;
      }
    }
    pcVar7 = (char *)(uint)abStack340[0];
    sVar9 = printf("mac = %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)abStack340[1],(uint)abStack340[2]
                   ,(uint)abStack340[3],(uint)mac[0],(uint)mac[1]);
  }
LAB_23000b88:
  aos_now_ms();
  sVar8 = strlen(bssid + 0x1c);
  sVar10 = strlen(pmk + 0x40);
  printf(
         "[APP] [WIFI] [T] %lld\r\n[APP]    SSID %s\r\n[APP]    SSID len %d\r\n[APP]    password %s\r\n[APP]    password len %d\r\n[APP]    pmk %s\r\n[APP]    bssid %s\r\n[APP]    channel band %d\r\n[APP]    channel freq %d\r\n"
         ,sVar9,pcVar7,bssid + 0x1c,sVar8,pmk + 0x40,sVar10);
  wifi_mgmr_sta_connect
            ((wifi_interface_t *)wifi_interface,bssid + 0x1c,pmk + 0x40,__dest,abStack340,
             password[64],freq);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void event_cb_wifi_event(input_event_t *event,void *private_data)

{
  ushort uVar1;
  char **ppcVar2;
  uint32_t uVar3;
  size_t sVar4;
  wifi_interface_t *wifi_interface;
  input_event_t *piVar5;
  char *pcVar6;
  void *pvVar7;
  char *pcVar8;
  undefined4 uVar9;
  longlong lVar10;
  
  uVar1 = event->code;
  piVar5 = event;
  switch(uVar1 - 1 & 0xffff) {
  case 0:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] INIT DONE %lld\r\n",event,private_data,(int)lVar10);
    wifi_mgmr_start_background(&conf);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 1:
    aos_now_ms();
    pvVar7 = private_data;
    uVar3 = bl_timer_now_us();
    printf("[APP] [EVT] MGMR DONE %lld, now %lums\r\n",event,private_data,uVar3 / 1000);
    _connect_wifi(pvVar7);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 2:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] Reconnect %lld\r\n";
    break;
  case 3:
  case 5:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] connected %lld\r\n";
    break;
  case 4:
    aos_now_ms();
    pcVar8 = wifi_mgmr_status_code_str(*(uint16_t *)&event->value);
    pcVar6 = "[APP] [EVT] disconnect %lld, Reason: %s\r\n";
    goto LAB_23000dee;
  case 6:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] GOT IP %lld\r\n",event,private_data,(int)lVar10);
    sVar4 = xPortGetFreeHeapSize();
    printf("[SYS] Memory left is %d Bytes\r\n",sVar4);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 7:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] Connecting %lld\r\n";
    break;
  case 8:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] SCAN Done %lld\r\n",event,private_data,(int)lVar10);
    wifi_mgmr_cli_scanlist();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 9:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] SCAN On Join %lld\r\n";
    break;
  default:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] Unknown code %u, %lld\r\n",(uint)uVar1,event,private_data,(int)lVar10);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 0xc:
    lVar10 = aos_now_ms();
    pcVar8 = (char *)event->value;
    if (pcVar8 == (char *)0x0) {
      pcVar8 = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [SSID] %lld: %s\r\n",piVar5,private_data,pcVar8,(int)lVar10);
    ppcVar2 = &event_cb_wifi_event::ssid;
    pcVar8 = event_cb_wifi_event::ssid;
    goto LAB_23000eaa;
  case 0xd:
    lVar10 = aos_now_ms();
    pcVar8 = (char *)event->value;
    if (pcVar8 == (char *)0x0) {
      pcVar8 = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [BSSID] %lld: %s\r\n",piVar5,private_data,pcVar8,(int)lVar10);
    if ((void *)event->value != (void *)0x0) {
      vPortFree((void *)event->value);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    goto LAB_23000eb4;
  case 0xe:
    lVar10 = aos_now_ms();
    pcVar8 = (char *)event->value;
    if (pcVar8 == (char *)0x0) {
      pcVar8 = "UNKNOWN";
    }
    printf("[APP] [EVT] [PROV] [PASSWD] %lld: %s\r\n",piVar5,private_data,pcVar8,(int)lVar10);
    ppcVar2 = &event_cb_wifi_event::password;
    pcVar8 = event_cb_wifi_event::password;
LAB_23000eaa:
    if (pcVar8 != (char *)0x0) {
      vPortFree(pcVar8);
    }
    *ppcVar2 = (char *)event->value;
LAB_23000eb4:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 0xf:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] [PROV] [CONNECT] %lld\r\n",event,private_data,(int)lVar10);
    printf("connecting to %s:%s...\r\n",event_cb_wifi_event::ssid,event_cb_wifi_event::password);
    pcVar6 = event_cb_wifi_event::ssid;
    pcVar8 = event_cb_wifi_event::password;
    wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
    wifi_mgmr_sta_connect(wifi_interface,pcVar6,pcVar8,(char *)0x0,(uint8_t *)0x0,'\0',0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 0x10:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] [PROV] [DISCONNECT] %lld\r\n";
    break;
  case 0x13:
    lVar10 = aos_now_ms();
    uVar9 = (undefined4)lVar10;
    pcVar8 = "[APP] [EVT] Microwave Denoise is ON %lld\r\n";
    break;
  case 0x14:
    aos_now_ms();
    pcVar8 = (char *)event->value;
    pcVar6 = "[APP] [EVT] [AP] [ADD] %lld, sta idx is %lu\r\n";
    goto LAB_23000dee;
  case 0x15:
    aos_now_ms();
    pcVar8 = (char *)event->value;
    pcVar6 = "[APP] [EVT] [AP] [DEL] %lld, sta idx is %lu\r\n";
LAB_23000dee:
    printf(pcVar6,piVar5,private_data,pcVar8);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 0x16:
    lVar10 = aos_now_ms();
    printf("[APP] [EVT] EMERGENCY MAC %lld\r\n",event,private_data,(int)lVar10);
    hal_reboot();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  printf(pcVar8,event,private_data,uVar9);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vApplicationGetIdleTaskMemory
               (StaticTask_t **ppxIdleTaskTCBBuffer,StackType_t **ppxIdleTaskStackBuffer,
               uint32_t *pulIdleTaskStackSize)

{
  *ppxIdleTaskTCBBuffer = &vApplicationGetIdleTaskMemory::xIdleTaskTCB;
  *ppxIdleTaskStackBuffer = vApplicationGetIdleTaskMemory::uxIdleTaskStack;
  *pulIdleTaskStackSize = 0x60;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vApplicationGetTimerTaskMemory
               (StaticTask_t **ppxTimerTaskTCBBuffer,StackType_t **ppxTimerTaskStackBuffer,
               uint32_t *pulTimerTaskStackSize)

{
  *ppxTimerTaskTCBBuffer = &vApplicationGetTimerTaskMemory::xTimerTaskTCB;
  *ppxTimerTaskStackBuffer = vApplicationGetTimerTaskMemory::uxTimerTaskStack;
  *pulTimerTaskStackSize = 400;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Removing unreachable block (ram,0x23001014)

void vAssertCalled(void)

{
  uint32_t ulSetTo1ToExitFunction;
  
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Variable defined which should be unmapped: chip_feature

void bfl_main(void)

{
  int iVar1;
  char *pcStack60;
  char *banner;
  char chip_feature [40];
  
  time_main = bl_timer_now_us();
  bl_uart_init('\0','\x10','\a',-1,-1,(uint32_t)&DAT_001e8480);
  puts("Starting bl602 now....\r\n");
  puts("Booting BL602 Chip...\r\n");
  iVar1 = bl_chip_banner(&pcStack60);
  if (iVar1 == 0) {
    puts(pcStack60);
  }
  puts("\r\n");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  puts("RISC-V Core Feature:");
  bl_chip_info((char *)&banner);
  puts((char *)&banner);
  puts("\r\n");
  puts("Build Version: ");
  puts("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  puts("\r\n");
  puts("PHY   Version: ");
  puts("a0_final-44-geb7fadd");
  puts("\r\n");
  puts("RF    Version: ");
  puts("f76e39a");
  puts("\r\n");
  puts("Build Date: ");
  puts("Oct 30 2020");
  puts("\r\n");
  puts("Build Time: ");
  puts("00:08:24");
  puts("\r\n");
  puts("------------------------------------------------------------\r\n");
  vPortDefineHeapRegions(xHeapRegions);
  printf("Heap %u@%p, %u@%p\r\n",&_heap_size,&__bss_end,0x860,&_heap_wifi_start);
  printf("Boot2 consumed %lums\r\n",time_main / 1000);
  blog_init();
  bl_irq_init();
  bl_sec_init();
  bl_sec_test();
  bl_dma_init();
  hal_boot2_init();
  hal_board_cfg('\0');
  puts("[OS] Starting proc_hellow_entry task...\r\n");
  xTaskCreateStatic(proc_hellow_entry,"hellow",0x200,(void *)0x0,0xf,bfl_main::proc_hellow_stack,
                    &bfl_main::proc_hellow_task);
  puts("[OS] Starting aos_loop_proc task...\r\n");
  xTaskCreateStatic(aos_loop_proc,"event_loop",0x400,(void *)0x0,0xf,bfl_main::aos_loop_proc_stack,
                    &bfl_main::aos_loop_proc_task);
  puts("[OS] Starting TCP/IP Stack...\r\n");
  tcpip_init((tcpip_init_done_fn)0x0,(void *)0x0);
  puts("[OS] Starting OS Scheduler...\r\n");
  vTaskStartScheduler();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ShadowUpdateStatusCallback
               (char *pThingName,ShadowActions_t action,Shadow_Ack_Status_t status,
               char *pReceivedJsonDocument,void *pContextData)

{
  char *fmt;
  undefined3 in_register_00002031;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002031,status);
  shadowUpdateInProgress = false;
  if (iVar1 == 0) {
    fmt = "Update timed out\r\n";
  }
  else {
    if (iVar1 == 1) {
      fmt = "Update rejected\r\n";
    }
    else {
      if (iVar1 != 2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        shadowUpdateInProgress = false;
        return;
      }
      fmt = "Update accepted\r\n";
    }
  }
  printf(fmt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void windowActuate_Callback(char *pJsonString,uint32_t JsonStringDataLen,jsonStruct_t *pContext)

{
  if (pContext != (jsonStruct_t *)0x0) {
                    // WARNING: Load size is inaccurate
    printf("Delta - Window state changed to %d\r\n",(uint)*pContext->pData);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void aws_main_entry(void *param)

{
  code cVar1;
  AWS_IoT_Client *pClient;
  size_t sVar2;
  code *pcVar3;
  IoT_Error_t IVar4;
  int iVar5;
  size_t sVar6;
  undefined3 extraout_var;
  uint uVar7;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  UBaseType_t UVar8;
  char *pcVar9;
  code *pcVar10;
  iot_disconnect_handler **pJsonDocument;
  char acStack4144 [716];
  char *pcStack3428;
  char cStack3421;
  _Bool windowOpen;
  float fStack3420;
  float temperature;
  ShadowConnectParameters_t scp;
  jsonStruct_t windowActuator;
  jsonStruct_t temperatureHandler;
  ShadowInitParameters_t sp;
  char JsonDocumentBuffer [200];
  AWS_IoT_Client mqttClient;
  
  memcpy(&temperatureHandler.cb,&ShadowInitParametersDefault,0x1c);
  memcpy(&temperature,&ShadowConnectParametersDefault,0x10);
  windowActuator._12_4_ = windowActuate_Callback;
  windowActuator.pKey = &cStack3421;
  scp.deleteActionHandler = (pApplicationHandler_t *)0x23072e68;
  windowActuator.dataLength._0_1_ = 8;
  windowActuator.pData = (void *)0x1;
  windowActuator.cb = (jsonStructCallback_t *)0x23072e74;
  temperatureHandler.pKey = &stack0xfffff2a4;
  temperatureHandler.dataLength._0_1_ = 6;
  fStack3420 = 0.0;
  cStack3421 = '\0';
  temperatureHandler._12_4_ = 0;
  temperatureHandler.pData = &DAT_00000004;
  printf("AWS IoT SDK Version %d.%d.%d-%s\r\n",3,0,1,&DAT_23088e60);
  iVar5 = aos_open("/romfs/aws/config",0);
  if (iVar5 < 0) {
    printf("Open config file %s failed\r\n","/romfs/aws/config");
    temperatureHandler.cb = (jsonStructCallback_t *)0x23072ed8;
    printf(" URL:%s\r\n","ap3im43fimllm-ats.iot.us-east-1.amazonaws.com");
    sp.pHost._0_2_ = 0x1bb;
    printf(", port is %d\r\n",0x1bb);
    sp.pRootCA = 
    "-----BEGIN CERTIFICATE-----\r\nMIIDWjCCAkKgAwIBAgIVAOosWE2Km3IxrIwFACK/p1K1hvclMA0GCSqGSIb3DQEB\r\nCwUAME0xSzBJBgNVBAsMQkFtYXpvbiBXZWIgU2VydmljZXMgTz1BbWF6b24uY29t\r\nIEluYy4gTD1TZWF0dGxlIFNUPVdhc2hpbmd0b24gQz1VUzAeFw0xOTA5MDQwNjUw\r\nNTFaFw00OTEyMzEyMzU5NTlaMB4xHDAaBgNVBAMME0FXUyBJb1QgQ2VydGlmaWNh\r\ndGUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDOLZXvbTzYCvzEhyxP\r\nGtF8chZ+r3FZszUdqicDnUqIcKAZiiUC2P/errXnaK/eEye2QUSZmUDpn1xybde4\r\neG1Kz8BvSnp6UYuoF1hPnLQvnm02ILwANcdjScql6CpYIwuGNvCxP1re+iOnOx7V\r\nkFP02d0w36voNMZHyK755IjjWz5PSEIzXx6RCP/wqkJlz+oZvIrDZZ1dXa5X3ffV\r\nbftYCPj2gDW8AohWYMapDJpRfEdo6g6NkP4VOPS+nZ9Fp9rY6BZqJR6m4otjdMna\r\nI7p3FY5wqOdcF3DPXYMHR0j5SjtDLIeNpX8AP6ekpZsO9k1/VLSK+wxXIHltsYW/\r\nlQtzAgMBAAGjYDBeMB8GA1UdIwQYMBaAFLcyZBzcJOBSL0d+yMxZh3trcG7rMB0G\r\nA1UdDgQWBBSgGPuINfSBCTZxtcV3epnSuxPdlTAMBgNVHRMBAf8EAjAAMA4GA1Ud\r\nDwEB/wQEAwIHgDANBgkqhkiG9w0BAQsFAAOCAQEAki9Ito1X7mxn8wCFqmhhXMnh\r\nU6GPvTJTBuTTO+exe8zPiBwHqE0GwJi7Gpu7mlXdlb0vCeNDPBIaDmdcXF/UvTQb\r\nebD3ifawME605r2DFb4IYXVypZzZ2/gKY1K7uKqL9dvyyPdWQJtQY2Kf5AZmKfQ0\r\nPhM6ed1GoMyoW6FRBhjds/znMAduxzvCGaJntKHLppDxl6YrzewgDHsc4iGRnjd2\r\nC8cX+aw7EwNrBwFCYKz+5kA4UFD6coAuMQlAqTSYvD6MJvFSKp8JvlvUVCqPTSHh\r\nPb9Nq++uF9n+F+X8lzA6ul6IoPt5DkzNhOJRdvkggKYuVCUGkMdkZJVKeUHq1g==\r\n-----END CERTIFICATE-----\r\n"
    ;
    sp.pClientCRT =
                  
         "-----BEGIN RSA PRIVATE KEY-----\r\nMIIEpgIBAAKCAQEAzi2V72082Ar8xIcsTxrRfHIWfq9xWbM1HaonA51KiHCgGYol\r\nAtj/3q6152iv3hMntkFEmZlA6Z9ccm3XuHhtSs/Ab0p6elGLqBdYT5y0L55tNiC8\r\nADXHY0nKpegqWCMLhjbwsT9a3vojpzse1ZBT9NndMN+r6DTGR8iu+eSI41s+T0hC\r\nM18ekQj/8KpCZc/qGbyKw2WdXV2uV9331W37WAj49oA1vAKIVmDGqQyaUXxHaOoO\r\njZD+FTj0vp2fRafa2OgWaiUepuKLY3TJ2iO6dxWOcKjnXBdwz12DB0dI+Uo7QyyH\r\njaV/AD+npKWbDvZNf1S0ivsMVyB5bbGFv5ULcwIDAQABAoIBAQCkRtoibU1/bjG8\r\nfV+mn92uZFDcG/oa2JlHy51OWfNbBzHpZ5LZ1AD7cwVpHpaSQXzw0MxR/jQkcV99\r\npVuulfWvGB1iD1vLPlIiWod414kSMA8gg7CIElGOIOugiX3DwBiclgXtlGdZJsFl\r\nq8uDqn3aqAR/vpgAapxZ8eLJJXiUfV7IaAu7dXr0Es1WEmyXV0xbtppEm9BIgjw9\r\n33YmSvTkBRMMfSBN5u0xp53axiwZ77I8ZNRROlUy/ki5myWazTcjAYdDnzO7M8of\r\n/iMaOY7UOcROKEzWCzTOucncrGg+Uv+YD0kMe37Aj3g3wK4BZcMA0LdiY9N31S0F\r\nl5IVbzfxAoGBAOv+4rURrsjyvbyqaWS3Y30k5bGsaA/m7Bwmyey/0NXOza02KqRa\r\n/ZfIB8jCChVkNmMFfc4Aqp4VsV8YZCxnQzjteiIRWurfZD9Xgf8fF4OYmZpUqZ6S\r\nU8GX8rd88RTkb5N6VlDRKK8aqhKRJ/OE4VF+c6p0PHITzaN42LEGldCFAoGBAN+n\r\nqFUyO9k0SvYz1LQFVgXF3kzIjzjI4ca/CYg8vYllS9n0wE0/m4KrA3wA0Qxpl5tI\r\nD8H1Br1G4iy+4n3Zwtb2wEa+KXYjSmHzxJNKiBOK5Ks6k4CbScswy7wV2fgPqUIK\r\nyoBLfdNlnhbcDHdWXwy84ea59pcRdjVMBVFrFumXAoGBAOHaDR08zwmBRhRJApRg\r\n7dXWefyQAwc0+MH4XUc2S6ZTRIOAU073xbp8tPZsvTm7rlEV8FA2UxL3r8hSj4vv\r\nR2Yz36667UfagxYbqU1/dAF9CYOpgqs/XujngmIYMKDN/fomGnU9trHd0uXyBUoI\r\n4ZocapW2qCKE0UihXsAMjVQBAoGBALH8n/blGkHZ3soeJ2j4UiQX+rhKZ8g9/YeI\r\nIpLcG85K4dlbcOpI835CkGxPzg29vpwh9gBZ+foJfhcz9dVHxkoCZrQlw6MzpI9d\r\nSpQZHT/IKgCmhhoz+r8MXyaYkTVbaUyYf90ntsPUO8JfbkBOaSge7PwMBFTm3Za+\r\noADSY5KTAoGBAK3f+otZPfZA1LTpWYbOpCl10Ci/R/xU13Ak7omahkpXX/dMHt3s\r\nd0fpsuduQwrQOGJLEZG/Z1zeNSp8QtGKH/RH57tWJBFR1XWEJ9kyH/FPVaighzPU\r\nT9VIJw2g//PLTT7yV/D9HmiNMj0hQYkTP3bGKvaiOrhC7a0Us4KhMGFc\r\n-----END RSA PRIVATE KEY-----\r\n"
    ;
    sp._4_4_ = &DAT_23073ab0;
    sp.pClientKey._0_1_ = 0;
    sp._20_4_ = 0;
    scp.pMyThingName = "bl60xDevRjwang";
    printf(", THING ID is %s\r\n","bl60xDevRjwang");
    sVar6 = strlen(scp.pMyThingName);
    scp.pMqttClientId._0_2_ = (uint16_t)sVar6;
    sVar6 = strlen("bl60xDevRjwang");
    printf("thing name len is %d",sVar6);
    temperature = 7.331795e-18;
    printf(", THING name is %s\r\n","bl60xDevRjwang");
  }
  else {
    aos_ioctl(iVar5,1,(ulong)&sp.disconnectHandler);
    sVar2 = 0;
    while( true ) {
      pcVar3 = sp.disconnectHandler + sVar2;
      if ((*pcVar3 == (code)0xa) || (*pcVar3 == (code)0xd)) break;
      sVar2 = sVar2 + 1;
    }
    printf("URL len is %d,",sVar2);
    temperatureHandler.cb = (jsonStructCallback_t *)pvPortMalloc(sVar2);
    pcStack3428 = acStack4144;
    if (temperatureHandler.cb == (jsonStructCallback_t *)0x0) {
      printf("NULL pHost %d\r\n",0xcc);
      do {
        vTaskDelay(1000);
      } while( true );
    }
    memcpy(temperatureHandler.cb,pcVar3 + -sVar2,sVar2);
    *(undefined *)(sVar2 + *(int *)(pcStack3428 + 0x310)) = 0;
    printf(" URL:%s\r\n",*(undefined4 *)(pcStack3428 + 0x310));
    while ((*pcVar3 == (code)0xa || (*pcVar3 == (code)0xd))) {
      pcVar3 = pcVar3 + 1;
    }
    sVar6 = 0;
    while( true ) {
      pcVar10 = pcVar3 + sVar6;
      if ((*pcVar10 == (code)0xa) || (*pcVar10 == (code)0xd)) break;
      sVar6 = sVar6 + 1;
    }
    printf("port len is %d",sVar6);
    if (5 < (int)sVar6) {
      printf("Too long port\r\n");
      do {
        vTaskDelay(1000);
      } while( true );
    }
    memcpy(JsonDocumentBuffer + 0xc4,pcVar10 + -sVar6,sVar6);
    pcStack3428 = acStack4144;
    JsonDocumentBuffer[sVar6 + 0xc4] = '\0';
    uVar7 = atoi(JsonDocumentBuffer + 0xc4);
    *(short *)(pcStack3428 + 0x314) = (short)uVar7;
    printf(", port is %d\r\n",uVar7 & 0xffff);
    pcVar9 = pcStack3428;
    *(undefined **)(pcStack3428 + 0x31c) = &DAT_23072f24;
    *(undefined **)(pcVar9 + 800) = &DAT_23073404;
    *(undefined **)(pcVar9 + 0x318) = &DAT_23073ab0;
    pcVar9[0x324] = '\0';
    *(undefined4 *)(pcVar9 + 0x328) = 0;
    while ((*pcVar10 == (code)0xa || (*pcVar10 == (code)0xd))) {
      pcVar10 = pcVar10 + 1;
    }
    sVar2 = 0;
    while( true ) {
      pcVar3 = pcVar10 + sVar2;
      if ((*pcVar3 == (code)0xa) || (*pcVar3 == (code)0xd)) break;
      sVar2 = sVar2 + 1;
    }
    printf("thing id len is %d",sVar2);
    scp.pMyThingName = (char *)pvPortMalloc(sVar2);
    pcStack3428 = acStack4144;
    if (scp.pMyThingName == (char *)0x0) {
      printf("NULL pMqttClientId %d\r\n",0xfd);
      do {
        vTaskDelay(1000);
      } while( true );
    }
    memcpy(scp.pMyThingName,pcVar3 + -sVar2,sVar2);
    *(undefined *)(sVar2 + *(int *)(pcStack3428 + 0x2dc)) = 0;
    printf(", THING ID is %s\r\n",*(undefined4 *)(pcStack3428 + 0x2dc));
    sVar6 = strlen(*(char **)(pcStack3428 + 0x2dc));
    *(short *)(pcStack3428 + 0x2e0) = (short)sVar6;
    while ((*pcVar3 == (code)0xa || (*pcVar3 == (code)0xd))) {
      pcVar3 = pcVar3 + 1;
    }
    sVar2 = 0;
    while( true ) {
      cVar1 = pcVar3[sVar2];
      if ((cVar1 == (code)0xa) || (cVar1 == (code)0xd)) break;
      sVar2 = sVar2 + 1;
    }
    printf("thing name len is %d",sVar2);
    temperature = (float)pvPortMalloc(sVar2);
    pcStack3428 = acStack4144;
    if ((char *)temperature == (char *)0x0) {
      printf("NULL pMyThingName %d\r\n",0x114);
      do {
        vTaskDelay(1000);
      } while( true );
    }
    memcpy((void *)temperature,pcVar3 + sVar2 + -sVar2,sVar2);
    *(undefined *)(sVar2 + *(int *)(pcStack3428 + 0x2d8)) = 0;
    printf(", THING name is %s\r\n",*(undefined4 *)(pcStack3428 + 0x2d8));
    aos_close(iVar5);
  }
  printf("Shadow Init\r\n");
  pClient = (AWS_IoT_Client *)(JsonDocumentBuffer + 0xc4);
  IVar4 = aws_iot_shadow_init(pClient,(ShadowInitParameters_t *)&temperatureHandler.cb);
  if (CONCAT31(extraout_var,IVar4) != 0) {
    printf("aws_iot_shadow_init returned error %d, aborting...\r\n",CONCAT31(extraout_var,IVar4));
    do {
      vTaskDelay(1000);
    } while( true );
  }
  printf("Shadow Connect\r\n",0);
  IVar4 = aws_iot_shadow_connect(pClient,(ShadowConnectParameters_t *)&temperature);
  if (CONCAT31(extraout_var_00,IVar4) != 0) {
    printf("aws_iot_shadow_connect returned error %d, aborting...\r\n",
           CONCAT31(extraout_var_00,IVar4));
    do {
      vTaskDelay(1000);
    } while( true );
  }
  IVar4 = aws_iot_shadow_set_autoreconnect_status(pClient,true);
  if (CONCAT31(extraout_var_01,IVar4) != 0) {
    printf("Unable to set Auto Reconnect to true - %d, aborting...\r\n",
           CONCAT31(extraout_var_01,IVar4));
    do {
      vTaskDelay(1000);
    } while( true );
  }
  IVar4 = aws_iot_shadow_register_delta(pClient,(jsonStruct_t *)&scp.deleteActionHandler);
  iVar5 = CONCAT31(extraout_var_02,IVar4);
  if (iVar5 != 0) {
    printf("Shadow Register Delta Error\r\n");
    do {
      vTaskDelay(1000);
    } while( true );
  }
  pcStack3428 = acStack4144;
  fStack3420 = 25.0;
  while (((iVar5 - 3U & 0xff) < 2 || (iVar5 == 0))) {
    IVar4 = aws_iot_shadow_yield((AWS_IoT_Client *)(JsonDocumentBuffer + 0xc4),200);
    if ((CONCAT31(extraout_var_04,IVar4) == 4) || ((_shadowUpdateInProgress & 0xff) != 0)) {
      IVar4 = aws_iot_shadow_yield((AWS_IoT_Client *)(JsonDocumentBuffer + 0xc4),1000);
      iVar5 = CONCAT31(extraout_var_05,IVar4);
    }
    else {
      printf(
            "=======================================================================================\r\n"
            );
      pcStack3428 = acStack4144;
      if (cStack3421 == '\0') {
        pcVar9 = "false";
      }
      else {
        pcVar9 = "true";
      }
      printf("On Device: window state %s\r\n",pcVar9);
      pcStack3428 = acStack4144;
      if (fStack3420 < 32.0) {
        if (fStack3420 <= 25.0) {
          deltaChange_6542 = 0.5;
        }
      }
      else {
        deltaChange_6542 = -0.5;
      }
      fStack3420 = deltaChange_6542 + fStack3420;
      pJsonDocument = &sp.disconnectHandler;
      IVar4 = aws_iot_shadow_init_json_document((char *)pJsonDocument,200);
      iVar5 = CONCAT31(extraout_var_06,IVar4);
      if (iVar5 == 0) {
        IVar4 = aws_iot_shadow_add_reported
                          ((char *)pJsonDocument,200,'\x02',&windowActuator.cb,
                           &scp.deleteActionHandler);
        iVar5 = CONCAT31(extraout_var_07,IVar4);
        if (iVar5 == 0) {
          IVar4 = aws_iot_finalize_json_document((char *)pJsonDocument,200);
          iVar5 = CONCAT31(extraout_var_08,IVar4);
          if (iVar5 == 0) {
            printf("Update Shadow: %s\r\n",pJsonDocument);
            IVar4 = aws_iot_shadow_update
                              ((AWS_IoT_Client *)(JsonDocumentBuffer + 0xc4),(char *)temperature,
                               (char *)pJsonDocument,ShadowUpdateStatusCallback,(void *)0x0,'\x04',
                               true);
            iVar5 = CONCAT31(extraout_var_09,IVar4);
            _shadowUpdateInProgress = CONCAT31(shadowUpdateInProgress_1,1);
          }
        }
      }
      printf(
            "*****************************************************************************************\r\n"
            );
      pcStack3428 = pcTaskGetName((TaskHandle_t)0x0);
      UVar8 = uxTaskGetStackHighWaterMark((TaskHandle_t)0x0);
      printf("Stack remaining for task \'%s\' is %ld bytes\r\n",pcStack3428,UVar8);
      vTaskDelay(1000);
    }
  }
  printf("An error occurred in the loop %d\r\n",iVar5);
  printf("Disconnecting\r\n");
  IVar4 = aws_iot_shadow_disconnect((AWS_IoT_Client *)(JsonDocumentBuffer + 0xc4));
  if (CONCAT31(extraout_var_03,IVar4) != 0) {
    printf("Disconnect error %d\r\n",CONCAT31(extraout_var_03,IVar4));
  }
  vTaskDelete((TaskHandle_t)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_coex_dump(char *buf,int len,int argc,char **argv)

{
  coex_dump_pta();
  coex_dump_wifi();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int codex_debug_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_rx_filter_set(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  return;
}



int element_notify_status_enabled
              (cfg_element_entry *entry,void *arg1,void *arg2,CFG_ELEMENT_TYPE_OPS ops)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_ap_setf(uint8_t ap)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = CONCAT31(in_register_00002029,ap) << 1 | _DAT_44b0004c & 0xfffffffd;
  return;
}



uchar ascii_to_hex(char asccode)

{
  byte bVar1;
  
  bVar1 = asccode - 0x30;
  if (9 < bVar1) {
    if ((byte)(asccode + 0x9fU) < 6) {
      bVar1 = asccode + 0xa9;
    }
    else {
      bVar1 = 0;
      if ((byte)(asccode + 0xbfU) < 6) {
        bVar1 = asccode - 0x37;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uchar)bVar1;
}



undefined4 element_notify_time_last_received_set(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_encr_cntrl_pack
               (uint8_t newread,uint8_t newwrite,uint16_t keyindexram,uint8_t ctyperam,
               uint8_t vlanidram,uint8_t sppram,uint8_t usedefkeyram,uint8_t clenram)

{
  uint uVar1;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  undefined3 in_register_00002045;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_00002039,vlanidram) << 4;
  if ((uVar2 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)vlanidram << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x1873);
  }
  uVar1 = CONCAT31(in_register_0000203d,sppram) << 2;
  if ((uVar1 & 0xfffffff3) != 0) {
    assert_err("(((uint32_t)sppram << 2) & ~((uint32_t)0x0000000C)) == 0","module",0x1874);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b000c4 =
       (uint)newread << 0x1f | CONCAT31(in_register_00002045,clenram) |
       CONCAT31(in_register_00002041,usedefkeyram) << 1 | uVar1 | uVar2 |
       CONCAT31(in_register_00002035,ctyperam) << 8 | (uint)keyindexram << 0x10 |
       (uint)newwrite << 0x1e;
  return;
}



undefined4 element_notify_keepalive_received(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x23001bd8)
// WARNING: Removing unreachable block (ram,0x23001be2)
// WARNING: Removing unreachable block (ram,0x23001c0a)
// WARNING: Removing unreachable block (ram,0x23001bfe)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t hal_machw_rx_duration(rx_hd *rhd,uint16_t len)

{
  if ((""[rhd->recvec1a >> 0xc & 0xf] & 0x80) != 0) {
    assert_err("(((uint32_t)ppdumcsindex << 0) & ~((uint32_t)0x0000007F)) == 0","module",0x1a99);
  }
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_env_max_ampdu_duration_set(void)

{
  mm_env.ampdu_max_dur[0] = 0x96;
  if (((_DAT_44b00200 >> 0xc & 0xffff) != 0) && ((_DAT_44b00200 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[0] = (uint16_t)(_DAT_44b00200 >> 0xc);
  }
  mm_env.ampdu_max_dur[1] = 0x96;
  if (((_DAT_44b00204 >> 0xc & 0xffff) != 0) && ((_DAT_44b00204 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[1] = (uint16_t)(_DAT_44b00204 >> 0xc);
  }
  mm_env.ampdu_max_dur[2] = 0x96;
  if (((_DAT_44b00208 >> 0xc & 0xffff) != 0) && ((_DAT_44b00208 >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[2] = (uint16_t)(_DAT_44b00208 >> 0xc);
  }
  mm_env.ampdu_max_dur[3] = 0x96;
  if (((_DAT_44b0020c >> 0xc & 0xffff) != 0) && ((_DAT_44b0020c >> 0xc & 0xffff) < 0x97)) {
    mm_env.ampdu_max_dur[3] = (uint16_t)(_DAT_44b0020c >> 0xc);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  mm_env.ampdu_max_dur[4] = mm_env.ampdu_max_dur[3];
  return;
}



void mm_env_init(void)

{
  memset(&mm_env,0,0x2c);
  mm_env._34_2_ = 0x101;
  mm_env._18_2_ = 0;
  mm_env.rx_filter_lmac_enable = 0;
  mm_env.rx_filter_umac = 0x7fffffde;
  mm_rx_filter_set();
  mm_env_max_ampdu_duration_set();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_init(void)

{
  hal_machw_init();
  mm_env_init();
  vif_mgmt_init();
  sta_mgmt_init();
  td_init();
  ps_init();
  txl_cntrl_init();
  rxl_init();
  mm_timer_init();
  scan_init();
  chan_init();
  hal_dma_init();
  mm_bcn_init();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_active(void)

{
  _DAT_44b00038 = 0x30;
  ke_state_set(0,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_reset(void)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT22(extraout_var,kVar1) == 1) {
    mm_active();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ke_state_set(0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_tbtt_evt(int dummy)

{
  uint event;
  vif_info_tag *p_vif_entry;
  char cVar1;
  
  event = ke_env.evt_field & 0x600000;
  if (event == 0x600000) {
    assert_err("evt != MM_TBTT_EVT_MASK","module",0x321);
  }
  ke_evt_clear(event);
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  txl_cntrl_halt_ac('\x04');
  txl_cntrl_flush_ac('\x04',0x40000000);
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if ((p_vif_entry->type == '\x02') &&
       (cVar1 = *(char *)((int)&p_vif_entry->u + 0x2e5) + -1,
       *(char *)((int)&p_vif_entry->u + 0x2e5) = cVar1, cVar1 == '\0')) {
      *(undefined *)((int)&p_vif_entry->u + 0x2e5) = *(undefined *)((int)&p_vif_entry->u + 0x2e4);
      vif_mgmt_bcn_to_prog(p_vif_entry);
      if (p_vif_entry->chan_ctxt != (chan_ctxt_tag *)0x0) {
        chan_tbtt_switch_update
                  (p_vif_entry,
                   (uint)*(ushort *)((int)&p_vif_entry->u + 0x2e2) * 0x400 +
                   _DAT_44b08040 * 0x20 + _DAT_44b00120);
      }
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  mm_bcn_transmit();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwaddr_wr(uint8_t sta_idx,uint8_t inst_nbr)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,sta_idx);
  uVar1 = iVar2 + 8U & 0xff;
  _DAT_44b000bc = *(undefined4 *)sta_info_tab[iVar2].mac_addr.array;
  _DAT_44b000c0 = (uint)sta_info_tab[iVar2].mac_addr.array[2];
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0',inst_nbr,'\0','\x01','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_keydump(void)

{
  uint uVar1;
  undefined *puVar2;
  int iVar3;
  
  uVar1 = _DAT_44b000d8;
  puts("==========================  Keyram Config ========================\r\n");
  printf("  start %02u -->> end %02u; nVAP %02u; max %02u\r\n",uVar1 & 0xff,uVar1 >> 8 & 0xff,
         uVar1 >> 0x10 & 0xff,uVar1 >> 0x18);
  puts("==========================  Keyram Dump =========================\r\n");
  uVar1 = _DAT_44b000d8 >> 8;
  puts("[id]   MAC Address     Key Len  VLan ID  Default      \tKey Hexdump(16Bytes MAX)\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uVar1 & 0xff)) {
    blmac_encr_cntrl_pack('\x01','\0',(uint16_t)iVar3,'\0','\0','\0','\0','\0');
    do {
    } while ((int)_DAT_44b000c4 < 0);
    printf("[%02d] %02X:%02X:%02X:%02X:%02X:%02X",iVar3,_DAT_44b000bc & 0xff,
           _DAT_44b000bc >> 8 & 0xff,_DAT_44b000bc >> 0x10 & 0xff,_DAT_44b000bc >> 0x18,
           _DAT_44b000c0 & 0xff,_DAT_44b000c0 >> 8 & 0xff);
    puVar2 = &UNK_230743ec;
    if ((_DAT_44b000c4 & 1) == 0) {
      puVar2 = &UNK_230743f4;
    }
    printf(" %s",puVar2);
    iVar3 = iVar3 + 1;
    printf("    %02u",_DAT_44b000c4 >> 4 & 0xf);
    printf("        %u",_DAT_44b000c4 >> 1 & 1);
    printf("     %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
           _DAT_44b000ac & 0xff,_DAT_44b000ac >> 8 & 0xff,_DAT_44b000ac >> 0x10 & 0xff,
           _DAT_44b000ac >> 0x18,_DAT_44b000b0 & 0xff,_DAT_44b000b0 >> 8 & 0xff,
           _DAT_44b000b0 >> 0x10 & 0xff);
    puts("\r\n");
  }
  puts("==========================  MAC Address =========================\r\n");
  printf("    MAC %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00010 & 0xff,_DAT_44b00010 >> 8 & 0xff,
         _DAT_44b00010 >> 0x10 & 0xff,_DAT_44b00010 >> 0x18,_DAT_44b00014 & 0xff,
         _DAT_44b00014 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00018 & 0xff,_DAT_44b00018 >> 8 & 0xff,
         _DAT_44b00018 >> 0x10 & 0xff,_DAT_44b00018 >> 0x18,_DAT_44b0001c & 0xff,
         _DAT_44b0001c >> 8 & 0xff);
  puts("\r\n");
  printf("  BSSID %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00020 & 0xff,_DAT_44b00020 >> 8 & 0xff,
         _DAT_44b00020 >> 0x10 & 0xff,_DAT_44b00020 >> 0x18,_DAT_44b00024 & 0xff,
         _DAT_44b00024 >> 8 & 0xff);
  printf(" Mask %02X:%02X:%02X:%02X:%02X:%02X",_DAT_44b00028 >> 8 & 0xff,
         _DAT_44b00028 >> 0x10 & 0xff,_DAT_44b00028 >> 0x18,_DAT_44b0002c & 0xff,
         _DAT_44b0002c >> 8 & 0xff);
  puts("\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t mm_sec_machwkey_wr(mm_key_add_req *param)

{
  byte vlanidram;
  uint16_t keyindexram;
  uint8_t ctyperam;
  uint8_t clenram;
  uint uVar2;
  uint uVar1;
  
  uVar2 = (uint)param->sta_idx;
  vlanidram = param->inst_nbr;
  if (uVar2 == 0xff) {
    keyindexram = (ushort)vlanidram * 4 + (ushort)param->key_idx & 0xff;
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_add_key(param,(uint8_t)keyindexram);
  }
  else {
    if (0xb < uVar2) {
      assert_err("sta_idx < STA_MAX","module",0x3e4);
    }
    uVar1 = uVar2 + 8 & 0xff;
    keyindexram = (uint16_t)uVar1;
    sta_mgmt_add_key(param,(uint8_t)uVar1);
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar2].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar2].mac_addr.array[2];
  }
  uVar2 = (uint)param->cipher_suite;
  if (uVar2 < 4) {
    clenram = *(uint8_t *)((int)&CSWTCH_22 + uVar2);
    ctyperam = *(uint8_t *)((int)&CSWTCH_23 + uVar2);
  }
  else {
    assert_err("0","module",0x429);
    ctyperam = '\0';
    clenram = '\x01';
  }
  _DAT_44b000ac = (param->key).array[0];
  _DAT_44b000b0 = (param->key).array[1];
  _DAT_44b000b4 = (param->key).array[2];
  _DAT_44b000b8 = (param->key).array[3];
  blmac_encr_cntrl_pack('\0','\x01',keyindexram,ctyperam,vlanidram,param->spp,'\0',clenram);
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)keyindexram;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwkey_del(uint8_t hw_key_idx)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  
  uVar1 = CONCAT31(in_register_00002029,hw_key_idx);
  if (uVar1 < 8) {
    _DAT_44b000bc = 0xffffffff;
    _DAT_44b000c0 = 0xffffffff;
    vif_mgmt_del_key(vif_info_tab + ((int)uVar1 >> 2),hw_key_idx & 3);
  }
  else {
    uVar2 = uVar1 - 8 & 0xff;
    _DAT_44b000bc = *(undefined4 *)sta_info_tab[uVar2].mac_addr.array;
    _DAT_44b000c0 = (uint)sta_info_tab[uVar2].mac_addr.array[2];
    sta_mgmt_del_key(sta_info_tab + uVar2);
  }
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',(uint16_t)uVar1,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_sec_machwaddr_del(uint8_t sta_idx)

{
  _DAT_44b000bc = 0xffffffff;
  _DAT_44b000c0 = 0xffffffff;
  _DAT_44b000ac = 0;
  _DAT_44b000b0 = 0;
  _DAT_44b000b4 = 0;
  _DAT_44b000b8 = 0;
  blmac_encr_cntrl_pack('\0','\x01',sta_idx + 8 & 0xff,'\0','\0','\0','\0','\0');
  do {
  } while (_DAT_44b000c4 << 1 < 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_hw_idle_evt(int dummy)

{
  ke_evt_clear(0x800000);
  ke_state_set(0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_info_set(mac_addr *mac_addr)

{
  blmac_ap_setf('\0');
  _DAT_44b0001c = 0x100;
  _DAT_44b080a4 = 0;
  _DAT_44b080a8 = 0;
  _DAT_44b00010 = *(undefined4 *)mac_addr->array;
  _DAT_44b00014 = (uint)mac_addr->array[2];
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff8ff | 1;
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_set(void)

{
  blmac_ap_setf('\x01');
  mm_env.rx_filter_umac = 0x3507a58c;
  mm_rx_filter_set();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 | 0x40001;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_hw_ap_info_reset(void)

{
  blmac_ap_setf('\0');
  mm_env.rx_filter_umac = 0x3503858c;
  mm_rx_filter_set();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b08070 = 0x40001;
  _DAT_44b08074 = _DAT_44b08074 & 0xfffbfffe;
  return;
}



void mm_back_to_host_idle(void)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(0);
  if (CONCAT22(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_MM) == MM_HOST_BYPASSED","module",0x52a);
  }
  if (mm_env.host_idle == '\0') {
    mm_active();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ke_state_set(0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_force_idle_req(void)

{
  hal_machw_reset();
  rxl_reset();
  txl_reset();
  ke_state_set(0,3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  mm_env._18_2_ = 0;
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t mm_sta_add(mm_sta_add_req *param,uint8_t *sta_idx,uint8_t *hw_sta_idx)

{
  uint uVar1;
  uint8_t uVar2;
  uchar uVar3;
  uchar uVar4;
  undefined3 extraout_var;
  size_t sVar5;
  int security_mode;
  uint8_t *puVar6;
  int iVar7;
  int iVar8;
  _Bool is_pmf_required;
  uint uVar9;
  int iVar10;
  undefined2 uStack92;
  mm_key_add_req key_add_req;
  
  uVar2 = sta_mgmt_register(param,sta_idx);
  iVar10 = CONCAT31(extraout_var,uVar2);
  if (iVar10 != 0) goto LAB_230025b8;
  uVar1 = (uint)param->inst_nbr;
  uVar2 = mm_sec_machwaddr_wr(*sta_idx,param->inst_nbr);
  *hw_sta_idx = uVar2;
  if (vif_info_tab[uVar1].type != '\0') goto LAB_230025b8;
  if (vif_info_tab[uVar1].bss_info.is_supplicant_enabled != false) {
    sta_conn_info.staId = *sta_idx;
    if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12800) == 0) {
      if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 2) != 0) {
        sVar5 = strlen((char *)(sm_env.connect_param)->phrase);
        printf("wep:len:%d,password:%s\n",sVar5,(sm_env.connect_param)->phrase);
        memset(&uStack92,0,0x2c);
        key_add_req.key.array[7]._1_1_ = param->inst_nbr;
        uStack92 = 0xff00;
        sVar5 = strlen((char *)(sm_env.connect_param)->phrase);
        uVar9 = sVar5 & 0xff;
        key_add_req.key_idx = (uint8_t)uVar9;
        if (uVar9 == 5) {
          key_add_req.key.array[7]._0_1_ = '\0';
LAB_230026d8:
          memcpy(&key_add_req.key,(sm_env.connect_param)->phrase,sVar5 & 0xff);
        }
        else {
          if (uVar9 == 0xd) {
            key_add_req.key.array[7]._0_1_ = '\x03';
            goto LAB_230026d8;
          }
          if (uVar9 == 10) {
            key_add_req.key.array[7]._0_1_ = '\0';
          }
          else {
            if (uVar9 != 0x1a) {
              printf("password length is not correct for wep\n");
              iVar10 = 1;
              sta_mgmt_unregister(*sta_idx);
              goto LAB_230025b8;
            }
            key_add_req.key.array[7]._0_1_ = '\x03';
          }
          uVar9 = sVar5 & 0xff;
          if ((sVar5 & 1) != 0) {
            uVar9 = sVar5 & 0xfe;
          }
          if (uVar9 != 0) {
            iVar7 = 0;
            puVar6 = (sm_env.connect_param)->phrase;
            do {
              uVar3 = ascii_to_hex(*puVar6);
              uVar4 = ascii_to_hex(puVar6[1]);
              *(uchar *)((int)key_add_req.key.array + (iVar7 >> 1) + -4) = uVar3 * '\x10' + uVar4;
              iVar7 = iVar7 + 2;
              puVar6 = puVar6 + 2;
            } while (iVar7 < (int)uVar9);
          }
          key_add_req.key_idx = key_add_req.key_idx >> 1;
        }
        wep_hw_keyid = mm_sec_machwkey_wr((mm_key_add_req *)&uStack92);
      }
    }
    else {
      if ((sm_env.connect_param)->phrase_pmk[0] == '\0') {
        puVar6 = (sm_env.connect_param)->phrase;
      }
      else {
        puVar6 = (sm_env.connect_param)->phrase_pmk;
      }
      set_psk((char *)vif_info_tab[uVar1].bss_info.ssid.array,
              vif_info_tab[uVar1].bss_info.ssid.length,(char *)puVar6);
    }
    iVar7 = uVar1 * 0x5d8;
    if ((*(uint *)&vif_info_tab[uVar1].bss_info.is_supplicant_enabled & 0x12000) == 0) {
      if ((*(byte *)&vif_info_tab[uVar1].bss_info.wpa_wpa2_wep & 8) != 0) {
        iVar8 = iVar7 + 0x3ec;
        iVar7 = iVar7 + 0x3eb;
        is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
        security_mode = 3;
        goto LAB_2300263a;
      }
    }
    else {
      is_pmf_required = vif_info_tab[uVar1].bss_info.is_pmf_required;
      iVar8 = iVar7 + 0x3ee;
      iVar7 = iVar7 + 0x3ed;
      security_mode = 4;
LAB_2300263a:
      supplicantEnable(&sta_conn_info,security_mode,
                       (void *)((int)vif_info_tab[0].txq_params + iVar7 + -8),
                       (void *)((int)vif_info_tab[0].txq_params + iVar8 + -8),is_pmf_required);
    }
    if (vif_info_tab[uVar1].type != '\0') goto LAB_230025b8;
  }
  iVar10 = 0;
  *(uint8_t *)&vif_info_tab[uVar1].u.field_0x4 = *sta_idx;
LAB_230025b8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)iVar10;
}



void mm_sta_del(uint8_t sta_idx)

{
  uint uVar1;
  undefined3 in_register_00002029;
  undefined *puVar2;
  char cVar3;
  uint uVar4;
  
  uVar4 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr;
  if (vif_info_tab[uVar4].type == '\0') {
    *(undefined *)&vif_info_tab[uVar4].u.field_0x4 = 0xff;
    if (vif_info_tab[uVar4].bss_info.is_supplicant_enabled != false) {
      if ((*(uint *)&vif_info_tab[uVar4].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if (((*(byte *)&vif_info_tab[uVar4].bss_info.wpa_wpa2_wep & 2) != 0) && (wep_hw_keyid != -1)
           ) {
          mm_sec_machwkey_del(wep_hw_keyid);
        }
      }
      else {
        mm_sec_machwkey_del(sta_conn_info.ptkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.gtkHwKeyId);
        mm_sec_machwkey_del(sta_conn_info.mfpHwKeyId);
        supplicantDisable(&sta_conn_info);
        memset(&(sta_conn_info.suppData)->hashSsId,0,0x22);
        remove_psk((char *)vif_info_tab[uVar4].bss_info.ssid.array,
                   vif_info_tab[uVar4].bss_info.ssid.length);
      }
      vif_info_tab[uVar4].bss_info.is_supplicant_enabled = false;
    }
  }
  else {
    if ((sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state == '\x01') &&
       (cVar3 = *(char *)&vif_info_tab[uVar4].u.field_0x2ee + -1,
       *(char *)&vif_info_tab[uVar4].u.field_0x2ee = cVar3, cVar3 == '\0')) {
      uVar1 = vif_info_tab[uVar4].index + 10 & 0xff;
      puVar2 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar1].ps_state = '\0';
      *puVar2 = (char)uVar1;
      puVar2[1] = 0;
      ke_msg_send(puVar2);
      apm_tx_int_ps_clear(vif_info_tab + uVar4,vif_info_tab[uVar4].index + '\n');
    }
  }
  mm_sec_machwaddr_del(sta_idx);
  sta_mgmt_unregister(sta_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_cfg_element_keepalive_timestamp_update(void)

{
  mm_env.keep_alive_time_last_received = xTaskGetTickCount();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  mm_env.keep_alive_packet_counter = mm_env.keep_alive_packet_counter + 1;
  return;
}



void mm_send_connection_loss_ind(vif_info_tag *p_vif_entry)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x43,6,0,1);
  *puVar1 = p_vif_entry->index;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_ap_probe_cfm(void *env,uint32_t status)

{
  if ((int)(status << 8) < 0) {
    *(undefined *)((int)env + 0x74) = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  mm_send_connection_loss_ind((vif_info_tag *)env);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: cur_us
// WARNING: Could not reconcile some variable overlaps

void mm_check_rssi(vif_info_tag *vif_entry,int8_t rssi)

{
  char cVar1;
  uint8_t uVar2;
  int iVar3;
  uint8_t *puVar4;
  undefined3 in_register_0000202d;
  int iVar5;
  uint uVar6;
  int iVar7;
  uint8_t uVar8;
  int iVar9;
  uint uStack40;
  longlong cur_us;
  
  iVar5 = CONCAT31(in_register_0000202d,rssi);
  iVar9 = (int)*(char *)&(vif_entry->u).field_0x19;
  iVar3 = (int)*(char *)&(vif_entry->u).field_0x1a;
  cVar1 = *(char *)&(vif_entry->u).field_0x1b;
  uVar8 = *(uint8_t *)&(vif_entry->u).field_0x1c;
  *(int8_t *)&(vif_entry->u).field_0x19 = rssi;
  uStack40 = 0;
  cur_us._0_4_ = 0;
  bl60x_current_time_us((longlong *)&uStack40);
  if (iVar9 != 0) {
    uVar6 = (uint)(uStack40 < uStack40 - (uint)last_us);
    if (((int)(((int)cur_us - last_us._4_4_) - uVar6) < 1) &&
       (((int)cur_us - last_us._4_4_ != uVar6 || (uStack40 - (uint)last_us < 0x1e8481))))
    goto LAB_230029d6;
  }
  puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
  uVar2 = vif_entry->index;
  puVar4[1] = uVar8;
  puVar4[2] = rssi;
  *puVar4 = uVar2;
  last_us._0_4_ = uStack40;
  last_us._4_4_ = (int)cur_us;
  ke_msg_send(puVar4);
LAB_230029d6:
  if (iVar3 != 0) {
    iVar7 = (int)cVar1;
    if (uVar8 == '\0') {
      if (iVar5 < iVar9) {
        uVar8 = iVar5 < iVar3 - iVar7;
      }
    }
    else {
      if (iVar9 < iVar5) {
        uVar8 = iVar5 <= iVar3 + iVar7;
      }
    }
    if (*(uint8_t *)&(vif_entry->u).field_0x1c != uVar8) {
      puVar4 = (uint8_t *)ke_msg_alloc(0x57,0xd,0,3);
      uVar2 = vif_entry->index;
      puVar4[1] = uVar8;
      puVar4[2] = rssi;
      *puVar4 = uVar2;
      ke_msg_send(puVar4);
    }
    *(uint8_t *)&(vif_entry->u).field_0x1c = uVar8;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_send_csa_traffic_ind(uint8_t vif_index,_Bool enable)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x59,0xd,0,2);
  *puVar1 = vif_index;
  puVar1[1] = enable;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool mm_check_beacon(rx_hd *rhd,vif_info_tag *vif_entry,sta_info_tag *p_sta_entry,uint32_t *tim)

{
  ushort len;
  ushort uVar1;
  ushort uVar2;
  uint uVar3;
  int iVar4;
  uint8_t uVar5;
  undefined3 extraout_var;
  uint32_t uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint uVar9;
  uint32_t uVar10;
  uint uVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  char *pcVar16;
  uint uVar17;
  
  len = rhd->frmlen;
  iVar13 = *(int *)(rhd->first_pbd_ptr + 8);
  *(undefined *)&(vif_entry->u).field_0x18 = 0;
  beacon_rx_count = beacon_rx_count + 1;
  iVar15 = *(int *)&(vif_entry->u).field_0x14;
  if (*(char *)&(vif_entry->u).field_0x1e != '\0') {
    mm_send_csa_traffic_ind(vif_entry->index,true);
    *(undefined *)&(vif_entry->u).field_0x1e = 0;
  }
  if ((((30000000 - _DAT_44b00120) + *(int *)&(vif_entry->u).field_0x10 < 0) &&
      (mm_env.keep_alive_status_enabled != false)) &&
     (uVar5 = txl_frame_send_null_frame
                        (*(uint8_t *)&(vif_entry->u).field_0x4,(cfm_func_ptr *)0x0,(void *)0x0),
     CONCAT31(extraout_var,uVar5) == 0)) {
    *(int *)&(vif_entry->u).field_0x10 = _DAT_44b00120;
  }
  uVar3 = len - 0x24;
  mm_check_rssi(vif_entry,*(int8_t *)((int)&rhd->recvec1c + 3));
  uVar6 = co_crc32(iVar13 + 0x20,4,0);
  pcVar16 = (char *)(iVar13 + 0x24);
  *tim = 0;
  while (uVar3 = uVar3 & 0xffff, 1 < uVar3) {
    uVar14 = (uint)(byte)pcVar16[1];
    if (uVar3 <= uVar14 + 1) break;
    if (*pcVar16 == '\x05') {
      *tim = (uint32_t)pcVar16;
    }
    else {
      uVar6 = co_crc32((uint32_t)(pcVar16 + 2),uVar14,uVar6);
    }
    uVar3 = uVar3 + (-2 - uVar14);
    pcVar16 = pcVar16 + 2 + uVar14;
  }
  *(uint32_t *)&(vif_entry->u).field_0x14 = uVar6;
  uVar1 = p_sta_entry->drift;
  uVar2 = *(ushort *)(iVar13 + 0x20);
  uVar3 = *(uint *)(iVar13 + 0x18);
  uVar6 = rhd->tsflo;
  iVar4 = (uint)uVar2 * 0x400;
  iVar13 = *(int *)(iVar13 + 0x1c);
  uVar14 = (uint)*(ushort *)&vif_entry->u;
  if (uVar14 == 0) {
    uVar10 = *tim;
    uVar14 = 1;
    if ((uVar10 != 0) && (uVar14 = (uint)*(byte *)(uVar10 + 2), uVar14 == 0)) {
      uVar14 = (uint)*(byte *)(uVar10 + 3);
    }
  }
  uVar10 = hal_machw_rx_duration(rhd,len);
  uVar7 = hal_machw_rx_duration(rhd,0x18);
  uVar8 = uVar3;
  iVar12 = iVar13;
  __udivdi3();
  uVar11 = uVar3 - uVar7;
  uVar17 = iVar13 - (uint)(uVar3 < uVar11);
  uVar9 = iVar12 * iVar4 + (int)((ulonglong)uVar8 * (ulonglong)uVar2 * 0x400 >> 0x20);
  if ((uVar9 < uVar17) || ((uVar17 == uVar9 && (uVar8 * iVar4 < uVar11)))) {
    uVar11 = uVar8 * iVar4;
  }
  iVar12 = ((uVar11 + uVar14 * iVar4) - ((uVar3 - uVar6) + (uVar10 - uVar7))) - uVar1 * uVar14;
  iVar13 = iVar12 + -400;
  if (iVar12 + (-0xc80 - _DAT_44b00120) < 0) {
    iVar13 = iVar13 + iVar4;
  }
  uVar6 = (_DAT_44b00120 - _DAT_44b080a4) + iVar13;
  if (uVar6 != (vif_entry->tbtt_timer).time) {
    mm_timer_set(&vif_entry->tbtt_timer,uVar6);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(*(int *)&(vif_entry->u).field_0x14 != iVar15);
}



void mm_sta_tbtt(void *env)

{
  uint32_t value;
  _Bool _Var1;
  undefined3 extraout_var;
  byte bVar2;
  
  if (*(char *)((int)env + 0x58) == '\0') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (*(char *)((int)env + 0x79) != '\0') {
    bVar2 = *(char *)((int)env + 0x79) - 1;
    *(byte *)((int)env + 0x79) = bVar2;
    if (bVar2 < 2) {
      vif_mgmt_switch_channel((vif_info_tag *)env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (bVar2 == 2) {
      mm_send_csa_traffic_ind(*(uint8_t *)((int)env + 0x57),false);
    }
  }
  value = sta_info_tab[*(byte *)((int)env + 0x60)].bcn_int + *(int *)((int)env + 0x24);
  mm_timer_set((mm_timer_tag *)((int)env + 0x18),value);
  vif_mgmt_bcn_to_prog((vif_info_tag *)env);
  chan_tbtt_switch_update((vif_info_tag *)env,value);
  _Var1 = chan_is_on_channel((vif_info_tag *)env);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    *(uint *)((int)env + 4) = *(uint *)((int)env + 4) | 1;
    bVar2 = *(char *)((int)env + 0x74) + 1;
    *(byte *)((int)env + 0x74) = bVar2;
    if (100 < bVar2) {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),mm_ap_probe_cfm,env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (bVar2 == 100) {
      chan_bcn_detect_start((vif_info_tag *)env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint16_t mm_get_rsn_wpa_ie(uint8_t sta_id,uint8_t *wpa_ie)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,sta_id)].inst_nbr;
  memcpy(wpa_ie,vif_info_tab[uVar1].bss_info.rsn_wpa_ie,
         (uint)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)(ushort)vif_info_tab[uVar1].bss_info.rsn_wpa_ie_len;
}



void mm_tim_update_proceed(mm_tim_update_req *param)

{
  byte bVar1;
  char cVar2;
  ushort uVar3;
  uint uVar4;
  uint8_t (*pauVar5) [251];
  uint uVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  short sVar13;
  byte *pbVar14;
  
  uVar3 = param->aid;
  uVar10 = (uint)param->inst_nbr;
  if (uVar3 == 0) {
    if (param->tx_avail == '\0') {
      *(undefined *)&vif_info_tab[uVar10].u.field_0x2ea = 0;
    }
    else {
      *(undefined *)&vif_info_tab[uVar10].u.field_0x2ea = 1;
    }
  }
  else {
    iVar9 = uVar10 * 8;
    uVar11 = (uint)(uVar3 >> 3);
    uVar12 = uVar11 & 0xff;
    pauVar5 = (uint8_t (*) [251])((int)txl_tim_bitmap_pool + uVar10 * 0xfc);
    pbVar14 = *pauVar5 + uVar12;
    bVar1 = *pbVar14;
    uVar8 = 1 << (uVar3 & 7);
    uVar6 = uVar8 & 0xff;
    uVar4 = uVar6 & bVar1;
    if (param->tx_avail == '\0') {
      if (uVar4 != 0) {
        *pbVar14 = ~(byte)uVar8 & bVar1;
        sVar13 = *(short *)&vif_info_tab[uVar10].u.field_0x2e0 + -1;
        *(short *)&vif_info_tab[uVar10].u.field_0x2e0 = sVar13;
        if (sVar13 == 0) {
          *(undefined2 *)&vif_info_tab[uVar10].u.field_0x2de = 6;
          *(undefined2 *)&vif_info_tab[uVar10].u.field_0x2e8 = 0xff;
          cVar2 = *(char *)&vif_info_tab[uVar10].u.field_0x2de;
          *(undefined *)((int)txl_tim_ie_pool + iVar9 + 4) = 0;
          *(char *)((int)txl_tim_ie_pool + iVar9 + 1) = cVar2 + -2;
          txl_tim_desc[uVar10][0].dataendptr = iVar9 + 0x42047365;
          txl_tim_desc[uVar10][0].next = (uint32_t)(txl_bcn_end_desc + param->inst_nbr);
          txl_tim_desc[uVar10][1].dataendptr =
               (uint32_t)(*pauVar5 + *(byte *)&vif_info_tab[uVar10].u.field_0x2e9);
        }
        else {
          if ((uint)*(byte *)&vif_info_tab[uVar10].u.field_0x2e8 == (uVar11 & 0xfe)) {
            while( true ) {
              bVar1 = *(byte *)&vif_info_tab[uVar10].u.field_0x2e8;
              uVar4 = (uint)bVar1;
              if ((uVar4 == 0xfb) || ((*pauVar5)[uVar4] != '\0')) break;
              *(byte *)&vif_info_tab[uVar10].u.field_0x2e8 = bVar1 + 1;
            }
            *(char *)&vif_info_tab[uVar10].u.field_0x2e8 = (char)(uVar4 & 0xfe);
            txl_tim_desc[uVar10][1].datastartptr = (uint32_t)(*pauVar5 + (uVar4 & 0xfe));
          }
          if (*(byte *)&vif_info_tab[uVar10].u.field_0x2e9 == uVar12) {
            while( true ) {
              bVar1 = *(byte *)&vif_info_tab[uVar10].u.field_0x2e9;
              if ((bVar1 == 0) || ((*pauVar5)[bVar1] != '\0')) break;
              *(byte *)&vif_info_tab[uVar10].u.field_0x2e9 = bVar1 - 1;
            }
            txl_tim_desc[uVar10][1].dataendptr = (uint32_t)(*pauVar5 + bVar1);
          }
          iVar7 = ((*(byte *)&vif_info_tab[uVar10].u.field_0x2e9 + 6) -
                  (uint)*(byte *)&vif_info_tab[uVar10].u.field_0x2e8) * 0x10000;
          *(short *)&vif_info_tab[uVar10].u.field_0x2de = (short)((uint)iVar7 >> 0x10);
          *(char *)((int)txl_tim_ie_pool + iVar9 + 1) = (char)((uint)iVar7 >> 0x10) + -2;
          *(undefined *)((int)txl_tim_ie_pool + iVar9 + 4) =
               *(undefined *)&vif_info_tab[uVar10].u.field_0x2e8;
        }
      }
    }
    else {
      if (uVar4 == 0) {
        *pbVar14 = (byte)uVar6 | bVar1;
        bVar1 = *(byte *)&vif_info_tab[uVar10].u.field_0x2e8;
        *(short *)&vif_info_tab[uVar10].u.field_0x2e0 =
             *(short *)&vif_info_tab[uVar10].u.field_0x2e0 + 1;
        if (uVar12 < bVar1) {
          *(char *)&vif_info_tab[uVar10].u.field_0x2e8 = (char)(uVar11 & 0xfe);
          txl_tim_desc[uVar10][1].datastartptr = (uint32_t)(*pauVar5 + (uVar11 & 0xfe));
        }
        if (*(byte *)&vif_info_tab[uVar10].u.field_0x2e9 < uVar12) {
          *(char *)&vif_info_tab[uVar10].u.field_0x2e9 = (char)uVar12;
          txl_tim_desc[uVar10][1].dataendptr = (uint32_t)pbVar14;
        }
        iVar7 = ((*(byte *)&vif_info_tab[uVar10].u.field_0x2e9 + 6) -
                (uint)*(byte *)&vif_info_tab[uVar10].u.field_0x2e8) * 0x10000;
        *(short *)&vif_info_tab[uVar10].u.field_0x2de = (short)((uint)iVar7 >> 0x10);
        *(char *)((int)txl_tim_ie_pool + iVar9 + 1) = (char)((uint)iVar7 >> 0x10) + -2;
        *(undefined *)((int)txl_tim_ie_pool + iVar9 + 4) =
             *(undefined *)&vif_info_tab[uVar10].u.field_0x2e8;
        txl_tim_desc[uVar10][0].dataendptr = iVar9 + 0x42047364;
        txl_tim_desc[uVar10][0].next = uVar10 * 0x28 + 0x42047aa4;
      }
    }
  }
  ke_msg_send_basic(0x42,param[-1].aid,0);
  ke_msg_free(param + -3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_bcn_init(void)

{
  memset(&mm_bcn_env,0,0x24);
  mm_bcn_env.dma.dma_desc = &bcn_dwnld_desc;
  mm_bcn_env.dma.cb = mm_bcn_updated;
  co_list_init(&mm_bcn_env.tim_list);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_bcn_init_vif(vif_info_tag *vif_entry)

{
  undefined uVar1;
  byte bVar2;
  tx_pbd *ptVar3;
  uint8_t (*__s) [251];
  uint uVar4;
  int iVar5;
  
  uVar4 = (uint)vif_entry->index;
  txl_frame_init_desc((txl_frame_desc_tag *)&(vif_entry->u).field_0x4,
                      (txl_buffer_tag *)txl_bcn_pool[uVar4],txl_bcn_hwdesc_pool + uVar4,
                      txl_bcn_buf_ctrl + uVar4);
  txl_bcn_hwdesc_pool[uVar4].cfm_ptr = txl_bcn_hwdesc_cfms + vif_entry->index;
  uVar4 = (uint)vif_entry->index;
  iVar5 = uVar4 * 8;
  *(undefined *)&(vif_entry->u).field_0x2e7 = 0;
  *(undefined2 *)&(vif_entry->u).field_0x2e0 = 0;
  *(undefined *)&(vif_entry->u).field_0x2ea = 0;
  __s = (uint8_t (*) [251])((int)txl_tim_bitmap_pool + uVar4 * 0xfc);
  *(undefined2 *)&(vif_entry->u).field_0x2de = 6;
  *(undefined2 *)&(vif_entry->u).field_0x2e8 = 0xff;
  txl_tim_desc[uVar4][0].dataendptr = iVar5 + 0x42047365;
  txl_tim_desc[uVar4][0].upatterntx = 0xcafefade;
  txl_tim_desc[uVar4][0].datastartptr = (uint32_t)(uint8_t (*) [6])((int)txl_tim_ie_pool + iVar5);
  txl_tim_desc[uVar4][0].bufctrlinfo = 0;
  ptVar3 = txl_bcn_end_desc + uVar4;
  txl_tim_desc[uVar4][0].next = (uint32_t)ptVar3;
  (*(uint8_t (*) [6])((int)txl_tim_ie_pool + iVar5))[0] = '\x05';
  *(undefined *)((int)txl_tim_ie_pool + iVar5 + 1) = 4;
  uVar1 = *(undefined *)&(vif_entry->u).field_0x2e7;
  *(undefined *)((int)txl_tim_ie_pool + iVar5 + 4) = 0;
  *(undefined *)((int)txl_tim_ie_pool + iVar5 + 2) = uVar1;
  *(undefined *)((int)txl_tim_ie_pool + iVar5 + 3) = 1;
  *(undefined *)((int)txl_tim_ie_pool + iVar5 + 5) = 0xff;
  txl_tim_desc[uVar4][1].upatterntx = 0xcafefade;
  bVar2 = *(byte *)&(vif_entry->u).field_0x2e9;
  txl_tim_desc[uVar4][1].next = (uint32_t)ptVar3;
  txl_tim_desc[uVar4][1].dataendptr = (uint32_t)(*__s + bVar2);
  memset(__s,0,0xfc);
  ptVar3->upatterntx = 0xcafefade;
  txl_bcn_end_desc[uVar4].next = 0;
  txl_bcn_end_desc[uVar4].bufctrlinfo = 0;
  iVar5 = *(int *)&(vif_entry->u).field_0x70;
  *(undefined4 *)(iVar5 + 0x24) = 0;
  *(undefined4 *)(iVar5 + 0x3c) = 0;
  *(undefined4 *)(iVar5 + 0x10) = 0;
  *(code **)&(vif_entry->u).field_0x2d0 = mm_bcn_transmitted;
  *(vif_info_tag **)&(vif_entry->u).field_0x2d4 = vif_entry;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_tim_update(mm_tim_update_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    co_list_push_back(&mm_bcn_env.tim_list,(co_list_hdr *)(param + -3));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  mm_tim_update_proceed(param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void mm_bcn_transmit(void)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  vif_info_tag *vif;
  txl_frame_desc_tag *frame;
  _Bool _Var4;
  undefined3 extraout_var;
  char *pcVar5;
  undefined3 extraout_var_00;
  uint8_t *puVar6;
  int iVar7;
  byte bVar8;
  uint uVar9;
  char cVar10;
  int iVar11;
  
  vif = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (mm_bcn_env.tx_cfm != 0) {
    assert_err("!mm_bcn_env.tx_cfm","module",0x339);
  }
  if (mm_bcn_env.update_ongoing == false) {
    mm_bcn_env.tx_pending = false;
    while (vif != (vif_info_tag *)0x0) {
      if (((vif->type == '\x02') && (*(char *)((int)&vif->u + 0x2e6) != '\0')) &&
         (*(char *)((int)&vif->u + 0x2e5) == *(char *)((int)&vif->u + 0x2e4))) {
        iVar7 = *(int *)((int)&vif->u + 0x70);
        iVar11 = (uint)vif->index * 8;
        bVar1 = *(byte *)((int)txl_tim_ie_pool + iVar11 + 4);
        *(uint *)(iVar7 + 0x1c) =
             (uint)*(ushort *)((int)&vif->u + 0x2dc) + (uint)*(ushort *)((int)&vif->u + 0x2de) + 4;
        uVar9 = (uint)txl_cntrl_env.seqnbr;
        frame = (txl_frame_desc_tag *)((int)&vif->u + 4);
        txl_cntrl_env.seqnbr = (uint16_t)((uVar9 + 1) * 0x10000 >> 0x10);
        *(short *)(*(int *)(iVar7 + 0x14) + 0x16) = (short)((uVar9 + 1 & 0xffff) << 4);
        cVar10 = *(char *)((int)&vif->u + 0x2e7);
        *(char *)((int)txl_tim_ie_pool + iVar11 + 2) = cVar10;
        if (cVar10 == '\0') {
          if ((*(char *)((int)&vif->u + 0x2ea) != '\0') ||
             (bVar8 = bVar1 & 0xfe, ipc_emb_env.txdesc[ipc_emb_env.txdesc_idx & 3].ready != 0)) {
            bVar8 = bVar1 | 1;
          }
          *(undefined *)((int)&vif->u + 0x2e7) = *(undefined *)((int)txl_tim_ie_pool + iVar11 + 3);
        }
        else {
          bVar8 = bVar1 & 0xfe;
          if ((*(byte *)((int)&vif->u + 0x2ea) & 2) != 0) {
            bVar8 = bVar1 | 1;
          }
        }
        *(byte *)((int)txl_tim_ie_pool + iVar11 + 4) = bVar8 | 1;
        *(char *)((int)&vif->u + 0x2e7) = *(char *)((int)&vif->u + 0x2e7) + -1;
        cVar10 = *(char *)((int)&vif->u + 0x2eb);
        if (cVar10 != '\0') {
          uVar9 = (uint)*(byte *)((int)&vif->u + 0x2ec);
          cVar10 = cVar10 + -1;
          *(char *)((int)&vif->u + 0x2eb) = cVar10;
          if (uVar9 != 0) {
            *(char *)(*(int *)(iVar7 + 0x14) + uVar9) = cVar10;
            uVar9 = (uint)*(byte *)((int)&vif->u + 0x2ed);
            if (uVar9 != 0) {
              *(undefined *)(*(int *)(iVar7 + 0x14) + uVar9) = *(undefined *)((int)&vif->u + 0x2eb);
            }
          }
          uVar2 = *(uint8_t *)((int)&vif->u + 0x2eb);
          if (uVar2 != '\0') {
            uVar3 = vif->index;
            puVar6 = (uint8_t *)ke_msg_alloc(0x4e,0xd,0,2);
            *puVar6 = uVar3;
            puVar6[1] = uVar2;
            ke_msg_send(puVar6);
            if (*(char *)((int)&vif->u + 0x2eb) != '\0') goto LAB_230033a6;
          }
          *(undefined *)((int)&vif->u + 0x2eb) = 1;
        }
LAB_230033a6:
        tpc_update_frame_tx_power(vif,frame);
        _Var4 = chan_is_on_operational_channel(vif);
        if (CONCAT31(extraout_var,_Var4) != 0) {
          uVar2 = vif->index;
          pcVar5 = (char *)ke_msg_alloc(0x4a,0xd,0,3);
          *pcVar5 = uVar2 + '\n';
          pcVar5[1] = '\0';
          pcVar5[2] = '\0';
          ke_msg_send(pcVar5);
          *(uint8_t *)((int)&vif->u + 0x33) = vif->index;
          *(undefined *)((int)&vif->u + 0x34) = 0xff;
          _Var4 = txl_frame_push(frame,'\x04');
          if (CONCAT31(extraout_var_00,_Var4) != 0) {
            mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + 1;
          }
          iVar7 = vif->index + 10;
          if ((sta_info_tab[iVar7].traffic_avail & PS_TRAFFIC_INT) != 0) {
            sta_info_tab[iVar7].ps_service_period = 9;
            sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar7,0);
            sta_info_tab[iVar7].ps_service_period = 0;
          }
        }
      }
      vif = *(vif_info_tag **)&vif->list_hdr;
    }
  }
  else {
    mm_bcn_env.tx_pending = true;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_bcn_updated(void *env,int dma_queue)

{
  ushort uVar1;
  ushort uVar2;
  mm_bcn_change_req *pmVar3;
  int iVar4;
  uint32_t uVar5;
  int iVar6;
  txl_buffer_control *ptVar7;
  mm_bcn_change_req *mem_ptr;
  int iVar8;
  uint uVar9;
  int iVar10;
  
  mem_ptr = mm_bcn_env.param + -1;
  ke_msg_send_basic(0x40,*(ke_task_id_t *)&mm_bcn_env.param[-1].tim_len,0);
  pmVar3 = mm_bcn_env.param;
  uVar9 = (uint)*(byte *)((int)env + 0x57);
  iVar4 = *(int *)((int)env + 0xcc);
  uVar1 = (mm_bcn_env.param)->tim_oft;
  iVar10 = (uint)(mm_bcn_env.param)->bcn_len - (uint)(mm_bcn_env.param)->tim_len;
  iVar8 = *(int *)(iVar4 + 0x14);
  *(short *)((int)env + 0x338) = (short)iVar10;
  me_beacon_check(*(byte *)((int)env + 0x57),pmVar3->bcn_len,*(uint32_t *)(iVar4 + 0x14));
  iVar6 = *(int *)(iVar4 + 0x14) + (pmVar3->tim_oft - 1);
  *(int *)(iVar4 + 0x18) = iVar6;
  uVar5 = pmVar3->tim_len + 1 + iVar6;
  txl_bcn_end_desc[uVar9].datastartptr = uVar5;
  uVar2 = pmVar3->tim_oft;
  txl_bcn_end_desc[uVar9].bufctrlinfo = 0;
  txl_bcn_end_desc[uVar9].dataendptr = ~(uint)uVar2 + iVar10 + uVar5;
  if (*(char *)(*(int *)((int)env + 0x40) + 4) == '\0') {
    ptVar7 = &txl_buffer_control_24G;
  }
  else {
    ptVar7 = &txl_buffer_control_5G;
  }
  *(uint *)&(ptVar7->field_0).field_0x24 = _DAT_44b000a0 & 0xff;
  *(txl_buffer_control **)(iVar4 + 0x28) = ptVar7;
  *(undefined4 *)(iVar4 + 0x24) = 0;
  *(undefined4 *)(iVar4 + 0x3c) = 0;
  *(tx_pbd (**) [2])(iVar4 + 0x10) = txl_tim_desc[*(byte *)((int)env + 0x57)];
  *(undefined *)((int)env + 0x342) = 1;
  *(undefined *)((int)txl_tim_ie_pool + uVar9 * 8 + 3) = *(undefined *)(iVar8 + uVar1 + 3);
  pmVar3 = mm_bcn_env.param;
  *(undefined *)((int)env + 0x347) = 0;
  *(uint8_t *)((int)env + 0x348) = pmVar3->csa_oft[0];
  *(uint8_t *)((int)env + 0x349) = pmVar3->csa_oft[1];
  if (pmVar3->csa_oft[0] != 0) {
    *(char *)((int)env + 0x347) =
         *(char *)(*(int *)(*(int *)((int)env + 0xcc) + 0x14) + (uint)pmVar3->csa_oft[0]) + '\x01';
  }
  mm_bcn_env.update_ongoing = false;
  if (mm_bcn_env.tx_pending != false) {
    mm_bcn_transmit();
  }
  mm_bcn_env.param = (mm_bcn_change_req *)0x0;
  ke_msg_free(mem_ptr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_bcn_update(mm_bcn_change_req *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  memcpy(txl_bcn_pool[bVar1] + 0x53,param + 1,(uint)param->bcn_len);
  mm_bcn_env.update_pending = false;
  mm_bcn_env.update_ongoing = true;
  mm_bcn_updated(vif_info_tab + bVar1,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_bcn_transmitted(void *env,uint32_t status)

{
  co_list_hdr *pcVar1;
  
  if (mm_bcn_env.tx_cfm == 0) {
    assert_err("mm_bcn_env.tx_cfm","module",0x244);
  }
  mm_bcn_env.tx_cfm = mm_bcn_env.tx_cfm + -1;
  if (mm_bcn_env.tx_cfm == 0) {
    if (mm_bcn_env.update_pending != false) {
      mm_bcn_update(mm_bcn_env.param);
    }
    while (mm_bcn_env.tim_list.first != (co_list_hdr *)0x0) {
      pcVar1 = co_list_pop_front(&mm_bcn_env.tim_list);
      mm_tim_update_proceed((mm_tim_update_req *)(pcVar1 + 3));
    }
    if (*(char *)((int)env + 0x347) == '\x01') {
      vif_mgmt_switch_channel((vif_info_tag *)env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_bcn_change(mm_bcn_change_req *param)

{
  if (mm_bcn_env.tx_cfm != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    mm_bcn_env.param = param;
    mm_bcn_env.update_pending = true;
    return;
  }
  mm_bcn_env.param = param;
  mm_bcn_update(param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_hw_set(mm_timer_tag *timer)

{
  if (timer == (mm_timer_tag *)0x0) {
    _DAT_44b0808c = _DAT_44b0808c & 0xffffff7f;
  }
  else {
    _DAT_44b00144 = timer->time;
    if ((_DAT_44b0808c & 0x80) == 0) {
      _DAT_44b08088 = 0x80;
      _DAT_44b0808c = _DAT_44b0808c | 0x80;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUB41((uint)((int)timerA[3].next - (int)timerB[3].next) >> 0x1f,0);
}



void mm_timer_init(void)

{
  co_list_init((co_list *)&mm_timer_env);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_set(mm_timer_tag *timer,uint32_t value)

{
  bool bVar1;
  
  if ((int)(value - _DAT_44b00120) < 0) {
    puts("\r\n-------------------[FW] Timer is past due to flash operation. Try to fix\r\n");
    value = _DAT_44b00120 + 3000;
  }
  bVar1 = timer != (mm_timer_tag *)mm_timer_env.prog.first;
  if (bVar1) {
    co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  }
  else {
    co_list_pop_front((co_list *)&mm_timer_env);
  }
  timer->time = value;
  co_list_insert((co_list *)&mm_timer_env,(co_list_hdr *)timer,cmp_abs_time);
  if ((!bVar1) || (timer == (mm_timer_tag *)mm_timer_env.prog.first)) {
    mm_timer_hw_set((mm_timer_tag *)mm_timer_env.prog.first);
  }
  if ((int)(value - _DAT_44b00120) < 0) {
    ke_evt_set(0x8000000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_timer_clear(mm_timer_tag *timer)

{
  if (timer == (mm_timer_tag *)mm_timer_env.prog.first) {
    co_list_pop_front((co_list *)&mm_timer_env);
    mm_timer_hw_set((mm_timer_tag *)mm_timer_env.prog.first);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  co_list_extract((co_list *)&mm_timer_env,(co_list_hdr *)timer);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mm_timer_schedule(int dummy)

{
  co_list_hdr *pcVar1;
  
  while( true ) {
    ke_evt_clear(0x8000000);
    pcVar1 = mm_timer_env.prog.first;
    if (mm_timer_env.prog.first == (co_list_hdr *)0x0) {
      mm_timer_hw_set((mm_timer_tag *)0x0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((-1 < (int)mm_timer_env.prog.first[3].next + (-0x32 - _DAT_44b00120)) &&
       (mm_timer_hw_set((mm_timer_tag *)mm_timer_env.prog.first),
       -1 < (int)((int)pcVar1[3].next - _DAT_44b00120))) break;
    co_list_pop_front((co_list *)&mm_timer_env);
    if (pcVar1[1].next == (co_list_hdr *)0x0) {
      assert_err("timer->cb","module",0xde);
    }
    (*(code *)pcVar1[1].next)(pcVar1[2].next,pcVar1[1].next);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_timer_handle(void *env)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 extraout_var;
  int iVar3;
  int iVar2;
  
  iVar3 = 0;
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (*(char *)((int)&p_vif_entry->u + 0xc) != '\0')) {
      _Var1 = chan_is_on_channel(p_vif_entry);
      iVar2 = CONCAT31(extraout_var,_Var1);
      if ((iVar2 != 0) &&
         (iVar3 = iVar2,
         (int)(((ps_env.uapsd_timeout >> 1) - _DAT_44b00120) + *(int *)((int)&p_vif_entry->u + 8)) <
         0)) {
        p_vif_entry->prevent_sleep = p_vif_entry->prevent_sleep | 8;
        txl_frame_send_qosnull_frame
                  (*(uint8_t *)((int)&p_vif_entry->u + 4),7,(cfm_func_ptr *)0x0,(void *)0x0);
        *(int *)((int)&p_vif_entry->u + 8) = _DAT_44b00120;
      }
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (iVar3 != 0) {
    mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ps_env.uapsd_tmr_on = false;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = CONCAT31(in_register_00002029,pwrmgt) << 2 | _DAT_44b0004c & 0xfffffffb;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_dpsm_update(_Bool pause)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  if (CONCAT31(in_register_00002029,pause) == 0) {
    ps_env.dpsm_state = ps_env.dpsm_state | 4;
    ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffff7;
    UNRECOVERED_JUMPTABLE = ps_enable_cfm;
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 2;
    ps_env.prevent_sleep = ps_env.prevent_sleep | 8;
    UNRECOVERED_JUMPTABLE = ps_disable_cfm;
  }
  blmac_pwr_mgt_setf(pause ^ 1);
  ps_env.cfm_cnt = '\0';
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
       (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
      *(undefined *)((int)&p_vif_entry->u + 3) = 0;
      ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
      txl_frame_send_null_frame
                (*(uint8_t *)((int)&p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
    }
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x230039d8. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t ps_send_pspoll(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char cStack40;
  phy_channel_info phy_info;
  
  uVar4 = (uint)*(byte *)&(vif_entry->u).field_0x4;
  phy_get_channel((phy_channel_info *)&cStack40,'\0');
  frame = txl_frame_get((uint)(cStack40 != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(char *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_init(void)

{
  memset(&ps_env,0,0x28);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ps_env.uapsd_timer.cb = ps_uapsd_timer_handle;
  return;
}



// WARNING: Type propagation algorithm not settling

void ps_set_mode(uint8_t mode,ke_task_id_t taskid)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  code *UNRECOVERED_JUMPTABLE;
  
  ps_env.taskid = taskid;
  if (((ps_env.dpsm_state & 1) == 0) || ((ps_env.dpsm_state & 6) == 0)) {
    if (CONCAT31(in_register_00002029,mode) == 0) {
      ps_env.dpsm_state = '\0';
      UNRECOVERED_JUMPTABLE = ps_disable_cfm;
      blmac_pwr_mgt_setf(mode);
    }
    else {
      if (CONCAT31(in_register_00002029,mode) == 2) {
        ps_env.dpsm_state = ps_env.dpsm_state | 1;
      }
      blmac_pwr_mgt_setf('\x01');
      UNRECOVERED_JUMPTABLE = ps_enable_cfm;
    }
    ps_env.cfm_cnt = '\0';
    ps_env.uapsd_on = false;
    p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
    while (p_vif_entry != (vif_info_tag *)0x0) {
      if (((p_vif_entry->type == '\0') && (p_vif_entry->active != false)) &&
         (_Var1 = chan_is_on_channel(p_vif_entry), CONCAT31(extraout_var,_Var1) != 0)) {
        *(undefined *)((int)&p_vif_entry->u + 3) = 0;
        ps_env.cfm_cnt = ps_env.cfm_cnt + '\x01';
        if (*(char *)((int)&p_vif_entry->u + 0xc) != '\0') {
          ps_env.uapsd_on = true;
        }
        txl_frame_send_null_frame
                  (*(uint8_t *)((int)&p_vif_entry->u + 4),UNRECOVERED_JUMPTABLE,p_vif_entry);
      }
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (ps_env.cfm_cnt == '\0') {
                    // WARNING: Could not recover jumptable at 0x23003ba6. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((void *)0x0,0x800000);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    ps_env.dpsm_state = ps_env.dpsm_state | 0x10;
    ps_env.next_mode = mode;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_enable_cfm(void *env,uint32_t status)

{
  co_list_hdr cVar1;
  char cVar2;
  
  if (-1 < (int)(status << 8)) {
    cVar2 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar2;
    if (cVar2 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_enable_cfm,env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    if (ps_env.uapsd_on != false) {
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
      while (cVar1 != (co_list_hdr)0x0) {
        if (((*(char *)((int)cVar1 + 0x56) == '\0') &&
            (*(char *)&((co_list_hdr *)((int)cVar1 + 0x58))->next != '\0')) &&
           (*(char *)&((co_list_hdr *)((int)cVar1 + 0x68))->next != '\0')) {
          ((co_list_hdr *)((int)cVar1 + 4))->next =
               (co_list_hdr *)((uint)((co_list_hdr *)((int)cVar1 + 4))->next & 0xfffffff7);
        }
        cVar1 = *(co_list_hdr *)cVar1;
      }
    }
    if ((ps_env.dpsm_state & 5) == 5) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xf3;
    }
    else {
      ps_env.ps_on = true;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ps_disable_cfm(void *env,uint32_t status)

{
  char cVar1;
  
  if (-1 < (int)(status << 8)) {
    cVar1 = *(char *)((int)env + 0x5f) + '\x01';
    *(char *)((int)env + 0x5f) = cVar1;
    if (cVar1 != '\x03') {
      txl_frame_send_null_frame(*(uint8_t *)((int)env + 0x60),ps_disable_cfm,env);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    mm_send_connection_loss_ind((vif_info_tag *)env);
  }
  if ((ps_env.cfm_cnt == '\0') || (ps_env.cfm_cnt = ps_env.cfm_cnt + -1, ps_env.cfm_cnt == '\0')) {
    mm_timer_clear(&ps_env.uapsd_timer);
    ps_env.uapsd_tmr_on = false;
    if ((ps_env.dpsm_state & 3) == 3) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xfd | 8;
    }
    else {
      ps_env.ps_on = false;
      ke_msg_send_basic(0x32,ps_env.taskid,0);
    }
    if ((ps_env.dpsm_state & 0x10) != 0) {
      ps_env.dpsm_state = ps_env.dpsm_state & 0xef;
      ps_set_mode(ps_env.next_mode,ps_env.taskid);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t ps_polling_frame(vif_info_tag *vif_entry)

{
  ushort uVar1;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar2;
  txl_buffer_tag *ptVar3;
  uint uVar4;
  char cStack40;
  
  uVar4 = (uint)*(byte *)&(vif_entry->u).field_0x4;
  phy_get_channel((phy_channel_info *)&cStack40,'\0');
  frame = txl_frame_get((uint)(cStack40 != '\0'),0x10);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_entry,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0xa4;
    *(undefined *)((int)&ptVar3[1].length + 1) = 0;
    uVar1 = sta_info_tab[uVar4].aid;
    *(char *)((int)&ptVar3[1].length + 2) = (char)uVar1;
    *(byte *)((int)&ptVar3[1].length + 3) = (byte)((uint)uVar1 >> 8) | 0xc0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[uVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_entry->mac_addr,6);
    ptVar2 = (frame->txdesc).lmac.hw_desc;
    (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 | 0x10000053;
    (frame->txdesc).host.vif_idx = sta_info_tab[uVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_info_tab[uVar4].staid;
    txl_frame_push(frame,'\x03');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



void ps_check_beacon(uint32_t tim,uint16_t len,vif_info_tag *vif_entry)

{
  byte sta_idx;
  ushort uVar1;
  _Bool _Var2;
  uint8_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar4;
  uint uVar5;
  uint32_t uVar6;
  byte bVar7;
  
  _Var2 = ps_env.ps_on;
  sta_idx = *(byte *)&(vif_entry->u).field_0x4;
  uVar1 = sta_info_tab[sta_idx].aid;
  uVar5 = vif_entry->prevent_sleep;
  uVar4 = uVar5 & 0xfffffffe;
  vif_entry->prevent_sleep = uVar4;
  if (((_Var2 == false) || ((ps_env.dpsm_state & 8) != 0)) || (tim == 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (*(char *)&(vif_entry->u).field_0x2 == '\0') {
    if ((*(byte *)(tim + 4) & 1) == 0) {
      vif_entry->prevent_sleep = uVar5 & 0xfffffffc;
    }
    else {
      vif_entry->prevent_sleep = uVar4 | 2;
    }
  }
  uVar5 = (uint)(uVar1 >> 3);
  uVar4 = *(byte *)(tim + 4) & 0xfe;
  bVar7 = *(byte *)&(vif_entry->u).field_0xc & 0xf;
  if (((uVar4 <= uVar5) && (uVar5 <= (*(byte *)(tim + 1) - 4) + uVar4)) &&
     (((uint)*(byte *)(((uVar5 + tim) - uVar4) + 5) & 1 << (uVar1 & 7)) != 0)) {
    if (bVar7 == 0xf) {
      uVar3 = txl_frame_send_qosnull_frame(sta_idx,7,(cfm_func_ptr *)0x0,(void *)0x0);
      if (CONCAT31(extraout_var,uVar3) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar6 = vif_entry->prevent_sleep | 8;
    }
    else {
      uVar3 = ps_send_pspoll(vif_entry);
      if (CONCAT31(extraout_var_00,uVar3) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar6 = vif_entry->prevent_sleep | 4;
    }
    vif_entry->prevent_sleep = uVar6;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (bVar7 == 0xf) {
    uVar6 = vif_entry->prevent_sleep & 0xfffffff7;
  }
  else {
    uVar6 = vif_entry->prevent_sleep & 0xfffffffb;
  }
  vif_entry->prevent_sleep = uVar6;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_frame(uint8_t *frame,uint32_t statinfo,vif_info_tag *vif_entry)

{
  byte bVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  char cVar5;
  
  cVar5 = ps_env.uapsd_on;
  if (ps_env.ps_on == false) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar2 = (uint)*(ushort *)frame;
  if ((frame[4] & 1) != 0) {
    if (((int)(uVar2 << 0x12) < 0) && (*(char *)&(vif_entry->u).field_0x2 == '\0')) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar4 = vif_entry->prevent_sleep & 0xfffffffd;
LAB_23003ee6:
    vif_entry->prevent_sleep = uVar4;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((statinfo & 0x200) != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (ps_env.uapsd_on != false) {
    if ((uVar2 & 0x88) == 0x88) {
      if ((uVar2 & 0x300) == 0x300) {
        bVar1 = frame[0x1e];
      }
      else {
        bVar1 = frame[0x18];
      }
      if ((*(byte *)&(vif_entry->u).field_0xc >> ("\x01"[bVar1 & 7] & 0x1f) & 1) != 0) {
        *(undefined4 *)&(vif_entry->u).field_0x8 = _DAT_44b00120;
        if ((bVar1 & 0x10) == 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        uVar4 = vif_entry->prevent_sleep & 0xfffffff7;
        goto LAB_23003ee6;
      }
    }
    else {
      if (((*(ushort *)frame & 0xc) == 0) && ((*(byte *)&(vif_entry->u).field_0xc & 8) != 0)) {
        *(undefined4 *)&(vif_entry->u).field_0x8 = _DAT_44b00120;
        goto LAB_23003f80;
      }
    }
    cVar5 = '\0';
  }
LAB_23003f80:
  td_pck_ps_ind(vif_entry->index,true);
  if ((cVar5 == '\0') &&
     ((-1 < (int)(uVar2 << 0x12) ||
      (((ps_env.dpsm_state & 8) == 0 &&
       (uVar3 = ps_send_pspoll(vif_entry), CONCAT31(extraout_var,uVar3) != 0)))))) {
    vif_entry->prevent_sleep = vif_entry->prevent_sleep & 0xfffffffb;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_check_tx_frame(uint8_t staid,uint8_t tid)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  if ((((ps_env.ps_on != false) && (CONCAT31(in_register_00002029,staid) != 0xff)) &&
      (CONCAT31(in_register_0000202d,tid) != 0xff)) &&
     ((uVar1 = (uint)sta_info_tab[CONCAT31(in_register_00002029,staid)].inst_nbr,
      vif_info_tab[uVar1].type == '\0' && (vif_info_tab[uVar1].active != false)))) {
    if ((*(byte *)&vif_info_tab[uVar1].u.field_0xc >>
         ("\x01"[CONCAT31(in_register_0000202d,tid)] & 0x1f) & 1) != 0) {
      vif_info_tab[uVar1].prevent_sleep = vif_info_tab[uVar1].prevent_sleep | 8;
      *(undefined4 *)&vif_info_tab[uVar1].u.field_0x8 = _DAT_44b00120;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    td_pck_ps_ind(vif_info_tab[uVar1].index,false);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ps_uapsd_set(vif_info_tag *vif_entry,uint8_t hw_queue,_Bool uapsd)

{
  byte bVar1;
  byte bVar2;
  undefined3 in_register_00002031;
  
  bVar1 = *(byte *)&(vif_entry->u).field_0xc;
  bVar2 = (byte)(1 << (hw_queue & 0x1f));
  if (CONCAT31(in_register_00002031,uapsd) == 0) {
    *(byte *)&(vif_entry->u).field_0xc = bVar1 & ~bVar2;
  }
  else {
    *(byte *)&(vif_entry->u).field_0xc = bVar1 | bVar2;
    if ((ps_env.ps_on != false) && (ps_env.uapsd_tmr_on == false)) {
      ps_env.uapsd_on = true;
      mm_timer_set(&ps_env.uapsd_timer,_DAT_44b00120 + ps_env.uapsd_timeout);
      ps_env.uapsd_tmr_on = true;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ps_traffic_status_update(uint8_t vif_index,uint8_t new_status)

{
  _Bool pause;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  char cVar1;
  co_list_hdr cVar2;
  
  if (((ps_env.ps_on != false) && ((ps_env.dpsm_state & 1) != 0)) && ((ps_env.dpsm_state & 6) == 0))
  {
    cVar2 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (CONCAT31(in_register_0000202d,new_status) == 0) {
      while (cVar2 != (co_list_hdr)0x0) {
        if ((((uint)*(byte *)((int)cVar2 + 0x57) != CONCAT31(in_register_00002029,vif_index)) &&
            (cVar1 = *(char *)&((co_list_hdr *)((int)cVar2 + 0x58))->next, cVar1 != '\0')) &&
           ((*(char *)((int)cVar2 + 0x56) == '\0' &&
            ((td_env[*(byte *)((int)cVar2 + 0x57)].status & 0xc) != 0)))) goto LAB_230040e0;
        cVar2 = *(co_list_hdr *)cVar2;
      }
      cVar1 = '\0';
LAB_230040e0:
      if (cVar1 == '\0') {
        if ((ps_env.dpsm_state & 8) == 0) goto LAB_230040c6;
        pause = false;
        goto LAB_230040e8;
      }
    }
    pause = true;
    if ((ps_env.dpsm_state & 8) == 0) {
LAB_230040e8:
      ps_dpsm_update(pause);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
LAB_230040c6:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mm_ps_change_ind(uint8_t sta_idx,uint8_t ps_state)

{
  undefined3 in_register_00002029;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x49,0xd,0,2);
  sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].ps_state = ps_state;
  *puVar1 = sta_idx;
  puVar1[1] = ps_state;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_mpdu_transfer(rx_swdesc *swdesc)

{
  rx_pbd *prVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_dmadesc *prVar4;
  
  prVar4 = swdesc->dma_hdrdesc;
  prVar1 = (rx_pbd *)(prVar4->hd).first_pbd_ptr;
  phy_get_channel(&prVar4->phy_info,'\0');
  prVar4->payl_offset = mac_payload_offset;
  swdesc->pbd_count = '\0';
  prVar3 = (rx_pbd *)0x0;
  do {
    prVar2 = prVar1;
    if ((prVar2->bufstatinfo & 1) != 0) {
      swdesc->spare_pbd = prVar2;
      swdesc->last_pbd = prVar3;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    prVar1 = (rx_pbd *)prVar2->next;
    swdesc->pbd_count = swdesc->pbd_count + '\x01';
    prVar3 = prVar2;
  } while (prVar1 != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0xb4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_init(void)

{
  rxl_hwdesc_init(1);
  rx_swdesc_init();
  co_list_init((co_list *)&rxl_cntrl_env);
  rxu_cntrl_init();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_cntrl_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  
  uVar1 = co_list_cnt((co_list *)&rxl_cntrl_env);
  cVar2 = (co_list_hdr)rxl_cntrl_env.ready.first;
  if (uVar1 != 0) {
    while (cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timer_int_handler(void)

{
  rx_hd *prVar1;
  rx_dmadesc *desc;
  char *condition;
  rx_swdesc *list_hdr;
  int line;
  uint32_t uVar2;
  
  _DAT_44b0807c = 0xa0000;
  do {
    while( true ) {
      if ((rxl_cntrl_env.first == (rx_dmadesc *)0x0) ||
         (-1 < (int)(((rxl_cntrl_env.first)->hd).statinfo << 0x11))) {
        if (rxl_cntrl_env.ready.first != (co_list_hdr *)0x0) {
          ke_evt_set(0x40000);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      list_hdr = ((rxl_cntrl_env.first)->hd).swdesc;
      prVar1 = &(rxl_cntrl_env.first)->hd;
      desc = list_hdr->dma_hdrdesc;
      rxl_cntrl_env.first = (rx_dmadesc *)((rxl_cntrl_env.first)->hd).next;
      list_hdr->pd = (rx_payloaddesc *)prVar1->first_pbd_ptr;
      uVar2 = (desc->hd).first_pbd_ptr;
      if ((desc->hd).frmlen == 0) break;
      if (uVar2 == 0) {
        line = 0xd8;
        condition = "pd != NULL";
LAB_23004280:
        assert_rec(condition,"module",line);
      }
      else {
        co_list_push_back((co_list *)&rxl_cntrl_env,(co_list_hdr *)list_hdr);
      }
    }
    if (uVar2 != 0) {
      line = 0xfa;
      condition = "dma_hdrdesc->hd.first_pbd_ptr == 0";
      goto LAB_23004280;
    }
    list_hdr->spare_pbd = (rx_pbd *)0x0;
    list_hdr->last_pbd = (rx_pbd *)0x0;
    rxl_hd_append(desc);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_timeout_int_handler(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffbf;
  return;
}



void rxl_dma_int_handler(void)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_dma_evt(int dummy)

{
  ke_evt_clear(0x100000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44a00020 = 0x20;
  return;
}



void rxl_frame_release(rx_swdesc *swdesc)

{
  rxl_pd_append((rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr,swdesc->last_pbd,swdesc->spare_pbd
               );
  rxl_hd_append(swdesc->dma_hdrdesc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_mpdu_free(rx_swdesc *swdesc)

{
  ushort uVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  prVar2 = (rx_pbd *)(swdesc->dma_hdrdesc->hd).first_pbd_ptr;
  vTaskEnterCritical();
  swdesc->use_in_tcpip = '\0';
  swdesc->dma_hdrdesc->use_in_tcpip = 0;
  prVar4 = (rx_pbd *)0x0;
  do {
    prVar3 = prVar2;
    uVar1 = prVar3->bufstatinfo;
    prVar3[1].upattern = 0;
    if ((uVar1 & 1) != 0) {
      swdesc->spare_pbd = prVar3;
      swdesc->last_pbd = prVar4;
      rxl_frame_release(swdesc);
      vTaskExitCritical();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    prVar2 = (rx_pbd *)prVar3->next;
    prVar4 = prVar3;
  } while ((rx_pbd *)prVar3->next != (rx_pbd *)0x0);
  assert_rec("pd != NULL","module",0x397);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_cntrl_evt(int dummy)

{
  byte bVar1;
  ushort uVar2;
  co_list_hdr *swdesc;
  uint uVar3;
  uint uVar4;
  _Bool _Var5;
  uint8_t sta_idx;
  char *condition;
  undefined3 extraout_var;
  TickType_t TVar6;
  undefined3 extraout_var_00;
  uint8_t *puVar7;
  int iVar8;
  char cVar9;
  uint32_t uVar10;
  uint uVar11;
  vif_info_tag *pvVar12;
  sta_info_tag *p_sta_entry;
  rx_hd *rhd;
  ushort *frame;
  uint statinfo;
  int iStack100;
  uint32_t uStack68;
  uint32_t tim;
  
  iStack100 = 5;
  do {
    swdesc = rxl_cntrl_env.ready.first;
    ke_evt_clear(0x40000);
    if (swdesc == (co_list_hdr *)0x0) {
LAB_230043ec:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    iStack100 = iStack100 + -1;
    if (iStack100 == 0) {
      ke_evt_set(0x40000);
      goto LAB_230043ec;
    }
    co_list_pop_front((co_list *)&rxl_cntrl_env);
    rhd = (rx_hd *)swdesc[1].next;
    uVar10 = rhd->first_pbd_ptr;
    if (uVar10 == 0) {
      iVar8 = 0x205;
      condition = "rhd->first_pbd_ptr != 0";
LAB_2300443a:
      assert_rec(condition,"module",iVar8);
      goto LAB_2300443e;
    }
    statinfo = rhd->statinfo;
    if ((statinfo & 0x2002000) == 0x2002000) {
      if ((statinfo >> 0xf & 0x3f8) == 0) {
        iVar8 = 0x215;
        condition = "key_idx_hw >= MM_SEC_DEFAULT_KEY_COUNT";
        goto LAB_2300443a;
      }
      uVar3 = (statinfo >> 0xf & 0x3ff) - 8 & 0xff;
      p_sta_entry = sta_info_tab + uVar3;
      if (sta_info_tab[uVar3].valid == false) {
        rhd->statinfo = statinfo & 0xfdffffff;
      }
      else {
        uVar4 = (uint)sta_info_tab[uVar3].inst_nbr;
        TVar6 = xTaskGetTickCount();
        sta_info_tab[uVar3].time_last_seen = TVar6;
        frame = *(ushort **)(uVar10 + 8);
        uVar2 = *frame;
        bVar1 = vif_info_tab[uVar4].index;
        uVar11 = (uint)bVar1;
        pvVar12 = vif_info_tab + uVar11;
        sta_idx = (uint8_t)uVar3;
        if (vif_info_tab[uVar11].type == '\x02') {
          if (sta_info_tab[uVar3].ps_state == '\x01') {
            if ((uVar2 & 0x140c) == 8) {
              mm_ps_change_ind(sta_idx,'\0');
              apm_tx_int_ps_clear(pvVar12,sta_idx);
              cVar9 = *(char *)&vif_info_tab[uVar11].u.field_0x2ee + -1;
              *(char *)&vif_info_tab[uVar11].u.field_0x2ee = cVar9;
              if (cVar9 == '\0') {
                mm_ps_change_ind(bVar1 + 10,'\0');
                apm_tx_int_ps_clear(pvVar12,bVar1 + 10);
              }
            }
            else {
              if ((uVar2 & 0xfc) == 0xa4) {
                if ((sta_info_tab[uVar3].traffic_avail & PS_TRAFFIC_INT) == 0) {
                  puVar7 = (uint8_t *)ke_msg_alloc(0x4a,0xd,0,3);
                  *puVar7 = sta_idx;
                  puVar7[1] = '\x01';
                  puVar7[2] = '\0';
                  ke_msg_send(puVar7);
                }
                else {
                  sta_info_tab[uVar3].ps_service_period = sta_info_tab[uVar3].ps_service_period | 1;
                  sta_mgmt_send_postponed_frame(pvVar12,p_sta_entry,1);
                  sta_info_tab[uVar3].ps_service_period =
                       sta_info_tab[uVar3].ps_service_period & 0xfffffffe;
                }
              }
              if ((uVar2 & 0x8c) == 0x88) {
                if ((uVar2 & 0x300) == 0x300) {
                  bVar1 = *(byte *)(frame + 0xf);
                }
                else {
                  bVar1 = *(byte *)(frame + 0xc);
                }
                if ((mac_ac2uapsd["\x01"[bVar1 & 7]] & sta_info_tab[uVar3].info.uapsd_queues) != 0)
                {
                  uVar11 = sta_info_tab[uVar3].ps_service_period & 6;
                  if ((sta_info_tab[uVar3].traffic_avail & UAPSD_TRAFFIC) == 0) {
                    if (uVar11 == 0) {
                      sta_info_tab[uVar3].ps_service_period = 2;
LAB_2300467a:
                      txl_frame_send_qosnull_frame
                                (sta_info_tab[uVar3].staid,(ushort)(bVar1 & 7) | 0x10,
                                 (cfm_func_ptr *)0x0,(void *)0x0);
                      sta_info_tab[uVar3].ps_service_period = 0;
                    }
                  }
                  else {
                    if (uVar11 == 0) {
                      uVar11 = (uint)sta_info_tab[uVar3].info.max_sp_len;
                      if ((sta_info_tab[uVar3].traffic_avail & UAPSD_TRAFFIC_INT) != 0) {
                        sta_info_tab[uVar3].ps_service_period = 2;
                        iVar8 = sta_mgmt_send_postponed_frame(pvVar12,p_sta_entry,uVar11);
                        if ((uVar11 != 0) && (uVar11 = uVar11 - iVar8, (int)uVar11 < 1))
                        goto LAB_2300467a;
                      }
                      if ((sta_info_tab[uVar3].traffic_avail & UAPSD_TRAFFIC_HOST) == 0)
                      goto LAB_2300467a;
                      sta_info_tab[uVar3].ps_service_period = 4;
                      puVar7 = (uint8_t *)ke_msg_alloc(0x4a,0xd,0,3);
                      *puVar7 = sta_idx;
                      puVar7[1] = (uint8_t)uVar11;
                      puVar7[2] = '\x01';
                      ke_msg_send(puVar7);
                    }
                  }
                }
              }
            }
          }
          else {
            if ((uVar2 & 0x1400) == 0x1000) {
              mm_ps_change_ind(sta_idx,'\x01');
              if (*(char *)&vif_info_tab[uVar11].u.field_0x2ee == '\0') {
                mm_ps_change_ind(bVar1 + 10,'\x01');
              }
              *(char *)&vif_info_tab[uVar11].u.field_0x2ee =
                   *(char *)&vif_info_tab[uVar11].u.field_0x2ee + '\x01';
            }
          }
        }
        if (vif_info_tab[uVar4].active != false) {
          if ((uVar2 & 4) == 0) {
            td_pck_ind(vif_info_tab[uVar4].index,sta_idx,true);
          }
          pvVar12 = vif_info_tab + uVar4;
          if (vif_info_tab[uVar4].type == '\0') {
            if ((uVar2 & 0xfc) == 0x80) {
              uStack68 = 0;
              pa_input('\0',rhd);
              pa_adapt('\0');
              _Var5 = mm_check_beacon(rhd,pvVar12,p_sta_entry,&uStack68);
              ps_check_beacon(uStack68,rhd->frmlen,pvVar12);
              vif_mgmt_bcn_recv(pvVar12);
              if (vif_info_tab[uVar4].chan_ctxt != (chan_ctxt_tag *)0x0) {
                chan_tbtt_switch_update(pvVar12,vif_info_tab[uVar4].tbtt_timer.time);
              }
              if (CONCAT31(extraout_var_00,_Var5) == 0) goto LAB_2300443e;
            }
            else {
              if ((uVar2 & 4) == 0) {
                ps_check_frame((uint8_t *)frame,statinfo,pvVar12);
              }
            }
          }
        }
      }
    }
    _Var5 = rxu_cntrl_frame_handle((rx_swdesc *)swdesc);
    if (CONCAT31(extraout_var,_Var5) == 0) {
LAB_2300443e:
      rxl_mpdu_free((rx_swdesc *)swdesc);
    }
  } while( true );
}



void bl60x_firmwre_mpdu_free(void *swdesc_ptr)

{
  rx_swdesc *swdesc;
  
  vTaskEnterCritical();
  rxl_cntrl_env.packet_stack_cnt =
       rxl_cntrl_env.packet_stack_cnt - *(byte *)((int)swdesc_ptr + 0x1d);
  vTaskExitCritical();
  rxl_mpdu_free((rx_swdesc *)swdesc_ptr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_reset(void)

{
  rxl_hwdesc_init(0);
  co_list_init((co_list *)&rxl_cntrl_env);
  co_list_init((co_list *)&rxu_cntrl_desc_transfer::swdesc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rxl_hwdesc_dump(void)

{
  rx_dmadesc *prVar1;
  rx_payloaddesc *prVar2;
  int iVar3;
  int iVar4;
  uint32_t uVar5;
  
  puts("---------- rxl_hwdesc_dump -------\r\n");
  printf("rx_dma_hdrdesc: %d\r\n",0xd);
  iVar3 = 0;
  prVar1 = rx_dma_hdrdesc;
  do {
    printf("  [%2d]@%08lx: upatternrx %08lx next %08lx first_pbd_ptr %08lx, swdesc %p\r\n",iVar3,
           prVar1,(prVar1->hd).upatternrx,(prVar1->hd).next,(prVar1->hd).first_pbd_ptr,
           (prVar1->hd).swdesc);
    iVar3 = iVar3 + 1;
    printf(
           "    datastartptr %08lx dataendptr %08lx, headerctrlinfo %08lx frmlen %4u ampdu_stat_info %04x\r\n"
           ,(prVar1->hd).datastartptr,(prVar1->hd).dataendptr,(prVar1->hd).headerctrlinfo,
           (uint)(prVar1->hd).frmlen,(uint)(prVar1->hd).ampdu_stat_info);
    printf(
           "    tsflo %08lx tsfhi %08lx recvec1b %08lx recvec1c %08lx recvec1d %08lx recvec2a %08lx recvec2b %08lx statinfo %08lx\r\n"
           ,(prVar1->hd).tsflo,(prVar1->hd).tsfhi,(prVar1->hd).recvec1b,(prVar1->hd).recvec1c,
           (prVar1->hd).recvec1d,(prVar1->hd).recvec2a,(prVar1->hd).recvec2b);
    prVar1 = prVar1 + 1;
  } while (iVar3 != 0xd);
  printf("rx_payload_desc: %d\r\n",0xd);
  iVar3 = 0;
  prVar2 = rx_payload_desc;
  do {
    uVar5 = (prVar2->pbd).dataendptr;
    iVar4 = 0;
    if (uVar5 != 0) {
      iVar4 = (uVar5 + 1) - (prVar2->pbd).datastartptr;
    }
    iVar3 = iVar3 + 1;
    printf(
           "  [%2d]@%08lx %3lu Bytes: upatternrx %08lx next %08lx datastartptr %08lx dataendptr %08lx bufstatinfo %04x reserved %04X\r\n"
           ,prVar2,iVar4,(prVar2->pbd).upattern,(prVar2->pbd).next);
    prVar2 = prVar2 + 1;
  } while (iVar3 != 0xd);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hwdesc_init(int init)

{
  rx_dmadesc *prVar1;
  rx_dmadesc *prVar2;
  txl_buffer_control *ptVar3;
  txl_buffer_control *ptVar4;
  txl_buffer_control *ptVar5;
  int iVar6;
  uint32_t (*pauVar7) [212];
  int iVar8;
  txl_buffer_control *ptVar9;
  rx_dmadesc *prVar10;
  rx_dmadesc *prVar11;
  rx_dmadesc *prVar12;
  rx_dmadesc *prVar13;
  txl_buffer_control *ptVar14;
  txl_buffer_control *ptVar15;
  
  vTaskEnterCritical();
  prVar13 = (rx_dmadesc *)0x0;
  iVar6 = 0;
  iVar8 = 0;
  prVar1 = (rx_dmadesc *)0x0;
  prVar10 = rx_dma_hdrdesc;
  prVar11 = (rx_dmadesc *)0x0;
  do {
    prVar2 = prVar10;
    prVar10 = prVar2 + 1;
    prVar12 = prVar11;
    if ((init == 0) && (prVar2->use_in_tcpip == 1)) {
      prVar2 = prVar1;
      if (prVar1 != (rx_dmadesc *)0x0) {
        (prVar1->hd).next = 0;
      }
    }
    else {
      if (prVar1 != (rx_dmadesc *)0x0) {
        (prVar1->hd).next = (uint32_t)prVar2;
      }
      (prVar2->hd).datastartptr = 0;
      (prVar2->hd).dataendptr = 0;
      (prVar2->hd).upatternrx = 0xbaadf00d;
      (prVar2->hd).statinfo = 0;
      (prVar2->hd).headerctrlinfo = 0;
      (prVar2->hd).next = (uint32_t)prVar10;
      (prVar2->hd).first_pbd_ptr = 0;
      (prVar2->hd).swdesc = rx_swdesc_tab + iVar8;
      (prVar2->hd).frmlen = 0;
      prVar12 = prVar2;
      if ((iVar6 != 0) && (prVar12 = prVar11, iVar6 == 1)) {
        prVar13 = prVar2;
      }
      iVar6 = iVar6 + 1;
    }
    iVar8 = iVar8 + 1;
    prVar1 = prVar2;
    prVar11 = prVar12;
  } while (iVar8 != 0xd);
  if (iVar6 < 4) {
    printf("No enough DESC %d(%d)\r\n",0xd);
  }
  if (prVar2 != (rx_dmadesc *)0x0) {
    (prVar2->hd).next = 0;
  }
  _DAT_44b08180 = 0x4000000;
  pauVar7 = rx_payload_desc_buffer;
  ptVar9 = (txl_buffer_control *)0x0;
  iVar6 = 0;
  ptVar3 = (txl_buffer_control *)0x0;
  ptVar5 = (txl_buffer_control *)rx_payload_desc;
  ptVar14 = (txl_buffer_control *)0x0;
  _DAT_44b081b8 = prVar13;
  do {
    ptVar4 = ptVar5;
    ptVar5 = (txl_buffer_control *)&ptVar4->mac_control_info;
    ptVar15 = ptVar14;
    if ((init == 0) && (*(int *)&(ptVar4->field_0).field_0x14 == 1)) {
      ptVar4 = ptVar3;
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(undefined4 *)&ptVar3->field_0 = 0;
      }
    }
    else {
      if (ptVar3 != (txl_buffer_control *)0x0) {
        *(txl_buffer_control **)&ptVar3->field_0 = ptVar4;
      }
      *(txl_buffer_control **)&ptVar4->field_0 = ptVar5;
      *(undefined4 *)&ptVar4->field_0 = 0xc0dedbad;
      *(undefined2 *)&ptVar4->field_0 = 0;
      *(uint32_t (**) [212])&ptVar4->field_0 = pauVar7;
      *(int *)&ptVar4->field_0 = (int)*pauVar7 + 0x34f;
      *(uint32_t (**) [212])&(ptVar4->field_0).field_0x18 = pauVar7;
      ptVar15 = ptVar4;
      if ((iVar6 != 0) && (ptVar15 = ptVar14, iVar6 == 1)) {
        ptVar9 = ptVar4;
      }
      iVar6 = iVar6 + 1;
    }
    pauVar7 = pauVar7[1];
    ptVar3 = ptVar4;
    ptVar14 = ptVar15;
  } while (ptVar5 != txl_buffer_control_desc_bcmc);
  if (iVar6 < 4) {
    printf("No enough PBD DESC, %d(%d)\r\n",0xd);
  }
  *(undefined4 *)&ptVar4->field_0 = 0;
  _DAT_44b08180 = 0x8000000;
  _DAT_44b081bc = ptVar9;
  if ((((prVar12 == (rx_dmadesc *)0x0) || (prVar13 == (rx_dmadesc *)0x0)) ||
      (prVar2 == (rx_dmadesc *)0x0)) ||
     ((ptVar15 == (txl_buffer_control *)0x0 || (ptVar9 == (txl_buffer_control *)0x0)))) {
    printf("%p:%p%p vs %p:%p:%p\r\n",prVar12,prVar13,prVar2,ptVar15,ptVar4);
  }
  rxl_cntrl_env.first = prVar13;
  rxl_cntrl_env.last = prVar2;
  rxl_cntrl_env.free = prVar12;
  rx_hwdesc_env.last = (rx_pbd *)ptVar4;
  rx_hwdesc_env.free = (rx_pbd *)ptVar15;
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_hd_append(rx_dmadesc *desc)

{
  rx_dmadesc *prVar1;
  
  if (desc == (rx_dmadesc *)0x0) {
    assert_err("desc != NULL","module",0xf9);
  }
  prVar1 = desc;
  if (rxl_cntrl_env.free != _DAT_44b08548) {
    prVar1 = rxl_cntrl_env.free;
    rxl_cntrl_env.free = desc;
  }
  (prVar1->hd).next = 0;
  (prVar1->hd).first_pbd_ptr = 0;
  (prVar1->hd).statinfo = 0;
  (prVar1->hd).frmlen = 0;
  ((rxl_cntrl_env.last)->hd).next = (uint32_t)prVar1;
  if (rxl_cntrl_env.first == (rx_dmadesc *)0x0) {
    rxl_cntrl_env.first = prVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  rxl_cntrl_env.last = prVar1;
  _DAT_44b08180 = 0x1000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxl_pd_append(rx_pbd *first,rx_pbd *last,rx_pbd *spare)

{
  rx_pbd **pprVar1;
  rx_pbd *prVar2;
  rx_pbd *prVar3;
  rx_pbd *prVar4;
  
  if (spare == (rx_pbd *)0x0) {
    assert_err("spare != NULL","module",0x128);
  }
  prVar4 = rx_hwdesc_env.free;
  if (rx_hwdesc_env.free == _DAT_44b0854c) {
    prVar4 = first;
    if (last == (rx_pbd *)0x0) {
      prVar4 = spare;
    }
    spare->bufstatinfo = 0;
  }
  else {
    prVar2 = rx_hwdesc_env.free;
    prVar3 = spare;
    if (last != (rx_pbd *)0x0) {
      pprVar1 = (rx_pbd **)&(rx_hwdesc_env.free)->next;
      rx_hwdesc_env.free = spare;
      *pprVar1 = first;
      prVar2 = last;
      prVar3 = rx_hwdesc_env.free;
    }
    rx_hwdesc_env.free = prVar3;
    spare = prVar2;
    prVar4->bufstatinfo = 0;
  }
  spare->next = 0;
  (rx_hwdesc_env.last)->next = (uint32_t)prVar4;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  rx_hwdesc_env.last = spare;
  _DAT_44b08180 = 0x2000000;
  return;
}



void scan_search_ds(void)

{
  DAT_42018f0c = mac_ie_find(0x42047d04,scan_search_ds::param->add_ie_len,'\x03');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scan_init(void)

{
  memset(&scan_env,0,0x1c);
  ke_state_set(2,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  DAT_42018efc = &scan_probe_req_ie;
  DAT_42018f00 = dma_cb;
  DAT_42018f04 = 0;
  scan_probe_req_ie.dma_desc.dest = 0x42047d04;
  scan_probe_req_ie.pbd.upatterntx = 0xcafefade;
  scan_probe_req_ie.pbd.next = 0;
  scan_probe_req_ie.pbd.datastartptr = 0x42047d04;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_set_channel_request(void)

{
  scan_chan_tag *psVar1;
  uint uVar2;
  undefined uVar3;
  int iVar4;
  
  psVar1 = scan_search_ds::param->chan + DAT_42018f12;
  chan_scan_req(*(uint8_t *)(&psVar1->freq + 1),psVar1->freq,*(int8_t *)(&psVar1->freq + 2),110000,
                scan_search_ds::param->vif_idx);
  if (DAT_42018f0c == 0) goto LAB_23004c56;
  uVar2 = (uint)psVar1->freq;
  if (*(char *)(&psVar1->freq + 1) == '\0') {
    uVar3 = 0;
    if (((uVar2 - 0x96c & 0xffff) < 0x49) && (uVar3 = 0xe, uVar2 != 0x9b4)) {
      iVar4 = -0x967;
LAB_23004c4a:
      uVar3 = (undefined)((int)(uVar2 + iVar4) / 5);
    }
  }
  else {
    uVar3 = 0;
    if ((*(char *)(&psVar1->freq + 1) == '\x01') && ((uVar2 - 0x138d & 0xffff) < 0x335)) {
      iVar4 = -5000;
      goto LAB_23004c4a;
    }
  }
  *(undefined *)(DAT_42018f0c + 2) = uVar3;
LAB_23004c56:
  ke_state_set(2,2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dma_cb(void *env,int dma_queue)

{
  scan_search_ds();
  scan_set_channel_request();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scan_ie_download(scan_start_req *param)

{
  scan_search_ds();
  scan_set_channel_request();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  scan_probe_req_ie.pbd.dataendptr =
       (scan_probe_req_ie.pbd.datastartptr - 1) + (uint)param->add_ie_len;
  scan_probe_req_ie.pbd.bufctrlinfo = 0;
  return;
}



void scan_probe_req_tx(void)

{
  byte bVar1;
  byte bVar2;
  scan_start_req *psVar3;
  txl_buffer_tag *ptVar4;
  uint uVar5;
  txl_frame_desc_tag *frame;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint8_t *puVar9;
  tx_hw_desc *ptVar10;
  
  psVar3 = scan_search_ds::param;
  uVar8 = (uint)DAT_42018f12;
  bVar1 = scan_search_ds::param->vif_idx;
  puVar9 = scan_search_ds::param->ssid[0].array;
  iVar7 = 0;
  while( true ) {
    if ((int)(uint)psVar3->ssid_cnt <= iVar7) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar5 = 1;
    if (psVar3->chan[uVar8].band == '\0') {
      uVar5 = (uint)psVar3->no_cck;
    }
    frame = txl_frame_get(uVar5,(uint)psVar3->add_ie_len + puVar9[-1] + 0x1a);
    if (frame == (txl_frame_desc_tag *)0x0) break;
    ptVar4 = (frame->txdesc).lmac.buffer;
    ptVar10 = (frame->txdesc).lmac.hw_desc;
    *(undefined *)&ptVar4[1].length = 0x40;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    *(undefined *)((int)&ptVar4[1].length + 2) = 0;
    *(undefined *)((int)&ptVar4[1].length + 3) = 0;
    memcpy(&ptVar4[1].lenheader,&mac_addr_bcst,6);
    memcpy((void *)((int)&ptVar4[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar4[1].next,&psVar3->bssid,6);
    uVar5 = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)&ptVar4[1].dma_desc[0].src = 0;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar5 + 1) * 0x10000 >> 0x10);
    iVar6 = (uVar5 + 1) * 0x100000;
    *(char *)((int)&ptVar4[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
    *(char *)((int)&ptVar4[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
    bVar2 = puVar9[-1];
    *(byte *)((int)&ptVar4[1].dma_desc[0].src + 1) = bVar2;
    uVar5 = 0;
    while (bVar2 != uVar5) {
      *(uint8_t *)((int)&ptVar4[1].dma_desc[0].src + uVar5 + 2) = puVar9[uVar5];
      uVar5 = uVar5 + 1;
    }
    (ptVar10->thd).field_3 = 0x42047cf0;
    (ptVar10->thd).field_5 = (ptVar10->thd).field_5 - (uint)psVar3->add_ie_len;
    (frame->cfm).cfm_func = (cfm_func_ptr *)0x0;
    (frame->cfm).env = (void *)0x0;
    iVar7 = iVar7 + 1;
    puVar9 = puVar9 + 0x22;
    (frame->txdesc).host.vif_idx = psVar3->vif_idx;
    (frame->txdesc).host.staid = -1;
    txl_frame_push(frame,'\x03');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scan_send_cancel_cfm(uint8_t status,ke_task_id_t dest_id)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x804,dest_id,2,1);
  *puVar1 = status;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sta_mgmt_entry_init(sta_info_tag *sta_entry)

{
  txdesc *txdesc;
  uint16_t *puVar1;
  
  while ((sta_entry->tx_desc_post).first != (co_list_hdr *)0x0) {
    txdesc = (txdesc *)co_list_pop_front(&sta_entry->tx_desc_post);
    txl_frame_release(txdesc,true);
  }
  memset(sta_entry,0,0x1b0);
  puVar1 = (uint16_t *)&sta_entry->ba_info[0].bam_idx_rx;
  do {
    *(uint8_t *)puVar1 = '\x02';
    *(uint8_t *)((int)puVar1 + 1) = '\x02';
    puVar1 = puVar1 + 6;
  } while (puVar1 != sta_entry->rx_qos_last_seqcntl + 3);
  sta_entry->inst_nbr = -1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sta_mgmt_init(void)

{
  sta_info_tag *sta_entry;
  sta_info_tag *psVar1;
  
  co_list_init((co_list *)&sta_info_env);
  sta_entry = sta_info_tab;
  do {
    sta_mgmt_entry_init(sta_entry);
    psVar1 = sta_entry + 1;
    co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
    sta_entry = psVar1;
  } while (psVar1 != sta_info_tab + 10);
  sta_mgmt_entry_init(sta_info_tab + 10);
  sta_info_tab[10].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc;
  sta_info_tab[10].sta_sec_info.cur_key = &vif_info_tab[0].default_key;
  sta_info_tab[10].inst_nbr = '\0';
  sta_info_tab[10].ctrl_port_state = '\0';
  printf("------ set default key %p, key ptr %p\r\n",0x4201a9d0,vif_info_tab[0].default_key);
  sta_mgmt_entry_init(sta_info_tab + 0xb);
  sta_info_tab[11].inst_nbr = '\x01';
  sta_info_tab[11].pol_tbl.buf_ctrl = txl_buffer_control_desc_bcmc + 1;
  sta_info_tab[11].ctrl_port_state = '\0';
  sta_info_tab[11].sta_sec_info.cur_key = &vif_info_tab[1].default_key;
  printf("------ set default key %p, key ptr %p\r\n",vif_info_tab[1].default_key);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t sta_mgmt_register(mm_sta_add_req *param,uint8_t *sta_idx)

{
  uint8_t uVar1;
  co_list_hdr *list_hdr;
  char *fmt;
  undefined4 uVar2;
  key_info_tag *pkVar3;
  co_list_hdr *pcVar4;
  byte bVar5;
  co_list_hdr *pcVar6;
  co_list_hdr *pcVar7;
  uint uVar8;
  
  uVar8 = (uint)param->inst_nbr;
  list_hdr = co_list_pop_front((co_list *)&sta_info_env);
  if (list_hdr == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    memcpy((void *)((int)&list_hdr[7].next + 2),&param->mac_addr,6);
    bVar5 = param->ampdu_spacing_min;
    if (bVar5 < 0x10) {
      bVar5 = 0x10;
    }
    *(byte *)&list_hdr[5].next = bVar5;
    *(uint16_t *)&list_hdr[3].next = param->ampdu_size_max_ht;
    list_hdr[2].next = (co_list_hdr *)param->ampdu_size_max_vht;
    list_hdr[4].next = (co_list_hdr *)param->paid_gid;
    *(uint8_t *)((int)&list_hdr[6].next + 2) = param->inst_nbr;
    *(int8_t *)&list_hdr[9].next = param->rssi;
    list_hdr[10].next = (co_list_hdr *)param->tsflo;
    list_hdr[0xb].next = (co_list_hdr *)param->tsfhi;
    *(uint8_t *)&list_hdr[0xc].next = param->data_rate;
    uVar1 = (char)((int)(list_hdr + -0x108063c8) >> 4) * '\x13';
    *sta_idx = uVar1;
    *(uint8_t *)((int)&list_hdr[6].next + 3) = uVar1;
    list_hdr[1].next = (co_list_hdr *)0x19000;
    *(undefined2 *)&list_hdr[0x62].next = 0xffff;
    pcVar6 = (co_list_hdr *)((int)&list_hdr[0x62].next + 2);
    do {
      *(undefined2 *)&pcVar6->next = 0xffff;
      pcVar6 = (co_list_hdr *)((int)&pcVar6->next + 2);
    } while (pcVar6 != list_hdr + 0x67);
    bVar5 = *sta_idx;
    *(undefined *)((int)&list_hdr[0xc].next + 1) = 0;
    list_hdr[0x43].next = (co_list_hdr *)(txl_buffer_control_desc + bVar5);
    if ((vif_info_tab[uVar8].flags & 8) == 0) {
      list_hdr[0x2b].next = (co_list_hdr *)(uVar8 * 0x5d8 + 0x4201a9d0);
      pkVar3 = vif_info_tab[uVar8].default_key;
      uVar2 = 0x10d;
      fmt = "------ %d set default key %p, ptr %p\r\n";
    }
    else {
      pkVar3 = (key_info_tag *)list_hdr[0x2a].next;
      list_hdr[0x2b].next = list_hdr + 0x2a;
      uVar2 = 0x102;
      fmt = "------ %d set default key %p, key ptr %p\r\n";
    }
    printf(fmt,uVar2,pkVar3);
    pcVar6 = _DAT_44b00120;
    pcVar7 = list_hdr + 0x47;
    pcVar4 = _DAT_44b00120 + -250000;
    do {
      pcVar7->next = pcVar6;
      pcVar7[1].next = pcVar4;
      pcVar7 = pcVar7 + 3;
    } while (pcVar7 != list_hdr + 0x62);
    co_list_push_back(&vif_info_tab[uVar8].sta_list,list_hdr);
    *(undefined *)((int)&list_hdr[7].next + 1) = 1;
    uVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void sta_mgmt_unregister(uint8_t sta_idx)

{
  sta_info_tag *sta_entry;
  undefined3 in_register_00002029;
  
  sta_entry = sta_info_tab + CONCAT31(in_register_00002029,sta_idx);
  co_list_extract(&vif_info_tab[sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].inst_nbr].
                   sta_list,(co_list_hdr *)sta_entry);
  sta_mgmt_entry_init(sta_entry);
  co_list_push_back((co_list *)&sta_info_env,(co_list_hdr *)sta_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sta_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  
  uVar2 = (uint)param->sta_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.hw_key_idx = hw_key_idx;
  sta_info_tab[uVar2].sta_sec_info.key_info.cipher = param->cipher_suite;
  sta_info_tab[uVar2].sta_sec_info.key_info.key_idx = param->key_idx;
  memset(&sta_info_tab[uVar2].sta_sec_info,0,0x48);
  uVar1 = sta_info_tab[uVar2].sta_sec_info.key_info.cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
    *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    *(uint32_t *)&sta_info_tab[uVar2].sta_sec_info.key_info.u = (param->key).array[4];
    *(uint32_t *)&sta_info_tab[uVar2].sta_sec_info.key_info.u.field_0x4 = (param->key).array[5];
    *(uint32_t *)&sta_info_tab[uVar2].sta_sec_info.key_info.u.field_0x8 = (param->key).array[6];
    *(uint32_t *)&sta_info_tab[uVar2].sta_sec_info.key_info.u.field_0xc = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(ulong *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = next >> 0x10;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn = 0;
      *(undefined4 *)((int)&sta_info_tab[uVar2].sta_sec_info.key_info.tx_pn + 4) = 0;
    }
  }
  sta_info_tab[uVar2].sta_sec_info.key_info.valid = true;
  sta_info_tab[uVar2].sta_sec_info.pairwise_key = (key_info_tag *)&sta_info_tab[uVar2].sta_sec_info;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sta_mgmt_del_key(sta_info_tag *sta)

{
  (sta->sta_sec_info).key_info.valid = false;
  (sta->sta_sec_info).pairwise_key = (key_info_tag *)0x0;
  sta->ctrl_port_state = '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int sta_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry,sta_info_tag *p_sta_entry,int limit)

{
  uint8_t access_category;
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txdesc *ptVar3;
  int iStack36;
  int stop;
  
  iVar1 = 0;
  while( true ) {
    ptVar3 = (txdesc *)(p_sta_entry->tx_desc_post).first;
    if (ptVar3 == (txdesc *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    iStack36 = 0;
    _Var2 = txl_cntrl_tx_check(p_vif_entry);
    if (CONCAT31(extraout_var,_Var2) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    _Var2 = apm_tx_int_ps_check(ptVar3);
    if (CONCAT31(extraout_var_00,_Var2) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    ptVar3 = apm_tx_int_ps_get_postpone(p_vif_entry,p_sta_entry,&iStack36);
    if (iStack36 != 0) break;
    if (ptVar3 == (txdesc *)0x0) {
      ptVar3 = (txdesc *)co_list_pop_front(&p_sta_entry->tx_desc_post);
    }
    access_category = (ptVar3->host).tid;
    *(undefined *)((int)&ptVar3[1].host.packet_addr + 1) = 0;
    iVar1 = iVar1 + 1;
    txl_cntrl_push_int(ptVar3,access_category);
    if ((limit != 0) && (iVar1 == limit)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_timer_end(void *env)

{
  int iVar1;
  byte bVar2;
  undefined *puVar3;
  undefined *puVar4;
  
  iVar1 = _DAT_44b00120;
  if (*(char *)((int)env + 0x23) != '\0') {
    bVar2 = *(int *)((int)env + 0x10) != 0;
    if (*(int *)((int)env + 0x14) != 0) {
      bVar2 = bVar2 | 2;
    }
    if (*(int *)((int)env + 0x18) != 0) {
      bVar2 = bVar2 | 4;
    }
    if (*(int *)((int)env + 0x1c) != 0) {
      bVar2 = bVar2 | 8;
    }
    if (((*(byte *)((int)env + 0x21) ^ bVar2) & 0xc) != 0) {
      if ((bVar2 & 4) == 0) {
        puVar3 = &UNK_23074b2c;
      }
      else {
        puVar3 = &UNK_23074b28;
      }
      if ((bVar2 & 8) == 0) {
        puVar4 = &UNK_23074b2c;
      }
      else {
        puVar4 = &UNK_23074b30;
      }
      printf(&DAT_23074b34,puVar3,puVar4);
      ps_traffic_status_update(*(uint8_t *)((int)env + 0x20),bVar2 & 0xc);
    }
    *(byte *)((int)env + 0x21) = bVar2;
  }
  *(undefined4 *)((int)env + 0x10) = 0;
  *(undefined4 *)((int)env + 0x14) = 0;
  *(undefined4 *)((int)env + 0x18) = 0;
  *(undefined4 *)((int)env + 0x1c) = 0;
  *(bool *)((int)env + 0x23) = vif_info_tab[*(byte *)((int)env + 0x20)].chan_ctxt == DAT_4201d1f8;
  mm_timer_set((mm_timer_tag *)env,iVar1 + 1000000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void td_reset(uint8_t vif_index)

{
  td_env_tag *timer;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  timer = td_env + iVar1;
  printf(&DAT_23074b00,iVar1);
  if (td_env[iVar1].is_on != false) {
    mm_timer_clear((mm_timer_tag *)timer);
  }
  memset(timer,0,0x24);
  td_env[iVar1].td_timer.cb = td_timer_end;
  td_env[iVar1].td_timer.env = timer;
  td_env[iVar1].vif_index = vif_index;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void td_init(void)

{
  printf(&DAT_23074af4);
  td_reset('\0');
  td_reset('\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void td_start(uint8_t vif_index)

{
  int iVar1;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar1 = _DAT_44b00120;
  iVar2 = CONCAT31(in_register_00002029,vif_index);
  if (td_env[iVar2].is_on == false) {
    printf(&DAT_23074b14,iVar2);
    td_env[iVar2].is_on = true;
    mm_timer_set((mm_timer_tag *)(td_env + iVar2),iVar1 + 1000000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void td_pck_ind(uint8_t vif_index,uint8_t sta_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_00002031;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_00002031,rx) != 0) {
    td_env[iVar1].pck_cnt_rx = td_env[iVar1].pck_cnt_rx + 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  td_env[iVar1].pck_cnt_tx = td_env[iVar1].pck_cnt_tx + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void td_pck_ps_ind(uint8_t vif_index,_Bool rx)

{
  undefined3 in_register_00002029;
  int iVar1;
  undefined3 in_register_0000202d;
  
  iVar1 = CONCAT31(in_register_00002029,vif_index);
  if (CONCAT31(in_register_0000202d,rx) != 0) {
    td_env[iVar1].pck_cnt_rx_ps = td_env[iVar1].pck_cnt_rx_ps + 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  td_env[iVar1].pck_cnt_tx_ps = td_env[iVar1].pck_cnt_tx_ps + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tpc_update_power_table(int8_t *power_table)

{
  char cVar1;
  int32_t *piVar2;
  char *pcVar3;
  int32_t iStack72;
  int32_t power_os [14];
  
  trpc_update_power((int8_t (*) [8])power_table);
  pcVar3 = power_table + 0x18;
  piVar2 = &iStack72;
  while (pcVar3 != power_table + 0x26) {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
    *piVar2 = (int)cVar1;
    piVar2 = piVar2 + 1;
  }
  rf_pri_update_power_offset(&iStack72);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tpc_power_table_get(int8_t *power_table_config)

{
  int iVar1;
  
  trpc_power_get(power_table_config);
  iVar1 = 0x18;
  do {
    power_table_config[iVar1] = '\0';
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x26);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tpc_update_power_rate_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tpc_update_power_rate_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t (*paiVar3) [8];
  
  iVar2 = 0;
  paiVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    paiVar3[1][0] = *piVar1;
    paiVar3 = (int8_t (*) [8])(*paiVar3 + 1);
  } while (iVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tpc_update_power_rate_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t (*paiVar3) [8];
  
  iVar2 = 0;
  paiVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    paiVar3[2][0] = *piVar1;
    paiVar3 = (int8_t (*) [8])(*paiVar3 + 1);
  } while (iVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void tpc_update_tx_power(int8_t pwr)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  uVar1 = trpc_get_default_power_idx('\x02','\0');
  _DAT_44b000a0 = CONCAT31(extraout_var,uVar1) | _DAT_44b000a0 & 0xffffff00;
  uVar1 = trpc_get_default_power_idx('\0','\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b000a0 = CONCAT31(extraout_var_00,uVar1) << 8 | _DAT_44b000a0 & 0xffff00ff;
  return;
}



// WARNING: Type propagation algorithm not settling

void tpc_update_vif_tx_power(vif_info_tag *vif,int8_t *pwr,uint8_t *idx)

{
  char cVar1;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  int *piVar4;
  
  if (*pwr == '\x7f') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  cVar1 = vif->tx_power;
  phy_get_rf_gain_idx(pwr,idx);
  cVar2 = *pwr;
  vif->tx_power = cVar2;
  if (vif->user_tx_power < cVar2) {
    *pwr = vif->user_tx_power;
    phy_get_rf_gain_idx(pwr,idx);
  }
  if (*pwr != cVar1) {
    piVar4 = (int *)(vif->sta_list).first;
    while (piVar4 != (int *)0x0) {
      *(byte *)((int)piVar4 + 0x11a) = *(byte *)((int)piVar4 + 0x11a) | 0x10;
      piVar4 = (int *)*piVar4;
    }
    if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
      chan_update_tx_power(vif->chan_ctxt);
      _Var3 = chan_is_on_channel(vif);
      if (CONCAT31(extraout_var,_Var3) != 0) {
        tpc_update_tx_power((vif->chan_ctxt->channel).tx_power);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t tpc_get_vif_tx_power_vs_rate(uint32_t rate_config)

{
  uint8_t uVar1;
  byte mcs;
  
  mcs = (byte)rate_config & 0x7f;
  if ((rate_config >> 0xb & 7) == 0) {
    uVar1 = (uint8_t)(rate_config & 0x7c);
    if ((rate_config & 0x7c) != 0) {
      mcs = mcs - 4;
      uVar1 = '\x01';
    }
  }
  else {
    uVar1 = '\x02';
  }
  uVar1 = trpc_get_default_power_idx(uVar1,mcs);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void tpc_update_frame_tx_power(vif_info_tag *vif,txl_frame_desc_tag *frame)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  
  uVar1 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
  uVar2 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)(uVar1 + 0x14));
  *(uint *)(uVar1 + 0x24) = CONCAT31(extraout_var,uVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_int_fake_transfer(txdesc *txdesc,uint8_t access_category)

{
  undefined3 in_register_0000202d;
  int iVar1;
  txl_buffer_tag *ptVar2;
  
  iVar1 = CONCAT31(in_register_0000202d,access_category);
  ptVar2 = (txdesc->lmac).buffer;
  (ptVar2->tbd).upatterntx = 0xcafefade;
  ptVar2->txdesc = txdesc;
  if (txl_buffer_env.list[iVar1].first == (txl_buffer_tag *)0x0) {
    txl_buffer_env.list[iVar1].first = ptVar2;
  }
  else {
    (txl_buffer_env.list[iVar1].last)->next = ptVar2;
  }
  txl_buffer_env.list[iVar1].last = ptVar2;
  ptVar2->next = (txl_buffer_tag *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void blmac_abs_timer_set(int reg_idx,uint32_t value)

{
  if (9 < reg_idx) {
    assert_err("reg_idx <= 9","module",0x26a0);
  }
  *(uint32_t *)((reg_idx + 0x112c004a) * 4) = value;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_machdr_format(uint32_t machdrptr)

{
  uint uVar1;
  
  if ((*(byte *)(machdrptr + 0x16) & 0xf) == 0) {
    txl_cntrl_env.seqnbr = txl_cntrl_env.seqnbr + 1;
  }
  uVar1 = (uint)txl_cntrl_env.seqnbr;
  *(byte *)(machdrptr + 0x16) = (byte)(uVar1 << 4) | *(byte *)(machdrptr + 0x16) & 0xf;
  *(char *)(machdrptr + 0x17) = (char)((uVar1 << 4) >> 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cntrl_init(void)

{
  txl_cntrl_env_tag *ptVar1;
  undefined4 uVar2;
  undefined4 *puVar3;
  
  txl_hwdesc_init();
  txl_buffer_init();
  txl_cfm_init();
  txl_frame_init(false);
  memset(&txl_cntrl_env,0,0x58);
  ptVar1 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  do {
    co_list_init(&ptVar1->txlist[0].transmitting);
    ptVar1->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar2 = *puVar3;
    ptVar1->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar1->txlist[0].bridgedmacnt = (uint16_t)uVar2;
    ptVar1 = (txl_cntrl_env_tag *)(ptVar1->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  txl_cntrl_env.seqnbr = 0;
  return;
}



_Bool txl_cntrl_tx_check(vif_info_tag *p_vif_entry)

{
  _Bool _Var1;
  
  if (txl_cntrl_env.reset == false) {
    _Var1 = chan_is_tx_allowed(p_vif_entry);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return _Var1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_halt_ac(uint8_t access_category)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,access_category)) {
  case 0:
    _DAT_44b08180 = 0x10000;
    do {
    } while ((_DAT_44b08188 >> 4 & 3) != 0);
    _DAT_44b08184 = 0x10000;
    break;
  case 1:
    _DAT_44b08180 = 0x20000;
    do {
    } while ((_DAT_44b08188 >> 8 & 3) != 0);
    _DAT_44b08184 = 0x20000;
    break;
  case 2:
    _DAT_44b08180 = 0x40000;
    do {
    } while ((_DAT_44b08188 >> 0xc & 3) != 0);
    _DAT_44b08184 = 0x40000;
    break;
  case 3:
    _DAT_44b08180 = 0x80000;
    do {
    } while ((_DAT_44b08188 >> 0x10 & 3) != 0);
    _DAT_44b08184 = 0x80000;
    break;
  case 4:
    _DAT_44b08180 = 0x8000;
    do {
    } while ((_DAT_44b08188 & 3) != 0);
    _DAT_44b08184 = 0x8000;
    break;
  default:
    assert_err("0","module",0x779);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cntrl_flush_ac(uint8_t access_category,uint32_t status)

{
  uint uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  uint uVar3;
  
  uVar1 = _DAT_44b0808c;
  iVar2 = CONCAT31(in_register_00002029,access_category);
  uVar3 = 1 << (access_category & 0x1f);
  txl_cfm_flush(access_category,txl_cfm_env.cfmlist + iVar2,status);
  txl_cfm_flush(access_category,&txl_cntrl_env.txlist[iVar2].transmitting,status);
  txl_cntrl_env.txlist[iVar2].last_frame_exch = (tx_hd *)0x0;
  txl_buffer_reset();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b08088 = uVar3;
  _DAT_44b0808c = ~uVar3 & uVar1;
  return;
}



void txl_cntrl_clear_bcn_ac(void)

{
  txl_cntrl_halt_ac('\x04');
  txl_cntrl_flush_ac('\x04',0x40000000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cntrl_clear_all_ac(void)

{
  txl_cntrl_halt_ac('\x04');
  txl_cntrl_flush_ac('\x04',0x40000000);
  txl_cntrl_halt_ac('\0');
  txl_cntrl_flush_ac('\0',0x40000000);
  txl_cntrl_halt_ac('\x01');
  txl_cntrl_flush_ac('\x01',0x40000000);
  txl_cntrl_halt_ac('\x02');
  txl_cntrl_flush_ac('\x02',0x40000000);
  txl_cntrl_halt_ac('\x03');
  txl_cntrl_flush_ac('\x03',0x40000000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cntrl_inc_pck_cnt(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle(void)

{
  int iVar1;
  
  while ((_DAT_44a00024 & 0x1f) != 0) {
    iVar1 = __clzsi2(_DAT_44a00024 & 0x1f);
    _DAT_44a00020 = 1 << (0x1fU - iVar1 & 0x1f);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_payload_handle_backup(void)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  txl_buffer_tag *ptVar4;
  char *condition;
  int line;
  byte bVar5;
  uint uVar6;
  tx_hd *ptVar7;
  undefined *puVar8;
  txdesc *txdesc;
  tx_hd *ptVar9;
  txl_buffer_env_tag *ptVar10;
  txl_cntrl_env_tag *ptVar11;
  uint uVar12;
  tx_hw_desc *ptVar13;
  
  ptVar10 = &txl_buffer_env;
  ptVar11 = &txl_cntrl_env;
  uVar3 = 0;
  while (ptVar4 = ptVar10->list[0].first, ptVar4 == (txl_buffer_tag *)0x0) {
LAB_230059f6:
    uVar3 = uVar3 + 1;
    ptVar10 = (txl_buffer_env_tag *)&ptVar10->buf_idx[0].free_size;
    ptVar11 = (txl_cntrl_env_tag *)(ptVar11->txlist + 1);
    if (uVar3 == 5) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  uVar2 = uVar3 & 0xff;
  ptVar10->list[0].first = ptVar4->next;
  uVar12 = 1 << (uVar3 & 0x1f);
  do {
    txdesc = ptVar4->txdesc;
    if ((txdesc->host).packet_addr != 0) {
      if (uVar3 == 4) {
        uVar6 = (uint)(txdesc->host).vif_idx;
        bVar5 = *(byte *)&vif_info_tab[uVar6].u.field_0x2ea;
        if ((*(byte *)((int)&ptVar4[1].length + 1) >> 5 & 1) == 0) {
          bVar5 = bVar5 & 0xfd;
        }
        else {
          bVar5 = bVar5 | 2;
        }
        *(byte *)&vif_info_tab[uVar6].u.field_0x2ea = bVar5;
      }
      if ((txdesc->host).tid == -1) {
        uVar1 = (txdesc->host).flags;
        if ((((uVar1 & 8) != 0) && ((*(byte *)&ptVar4[1].length & 0xdc) == 0x10)) &&
           (*(short *)((int)&ptVar4[1].dma_desc[0].src + 2) == 0)) {
          (txdesc->host).flags = uVar1 | 0x20;
          rxu_cntrl_monitor_pm((mac_addr *)&ptVar4[1].lenheader);
        }
        txl_machdr_format((uint32_t)(ptVar4 + 1));
      }
      ptVar4 = (txdesc->lmac).buffer;
      ptVar13 = (txdesc->lmac).hw_desc;
      if (((txdesc->host).flags & 8) == 0) {
        txu_cntrl_tkip_mic_append(txdesc,(uint8_t)uVar2);
        (ptVar13->thd).macctrlinfo1 = (ptVar4->buffer_control).mac_control_info;
      }
      else {
        (ptVar13->thd).macctrlinfo2 = (ptVar13->thd).macctrlinfo2 & 0xff87ffff;
        bVar5 = *(byte *)&ptVar4[1].lenheader;
        (ptVar13->thd).statinfo = 0;
        (ptVar13->thd).macctrlinfo1 = (uint)((bVar5 & 1) == 0) << 9;
      }
      (ptVar13->thd).policyentryaddr = (uint32_t)&ptVar4->buffer_control;
      (ptVar13->thd).phyctrlinfo = (ptVar4->buffer_control).phy_control_info;
    }
    ptVar11->txlist[0].bridgedmacnt = ptVar11->txlist[0].bridgedmacnt + 1;
    ptVar7 = ptVar11->txlist[0].last_frame_exch;
    ptVar9 = &((txdesc->lmac).hw_desc)->thd;
    if (ptVar7 == (tx_hd *)0x0) {
      uVar6 = uVar3;
      if (uVar2 == 2) {
        if ((_DAT_44b08188 >> 0xc & 3) == 2) {
          line = 0x23c;
          condition = "blmac_tx_ac_2_state_getf() != 2";
          goto LAB_23005bec;
        }
        _DAT_44b08180 = 0x800;
        puVar8 = (undefined *)0x61a80;
        _DAT_44b081a4 = ptVar9;
      }
      else {
        if (2 < uVar2) {
          if (uVar2 == 3) {
            if ((_DAT_44b08188 >> 0x10 & 3) != 2) {
              _DAT_44b08180 = 0x1000;
              _DAT_44b081a8 = ptVar9;
              goto LAB_23005c4c;
            }
            line = 0x236;
            condition = "blmac_tx_ac_3_state_getf() != 2";
          }
          else {
            if (uVar2 != 4) goto LAB_23005b9a;
            if ((_DAT_44b08188 & 3) != 2) {
              _DAT_44b08180 = 0x100;
              uVar6 = 4;
              puVar8 = (undefined *)0xc350;
              _DAT_44b08198 = ptVar9;
              goto LAB_23005c08;
            }
            line = 0x22f;
            condition = "blmac_tx_bcn_state_getf() != 2";
          }
LAB_23005bec:
          assert_rec(condition,"module",line);
          goto LAB_23005b5e;
        }
        if (uVar2 == 1) {
          if ((_DAT_44b08188 >> 8 & 3) == 2) {
            line = 0x242;
            condition = "blmac_tx_ac_1_state_getf() != 2";
            goto LAB_23005bec;
          }
          _DAT_44b08180 = 0x400;
          puVar8 = &DAT_001e8480;
          _DAT_44b081a0 = ptVar9;
        }
        else {
LAB_23005b9a:
          if ((_DAT_44b08188 >> 4 & 3) == 2) {
            line = 0x248;
            condition = "blmac_tx_ac_0_state_getf() != 2";
            goto LAB_23005bec;
          }
          _DAT_44b08180 = 0x200;
          _DAT_44b0819c = ptVar9;
LAB_23005c4c:
          puVar8 = (undefined *)0x30d40;
        }
      }
LAB_23005c08:
      blmac_abs_timer_set(uVar6,(uint32_t)(puVar8 + _DAT_44b00120));
      _DAT_44b0808c = uVar12 | _DAT_44b0808c;
      _DAT_44b08088 = uVar12;
    }
    else {
      ptVar7->nextfrmexseq_ptr = (uint32_t)ptVar9;
      if (uVar2 == 2) {
        _DAT_44b08180 = 8;
      }
      else {
        if (uVar2 < 3) {
          if (uVar2 == 1) {
            _DAT_44b08180 = 4;
          }
          else {
LAB_23005b26:
            _DAT_44b08180 = 2;
          }
        }
        else {
          if (uVar2 == 3) {
            _DAT_44b08180 = 0x10;
          }
          else {
            if (uVar2 != 4) goto LAB_23005b26;
            _DAT_44b08180 = 1;
          }
        }
      }
    }
LAB_23005b5e:
    ptVar4 = ptVar10->list[0].first;
    ptVar11->txlist[0].last_frame_exch = ptVar9;
    if (ptVar4 == (txl_buffer_tag *)0x0) goto LAB_230059f6;
    ptVar10->list[0].first = ptVar4->next;
  } while( true );
}



_Bool txl_cntrl_push_int(txdesc *txdesc,uint8_t access_category)

{
  _Bool _Var1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  uint uVar2;
  int iVar3;
  tx_hw_desc *ptVar4;
  
  ptVar4 = (txdesc->lmac).hw_desc;
  _Var1 = txl_cntrl_tx_check(vif_info_tab + (txdesc->host).vif_idx);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    _Var1 = apm_tx_int_ps_check(txdesc);
    iVar3 = CONCAT31(extraout_var_00,_Var1);
    if (iVar3 != 0) {
      (ptVar4->thd).macctrlinfo2 = (ptVar4->thd).macctrlinfo2 | 0x100;
      txl_int_fake_transfer(txdesc,access_category);
      co_list_push_back(&txl_cntrl_env.txlist[CONCAT31(in_register_0000202d,access_category)].
                         transmitting,(co_list_hdr *)txdesc);
      txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
      txl_payload_handle_backup();
      goto LAB_23005d94;
    }
  }
  uVar2 = (uint)(txdesc->host).staid;
  if (uVar2 == 0xff) {
    txl_frame_release(txdesc,false);
    iVar3 = 0;
  }
  else {
    (txdesc->host).tid = access_category;
    *(undefined *)((int)&txdesc[1].host.packet_addr + 1) = 1;
    co_list_push_back(&sta_info_tab[uVar2].tx_desc_post,(co_list_hdr *)txdesc);
    apm_tx_int_ps_postpone(txdesc,sta_info_tab + uVar2);
    iVar3 = 1;
  }
LAB_23005d94:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUB41(iVar3,0);
}



_Bool txl_cntrl_push_int_force(txdesc *txdesc,uint8_t access_category)

{
  undefined3 in_register_0000202d;
  tx_hw_desc *ptVar1;
  
  ptVar1 = (txdesc->lmac).hw_desc;
  (ptVar1->thd).macctrlinfo2 = (ptVar1->thd).macctrlinfo2 | 0x100;
  txl_int_fake_transfer(txdesc,access_category);
  co_list_push_back(&txl_cntrl_env.txlist[CONCAT31(in_register_0000202d,access_category)].
                     transmitting,(co_list_hdr *)txdesc);
  txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
  txl_payload_handle_backup();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return true;
}



_Bool txl_cntrl_push(txdesc *txdesc,uint8_t access_category)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  txl_buffer_tag *ptVar4;
  undefined3 in_register_0000202d;
  tx_hw_desc *ptVar5;
  
  bVar1 = (txdesc->umac).tail_len;
  bVar2 = (txdesc->umac).head_len;
  ptVar5 = (txdesc->lmac).hw_desc;
  uVar3 = (txdesc->host).packet_len;
  (ptVar5->thd).nextmpdudesc_ptr = 0;
  (ptVar5->thd).frmlen = (uint)bVar2 + (uint)bVar1 + (uint)uVar3 + 4;
  (ptVar5->thd).upatterntx = 0xcafebabe;
  (ptVar5->thd).nextfrmexseq_ptr = 0;
  (ptVar5->thd).field_3 = 0;
  (ptVar5->thd).policyentryaddr = 0;
  (ptVar5->thd).macctrlinfo2 = 0;
  (ptVar5->thd).field_4 = 0;
  (ptVar5->thd).field_5 = 0;
  (ptVar5->thd).frmlifetime = 0;
  (ptVar5->thd).statinfo = 0;
  if ((txdesc->host).packet_addr == 0) {
    txl_int_fake_transfer(txdesc,access_category);
  }
  else {
    ptVar4 = txl_buffer_alloc(txdesc,access_category,'\0');
    (txdesc->lmac).buffer = ptVar4;
    ptVar4->txdesc = txdesc;
    txl_buffer_update_thd(txdesc);
  }
  txl_payload_handle_backup();
  co_list_push_back(&txl_cntrl_env.txlist[CONCAT31(in_register_0000202d,access_category)].
                     transmitting,(co_list_hdr *)txdesc);
  txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt + 1;
  td_pck_ind((txdesc->host).vif_idx,(txdesc->host).staid,false);
  ps_check_tx_frame((txdesc->host).staid,(txdesc->host).tid);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_transmit_trigger(void)

{
  uint reg_idx;
  uint uVar1;
  int iVar2;
  uint32_t status;
  tx_hw_desc *ptVar3;
  uint32_t uVar4;
  txdesc *txdesc;
  co_list *list;
  
  if ((_DAT_44b08078 & 0x7c0) == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar2 = __clzsi2(_DAT_44b08078 & 0x7c0);
  reg_idx = 0x19U - iVar2 & 0xff;
  if (4 < reg_idx) {
    assert_err("access_category < NX_TXQ_CNT","module",0x90b);
  }
  _DAT_44b0807c = 1 << (reg_idx + 6 & 0x1f);
  list = &txl_cntrl_env.txlist[reg_idx].transmitting;
  uVar1 = ~(1 << (0x19U - iVar2 & 0x1f));
  while( true ) {
    txdesc = (txdesc *)list->first;
    if (txdesc == (txdesc *)0x0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_44b0808c = uVar1 & _DAT_44b0808c;
      return;
    }
    ptVar3 = (txdesc->lmac).hw_desc;
    status = (ptVar3->thd).statinfo;
    if (-1 < (int)status) break;
    if (((txdesc->host).packet_addr != 0) && ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0)) {
      (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
    }
    ptVar3->cfm_ptr->status = status;
    uVar4 = (ptVar3->thd).nextfrmexseq_ptr;
    if (uVar4 == 0) {
      txl_cntrl_env.txlist[reg_idx].last_frame_exch = (tx_hd *)0x0;
      _DAT_44b0808c = _DAT_44b0808c & uVar1;
    }
    else {
      if (-1 < *(int *)(uVar4 + 0x3c)) {
        blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    co_list_pop_front(list);
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txl_cfm_push(txdesc,status,(uint8_t)reg_idx);
    }
    blmac_abs_timer_set(reg_idx,_DAT_44b00120 + TX_TIMEOUT[reg_idx]);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_reset(void)

{
  uint8_t access_category;
  uint16_t uVar1;
  txl_cntrl_env_tag *ptVar2;
  undefined4 *puVar3;
  undefined4 uVar4;
  uint uVar5;
  co_list *list;
  txl_cfm_env_tag *list_00;
  
  uVar1 = txl_cntrl_env.seqnbr;
  ke_evt_clear(0x1f000);
  do {
  } while ((_DAT_44a00010 & 0xffff) != 0xffff);
  txl_cntrl_env.reset = true;
  list_00 = &txl_cfm_env;
  list = &txl_cntrl_env.txlist[0].transmitting;
  uVar5 = 0;
  do {
    _DAT_44a00020 = 1 << (uVar5 & 0x1f);
    access_category = (uint8_t)uVar5;
    txl_cfm_flush(access_category,(co_list *)list_00,0x40000000);
    uVar5 = uVar5 + 1;
    txl_cfm_flush(access_category,list,0x40000000);
    list_00 = (txl_cfm_env_tag *)(list_00->cfmlist + 1);
    list = list + 2;
  } while (uVar5 != 5);
  txl_hwdesc_reset();
  txl_buffer_reinit();
  txl_cfm_init();
  memset(&txl_cntrl_env,0,0x58);
  ptVar2 = &txl_cntrl_env;
  puVar3 = (undefined4 *)&DAT_44a00080;
  txl_cntrl_env.seqnbr = uVar1;
  do {
    co_list_init(&ptVar2->txlist[0].transmitting);
    ptVar2->txlist[0].last_frame_exch = (tx_hd *)0x0;
    uVar4 = *puVar3;
    ptVar2->txlist[0].chk_state = '\0';
    puVar3 = puVar3 + 1;
    ptVar2->txlist[0].bridgedmacnt = (uint16_t)uVar4;
    ptVar2 = (txl_cntrl_env_tag *)(ptVar2->txlist + 1);
  } while (puVar3 != (undefined4 *)0x44a00094);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void txl_cntrl_env_dump(void)

{
  int iVar1;
  uint32_t uVar2;
  int *piVar3;
  int iVar4;
  int *piVar5;
  co_list *list;
  
  iVar1 = 4;
  do {
    list = (co_list *)((int)&txl_cntrl_env.txlist[0].last_frame_exch + iVar1);
    uVar2 = co_list_cnt(list);
    if (uVar2 != 0) {
      piVar5 = (int *)list->first;
      piVar3 = piVar5;
      while (piVar3 != (int *)0x0) {
        piVar3 = (int *)*piVar3;
      }
      while (piVar5 != (int *)0x0) {
        iVar4 = *(int *)(piVar5[0x1b] + 0x10);
        while (iVar4 != 0) {
          iVar4 = *(int *)(iVar4 + 4);
        }
        piVar5 = (int *)*piVar5;
      }
    }
    iVar1 = iVar1 + 0x10;
  } while (iVar1 != 0x54);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_frame_init_desc(txl_frame_desc_tag *frame,txl_buffer_tag *buffer,tx_hw_desc *hwdesc,
                        txl_buffer_control *bufctrl)

{
  memset(frame,0,0x2d8);
  (hwdesc->thd).upatterntx = 0xcafebabe;
  (hwdesc->thd).field_4 = buffer + 1;
  (hwdesc->thd).frmlifetime = 0;
  (hwdesc->thd).optlen[0] = 0;
  (hwdesc->thd).optlen[1] = 0;
  (hwdesc->thd).optlen[2] = 0;
  *(undefined4 *)&bufctrl->field_0 = 0xbadcab1e;
  (frame->txdesc).lmac.hw_desc = hwdesc;
  (frame->txdesc).lmac.buffer = buffer;
  (frame->txdesc).umac.buf_control = bufctrl;
  frame->type = '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_frame_init(_Bool reset)

{
  tx_hw_desc *ptVar1;
  txl_frame_desc_tag *list_hdr;
  uint8_t uVar2;
  byte bVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  txl_buffer_control *ptVar4;
  uint32_t (*pauVar5) [147];
  int iVar6;
  
  co_list_init((co_list *)&txl_frame_env);
  co_list_init(&txl_frame_env.desc_done);
  list_hdr = txl_frame_desc;
  ptVar1 = txl_frame_hwdesc_pool;
  pauVar5 = txl_frame_pool;
  ptVar4 = txl_frame_buf_ctrl;
  iVar6 = 0;
  do {
    if ((CONCAT31(in_register_00002029,reset) == 0) || ((&list_hdr->type)[1] == '\0')) {
      memset(list_hdr,0,0x2d8);
      (ptVar1->thd).upatterntx = 0xcafebabe;
      (ptVar1->thd).frmlifetime = 0;
      (ptVar1->thd).optlen[0] = 0;
      (ptVar1->thd).optlen[1] = 0;
      (ptVar1->thd).optlen[2] = 0;
      *(undefined4 *)&ptVar4->field_0 = 0xbadcab1e;
      (list_hdr->txdesc).lmac.buffer = (txl_buffer_tag *)pauVar5;
      (list_hdr->txdesc).umac.buf_control = ptVar4;
      (list_hdr->txdesc).lmac.hw_desc = ptVar1;
      ptVar1->cfm_ptr = txl_frame_hwdesc_cfms + iVar6;
      (ptVar1->thd).field_4 = *pauVar5 + 0x53;
      list_hdr->type = '\0';
      co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)list_hdr);
    }
    iVar6 = iVar6 + 1;
    list_hdr = list_hdr + 1;
    ptVar1 = ptVar1 + 1;
    pauVar5 = pauVar5[1];
    ptVar4 = ptVar4 + 1;
  } while (iVar6 != 4);
  txl_buffer_control_24G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_24G.mac_control_info = 0;
  txl_buffer_control_24G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_24G.field_0._4_4_ = CONCAT31(extraout_var,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  txl_buffer_control_24G.field_0._8_4_ = (1 << (bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_24G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_24G.field_0._20_4_ = 0x400;
  txl_buffer_control_24G.field_0._12_4_ = 0;
  txl_buffer_control_24G.field_0._24_4_ = 0;
  txl_buffer_control_24G.field_0._28_4_ = 0;
  txl_buffer_control_24G.field_0._32_4_ = 0;
  txl_buffer_control_24G.field_0._40_4_ = 0;
  txl_buffer_control_24G.field_0._44_4_ = 0;
  txl_buffer_control_24G.field_0._48_4_ = 0;
  txl_buffer_control_5G.field_0._0_4_ = 0xbadcab1e;
  txl_buffer_control_5G.mac_control_info = 0;
  txl_buffer_control_5G.phy_control_info = 0;
  uVar2 = phy_get_ntx();
  txl_buffer_control_5G.field_0._4_4_ = CONCAT31(extraout_var_00,uVar2) << 0xe;
  bVar3 = phy_get_ntx();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  txl_buffer_control_5G.field_0._8_4_ = (1 << (bVar3 + 1 & 0x1f)) + -1;
  txl_buffer_control_5G.field_0._12_4_ = 0;
  txl_buffer_control_5G.field_0._16_4_ = 0xffff0704;
  txl_buffer_control_5G.field_0._20_4_ = iVar6;
  txl_buffer_control_5G.field_0._24_4_ = 0;
  txl_buffer_control_5G.field_0._28_4_ = 0;
  txl_buffer_control_5G.field_0._32_4_ = 0;
  txl_buffer_control_5G.field_0._40_4_ = 0;
  txl_buffer_control_5G.field_0._44_4_ = 0;
  txl_buffer_control_5G.field_0._48_4_ = 0;
  return;
}



// WARNING: Type propagation algorithm not settling

txl_frame_desc_tag * txl_frame_get(int type,int len)

{
  tx_hw_desc *ptVar1;
  uint8_t uVar2;
  txl_frame_desc_tag *ptVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  uint32_t uVar5;
  txl_buffer_control *__src;
  txl_buffer_control *__dest;
  txl_buffer_tag *ptVar6;
  
  ptVar3 = (txl_frame_desc_tag *)co_list_pop_front((co_list *)&txl_frame_env);
  if (ptVar3 == (txl_frame_desc_tag *)0x0) {
    tx_count = tx_count + 1;
    if (tx_count == 10) {
      tx_count = 0;
      rx_count = 2;
      uVar4 = co_list_cnt((co_list *)&txl_frame_env);
      uVar5 = co_list_cnt(&txl_frame_env.desc_done);
      if ((uVar5 | uVar4) == 0) {
        txl_cntrl_clear_all_ac();
      }
    }
  }
  else {
    if (rx_count == 1) {
      rx_count = 0;
      mac_hw_reset = '\x01';
      vTaskEnterCritical();
      assert_rec("MAC HW RESET include tx and rx","tx rx",0x10b);
      vTaskDelay(200);
      ptVar3 = (txl_frame_desc_tag *)0x0;
      vTaskExitCritical();
    }
    else {
      if (rx_count != 0) {
        rx_count = rx_count - 1;
      }
      ptVar1 = (ptVar3->txdesc).lmac.hw_desc;
      ptVar6 = (ptVar3->txdesc).lmac.buffer;
      (ptVar1->thd).frmlen = len + 4;
      (ptVar1->thd).field_5 = (ptVar1->thd).field_4 + len + -1;
      __dest = &ptVar6->buffer_control;
      if (type == 0) {
        __src = &txl_buffer_control_24G;
      }
      else {
        __src = __dest;
        if (type == 1) {
          __src = &txl_buffer_control_5G;
        }
      }
      memcpy(__dest,__src,0x34);
      uVar2 = tpc_get_vif_tx_power_vs_rate
                        (*(uint32_t *)&(ptVar6->buffer_control).field_0.field_0x14);
      *(uint *)&(ptVar6->buffer_control).field_0.field_0x24 = CONCAT31(extraout_var,uVar2);
      (ptVar1->thd).policyentryaddr = (uint32_t)__dest;
      (ptVar1->thd).phyctrlinfo = 0;
      (ptVar1->thd).macctrlinfo2 = 0;
      (ptVar1->thd).field_3 = 0;
      (ptVar3->cfm).cfm_func = (cfm_func_ptr *)0x0;
      (ptVar3->cfm).env = (void *)0x0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar3;
}



_Bool txl_frame_push(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x182);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int((txdesc *)frame,ac);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var3;
}



_Bool txl_frame_push_force(txl_frame_desc_tag *frame,uint8_t ac)

{
  byte bVar1;
  tx_hw_desc *ptVar2;
  _Bool _Var3;
  
  ptVar2 = (frame->txdesc).lmac.hw_desc;
  if (((ptVar2->thd).field_4 & 1) != 0) {
    assert_err("(thd->datastartptr & 0x01) == 0","module",0x1ad);
  }
  (ptVar2->thd).nextfrmexseq_ptr = 0;
  (ptVar2->thd).nextmpdudesc_ptr = 0;
  (ptVar2->thd).macctrlinfo2 = (ptVar2->thd).macctrlinfo2 & 0xff87ffff;
  bVar1 = *(byte *)((ptVar2->thd).field_4 + 4);
  (ptVar2->thd).statinfo = 0;
  (ptVar2->thd).macctrlinfo1 = (uint)((bVar1 & 1) == 0) << 9;
  _Var3 = txl_cntrl_push_int_force((txdesc *)frame,ac);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var3;
}



void txl_frame_cfm(txdesc *txdesc)

{
  co_list_push_back(&txl_frame_env.desc_done,(co_list_hdr *)txdesc);
  ke_evt_set(0x20000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_frame_release(txdesc *txdesc,_Bool postponed)

{
  co_list_hdr *UNRECOVERED_JUMPTABLE;
  undefined3 in_register_0000202d;
  
  if (*(char *)&txdesc[1].host.packet_addr == '\0') {
    co_list_push_back((co_list *)&txl_frame_env,(co_list_hdr *)txdesc);
  }
  if ((CONCAT31(in_register_0000202d,postponed) != 0) &&
     (UNRECOVERED_JUMPTABLE = txdesc[1].list_hdr.next, UNRECOVERED_JUMPTABLE != (co_list_hdr *)0x0))
  {
                    // WARNING: Could not recover jumptable at 0x230065c4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(code *)UNRECOVERED_JUMPTABLE)(txdesc[1].host.pbuf_addr,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_frame_evt(int dummy)

{
  co_list_hdr *list_hdr;
  
  ke_evt_clear(0x20000);
  while (list_hdr = co_list_pop_front(&txl_frame_env.desc_done), list_hdr != (co_list_hdr *)0x0) {
    txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt - 1;
    if ((list_hdr[0xb3].next == (co_list_hdr *)0x0) ||
       ((*(code *)list_hdr[0xb3].next)(list_hdr[0xb4].next,list_hdr[0x1b].next[0x10].next),
       *(char *)((int)&list_hdr[0xb5].next + 2) == '\0')) {
      if (*(char *)&list_hdr[0xb5].next == '\0') {
        co_list_push_back((co_list *)&txl_frame_env,list_hdr);
      }
    }
    else {
      *(undefined *)((int)&list_hdr[0xb5].next + 2) = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t txl_frame_send_null_frame(uint8_t sta_idx,cfm_func_ptr *cfm,void *env)

{
  byte bVar1;
  uint8_t uVar2;
  txl_buffer_tag *ptVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  uint uVar5;
  int iVar6;
  char cStack56;
  phy_channel_info phy_info;
  
  iVar4 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  phy_get_channel((phy_channel_info *)&cStack56,'\0');
  frame = txl_frame_get((uint)(cStack56 != '\0'),0x18);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + bVar1,frame);
    ptVar3 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar3[1].length = 0x48;
    *(undefined *)((int)&ptVar3[1].length + 1) = 1;
    *(undefined *)((int)&ptVar3[1].length + 2) = 0;
    *(undefined *)((int)&ptVar3[1].length + 3) = 0;
    memcpy(&ptVar3[1].lenheader,&sta_info_tab[iVar4].mac_addr,6);
    memcpy((void *)((int)&ptVar3[1].lenpad + 2),&vif_info_tab[bVar1].mac_addr,6);
    memcpy(&ptVar3[1].next,&sta_info_tab[iVar4].mac_addr,6);
    uVar5 = (uint)txl_cntrl_env.seqnbr;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar5 + 1) * 0x10000 >> 0x10);
    iVar6 = (uVar5 + 1) * 0x100000;
    *(char *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
    *(char *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(frame == (txl_frame_desc_tag *)0x0);
}



// WARNING: Variable defined which should be unmapped: phy_info

uint8_t txl_frame_send_qosnull_frame(uint8_t sta_idx,uint16_t qos,cfm_func_ptr *cfm,void *env)

{
  txl_buffer_tag *ptVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  txl_frame_desc_tag *frame;
  mac_addr *__src;
  uint uVar4;
  char cStack56;
  phy_channel_info phy_info;
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  uVar4 = (uint)sta_info_tab[iVar3].inst_nbr;
  phy_get_channel((phy_channel_info *)&cStack56,'\0');
  frame = txl_frame_get((uint)(cStack56 != '\0'),0x1a);
  if (frame == (txl_frame_desc_tag *)0x0) {
    uVar2 = '\x01';
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar4,frame);
    ptVar1 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar1[1].length = 200;
    *(undefined *)((int)&ptVar1[1].length + 1) = 0;
    *(undefined *)((int)&ptVar1[1].length + 2) = 0;
    *(undefined *)((int)&ptVar1[1].length + 3) = 0;
    memcpy(&ptVar1[1].lenheader,&sta_info_tab[iVar3].mac_addr,6);
    __src = &vif_info_tab[uVar4].mac_addr;
    memcpy((void *)((int)&ptVar1[1].lenpad + 2),__src,6);
    uVar2 = vif_info_tab[uVar4].type;
    *(undefined *)&ptVar1[1].length = 200;
    if (uVar2 == '\0') {
      *(undefined *)((int)&ptVar1[1].length + 1) = 1;
      __src = &sta_info_tab[iVar3].mac_addr;
    }
    else {
      *(undefined *)((int)&ptVar1[1].length + 1) = 2;
    }
    memcpy(&ptVar1[1].next,__src,6);
    *(char *)&ptVar1[1].dma_desc[0].src = (char)qos;
    *(undefined *)((int)&ptVar1[1].txdesc + 2) = 0;
    *(undefined *)((int)&ptVar1[1].txdesc + 3) = 0;
    *(char *)((int)&ptVar1[1].dma_desc[0].src + 1) = (char)(qos >> 8);
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = env;
    uVar2 = sta_info_tab[iVar3].inst_nbr;
    (frame->txdesc).host.staid = sta_idx;
    (frame->txdesc).host.vif_idx = uVar2;
    txl_frame_push(frame,'\x03');
    uVar2 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



uint8_t txl_frame_send_eapol_frame
                  (uint8_t sta_idx,cfm_func_ptr *cfm,void *cfm_env,uint8_t *pBuf,uint32_t pBuf_len)

{
  byte bVar1;
  u8_l uVar2;
  uint8_t uVar3;
  txl_buffer_tag *ptVar4;
  undefined3 in_register_00002029;
  txl_frame_desc_tag *frame;
  key_info_tag *pkVar5;
  uint32_t uVar6;
  ushort uVar7;
  undefined *puVar8;
  int iVar9;
  tx_hw_desc *ptVar10;
  uint16_t uVar11;
  uint uVar12;
  dma_desc *pdVar13;
  uint uVar14;
  dma_desc *unaff_s8;
  mac_addr *pmVar15;
  mac_addr *pmVar16;
  uint uVar17;
  int iVar18;
  char cStack88;
  phy_channel_info phy_info;
  mic_calc mic;
  
  iVar18 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar18].inst_nbr;
  uVar17 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)&cStack88,'\0');
  frame = txl_frame_get((uint)(cStack88 != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = sta_idx;
  (frame->txdesc).host.tid = '\0';
  uVar11 = sta_info_tab[iVar18].seq_nbr[0];
  sta_info_tab[iVar18].seq_nbr[0] = uVar11 + 1 & 0xfff;
  (frame->txdesc).host.ethertype = 0x8e88;
  (frame->txdesc).host.sn = uVar11;
  pmVar15 = &sta_info_tab[iVar18].mac_addr;
  *(uint16_t *)(frame->txdesc).host.eth_dest_addr.array = pmVar15->array[0];
  *(uint16_t *)((frame->txdesc).host.eth_dest_addr.array + 2) =
       sta_info_tab[iVar18].mac_addr.array[1];
  *(uint16_t *)((frame->txdesc).host.eth_dest_addr.array + 4) =
       sta_info_tab[iVar18].mac_addr.array[2];
  pmVar16 = &vif_info_tab[uVar17].mac_addr;
  *(uint16_t *)(frame->txdesc).host.eth_src_addr.array = pmVar16->array[0];
  *(uint16_t *)((frame->txdesc).host.eth_src_addr.array + 2) =
       vif_info_tab[uVar17].mac_addr.array[1];
  *(uint16_t *)((frame->txdesc).host.eth_src_addr.array + 4) =
       vif_info_tab[uVar17].mac_addr.array[2];
  tpc_update_frame_tx_power(vif_info_tab + uVar17,frame);
  ptVar4 = (frame->txdesc).lmac.buffer;
  if ((vif_info_tab[uVar17].bss_info.valid_flags & 1) == 0) {
    *(undefined *)&ptVar4[1].length = 8;
    uVar14 = (uint)txl_cntrl_env.seqnbr;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    pdVar13 = ptVar4[1].dma_desc;
    txl_cntrl_env.seqnbr = (uint16_t)((uVar14 + 1) * 0x10000 >> 0x10);
    iVar9 = (uVar14 + 1) * 0x100000;
    *(char *)((int)&ptVar4[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(char *)((int)&ptVar4[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar14 = pBuf_len + 0x20;
  }
  else {
    *(undefined *)&ptVar4[1].length = 0x88;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    pdVar13 = (dma_desc *)((int)&ptVar4[1].dma_desc[0].src + 2);
    uVar14 = pBuf_len + 0x22;
    iVar9 = (uint)(frame->txdesc).host.sn << 0x14;
    *(char *)((int)&ptVar4[1].txdesc + 2) = (char)((uint)iVar9 >> 0x10);
    *(char *)((int)&ptVar4[1].txdesc + 3) = (char)((uint)iVar9 >> 0x18);
    uVar2 = (frame->txdesc).host.tid;
    *(undefined *)((int)&ptVar4[1].dma_desc[0].src + 1) = 0;
    *(u8_l *)&ptVar4[1].dma_desc[0].src = uVar2;
  }
  if (0x100 < uVar14) {
    assert_err("length<=NX_TXFRAME_LEN","module",0x591);
  }
  uVar7 = *(ushort *)&ptVar4[1].length | 0x100;
  if (vif_info_tab[uVar17].type == '\x02') {
    uVar7 = *(ushort *)&ptVar4[1].length | 0x200;
  }
  *(char *)&ptVar4[1].length = (char)uVar7;
  *(char *)((int)&ptVar4[1].length + 1) = (char)(uVar7 >> 8);
  *(undefined *)((int)&ptVar4[1].length + 2) = 0;
  *(undefined *)((int)&ptVar4[1].length + 3) = 0;
  *(uint16_t *)&ptVar4[1].lenheader = pmVar15->array[0];
  *(uint16_t *)((int)&ptVar4[1].lenheader + 2) = sta_info_tab[iVar18].mac_addr.array[1];
  *(uint16_t *)&ptVar4[1].lenpad = sta_info_tab[iVar18].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar4[1].lenpad + 2) = pmVar16->array[0];
  *(uint16_t *)&ptVar4[1].flags = vif_info_tab[uVar17].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar4[1].flags + 2) = vif_info_tab[uVar17].mac_addr.array[2];
  if (vif_info_tab[uVar17].type == '\x02') {
    *(uint16_t *)&ptVar4[1].next = pmVar16->array[0];
    *(uint16_t *)((int)&ptVar4[1].next + 2) = vif_info_tab[uVar17].mac_addr.array[1];
    uVar11 = vif_info_tab[uVar17].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar4[1].next = pmVar15->array[0];
    *(uint16_t *)((int)&ptVar4[1].next + 2) = sta_info_tab[iVar18].mac_addr.array[1];
    uVar11 = sta_info_tab[iVar18].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar4[1].txdesc = uVar11;
  iVar18 = 0;
  if ((vif_info_tab[(frame->txdesc).host.vif_idx].type != '\0') ||
     (uVar17 = (uint)(frame->txdesc).host.staid, sta_info_tab[uVar17].ctrl_port_state != '\x02'))
  goto LAB_23006b64;
  pkVar5 = *sta_info_tab[uVar17].sta_sec_info.cur_key;
  uVar3 = pkVar5->cipher;
  if (uVar3 == '\x01') {
    uVar17 = *(uint *)&pkVar5->tx_pn + 1;
    *(uint *)((int)&pkVar5->tx_pn + 4) =
         (uint)(uVar17 < *(uint *)&pkVar5->tx_pn) + *(int *)((int)&pkVar5->tx_pn + 4);
    *(uint *)&pkVar5->tx_pn = uVar17;
    memcpy((frame->txdesc).host.pn,&pkVar5->tx_pn,6);
    iVar9 = 0xc;
LAB_23006cbc:
    iVar18 = 8;
  }
  else {
    if (uVar3 == '\0') {
LAB_23006a9e:
      uVar17 = *(uint *)&pkVar5->tx_pn + 1;
      *(uint *)((int)&pkVar5->tx_pn + 4) =
           (uint)(uVar17 < *(uint *)&pkVar5->tx_pn) + *(int *)((int)&pkVar5->tx_pn + 4);
      *(uint *)&pkVar5->tx_pn = uVar17;
      memcpy((frame->txdesc).host.pn,&pkVar5->tx_pn,4);
      iVar9 = 4;
      iVar18 = 4;
    }
    else {
      if (uVar3 == '\x02') {
        uVar17 = *(uint *)&pkVar5->tx_pn + 1;
        *(uint *)((int)&pkVar5->tx_pn + 4) =
             (uint)(uVar17 < *(uint *)&pkVar5->tx_pn) + *(int *)((int)&pkVar5->tx_pn + 4);
        *(uint *)&pkVar5->tx_pn = uVar17;
        memcpy((frame->txdesc).host.pn,&pkVar5->tx_pn,6);
        iVar9 = 8;
        goto LAB_23006cbc;
      }
      if (uVar3 == '\x03') goto LAB_23006a9e;
      iVar9 = 0;
      iVar18 = 0;
    }
  }
  iVar18 = iVar18 + iVar9;
  if (iVar18 == 0) goto LAB_23006b64;
  uVar7 = *(ushort *)&ptVar4[1].length;
  uVar14 = uVar14 + iVar18;
  *(char *)&ptVar4[1].length = (char)uVar7;
  *(byte *)((int)&ptVar4[1].length + 1) = (byte)((uint)uVar7 >> 8) | 0x40;
  uVar17 = (uint)vif_info_tab[(frame->txdesc).host.vif_idx].type;
  if (uVar17 == 0) {
    uVar12 = (uint)(frame->txdesc).host.staid;
    if (sta_info_tab[uVar12].ctrl_port_state == '\x02') {
      pkVar5 = *sta_info_tab[uVar12].sta_sec_info.cur_key;
      uVar6 = (((frame->txdesc).lmac.hw_desc)->thd).policyentryaddr;
      uVar3 = pkVar5->cipher;
      if (uVar3 == '\x01') {
        uVar7 = (frame->txdesc).host.pn[0];
        *(ushort *)&pdVar13->src = uVar7 & 0x7f00 | 0x2000 | uVar7 >> 8;
        uVar7 = (ushort)*(byte *)(frame->txdesc).host.pn | (ushort)pkVar5->key_idx << 0xe;
LAB_23006d14:
        *(ushort *)((int)&pdVar13->src + 2) = uVar7 | 0x2000;
        uVar17 = 8;
        *(u16_l *)&pdVar13->dest = (frame->txdesc).host.pn[1];
        *(u16_l *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.pn[2];
      }
      else {
        if (uVar3 == '\0') {
LAB_23006b32:
          *(u16_l *)&pdVar13->src = (frame->txdesc).host.pn[0];
          *(ushort *)((int)&pdVar13->src + 2) =
               (ushort)pkVar5->key_idx << 0xe | (frame->txdesc).host.pn[1];
          uVar17 = 4;
        }
        else {
          if (uVar3 == '\x02') {
            *(u16_l *)&pdVar13->src = (frame->txdesc).host.pn[0];
            uVar7 = (ushort)pkVar5->key_idx << 0xe;
            goto LAB_23006d14;
          }
          if (uVar3 == '\x03') goto LAB_23006b32;
        }
      }
      *(uint *)(uVar6 + 0xc) = *(uint *)(uVar6 + 0xc) & 0xffc00 | (uint)pkVar5->hw_key_idx;
    }
  }
  else {
    uVar17 = 0;
  }
  pdVar13 = (dma_desc *)((int)&pdVar13->src + uVar17);
  unaff_s8 = pdVar13;
LAB_23006b64:
  *(undefined2 *)&pdVar13->src = 0xaaaa;
  *(undefined2 *)((int)&pdVar13->src + 2) = 3;
  *(undefined2 *)&pdVar13->dest = 0;
  *(u16_l *)((int)&pdVar13->dest + 2) = (frame->txdesc).host.ethertype;
  memcpy(&pdVar13->length,pBuf,pBuf_len);
  if ((iVar18 != 0) &&
     (pkVar5 = *sta_info_tab[(frame->txdesc).host.staid].sta_sec_info.cur_key,
     pkVar5->cipher == '\x01')) {
    me_mic_init((mic_calc *)&phy_info.info2,(uint32_t *)&pkVar5->u,
                (mac_addr *)&(frame->txdesc).host.eth_dest_addr,
                (mac_addr *)&(frame->txdesc).host.eth_src_addr,(frame->txdesc).host.tid);
    me_mic_calc((mic_calc *)&phy_info.info2,(uint32_t)unaff_s8,pBuf_len + 8);
    me_mic_end((mic_calc *)&phy_info.info2);
    iVar18 = 0;
    do {
      puVar8 = (undefined *)((int)&phy_info.info2 + iVar18);
      iVar9 = iVar18 + pBuf_len + 8;
      iVar18 = iVar18 + 1;
      *(undefined *)((int)&unaff_s8->length + iVar9 + -8) = *puVar8;
    } while (iVar18 != 8);
  }
  ptVar10 = (frame->txdesc).lmac.hw_desc;
  (ptVar10->thd).field_5 = (ptVar10->thd).field_4 + -1 + uVar14;
  (ptVar10->thd).frmlen = uVar14 + 4;
  if (cfm != (cfm_func_ptr *)0x0) {
    (frame->cfm).cfm_func = cfm;
    (frame->cfm).env = cfm_env;
  }
  txl_frame_push(frame,"\x01"[(frame->txdesc).host.tid]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void txl_frame_dump(void)

{
  uint32_t uVar1;
  co_list_hdr cVar2;
  co_list_hdr cVar3;
  
  uVar1 = co_list_cnt((co_list *)&txl_frame_env);
  cVar2 = (co_list_hdr)txl_frame_env.desc_free.first;
  if (uVar1 != 0) {
    while (cVar3 = (co_list_hdr)txl_frame_env.desc_done.first, cVar2 != (co_list_hdr)0x0) {
      cVar2 = *(co_list_hdr *)cVar2;
    }
    while (cVar3 != (co_list_hdr)0x0) {
      cVar3 = *(co_list_hdr *)cVar3;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_hwdesc_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_hwdesc_reset(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vif_mgmt_bcn_to_evt(void *env)

{
  if (*(int *)((int)env + 0x40) != 0) {
    chan_bcn_to_evt((vif_info_tag *)env);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vif_mgmt_init(void)

{
  memset(&vif_mgmt_env,0,0x14);
  co_list_init((co_list *)&vif_mgmt_env);
  co_list_init(&vif_mgmt_env.used_list);
  memset(vif_info_tab,0,0x5d8);
  vif_info_tab[0].type = '\x04';
  vif_info_tab[0].tx_power = '\x7f';
  vif_info_tab[0].user_tx_power = '\x7f';
  vif_info_tab[0].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[0].tmr_bcn_to.env = vif_info_tab;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)vif_info_tab);
  memset(vif_info_tab + 1,0,0x5d8);
  vif_info_tab[1].type = '\x04';
  vif_info_tab[1].tx_power = '\x7f';
  vif_info_tab[1].user_tx_power = '\x7f';
  vif_info_tab[1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[1].tmr_bcn_to.env = vif_info_tab + 1;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)(vif_info_tab + 1));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t vif_mgmt_register(mac_addr *mac_addr,uint8_t vif_type,_Bool p2p,uint8_t *vif_idx)

{
  uint8_t uVar1;
  vif_info_tag *vif_entry;
  undefined3 in_register_0000202d;
  
  if (vif_mgmt_env.free_list.first == (co_list_hdr *)0x0) {
    uVar1 = '\x01';
  }
  else {
    if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
      mm_hw_info_set(mac_addr);
    }
    else {
      if (*(int *)mac_addr->array != _DAT_44b00010) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\x01';
      }
      if (((mac_addr->array[2] ^ _DAT_44b00014) & ~_DAT_44b0001c) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\x01';
      }
      mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x10;
      _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    }
    vif_entry = (vif_info_tag *)co_list_pop_front((co_list *)&vif_mgmt_env);
    vif_entry->type = vif_type;
    memcpy(&vif_entry->mac_addr,mac_addr,6);
    uVar1 = (char)((int)&vif_entry[-0xb4b94].key_info[1].tx_pn >> 3) * 's';
    vif_entry->txq_params[1] = 0xa43;
    vif_entry->txq_params[2] = 0x5e432;
    vif_entry->index = uVar1;
    vif_entry->txq_params[0] = 0xa47;
    vif_entry->txq_params[3] = 0x2f322;
    vif_entry->chan_ctxt = (chan_ctxt_tag *)0x0;
    (vif_entry->tbtt_switch).vif_index = uVar1;
    if (CONCAT31(in_register_0000202d,vif_type) == 0) {
      (vif_entry->tbtt_timer).env = vif_entry;
      *(undefined *)&(vif_entry->u).field_0x1d = 0;
      vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + '\x01';
      (vif_entry->tbtt_timer).cb = mm_sta_tbtt;
      *(undefined *)&(vif_entry->u).field_0x4 = 0xff;
      *(undefined *)&(vif_entry->u).field_0x1e = 0;
    }
    else {
      if (CONCAT31(in_register_0000202d,vif_type) == 2) {
        if (vif_mgmt_env.vif_ap_cnt == '\0') {
          mm_hw_ap_info_set();
        }
        vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + '\x01';
        mm_bcn_init_vif(vif_entry);
      }
    }
    td_start(vif_entry->index);
    *vif_idx = vif_entry->index;
    co_list_push_back(&vif_mgmt_env.used_list,(co_list_hdr *)vif_entry);
    uVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_unregister(uint8_t vif_idx)

{
  vif_info_tag *list_hdr;
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,vif_idx);
  list_hdr = vif_info_tab + iVar1;
  co_list_extract(&vif_mgmt_env.used_list,(co_list_hdr *)list_hdr);
  if (vif_info_tab[iVar1].type == '\0') {
    vif_mgmt_env.vif_sta_cnt = vif_mgmt_env.vif_sta_cnt + -1;
  }
  else {
    if ((vif_info_tab[iVar1].type == '\x02') &&
       (vif_mgmt_env.vif_ap_cnt = vif_mgmt_env.vif_ap_cnt + -1, vif_mgmt_env.vif_ap_cnt == '\0')) {
      mm_hw_ap_info_reset();
    }
  }
  if ((uint)vif_mgmt_env.vif_ap_cnt + (uint)vif_mgmt_env.vif_sta_cnt == 1) {
    mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffffef;
    _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
    _DAT_44b00020 = vif_mgmt_env.used_list.first[0xe].next;
    _DAT_44b00024 = (uint)*(ushort *)&vif_mgmt_env.used_list.first[0xf].next;
  }
  if (vif_info_tab[iVar1].type == '\x02') {
    txl_cntrl_clear_bcn_ac();
  }
  mm_timer_clear(&vif_info_tab[iVar1].tbtt_timer);
  mm_timer_clear(&vif_info_tab[iVar1].tmr_bcn_to);
  td_reset(vif_info_tab[iVar1].index);
  memset(list_hdr,0,0x5d8);
  vif_info_tab[iVar1].type = '\x04';
  vif_info_tab[iVar1].tx_power = '\x7f';
  vif_info_tab[iVar1].user_tx_power = '\x7f';
  vif_info_tab[iVar1].tmr_bcn_to.cb = vif_mgmt_bcn_to_evt;
  vif_info_tab[iVar1].tmr_bcn_to.env = list_hdr;
  co_list_push_back((co_list *)&vif_mgmt_env,(co_list_hdr *)list_hdr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vif_mgmt_add_key(mm_key_add_req *param,uint8_t hw_key_idx)

{
  uint8_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  uVar2 = (uint)param->key_idx;
  vif_info_tab[uVar3].key_info[uVar2].hw_key_idx = hw_key_idx;
  vif_info_tab[uVar3].key_info[uVar2].cipher = param->cipher_suite;
  vif_info_tab[uVar3].key_info[uVar2].key_idx = param->key_idx;
  memset(vif_info_tab[uVar3].key_info + uVar2,0,0x48);
  uVar1 = vif_info_tab[uVar3].key_info[uVar2].cipher;
  if (uVar1 == '\x01') {
    *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
    *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    *(uint32_t *)&vif_info_tab[uVar3].key_info[uVar2].u = (param->key).array[4];
    *(uint32_t *)&vif_info_tab[uVar3].key_info[uVar2].u.field_0x4 = (param->key).array[5];
    *(uint32_t *)&vif_info_tab[uVar3].key_info[uVar2].u.field_0x8 = (param->key).array[6];
    *(uint32_t *)&vif_info_tab[uVar3].key_info[uVar2].u.field_0xc = (param->key).array[7];
  }
  else {
    if ((uVar1 == '\0') || (uVar1 == '\x03')) {
      next = next * 0x41c64e6d + 0x3039;
      *(ulong *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = next >> 0x10;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
    else {
      *(undefined4 *)&vif_info_tab[uVar3].key_info[uVar2].tx_pn = 0;
      *(undefined4 *)((int)&vif_info_tab[uVar3].key_info[uVar2].tx_pn + 4) = 0;
    }
  }
  vif_info_tab[uVar3].key_info[uVar2].valid = true;
  vif_info_tab[uVar3].default_key = vif_info_tab[uVar3].key_info + uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vif_mgmt_del_key(vif_info_tag *vif,uint8_t keyid)

{
  undefined3 in_register_0000202d;
  _Bool *p_Var1;
  int iVar2;
  
  vif->key_info[CONCAT31(in_register_0000202d,keyid)].valid = false;
  if (vif->default_key == vif->key_info + CONCAT31(in_register_0000202d,keyid)) {
    vif->default_key = (key_info_tag *)0x0;
    p_Var1 = &vif->key_info[0].valid;
    iVar2 = 0;
    do {
      if (*p_Var1 != false) {
        vif->default_key = vif->key_info + iVar2;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      iVar2 = iVar2 + 1;
      p_Var1 = p_Var1 + 0x68;
    } while (iVar2 != 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_send_postponed_frame(vif_info_tag *p_vif_entry)

{
  sta_info_tag *p_sta_entry;
  
  p_sta_entry = (sta_info_tag *)(p_vif_entry->sta_list).first;
  while (p_sta_entry != (sta_info_tag *)0x0) {
    sta_mgmt_send_postponed_frame(p_vif_entry,p_sta_entry,0);
    p_sta_entry = *(sta_info_tag **)&p_sta_entry->list_hdr;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void vif_mgmt_reset(void)

{
  vif_info_tag *p_vif_entry;
  
  p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  while (p_vif_entry != (vif_info_tag *)0x0) {
    vif_mgmt_send_postponed_frame(p_vif_entry);
    p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_bcn_to_prog(vif_info_tag *p_vif_entry)

{
  mm_timer_set(&p_vif_entry->tmr_bcn_to,_DAT_44b00120 + 10000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vif_mgmt_bcn_recv(vif_info_tag *p_vif_entry)

{
  if (((ps_env.ps_on != false) && ((ps_env.prevent_sleep & 8) == 0)) &&
     (p_vif_entry->prevent_sleep == 0)) {
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    vif_mgmt_bcn_to_evt(p_vif_entry);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_set_ap_bcn_int(vif_info_tag *p_vif_entry,uint16_t bcn_int)

{
  undefined2 in_register_0000202e;
  uint uVar1;
  uint uVar2;
  co_list_hdr cVar3;
  
  uVar1 = CONCAT22(in_register_0000202e,bcn_int);
  *(uint16_t *)&(p_vif_entry->u).field_0x2e2 = bcn_int;
  if (vif_mgmt_env.vif_ap_cnt < 2) {
    vif_mgmt_env.low_bcn_int_idx = p_vif_entry->index;
    *(undefined2 *)&(p_vif_entry->u).field_0x2e4 = 0x101;
  }
  else {
    uVar2 = (uint)*(ushort *)&vif_info_tab[vif_mgmt_env.low_bcn_int_idx].u.field_0x2e2;
    cVar3 = (co_list_hdr)vif_mgmt_env.used_list.first;
    if (uVar1 < uVar2) {
      vif_mgmt_env.low_bcn_int_idx = p_vif_entry->index;
      uVar2 = uVar1;
    }
    while (uVar1 = uVar2, cVar3 != (co_list_hdr)0x0) {
      *(undefined *)((int)cVar3 + 0x341) = 1;
      *(char *)&((co_list_hdr *)((int)cVar3 + 0x340))->next =
           (char)(*(ushort *)((int)cVar3 + 0x33e) / uVar1);
      cVar3 = *(co_list_hdr *)cVar3;
      uVar2 = uVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b00064 = _DAT_44b00064 & 0xffff0000 | uVar1;
  return;
}



// WARNING: Variable defined which should be unmapped: chan_idx
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vif_mgmt_switch_channel(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  uint16_t uVar2;
  uint8_t uVar3;
  void *pvVar4;
  scan_chan_tag *psVar5;
  undefined3 extraout_var;
  uint8_t chan_idx_00;
  uint8_t local_11 [4];
  uint8_t chan_idx;
  
  pvVar4 = ke_msg_alloc(0x58,0xd,0,3);
  local_11[0] = -1;
  chan_ctxt_unlink(p_vif_entry->index);
  uVar2 = (p_vif_entry->csa_channel).prim20_freq;
  chan_idx_00 = (uint8_t)uVar2;
  psVar5 = me_freq_to_chan_ptr((p_vif_entry->csa_channel).band,uVar2);
  uVar2 = (p_vif_entry->csa_channel).center1_freq;
  (p_vif_entry->bss_info).chan = psVar5;
  (p_vif_entry->bss_info).center_freq1 = uVar2;
  (p_vif_entry->bss_info).center_freq2 = (p_vif_entry->csa_channel).center2_freq;
  uVar3 = (p_vif_entry->csa_channel).type;
  (p_vif_entry->bss_info).phy_bw = uVar3;
  if (uVar3 == '\x04') {
    uVar3 = '\x03';
  }
  (p_vif_entry->bss_info).bw = uVar3;
  if (psVar5 == (scan_chan_tag *)0x0) {
    ebreak();
  }
  else {
    (p_vif_entry->csa_channel).tx_power = psVar5->tx_power;
    uVar3 = chan_ctxt_add(&p_vif_entry->csa_channel,local_11);
    psVar5 = (scan_chan_tag *)CONCAT31(extraout_var,uVar3);
    *(uint8_t *)((int)pvVar4 + 1) = uVar3;
    *(uint8_t *)((int)pvVar4 + 2) = local_11[0];
    chan_idx_00 = local_11[0];
    if (p_vif_entry->type != '\0') {
      if ((p_vif_entry->type == '\x02') &&
         (*(undefined *)&(p_vif_entry->u).field_0x2eb = 0, psVar5 == (scan_chan_tag *)0x0)) {
        chan_ctxt_link(p_vif_entry->index,local_11[0]);
        mm_bcn_env.update_ongoing = true;
      }
      goto LAB_2300745a;
    }
  }
  *(undefined *)&(p_vif_entry->u).field_0x1d = 0;
  if (psVar5 == (scan_chan_tag *)0x0) {
    bVar1 = *(byte *)&(p_vif_entry->u).field_0x4;
    chan_ctxt_link(p_vif_entry->index,chan_idx_00);
    mm_timer_clear(&p_vif_entry->tmr_bcn_to);
    mm_timer_set(&p_vif_entry->tbtt_timer,_DAT_44b00120 + sta_info_tab[bVar1].bcn_int);
    *(undefined *)&(p_vif_entry->u).field_0x18 = 0;
    *(undefined *)&(p_vif_entry->u).field_0x1e = 1;
  }
  else {
    mm_send_connection_loss_ind(p_vif_entry);
  }
LAB_2300745a:
  ke_msg_send(pvVar4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



vif_info_tag * vif_mgmt_get_first_ap_inf(void)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  cVar1 = (co_list_hdr)vif_mgmt_env.used_list.first;
  cVar2 = (co_list_hdr)0x0;
  if (vif_mgmt_env.vif_ap_cnt != '\0') {
    while ((cVar2 = cVar1, cVar1 != (co_list_hdr)0x0 && (*(char *)((int)cVar1 + 0x56) != '\x02'))) {
      cVar1 = *(co_list_hdr *)cVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (vif_info_tag *)cVar2;
}



void me_init(void)

{
  memset(&me_env,0,0x134);
  ke_state_set(5,0);
  scanu_init();
  apm_init();
  sm_init();
  bam_init();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



scan_chan_tag * me_freq_to_chan_ptr(uint8_t band,uint16_t freq)

{
  int iVar1;
  byte bVar2;
  ushort *puVar3;
  undefined3 in_register_00002029;
  scan_chan_tag *psVar4;
  undefined2 in_register_0000202e;
  scan_chan_tag *psVar5;
  scan_chan_tag *psVar6;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    iVar1 = 4;
    bVar2 = me_env.chan.chan2G4_cnt;
  }
  else {
    iVar1 = 0x58;
    bVar2 = me_env.chan.chan5G_cnt;
  }
  psVar5 = (scan_chan_tag *)((int)me_env.chan.chan2G4 + iVar1 + -4);
  psVar6 = psVar5;
  do {
    if (psVar6 == psVar5 + bVar2) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (scan_chan_tag *)0x0;
    }
    psVar4 = psVar6;
    puVar3 = &psVar6->freq;
    psVar6 = psVar6 + 1;
  } while ((uint)*puVar3 != CONCAT22(in_register_0000202e,freq));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return psVar4;
}



void michael_block(mic_calc *mic_calc_ptr,uint32_t block)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = block ^ mic_calc_ptr->mic_key_least;
  uVar2 = mic_calc_ptr->mic_key_most ^ (uVar1 >> 0xf | uVar1 << 0x11);
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 8 & 0xff00ff | uVar1 * 0x100 & 0xff00ff00) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 * 8 | uVar1 >> 0x1d) ^ uVar2;
  uVar1 = uVar1 + uVar2;
  uVar2 = (uVar1 >> 2 | uVar1 * 0x40000000) ^ uVar2;
  mic_calc_ptr->mic_key_most = uVar2;
  mic_calc_ptr->mic_key_least = uVar1 + uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_mic_init(mic_calc *mic_calc_ptr,uint32_t *mic_key_ptr,mac_addr *da,mac_addr *sa,uint8_t tid)

{
  uint32_t block;
  uint16_t uVar1;
  uint16_t uVar2;
  uint32_t block_00;
  undefined3 in_register_00002039;
  uint32_t uVar3;
  uint32_t block_01;
  
  block = *(uint32_t *)da->array;
  block_01 = tid & 7;
  uVar1 = sa->array[0];
  uVar2 = da->array[2];
  block_00 = *(uint32_t *)(sa->array + 1);
  if (CONCAT31(in_register_00002039,tid) == 0xff) {
    block_01 = 0;
  }
  mic_calc_ptr->mic_key_least = *mic_key_ptr;
  uVar3 = mic_key_ptr[1];
  mic_calc_ptr->last_m_i = 0;
  mic_calc_ptr->mic_key_most = uVar3;
  mic_calc_ptr->last_m_i_len = '\0';
  michael_block(mic_calc_ptr,block);
  michael_block(mic_calc_ptr,CONCAT22(uVar1,uVar2));
  michael_block(mic_calc_ptr,block_00);
  michael_block(mic_calc_ptr,block_01);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_mic_calc(mic_calc *mic_calc_ptr,uint32_t start_ptr,uint32_t data_len)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint *puVar9;
  uint uVar10;
  
  puVar9 = (uint *)(start_ptr & 0xfffffffc) + 1;
  uVar1 = 4 - (start_ptr & 3) & 0xff;
  uVar4 = (uint)mic_calc_ptr->last_m_i_len;
  uVar3 = *(uint *)(start_ptr & 0xfffffffc) >> ((start_ptr & 3) << 3);
  uVar10 = data_len - uVar1;
  if (data_len < uVar1) {
    uVar3 = uVar3 & 0xffffffffU >> ((4 - data_len) * 8 & 0x1f);
    uVar1 = data_len & 0xff;
    uVar10 = 0;
  }
  uVar1 = uVar1 + uVar4;
  uVar2 = uVar3 << ((uVar4 & 3) << 3) | mic_calc_ptr->last_m_i;
  uVar8 = uVar2;
  if (3 < uVar1) {
    uVar4 = (4 - uVar4) * 8;
    uVar8 = 0;
    if (uVar4 != 0x20) {
      uVar8 = uVar3 >> (uVar4 & 0x1f);
    }
    uVar1 = uVar1 - 4;
    michael_block(mic_calc_ptr,uVar2);
  }
  uVar4 = uVar1 << 3;
  uVar3 = (4 - uVar1) * 8;
  uVar2 = 0;
  puVar5 = puVar9;
  while (uVar10 >> 2 != uVar2) {
    uVar7 = *puVar5;
    puVar5 = puVar5 + 1;
    uVar6 = uVar7 << (uVar4 & 0x1f) | uVar8;
    uVar8 = 0;
    if (uVar3 != 0x20) {
      uVar8 = uVar7 >> (uVar3 & 0x1f);
    }
    michael_block(mic_calc_ptr,uVar6);
    uVar2 = uVar2 + 1;
  }
  if ((uVar10 & 0xfffffffc) < uVar10) {
    uVar6 = (4 - (uVar10 & 3)) * 8;
    uVar2 = 0;
    if (uVar6 != 0x20) {
      uVar2 = 0xffffffff >> (uVar6 & 0x1f);
    }
    uVar2 = *(uint *)((int)puVar9 + (uVar10 & 0xfffffffc)) & uVar2;
    uVar1 = uVar1 + (uVar10 & 3);
    uVar4 = uVar8 | uVar2 << (uVar4 & 0x1f);
    uVar8 = uVar4;
    if (3 < uVar1) {
      uVar8 = 0;
      if (uVar3 != 0x20) {
        uVar8 = uVar2 >> (uVar3 & 0x1f);
      }
      uVar1 = uVar1 - 4;
      michael_block(mic_calc_ptr,uVar4);
    }
  }
  mic_calc_ptr->last_m_i_len = (uint8_t)uVar1;
  mic_calc_ptr->last_m_i = uVar8;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_mic_end(mic_calc *mic_calc_ptr)

{
  uint uVar1;
  
  uVar1 = mic_calc_ptr->last_m_i;
  if (3 < mic_calc_ptr->last_m_i_len) {
    assert_err("mic_calc_ptr->last_m_i_len < 4","module",0x13e);
  }
  michael_block(mic_calc_ptr,0x5a << ((mic_calc_ptr->last_m_i_len & 3) << 3) | uVar1);
  michael_block(mic_calc_ptr,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool me_set_sta_ht_vht_param(sta_info_tag *sta,mac_bss_info *bss)

{
  ushort uVar1;
  uint uVar2;
  ushort uVar3;
  uint8_t uVar4;
  ushort uVar5;
  
  uVar1 = (sta->info).ht_cap.ht_capa_info;
  uVar3 = uVar1 >> 1 & 1;
  uVar2 = (int)(uint)uVar1 >> 8 & 3;
  if (me_env.phy_bw_max < uVar3) {
    uVar3 = (ushort)me_env.phy_bw_max;
  }
  (sta->info).phy_bw_max = (uint8_t)uVar3;
  uVar5 = (ushort)bss->phy_bw;
  if (uVar5 == 4) {
    uVar5 = 2;
  }
  uVar4 = (uint8_t)uVar5;
  if (uVar3 < uVar5) {
    uVar4 = (uint8_t)uVar3;
  }
  (sta->info).bw_cur = uVar4;
  uVar4 = me_env.stbc_nss;
  if (uVar2 < me_env.stbc_nss) {
    uVar4 = (uint8_t)uVar2;
  }
  (sta->info).stbc_nss = uVar4;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)((uVar1 & 0xc) != 0xc);
}



uint8_t me_11n_nss_max(uint8_t *mcs_set)

{
  uint8_t uVar1;
  
  if (mcs_set[3] == '\0') {
    uVar1 = '\x02';
    if ((mcs_set[2] == '\0') && (uVar1 = mcs_set[1], uVar1 != '\0')) {
      uVar1 = '\x01';
    }
  }
  else {
    uVar1 = '\x03';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint8_t me_legacy_ridx_min(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  
  uVar1 = 0;
  do {
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar1 & 0x1f) & 1U) != 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (uint8_t)uVar1;
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 != 0xc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\f';
}



uint8_t me_legacy_ridx_max(uint16_t rate_map)

{
  undefined2 in_register_0000202a;
  char cVar1;
  uint uVar2;
  
  if (CONCAT22(in_register_0000202a,rate_map) == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\f';
  }
  uVar2 = 0xb;
  do {
    cVar1 = '\v' - (char)uVar2;
    if ((CONCAT22(in_register_0000202a,rate_map) >> (uVar2 & 0x1f) & 1U) != 0) goto LAB_23007860;
    uVar2 = uVar2 - 1;
  } while (uVar2 != 0xffffffff);
  cVar1 = '\f';
LAB_23007860:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\v' - cVar1;
}



uint8_t me_rate_translate(uint8_t rate)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  
  bVar3 = rate & 0x7f;
  if (bVar3 == 0x16) {
    uVar1 = '\x03';
  }
  else {
    if (bVar3 < 0x17) {
      if (bVar3 == 0xb) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\x02';
      }
      if (bVar3 < 0xc) {
        if (bVar3 == 2) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\0';
        }
        bVar2 = 4;
        uVar1 = '\x01';
      }
      else {
        if (bVar3 == 0xc) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\x04';
        }
        bVar2 = 0x12;
        uVar1 = '\x05';
      }
    }
    else {
      if (bVar3 == 0x30) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\b';
      }
      if (bVar3 < 0x31) {
        if (bVar3 == 0x18) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\x06';
        }
        bVar2 = 0x24;
        uVar1 = '\a';
      }
      else {
        if (bVar3 == 0x60) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\n';
        }
        if (bVar3 == 0x6c) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\v';
        }
        bVar2 = 0x48;
        uVar1 = '\t';
      }
    }
    if (bVar3 != bVar2) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void me_get_basic_rates(mac_rateset *rateset,mac_rateset *basic_ratest)

{
  byte bVar1;
  int iVar2;
  
  basic_ratest->length = '\0';
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((char)rateset->array[iVar2] < '\0') {
      bVar1 = basic_ratest->length;
      basic_ratest->array[bVar1] = rateset->array[iVar2];
      basic_ratest->length = bVar1 + 1;
    }
    iVar2 = iVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint16_t me_legacy_rate_bitfield_build(mac_rateset *rateset,_Bool basic_only)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  
  uVar1 = 0;
  iVar2 = 0;
  while (iVar2 < (int)(uint)rateset->length) {
    if ((CONCAT31(in_register_0000202d,basic_only) == 0) || ((char)rateset->array[iVar2] < '\0')) {
      bVar3 = me_rate_translate(rateset->array[iVar2]);
      if (CONCAT31(extraout_var,bVar3) < 0xc) {
        uVar1 = uVar1 | 1 << (bVar3 & 0x1f) & 0xffffU;
      }
      else {
        assert_warn("bit_pos < MAC_RATESET_LEN","module",0x1c6);
      }
    }
    iVar2 = iVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)uVar1;
}



uint16_t me_build_capability(uint8_t vif_idx)

{
  ushort uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  ushort uVar3;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  uVar3 = 0x11;
  if (((vif_info_tab[iVar2].type != '\0') && (uVar3 = 1, vif_info_tab[iVar2].type == '\x02')) &&
     ((*(uint *)&vif_info_tab[iVar2].bss_info.is_supplicant_enabled & 0x12a00) != 0)) {
    uVar3 = 0x11;
  }
  uVar1 = uVar3 | 0x520;
  if ((vif_info_tab[iVar2].bss_info.chan)->band != '\x01') {
    uVar1 = uVar3 | 0x420;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)uVar1;
}



void me_init_bcmc_rate(sta_info_tag *sta_entry)

{
  byte bVar1;
  byte rate;
  uint8_t basic_rate_idx;
  int iVar2;
  
  if ((sta_entry->info).rate_set.length == '\0') {
    assert_err("rates->length != 0","module",0x229);
  }
  iVar2 = 0;
  rate = 0;
  while (iVar2 < (int)(uint)(sta_entry->info).rate_set.length) {
    bVar1 = (sta_entry->info).rate_set.array[iVar2];
    if (rate < (bVar1 & 0x7f)) {
      rate = bVar1 & 0x7f;
    }
    iVar2 = iVar2 + 1;
  }
  basic_rate_idx = me_rate_translate(rate);
  rc_init_bcmc_rate(sta_entry,basic_rate_idx);
  (sta_entry->pol_tbl).upd_field = '\0';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_tx_cfm_singleton(txdesc *txdesc)

{
  uint8_t sta_idx;
  uint uVar1;
  uint uVar2;
  
  uVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr->status;
  uVar2 = uVar1 & 0x10000;
  uVar1 = uVar1 >> 8 & 0xff;
  if (uVar2 == 0) {
    sta_idx = (txdesc->host).staid;
  }
  else {
    rf_dump_status();
    sta_idx = (txdesc->host).staid;
  }
  rc_update_counters(sta_idx,uVar1 + 1,uVar1 + (uVar2 != 0),false,false);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void me_check_rc(uint8_t sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  uint16_t uVar3;
  uint16_t rate_config;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  uint8_t uVar7;
  uint8_t uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint32_t uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  byte bVar12;
  uint8_t *puVar13;
  uint uVar14;
  int iVar15;
  ushort uVar16;
  uint uVar17;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar15 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar15 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar12 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar14 = (uint)uVar1;
      if (bVar12 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar14].probability + 0xe667) < 0xd99b) {
          uVar7 = '\n';
        }
        else {
          uVar7 = '\x05';
        }
      }
      else {
        uVar7 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar7;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar14) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != uVar2) && (uVar17 = (uint)rc_ss->retry[2].idx, uVar5 != uVar17)) &&
           (puVar13 = &rc_ss->rate_stats[uVar5 - 1].sample_skipped,
           *(ushort *)(puVar13 + 8) < 0xf334)) {
          uVar3 = *(uint16_t *)(puVar13 + 10);
          uVar10 = rc_get_duration(uVar3);
          rate_config = rc_ss->rate_stats[uVar14].rate_config;
          if (bVar12 < 2) {
            uVar11 = rc_get_duration(rate_config);
            if (uVar11 < uVar10) {
              uVar10 = 0;
              bVar4 = 0x13 < puVar13[0xc];
            }
            else {
              uVar10 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar16 = 0x20;
            uVar11 = rc_get_duration(rc_ss->rate_stats[uVar2].rate_config);
            if (puVar13[0xd] == '\0') {
              uVar16 = *(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar11 <= uVar10) {
              uVar7 = rc_get_nss(rate_config);
              uVar8 = rc_get_nss(uVar3);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar11 = rc_get_duration(rc_ss->rate_stats[uVar17].rate_config), uVar11 <= uVar10)
                 ) {
                if (uVar16 <= puVar13[0xc]) {
                  bVar12 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar12;
                  if (bVar12 < 3) goto LAB_2300964c;
                  if (0xf < bVar12) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_23009626;
              }
            }
LAB_2300964c:
            uVar10 = rc_calc_tp(rc_ss,(uint8_t)uVar5);
            bVar4 = true;
            if ((puVar13[0xe] & 0xf) < 10) {
              bVar4 = uVar16 <= puVar13[0xc];
            }
          }
          uVar11 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar11;
          if (bVar4) {
            uVar11 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar10;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar10;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_2300958c;
        }
      }
    }
LAB_23009626:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar10 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar10;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_2300958c;
    }
  }
  if (iVar15 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_2300958c:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: pwr_info

txl_buffer_control * me_update_buffer_control(sta_info_tag *sta_info)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  ushort uVar4;
  bool bVar5;
  undefined4 *puVar6;
  uint8_t uVar7;
  undefined3 extraout_var;
  undefined4 *puVar8;
  uint uVar9;
  undefined4 *puVar10;
  uint uVar11;
  uint *puVar12;
  int iVar13;
  uint *puVar14;
  rc_sta_stats *prVar15;
  uint uVar16;
  txl_buffer_control *ptVar17;
  uint32_t *puVar18;
  uint local_40;
  uint32_t rate_info [4];
  uint32_t pwr_info [4];
  
  puVar12 = &local_40;
  bVar1 = (sta_info->pol_tbl).upd_field;
  ptVar17 = (sta_info->pol_tbl).buf_ctrl;
  if (bVar1 != 0) {
    uVar16 = *(uint *)&(ptVar17->field_0).field_0x4;
    puVar6 = (undefined4 *)&(ptVar17->field_0).field_0x14;
    iVar13 = 0;
    puVar18 = rate_info + 3;
    puVar10 = puVar6;
    do {
      *(undefined4 *)((int)rate_info + iVar13 + -4) = *puVar10;
      puVar8 = (undefined4 *)((int)puVar18 + iVar13);
      iVar13 = iVar13 + 4;
      *puVar8 = puVar10[4];
      puVar10 = puVar10 + 1;
    } while (iVar13 != 0x10);
    if ((bVar1 & 1) != 0) {
      prVar15 = (sta_info->pol_tbl).sta_stats;
      bVar2 = (sta_info->info).stbc_nss;
      bVar3 = prVar15->sw_retry_step;
      bVar5 = false;
      uVar11 = 0;
      iVar13 = 0;
      puVar14 = &local_40;
      do {
        uVar4 = prVar15->rate_stats[prVar15->retry[(uint)bVar3 + iVar13 & 3].idx].rate_config;
        if ((uVar4 & 0x3000) != 0) {
          uVar9 = (uVar4 & 0x18) >> 3;
          if (iVar13 == 0) {
            if (uVar9 < bVar2) {
              bVar5 = true;
              uVar11 = uVar9;
            }
          }
          else {
            if (bVar5) {
              bVar5 = uVar9 == uVar11;
            }
          }
        }
        iVar13 = iVar13 + 1;
        *puVar14 = uVar4 & 0x3fff | 0x80000000 | *puVar14 & 0x1fffc000;
        puVar14 = puVar14 + 1;
      } while (iVar13 != 4);
      uVar16 = uVar16 & 0xfffffe7f;
      if (bVar5) {
        uVar16 = uVar16 | (uVar11 + 1) * 0x80;
      }
      (sta_info->pol_tbl).upd_field = bVar1 | 2;
    }
    bVar1 = (sta_info->pol_tbl).upd_field;
    if ((bVar1 & 2) != 0) {
      do {
        uVar11 = *puVar12;
        if ((uVar11 >> 0xb & 7 | uVar11 & 0x7c) != 0) {
          *puVar12 = uVar11 & 0xe0003fff | (sta_info->pol_tbl).prot_cfg;
        }
        puVar12 = puVar12 + 1;
      } while (puVar18 != puVar12);
    }
    if ((bVar1 & 0x10) != 0) {
      iVar13 = 0;
      do {
        uVar7 = tpc_get_vif_tx_power_vs_rate(*(uint32_t *)((int)rate_info + iVar13 + -4));
        *(uint *)((int)puVar18 + iVar13) = CONCAT31(extraout_var,uVar7);
        iVar13 = iVar13 + 4;
      } while (iVar13 != 0x10);
    }
    iVar13 = 0;
    *(uint *)&(ptVar17->field_0).field_0x4 = uVar16;
    do {
      *puVar6 = *(undefined4 *)((int)rate_info + iVar13 + -4);
      puVar10 = (undefined4 *)((int)puVar18 + iVar13);
      iVar13 = iVar13 + 4;
      puVar6[4] = *puVar10;
      puVar6 = puVar6 + 1;
    } while (iVar13 != 0x10);
    (sta_info->pol_tbl).upd_field = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar17;
}



void me_init_rate(sta_info_tag *sta_entry)

{
  rc_init(sta_entry);
  me_update_buffer_control(sta_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_bw_check(uint32_t ht_op_addr,uint32_t vht_op_addr,mac_bss_info *bss)

{
  short sVar1;
  uint16_t uVar2;
  byte bVar3;
  
  uVar2 = bss->chan->freq;
  bVar3 = 0;
  if (((ht_op_addr != 0) && (bVar3 = me_env.phy_bw_max, me_env.phy_bw_max != '\0')) &&
     (bVar3 = *(byte *)(ht_op_addr + 3) & 3, (*(byte *)(ht_op_addr + 3) & 3) != 0)) {
    sVar1 = 10;
    if (bVar3 != 1) {
      sVar1 = -10;
    }
    uVar2 = uVar2 + sVar1;
    bVar3 = 1;
  }
  bss->bw = bVar3;
  bss->phy_bw = bVar3;
  bss->center_freq1 = uVar2;
  bss->center_freq2 = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_beacon_check(uint8_t vif_idx,uint16_t length,uint32_t bcn_addr)

{
  byte bVar1;
  uint8_t uVar2;
  byte bVar3;
  uint8_t uVar4;
  undefined3 in_register_00002029;
  int iVar5;
  uint32_t uVar6;
  uint uVar7;
  uint8_t *puVar8;
  uint16_t buflen;
  uint16_t uVar9;
  scan_chan_tag *psVar10;
  uint32_t addr;
  undefined uVar11;
  uint8_t uStack51;
  char cStack50;
  uint8_t auStack49 [2];
  uint8_t csa_mode;
  int8_t pwr;
  uint8_t idx;
  
  iVar5 = CONCAT31(in_register_00002029,vif_idx);
  psVar10 = vif_info_tab[iVar5].bss_info.chan;
  vif_info_tab[iVar5].bss_info.prot_status = 0;
  buflen = length - 0x24;
  bVar1 = vif_info_tab[iVar5].bss_info.phy_bw;
  uVar2 = vif_info_tab[iVar5].bss_info.power_constraint;
  addr = bcn_addr + 0x24;
  if ((psVar10->band == '\0') && (uVar6 = mac_ie_find(addr,buflen,'*'), uVar6 != 0)) {
    bVar3 = *(byte *)(uVar6 + 2);
    uVar9 = vif_info_tab[iVar5].bss_info.prot_status & 0xfff8;
    if ((bVar3 & 1) != 0) {
      uVar9 = uVar9 | 1;
    }
    vif_info_tab[iVar5].bss_info.prot_status = uVar9;
    if ((bVar3 & 2) != 0) {
      vif_info_tab[iVar5].bss_info.prot_status = vif_info_tab[iVar5].bss_info.prot_status | 2;
    }
    if ((bVar3 & 4) != 0) {
      vif_info_tab[iVar5].bss_info.prot_status = vif_info_tab[iVar5].bss_info.prot_status | 4;
    }
  }
  uVar6 = 0;
  if (me_env.ht_supported != false) {
    uVar6 = mac_ie_find(addr,buflen,'=');
  }
  me_bw_check(uVar6,0,&vif_info_tab[iVar5].bss_info);
  uVar7 = me_extract_csa(addr,buflen,&uStack51,&vif_info_tab[iVar5].csa_channel);
  if ((uVar7 & 0xff) != 0) {
    uVar11 = (undefined)(uVar7 & 0xff);
    if (vif_info_tab[iVar5].type == '\0') {
      if ((*(char *)&vif_info_tab[iVar5].u.field_0x1d == '\0') && (uStack51 == '\x01')) {
        mm_send_csa_traffic_ind(vif_info_tab[iVar5].index,false);
      }
      *(undefined *)&vif_info_tab[iVar5].u.field_0x1d = uVar11;
    }
    else {
      if (vif_info_tab[iVar5].type == '\x02') {
        *(undefined *)&vif_info_tab[iVar5].u.field_0x2eb = uVar11;
      }
    }
  }
  me_extract_power_constraint(addr,buflen,&vif_info_tab[iVar5].bss_info);
  uVar4 = vif_info_tab[iVar5].bss_info.power_constraint;
  if (uVar4 != uVar2) {
    cStack50 = (vif_info_tab[iVar5].bss_info.chan)->tx_power - uVar4;
    tpc_update_vif_tx_power(vif_info_tab + iVar5,&cStack50,auStack49);
  }
  if (bVar1 < vif_info_tab[iVar5].bss_info.phy_bw) {
    puVar8 = (uint8_t *)ke_msg_alloc(0x3b,0,5,0xc);
    if (vif_info_tab[iVar5].chan_ctxt == (chan_ctxt_tag *)0x0) {
      assert_err("vif->chan_ctxt != NULL","module",0x39);
    }
    *puVar8 = (vif_info_tab[iVar5].chan_ctxt)->idx;
    puVar8[1] = (vif_info_tab[iVar5].bss_info.chan)->band;
    puVar8[2] = vif_info_tab[iVar5].bss_info.phy_bw;
    *(uint16_t *)(puVar8 + 4) = (vif_info_tab[iVar5].bss_info.chan)->freq;
    *(uint16_t *)(puVar8 + 6) = vif_info_tab[iVar5].bss_info.center_freq1;
    *(uint16_t *)(puVar8 + 8) = vif_info_tab[iVar5].bss_info.center_freq2;
    puVar8[10] = ((vif_info_tab[iVar5].chan_ctxt)->channel).tx_power;
    ke_msg_send(puVar8);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_sta_bw_nss_max_upd(uint8_t sta_idx,uint8_t bw,uint8_t nss)

{
  byte bVar1;
  uint8_t uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar5;
  undefined3 in_register_0000202d;
  uint uVar6;
  undefined3 in_register_00002031;
  uint uVar7;
  
  iVar4 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar4].inst_nbr;
  if (me_env.ht_supported == false) {
    assert_err("me_env.ht_supported","module",0x429);
  }
  uVar2 = me_11n_nss_max(sta_info_tab[iVar4].info.ht_cap.mcs_rate);
  uVar3 = me_11n_nss_max(me_env.ht_cap.mcs_rate);
  uVar5 = CONCAT31(extraout_var_00,uVar3);
  if (CONCAT31(extraout_var,uVar2) < CONCAT31(extraout_var_00,uVar3)) {
    uVar5 = CONCAT31(extraout_var,uVar2);
  }
  if (CONCAT31(in_register_00002031,nss) < uVar5) {
    uVar5 = CONCAT31(in_register_00002031,nss);
  }
  uVar7 = (uint)sta_info_tab[iVar4].info.phy_bw_max;
  if (uVar7 == 4) {
    uVar7 = 3;
  }
  uVar6 = (uint)vif_info_tab[bVar1].bss_info.bw;
  if (CONCAT31(in_register_0000202d,bw) < uVar6) {
    uVar6 = CONCAT31(in_register_0000202d,bw);
  }
  if (uVar7 < uVar6) {
    uVar6 = uVar7;
  }
  uVar2 = sta_info_tab[iVar4].staid;
  sta_info_tab[iVar4].info.bw_cur = (uint8_t)uVar6;
  rc_update_bw_nss_max(uVar2,(uint8_t)uVar6,(uint8_t)uVar5);
  sta_info_tab[iVar4].pol_tbl.upd_field = sta_info_tab[iVar4].pol_tbl.upd_field | 8;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t me_add_chan_ctx(uint8_t *p_chan_idx,scan_chan_tag *p_chan,uint32_t center_freq1,
                       uint32_t center_freq2,uint8_t ch_width)

{
  uint8_t uVar1;
  undefined auStack28 [4];
  mm_chan_ctxt_add_req req;
  
  auStack28[0] = p_chan->band;
  req._0_2_ = (uint16_t)center_freq1;
  auStack28._2_2_ = p_chan->freq;
  req.prim20_freq = (uint16_t)center_freq2;
  req.center1_freq._0_1_ = p_chan->tx_power;
  auStack28[1] = ch_width;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)auStack28,p_chan_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint8_t rc_get_nss(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  
  if ((CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7U) - 2 < 2) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint8_t)((byte)(CONCAT22(in_register_0000202a,rate_config) >> 3) & 3);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



uint8_t rc_get_mcs_index(uint16_t rate_config)

{
  undefined2 in_register_0000202a;
  byte bVar1;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7;
  if (uVar2 < 2) {
    bVar1 = (byte)rate_config & 0x7f;
  }
  else {
    bVar1 = 0;
    if (uVar2 < 4) {
      bVar1 = (byte)rate_config & 7;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)bVar1;
}



uint16_t rc_set_previous_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar4;
  uint uVar3;
  
  uVar4 = CONCAT22(in_register_0000202e,rate_config);
  uVar2 = rc_get_mcs_index(rate_config);
  uVar3 = CONCAT31(extraout_var,uVar2);
  uVar1 = (int)uVar4 >> 0xb & 7;
  if (uVar1 < 2) {
    if (rc_ss->r_idx_min < uVar3) {
      uVar4 = (uVar4 & 0xffffff80 | uVar3 - 1) & 0xffff;
    }
  }
  else {
    if (((uVar1 < 4) && (uVar3 != 0)) &&
       (uVar4 = (uVar4 & 0xfffffff8 | uVar3 - 1) & 0xffff, rc_ss->short_gi != '\0')) {
      uVar4 = uVar4 | 0x200;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)uVar4;
}



uint16_t rc_set_next_mcs_index(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 in_register_0000202e;
  uint uVar4;
  uint uVar3;
  
  uVar1 = CONCAT22(in_register_0000202e,rate_config);
  uVar2 = rc_get_mcs_index(rate_config);
  uVar3 = CONCAT31(extraout_var,uVar2);
  uVar4 = (int)uVar1 >> 0xb & 7;
  if (uVar4 < 2) {
    if ((uVar3 < rc_ss->r_idx_max) && ((rc_ss->rate_map_l >> (uVar3 + 1 & 0x1f) & 1) != 0)) {
      uVar1 = (uVar1 & 0xffffff80 | uVar3 + 1) & 0xffff;
    }
  }
  else {
    if ((uVar4 < 4) && (uVar3 < rc_ss->mcs_max)) {
      uVar2 = rc_get_nss(rate_config);
      if (((*(byte *)(&rc_ss->retry[6].field_0x6 + CONCAT31(extraout_var_00,uVar2)) >>
            (uVar3 + 1 & 0x1f) & 1) != 0) &&
         (uVar1 = (uVar1 & 0xfffffff8 | uVar3 + 1) & 0xffff, rc_ss->short_gi != '\0')) {
        uVar1 = uVar1 | 0x200;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)uVar1;
}



_Bool is_cck_group(uint16_t rate_config)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  if ((rate_config & 0x3000) == 0) {
    uVar1 = rc_get_mcs_index(rate_config);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)(CONCAT31(extraout_var,uVar1) < 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void rc_update_retry_chain(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  _Bool _Var5;
  ushort uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  ushort *puVar7;
  int iVar8;
  uint32_t uVar9;
  uint uVar10;
  uint uVar11;
  uint8_t *puVar12;
  uint uVar13;
  uint uVar14;
  uint8_t *puVar15;
  
  uVar6 = rc_ss->no_samples;
  uVar14 = (uint)uVar6;
  if (((rc_ss->info & 4) == 0) && (cur_tp[uVar14 - 1] < *cur_tp)) {
    rc_ss->retry[0].idx = 0;
    rc_ss->retry[0].tp = 0;
    uVar4 = 1;
  }
  else {
    rc_ss->retry[0].idx = uVar6 - 1;
    uVar4 = 2;
    rc_ss->retry[0].tp = cur_tp[uVar14 - 1];
  }
  uVar1 = rc_ss->retry[0].idx;
  puVar12 = &rc_ss->rate_stats[uVar1 - 1].sample_skipped;
  _Var5 = is_cck_group(*(uint16_t *)(puVar12 + 10));
  if (CONCAT31(extraout_var,_Var5) == 0) {
    uVar13 = 0;
    while ((int)uVar13 < (int)(uVar14 - 1)) {
      puVar15 = &rc_ss->rate_stats[uVar13 - 1].sample_skipped;
      _Var5 = is_cck_group(*(uint16_t *)(puVar15 + 10));
      if (CONCAT31(extraout_var_00,_Var5) != 0) {
        puVar15[0xf] = '\0';
      }
      uVar13 = uVar13 + 1 & 0xffff;
    }
    puVar12[0xf] = '\x01';
  }
  uVar9 = rc_ss->retry[0].tp;
  rc_ss->retry[1].idx = uVar1;
  rc_ss->retry[1].tp = uVar9;
  iVar3 = uVar14 - uVar4;
  do {
    iVar8 = iVar3;
    uVar13 = uVar4;
    uVar4 = uVar13 + 1 & 0xffff;
    if (uVar14 <= uVar13) goto LAB_230081c4;
    iVar3 = iVar8 + -1;
  } while (rc_ss->rate_stats[iVar8].rate_allowed == false);
  rc_ss->retry[1].idx = uVar6 - (short)uVar13;
  rc_ss->retry[1].tp = cur_tp[iVar8];
LAB_230081c4:
  uVar13 = (uint)rc_ss->retry[1].idx;
  uVar4 = uVar14 - uVar4;
  do {
    uVar10 = uVar4;
    uVar11 = uVar13;
    if (uVar14 <= (uVar14 - uVar10 & 0xffff)) break;
    uVar4 = uVar10 - 1;
    uVar11 = uVar10;
  } while (rc_ss->rate_stats[uVar10].rate_allowed == false);
  uVar14 = cur_tp[uVar11];
  puVar7 = &rc_ss->rate_stats[0].probability;
  uVar6 = rc_ss->rate_stats[uVar11].probability;
  uVar4 = 0;
  do {
    if (uVar13 <= (uVar4 & 0xffff)) {
      rc_ss->retry[2].idx = (uint16_t)uVar11;
      uVar9 = cur_tp[uVar11];
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[2].tp = uVar9;
      rc_ss->retry[3].tp = *cur_tp;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((*(char *)((int)puVar7 + 7) != '\0') && ((uVar4 & 0xffff) != (uint)uVar1)) {
      uVar2 = *puVar7;
      if (uVar2 < 0xf333) {
        if (uVar6 <= uVar2) {
          uVar9 = cur_tp[uVar4];
          goto LAB_230082a8;
        }
      }
      else {
        uVar9 = cur_tp[uVar4];
        if (uVar14 <= uVar9) {
LAB_230082a8:
          uVar14 = uVar9;
          uVar11 = uVar4;
          uVar6 = uVar2;
        }
      }
    }
    uVar4 = uVar4 + 1;
    puVar7 = puVar7 + 6;
  } while( true );
}



uint16_t rc_get_lowest_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  uint16_t uVar2;
  uint16_t uVar3;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar3 = 0x400;
    uVar2 = (ushort)rc_ss->r_idx_min;
    if (rc_ss->r_idx_min == 0) goto LAB_230082f4;
  }
  else {
    uVar3 = 0;
    if ((3 < bVar1) || (uVar3 = 0x400, rc_ss->r_idx_min == '\0')) goto LAB_230082f4;
    uVar2 = (ushort)bVar1 << 0xb;
  }
  uVar3 = uVar2;
LAB_230082f4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



// WARNING: Variable defined which should be unmapped: rc_ss_tmp

void rc_sort_samples_tp(rc_sta_stats *rc_ss,uint32_t *cur_tp)

{
  ushort uVar1;
  uint32_t *puVar2;
  ushort uVar3;
  uint32_t uVar4;
  ushort uVar5;
  rc_rate_stats *__src;
  ushort uVar6;
  rc_rate_stats *__src_00;
  undefined auStack44 [4];
  rc_rate_stats rc_ss_tmp;
  
  uVar5 = rc_ss->no_samples;
  uVar1 = uVar5 - 1;
  while (uVar6 = uVar1, uVar5 != 0) {
    puVar2 = cur_tp + 1;
    uVar5 = 0;
    uVar3 = 1;
    __src = rc_ss->rate_stats + 1;
    while (uVar1 = uVar5, uVar3 < uVar6) {
      __src_00 = __src + 1;
      if (puVar2[1] < *puVar2) {
        memmove(auStack44,__src,0xc);
        memmove(__src,__src_00,0xc);
        memmove(__src_00,auStack44,0xc);
        uVar4 = puVar2[1];
        puVar2[1] = *puVar2;
        *puVar2 = uVar4;
        uVar5 = uVar3;
      }
      uVar3 = uVar3 + 1;
      puVar2 = puVar2 + 1;
      __src = __src_00;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint16_t rc_get_initial_rate_config(rc_sta_stats *rc_ss)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  int iVar4;
  ushort uVar5;
  
  bVar1 = rc_ss->format_mod;
  if (bVar1 < 2) {
    uVar3 = (ushort)rc_ss->r_idx_max;
    uVar5 = (ushort)bVar1 << 0xb | (ushort)rc_ss->p_type << 10;
  }
  else {
    if (3 < bVar1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    bVar2 = rc_ss->no_ss;
    iVar4 = __clzsi2((uint)*(byte *)(&rc_ss->retry[6].field_0x6 + (uint)bVar2));
    uVar5 = (ushort)rc_ss->short_gi << 9 | (ushort)bVar1 << 0xb | (ushort)rc_ss->bw_max << 7 |
            (ushort)bVar2 << 3;
    uVar3 = 0x1fU - (short)iVar4 & 0xff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)(uVar5 | uVar3);
}



void rc_calc_prob_ewma(rc_rate_stats *rc_rs)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = (uint)rc_rs->attempts;
  if (uVar1 != 0) {
    rc_rs->sample_skipped = '\0';
    uVar3 = (uint)rc_rs->success << 0x10;
    uVar2 = uVar3 / uVar1;
    if (rc_rs->old_prob_available == false) {
      if (uVar3 < uVar1) {
        rc_rs->probability = 0;
      }
      else {
        rc_rs->probability = (short)uVar2 - 1;
      }
    }
    else {
      rc_rs->probability = (uint16_t)((uint)rc_rs->probability * 0x60 + uVar2 * 0x20 >> 7);
    }
    rc_rs->old_prob_available = true;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (rc_rs->sample_skipped != -1) {
    rc_rs->sample_skipped = rc_rs->sample_skipped + '\x01';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool rc_check_valid_rate(rc_sta_stats *rc_ss,uint16_t rate_config)

{
  uint8_t uVar1;
  byte bVar2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar3 = CONCAT22(in_register_0000202e,rate_config) >> 0xb & 7;
  if (uVar3 < 2) {
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)rc_ss->rate_map_l;
  }
  else {
    if (3 < uVar3) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return true;
    }
    uVar1 = rc_get_nss(rate_config);
    bVar2 = rc_get_mcs_index(rate_config);
    uVar3 = (uint)*(byte *)(&rc_ss->retry[6].field_0x6 + CONCAT31(extraout_var,uVar1));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)((byte)(uVar3 >> (bVar2 & 0x1f)) & 1);
}



uint16_t rc_new_random_rate(rc_sta_stats *rc_ss)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint16_t uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  
  uVar2 = (uint)rc_ss->bw_max;
  uVar8 = 0;
  next = next * 0x41c64e6d + 0x3039;
  uVar3 = (uint)rc_ss->format_mod;
  uVar6 = next >> 0x10;
  uVar5 = (uint16_t)((uVar3 << 0x1b) >> 0x10);
  if (uVar2 != 0) {
    uVar8 = uVar2 - 1 & 0xff;
  }
  uVar1 = (ushort)(next >> 0x10);
  if (uVar3 < 2) {
    uVar3 = (int)(uVar6 & 0x7f) % (int)(((uint)rc_ss->r_idx_max - (uint)rc_ss->r_idx_min) + 1) +
            (uint)rc_ss->r_idx_min;
    uVar2 = uVar3 & 0xff;
    if ((rc_ss->rate_map_l >> (uVar3 & 0x1f) & 1) == 0) {
      uVar2 = (uint)rc_ss->r_idx_max;
    }
    uVar5 = uVar5 | (ushort)uVar2;
    if (uVar2 == 0) {
      uVar5 = uVar5 | 0x400;
    }
    else {
      if ((uVar2 - 1 & 0xff) < 3) {
        uVar5 = uVar5 | uVar1 & 0x400 | (ushort)rc_ss->p_type << 10;
      }
    }
  }
  else {
    if (uVar3 < 4) {
      uVar3 = (uint)rc_ss->r_idx_min;
      if ((uVar3 < 4) && ((int)(uVar6 << 0x14) < 0)) {
        uVar3 = (int)(uVar6 & 0x7f) % (int)((rc_ss->r_idx_max - uVar3) + 1) + uVar3;
        uVar2 = uVar3 & 0xff;
        if ((rc_ss->rate_map_l >> (uVar3 & 0x1f) & 1) == 0) {
          uVar2 = (uint)rc_ss->r_idx_max;
        }
        uVar5 = 0x400;
        if (uVar2 != 0) {
          uVar5 = (ushort)rc_ss->p_type << 10 | uVar1 & 0x400 | (ushort)uVar2;
        }
      }
      else {
        uVar7 = (uint)rc_ss->mcs_max;
        uVar4 = ((int)uVar6 >> 3 & 3U) % (rc_ss->no_ss + 1);
        uVar3 = (uVar6 & 7) % (uVar7 + 1);
        if ((*(byte *)(&rc_ss->retry[6].field_0x6 + uVar4) >> (uVar3 & 0x1f) & 1) != 0) {
          uVar7 = uVar3 & 0xff;
        }
        uVar5 = uVar5 | (ushort)(((int)uVar6 >> 9 & 1U) % (rc_ss->short_gi + 1) << 9) |
                        (ushort)(uVar4 << 3) |
                ((short)((int)((int)uVar6 >> 7 & 3U) % (int)((uVar2 - uVar8) + 1)) + (short)uVar8) *
                0x80 | (ushort)uVar7;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar5;
}



void rc_update_counters(uint8_t sta_idx,uint32_t attempts,uint32_t failures,_Bool tx_ampdu,
                       _Bool retry_required)

{
  short sVar1;
  rc_sta_stats *prVar2;
  undefined3 in_register_00002029;
  uint uVar3;
  uint8_t uVar4;
  uint8_t *puVar5;
  ushort *puVar6;
  
  uVar3 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar3) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (sta_info_tab[uVar3].inst_nbr != -1) {
    prVar2 = sta_info_tab[uVar3].pol_tbl.sta_stats;
    if (prVar2 == (rc_sta_stats *)0x0) {
      assert_err("rc_ss != NULL","module",0x7ce);
    }
    puVar6 = &prVar2->retry[0].idx;
    prVar2->ampdu_packets = prVar2->ampdu_packets + 1;
    prVar2->ampdu_len = prVar2->ampdu_len + 1;
    do {
      if (attempts == 0) break;
      puVar5 = &prVar2->rate_stats[*puVar6 - 1].sample_skipped;
      if (failures < 4) {
        *(short *)(puVar5 + 4) = *(short *)(puVar5 + 4) + (short)attempts;
        sVar1 = (short)failures;
        failures = 0;
        *(short *)(puVar5 + 6) = ((short)attempts - sVar1) + *(short *)(puVar5 + 6);
        attempts = 0;
      }
      else {
        *(short *)(puVar5 + 4) = *(short *)(puVar5 + 4) + 4;
        attempts = attempts - 4;
        failures = failures - 4;
      }
      if (*(ushort *)(puVar5 + 4) < *(ushort *)(puVar5 + 6)) {
        assert_err("rc_rs->attempts >= rc_rs->success","module",0x7fa);
      }
      puVar6 = puVar6 + 4;
    } while (puVar6 != &(prVar2->max_tp_2_trial).idx);
    if (prVar2->trial_status == '\0') {
      if (prVar2->sample_wait != '\0') {
        prVar2->sample_wait = prVar2->sample_wait + -1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar4 = '\x01';
    }
    else {
      if (prVar2->trial_status != '\x02') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      if ((sta_info_tab[uVar3].pol_tbl.upd_field & 1) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar4 = '\x03';
    }
    prVar2->trial_status = uVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t rc_get_duration(uint16_t rate_config)

{
  uint8_t uVar1;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 extraout_var_00;
  uint uVar4;
  uint uVar2;
  
  uVar1 = rc_get_mcs_index(rate_config);
  uVar2 = CONCAT31(extraout_var,uVar1);
  uVar4 = CONCAT22(in_register_0000202a,rate_config) >> 0xb & 7;
  if (uVar4 < 2) {
    if (uVar2 < 4) {
      uVar3 = rc_duration_cck[CONCAT22(in_register_0000202a,rate_config) >> 10 & 1U | uVar2 << 1];
    }
    else {
      uVar3 = rc_duration_non_ht[uVar2 - 4];
    }
  }
  else {
    uVar3 = 0;
    if (uVar4 < 4) {
      uVar1 = rc_get_nss(rate_config);
      uVar3 = rc_duration_ht_ampdu
              [uVar2 << 3 | (rate_config & 0x200) >> 9 | (rate_config & 0x180) >> 6] /
              (CONCAT31(extraout_var_00,uVar1) + 1U);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



void rc_update_bw_nss_max(uint8_t sta_idx,uint8_t bw_max,uint8_t nss_max)

{
  ushort uVar1;
  rc_sta_stats *rc_ss;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  undefined2 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint32_t *puVar4;
  uint uVar5;
  ushort *puVar6;
  uint16_t *puVar7;
  uint uVar8;
  uint32_t local_48;
  uint32_t cur_tp [10];
  
  iVar3 = CONCAT31(in_register_00002029,sta_idx);
  rc_ss = sta_info_tab[iVar3].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x969);
  }
  if (((uint)rc_ss->bw_max != CONCAT31(in_register_0000202d,bw_max)) ||
     ((uint)rc_ss->no_ss != CONCAT31(in_register_00002031,nss_max))) {
    rc_ss->bw_max = bw_max;
    if (3 < CONCAT31(in_register_0000202d,bw_max)) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x96f);
    }
    rc_ss->no_ss = nss_max;
    if (7 < CONCAT31(in_register_00002031,nss_max)) {
      assert_err("rc_ss->no_ss < 8","module",0x971);
    }
    if (rc_ss->fixed_rate_cfg == 0xffff) {
      uVar2 = rc_get_lowest_rate_config(rc_ss);
      rc_ss->rate_stats[0].rate_config = uVar2;
      uVar2 = rc_get_initial_rate_config(rc_ss);
      rc_ss->rate_stats[rc_ss->no_samples - 1].rate_config = uVar2;
      uVar5 = 1;
LAB_230088ac:
      uVar1 = rc_ss->no_samples;
      if ((int)uVar5 < (int)(uVar1 - 1)) {
        do {
          uVar2 = rc_new_random_rate(rc_ss);
          uVar8 = 0;
          puVar6 = &rc_ss->rate_stats[0].rate_config;
          while( true ) {
            if (rc_ss->no_samples <= uVar8) {
              rc_ss->rate_stats[uVar5].rate_config = uVar2;
              uVar5 = uVar5 + 1 & 0xffff;
              goto LAB_230088ac;
            }
            if ((uint)*puVar6 == CONCAT22(extraout_var,uVar2)) break;
            uVar8 = uVar8 + 1;
            puVar6 = puVar6 + 6;
          }
        } while( true );
      }
      puVar7 = &rc_ss->rate_stats[0].probability;
      uVar5 = 0;
      puVar4 = &local_48;
      while (uVar1 != uVar5) {
        *(undefined *)(puVar7 + 3) = 0;
        *(undefined *)((int)puVar7 + 7) = 1;
        *puVar7 = 0;
        *(undefined *)((int)puVar7 + 5) = 0;
        *puVar4 = 0;
        uVar5 = uVar5 + 1 & 0xffff;
        puVar7 = puVar7 + 6;
        puVar4 = puVar4 + 1;
      }
      rc_sort_samples_tp(rc_ss,&local_48);
      rc_update_retry_chain(rc_ss,&local_48);
      sta_info_tab[iVar3].pol_tbl.upd_field = sta_info_tab[iVar3].pol_tbl.upd_field | 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rc_init_bcmc_rate(sta_info_tag *sta_entry,uint8_t basic_rate_idx)

{
  undefined3 in_register_0000202d;
  txl_buffer_control *ptVar1;
  uint uVar2;
  
  ptVar1 = (sta_entry->pol_tbl).buf_ctrl;
  uVar2 = 0;
  if (CONCAT31(in_register_0000202d,basic_rate_idx) < 4) {
    uVar2 = SEXT24((short)((sta_entry->pol_tbl).ppdu_tx_cfg & 0x400));
  }
  uVar2 = CONCAT31(in_register_0000202d,basic_rate_idx) | uVar2 | 0x20000000;
  *(uint *)&(ptVar1->field_0).field_0x14 = uVar2;
  *(uint *)&(ptVar1->field_0).field_0x18 = uVar2;
  *(uint *)&(ptVar1->field_0).field_0x1c = uVar2;
  *(uint *)&(ptVar1->field_0).field_0x20 = uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool rc_check_fixed_rate_config(rc_sta_stats *rc_ss,uint16_t fixed_rate_config)

{
  uint8_t uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  uint uVar3;
  uint uVar4;
  
  uVar4 = (uint)rc_ss->format_mod;
  uVar3 = (fixed_rate_config & 0x3800) >> 0xb;
  if (uVar4 < uVar3) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  if (uVar4 == 4) {
    if (uVar3 != 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return false;
    }
LAB_2300899e:
    if ((fixed_rate_config & 0x3000) == 0) {
LAB_230089f6:
      if (((CONCAT22(in_register_0000202e,fixed_rate_config) >> 10 & 1U) == 0) &&
         (rc_ss->p_type == '\x01')) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return false;
      }
      goto LAB_230089d0;
    }
  }
  else {
    if (1 < (uVar4 - 2 & 0xff)) goto LAB_2300899e;
    if ((fixed_rate_config & 0x3000) == 0) {
      if (3 < rc_ss->r_idx_min) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return false;
      }
      goto LAB_230089f6;
    }
  }
  if (((((fixed_rate_config & 0x200) != 0) && (rc_ss->short_gi == '\0')) ||
      ((uint)rc_ss->bw_max < (CONCAT22(in_register_0000202e,fixed_rate_config) >> 7 & 3U))) ||
     (uVar1 = rc_get_nss(fixed_rate_config), (uint)rc_ss->no_ss < CONCAT31(extraout_var,uVar1))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
LAB_230089d0:
  _Var2 = rc_check_valid_rate(rc_ss,fixed_rate_config);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



uint32_t rc_calc_tp(rc_sta_stats *rc_ss,uint8_t sample_idx)

{
  uint16_t rate_config;
  uint uVar1;
  uint uVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  uint32_t uVar4;
  undefined3 in_register_0000202d;
  uint8_t *puVar5;
  
  puVar5 = &rc_ss->rate_stats[CONCAT31(in_register_0000202d,sample_idx) + -1].sample_skipped;
  uVar1 = (uint)*(ushort *)(puVar5 + 8);
  if (uVar1 < 0x1999) {
    uVar4 = 0;
  }
  else {
    rate_config = *(uint16_t *)(puVar5 + 10);
    uVar2 = 0;
    _Var3 = is_cck_group(rate_config);
    if (CONCAT31(extraout_var,_Var3) == 0) {
      uVar2 = 0x35390 / *(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
    }
    uVar4 = rc_get_duration(rate_config);
    uVar4 = ((uVar1 * 1000) / (uVar4 + uVar2)) * 1000000 >> 0x10;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar4;
}



_Bool rc_update_stats(rc_sta_stats *rc_ss,_Bool init)

{
  byte bVar1;
  ushort uVar2;
  int iVar3;
  _Bool _Var4;
  uint16_t uVar5;
  uint32_t uVar6;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined2 extraout_var_04;
  undefined3 extraout_var_00;
  undefined2 extraout_var_05;
  undefined3 extraout_var_01;
  undefined2 extraout_var_06;
  undefined3 extraout_var_02;
  uint uVar7;
  undefined3 in_register_0000202d;
  rc_rate_stats *prVar8;
  uint32_t *cur_tp_00;
  uint32_t *puVar9;
  uint uVar10;
  ushort uVar11;
  uint8_t *puVar12;
  uint16_t *puVar13;
  uint16_t *puVar14;
  uint uVar15;
  char cVar16;
  uint16_t uStack148;
  ushort uStack146;
  uint16_t new_rate_cfg_array [6];
  step old_retry [4];
  uint32_t cur_tp [10];
  
  iVar3 = CONCAT31(in_register_0000202d,init);
  memcpy(new_rate_cfg_array + 4,rc_ss->retry,0x20);
  if (rc_ss->ampdu_packets != 0) {
    uVar2 = rc_ss->ampdu_len;
    *(undefined4 *)&rc_ss->ampdu_len = 0;
    rc_ss->avg_ampdu_len =
         ((int)((uint)uVar2 << 0x10) / (int)(uint)rc_ss->ampdu_packets) * 0x20 +
         rc_ss->avg_ampdu_len * 0x60 >> 7;
  }
  uVar2 = rc_ss->no_samples;
  cur_tp_00 = (uint32_t *)&old_retry[3].idx;
  rc_ss->sample_slow = '\0';
  puVar12 = &rc_ss->rate_stats[0].n_retry;
  uVar10 = 0;
  puVar9 = cur_tp_00;
  while (uVar2 != uVar10) {
    *puVar9 = 0;
    *puVar12 = '\0';
    puVar12[1] = '\x01';
    uVar10 = uVar10 + 1 & 0xffff;
    puVar9 = puVar9 + 1;
    puVar12 = puVar12 + 0xc;
  }
  uVar5 = rc_ss->fixed_rate_cfg;
  uVar15 = 0;
  if (uVar5 == 0xffff) {
    while (uVar15 < rc_ss->no_samples) {
      rc_calc_prob_ewma(rc_ss->rate_stats + uVar15);
      uVar6 = rc_calc_tp(rc_ss,(uint8_t)uVar15);
      *(uint32_t *)(&old_retry[3].idx + uVar15 * 2) = uVar6;
      uVar15 = uVar15 + 1 & 0xffff;
    }
    rc_sort_samples_tp(rc_ss,cur_tp_00);
    rc_update_retry_chain(rc_ss,cur_tp_00);
    if (iVar3 == 0) {
      uVar2 = rc_ss->no_samples;
      if (9 < uVar2) {
        cVar16 = '\0';
        uVar2 = rc_ss->rate_stats[rc_ss->retry[0].idx].rate_config;
        uVar10 = (uint)uVar2;
        uVar11 = rc_ss->rate_stats[rc_ss->retry[1].idx].rate_config;
        memset(&uStack148,-1,0xc);
        do {
          switch(cVar16) {
          case '\x01':
            if ((((int)uVar10 >> 0xb & 6U) != 0) && (rc_ss->short_gi == '\x01')) {
              if ((uVar2 & 0x200) == 0) {
                uStack146 = uVar2 | 0x200;
              }
              else {
                uStack146 = uVar2 & 0xfdff;
              }
            }
            break;
          case '\x02':
            uVar5 = rc_set_next_mcs_index(rc_ss,uVar2);
            if ((uVar10 != CONCAT22(extraout_var_03,uVar5)) &&
               (_Var4 = rc_check_valid_rate(rc_ss,uVar5), CONCAT31(extraout_var,_Var4) != 0)) {
              new_rate_cfg_array[0] = uVar5;
            }
            break;
          case '\x03':
            uVar5 = rc_set_previous_mcs_index(rc_ss,uVar2);
            if ((uVar10 != CONCAT22(extraout_var_04,uVar5)) &&
               (_Var4 = rc_check_valid_rate(rc_ss,uVar5), CONCAT31(extraout_var_00,_Var4) != 0)) {
              new_rate_cfg_array[1] = uVar5;
            }
            break;
          case '\x04':
            uVar5 = rc_set_next_mcs_index(rc_ss,uVar11);
            if (((uint)uVar11 != CONCAT22(extraout_var_05,uVar5)) &&
               (_Var4 = rc_check_valid_rate(rc_ss,uVar5), CONCAT31(extraout_var_01,_Var4) != 0)) {
              new_rate_cfg_array[2] = uVar5;
            }
            break;
          case '\x05':
            uVar5 = rc_set_previous_mcs_index(rc_ss,uVar11);
            if (((uint)uVar11 != CONCAT22(extraout_var_06,uVar5)) &&
               (_Var4 = rc_check_valid_rate(rc_ss,uVar5), CONCAT31(extraout_var_02,_Var4) != 0)) {
              new_rate_cfg_array[3] = uVar5;
            }
            break;
          default:
            uStack148 = rc_new_random_rate(rc_ss);
          }
          cVar16 = cVar16 + '\x01';
        } while (cVar16 != '\x06');
        uVar2 = rc_ss->no_samples;
        uVar15 = 1;
        uVar10 = 0;
        while (uVar15 < uVar2) {
          puVar12 = &rc_ss->rate_stats[uVar15 - 1].sample_skipped;
          if ((((*(short *)(puVar12 + 8) < 0) && (puVar12[0xc] < 0xb)) ||
              (rc_ss->retry[0].idx == uVar15)) ||
             (((rc_ss->retry[1].idx == uVar15 || (rc_ss->retry[2].idx == uVar15)) || (5 < uVar10))))
          {
            uVar15 = uVar15 + 1 & 0xffff;
          }
          else {
            uVar5 = (&uStack148)[uVar10];
            if (uVar5 != 0xffff) {
              uVar7 = 0;
              puVar14 = &rc_ss->rate_stats[0].rate_config;
              while (uVar7 < uVar2) {
                if (*puVar14 == uVar5) goto LAB_23008d8e;
                uVar7 = uVar7 + 1;
                puVar14 = puVar14 + 6;
              }
              *(uint16_t *)(puVar12 + 10) = uVar5;
              *(undefined2 *)(puVar12 + 8) = 0;
              puVar12[0xd] = '\0';
              uVar15 = uVar15 + 1 & 0xffff;
            }
LAB_23008d8e:
            uVar10 = uVar10 + 1;
          }
          *(undefined2 *)(puVar12 + 4) = 0;
          *(undefined2 *)(puVar12 + 6) = 0;
        }
        *(undefined4 *)rc_ss->rate_stats = 0;
        goto LAB_23008c54;
      }
      prVar8 = rc_ss->rate_stats;
      uVar11 = 0;
      while (uVar2 != uVar11) {
        uVar11 = uVar11 + 1;
        prVar8->attempts = 0;
        prVar8->success = 0;
        prVar8 = prVar8 + 1;
      }
    }
  }
  else {
    bVar1 = rc_ss->info;
    uVar15 = 0;
    if ((bVar1 & 0x20) != 0) {
      while (uVar15 < uVar10) {
        if (rc_ss->rate_stats[uVar15].rate_config == uVar5) goto LAB_23008de8;
        uVar15 = uVar15 + 1 & 0xff;
      }
      if (uVar10 == uVar15) {
        uVar15 = uVar15 - 1 & 0xff;
        puVar12 = &rc_ss->rate_stats[uVar15 - 1].sample_skipped;
        *(uint16_t *)(puVar12 + 10) = uVar5;
        *(undefined2 *)(puVar12 + 8) = 0;
      }
LAB_23008de8:
      uVar5 = (uint16_t)uVar15;
      rc_ss->retry[0].idx = uVar5;
      rc_ss->retry[1].idx = uVar5;
      rc_ss->retry[2].idx = uVar5;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      prVar8 = rc_ss->rate_stats;
      uVar15 = 0;
      while (uVar10 != uVar15) {
        prVar8->attempts = 0;
        prVar8->success = 0;
        uVar15 = uVar15 + 1 & 0xffff;
        prVar8 = prVar8 + 1;
      }
      rc_ss->info = bVar1 & 0x9f | 0x40;
      iVar3 = 1;
      goto LAB_23008c54;
    }
    uVar10 = (uint)*(byte *)&rc_ss->retry[0].idx;
    puVar12 = &rc_ss->rate_stats[uVar10 - 1].sample_skipped;
    rc_calc_prob_ewma(rc_ss->rate_stats + uVar10);
    *(undefined2 *)(puVar12 + 4) = 0;
    *(undefined2 *)(puVar12 + 6) = 0;
    *(undefined4 *)rc_ss->rate_stats = 0;
  }
  iVar3 = 0;
LAB_23008c54:
  puVar13 = &rc_ss->retry[0].idx;
  puVar14 = new_rate_cfg_array;
  do {
    if (puVar14[6] != *puVar13) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return true;
    }
    puVar13 = puVar13 + 4;
    puVar14 = puVar14 + 4;
  } while (puVar13 != &(rc_ss->max_tp_2_trial).idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(char)iVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_init(sta_info_tag *sta_entry)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  step *psVar4;
  uint8_t uVar5;
  uint8_t uVar6;
  _Bool _Var7;
  byte bVar8;
  uint16_t uVar9;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined2 extraout_var_07;
  int iVar10;
  short sVar11;
  uint *puVar12;
  uint *puVar13;
  uint uVar14;
  ushort *puVar15;
  uint uVar16;
  uint uVar17;
  rc_sta_stats *__s;
  txl_buffer_control *ptVar18;
  uint uVar19;
  rc_sta_stats *rc_ss;
  uint uVar20;
  uint8_t *mcs_set;
  ushort *puVar21;
  
  bVar8 = sta_entry->staid;
  ptVar18 = (sta_entry->pol_tbl).buf_ctrl;
  if (9 < bVar8) {
    assert_err("sta_entry->staid < NX_REMOTE_STA_MAX","module",0x85f);
  }
  uVar17 = (uint)sta_entry->staid;
  __s = sta_stats + uVar17;
  (sta_entry->pol_tbl).sta_stats = __s;
  uVar5 = phy_get_ntx();
  uVar19 = CONCAT31(extraout_var,uVar5) << 0xe;
  memset(__s,0,200);
  if (((sta_entry->info).capa_flags & 2) == 0) {
    uVar9 = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    sta_stats[uVar17].rate_map_l = uVar9;
    uVar5 = me_legacy_ridx_min(uVar9);
    sta_stats[uVar17].r_idx_min = uVar5;
    if (0xb < CONCAT31(extraout_var_05,uVar5)) {
      assert_err("rc_ss->r_idx_min < MAC_RATESET_LEN","module",0x8f4);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar17].rate_map_l);
    sta_stats[uVar17].r_idx_max = uVar5;
    if (0xb < CONCAT31(extraout_var_06,uVar5)) {
      assert_err("rc_ss->r_idx_max < MAC_RATESET_LEN","module",0x8f6);
    }
    sta_stats[uVar17].mcs_max = -1;
    uVar5 = (sta_entry->info).bw_cur;
    sta_stats[uVar17].bw_max = uVar5;
    if (uVar5 != '\0') {
      assert_err("rc_ss->bw_max == BW_20MHZ","module",0x8f9);
    }
    sta_stats[uVar17].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
  }
  else {
    uVar9 = me_legacy_rate_bitfield_build((mac_rateset *)&sta_entry->info,false);
    mcs_set = (sta_entry->info).ht_cap.mcs_rate;
    sta_stats[uVar17].format_mod = '\x02';
    sta_stats[uVar17].rate_map_l = uVar9;
    uVar5 = me_11n_nss_max(mcs_set);
    uVar6 = me_11n_nss_max(me_env.ht_cap.mcs_rate);
    uVar20 = CONCAT31(extraout_var_00,uVar5);
    if (CONCAT31(extraout_var_01,uVar6) < CONCAT31(extraout_var_00,uVar5)) {
      uVar20 = CONCAT31(extraout_var_01,uVar6);
    }
    sta_stats[uVar17].no_ss = (uint8_t)uVar20;
    if (3 < uVar20) {
      assert_err("rc_ss->no_ss <= 3","module",0x8a6);
    }
    memcpy(&sta_stats[uVar17].rate_map,mcs_set,4);
    uVar9 = sta_stats[uVar17].rate_map_l;
    *(undefined *)&sta_stats[uVar17].rate_map = 0xff;
    sta_stats[uVar17].mcs_max = '\a';
    uVar5 = me_legacy_ridx_min(uVar9);
    sta_stats[uVar17].r_idx_min = uVar5;
    if (0xc < CONCAT31(extraout_var_02,uVar5)) {
      assert_err("(rc_ss->r_idx_min <= HW_RATE_54MBPS) || (rc_ss->r_idx_min == MAC_RATESET_LEN)",
                 "module",0x8b8);
    }
    uVar5 = me_legacy_ridx_max(sta_stats[uVar17].rate_map_l);
    sta_stats[uVar17].r_idx_max = uVar5;
    if (0xc < CONCAT31(extraout_var_03,uVar5)) {
      assert_err("(rc_ss->r_idx_max <= HW_RATE_54MBPS) || (rc_ss->r_idx_max == MAC_RATESET_LEN)",
                 "module",0x8be);
    }
    sta_stats[uVar17].p_type = (byte)((int)(uint)(sta_entry->pol_tbl).ppdu_tx_cfg >> 10) & 1;
    _Var7 = phy_ldpc_tx_supported();
    uVar2 = (sta_entry->info).ht_cap.ht_capa_info;
    if ((CONCAT31(extraout_var_04,_Var7) != 0) && ((uVar2 & 1) != 0)) {
      uVar19 = uVar19 | 0x40;
    }
    if ((int)((uint)uVar2 << 0x14) < 0) {
      sVar11 = 0x2000;
    }
    else {
      sVar11 = 0x1000;
    }
    sta_stats[uVar17].max_amsdu_len = sVar11 - 0x101;
    bVar1 = (sta_entry->info).bw_cur;
    sta_stats[uVar17].bw_max = bVar1;
    if (3 < bVar1) {
      assert_err("rc_ss->bw_max <= BW_160MHZ","module",0x8d5);
    }
    uVar5 = (sta_entry->info).bw_cur;
    if (uVar5 == '\0') {
      if (((sta_entry->info).ht_cap.ht_capa_info & 0x20) != 0) {
        uVar5 = '\x01';
        goto LAB_2300909a;
      }
    }
    else {
      if ((uVar5 == '\x01') && (((sta_entry->info).ht_cap.ht_capa_info & 0x40) != 0)) {
LAB_2300909a:
        sta_stats[uVar17].short_gi = uVar5;
      }
    }
  }
  if (sta_stats[uVar17].format_mod < 2) {
    uVar20 = (uint)sta_stats[uVar17].rate_map_l;
    uVar16 = 1 - sta_stats[uVar17].p_type;
    uVar14 = (((int)uVar20 >> 1 & 1U) + ((int)uVar20 >> 2 & 1U) << (uVar16 & 0x1f)) + (uVar20 & 1) +
             (((int)uVar20 >> 3 & 1U) << (uVar16 & 0x1f)) & 0xffff;
    uVar16 = 4;
    do {
      uVar3 = uVar16 & 0x1f;
      uVar16 = uVar16 + 1;
      uVar14 = uVar14 + ((int)uVar20 >> uVar3 & 1U) & 0xffff;
    } while (uVar16 != 0xc);
LAB_230091b4:
    if (10 < uVar14) {
      sta_stats[uVar17].no_samples = 10;
      goto LAB_230091c8;
    }
    sta_stats[uVar17].no_samples = (uint16_t)uVar14;
    if (uVar14 != 0) goto LAB_230091c8;
  }
  else {
    if (sta_stats[uVar17].format_mod < 4) {
      uVar20 = (uint)*(byte *)&sta_stats[uVar17].rate_map;
      iVar10 = 8;
      uVar16 = 0;
      do {
        uVar14 = uVar20 & 1;
        iVar10 = iVar10 + -1;
        uVar20 = uVar20 >> 1;
        uVar16 = uVar16 + (1 << (sta_stats[uVar17].short_gi & 0x1f)) * uVar14 & 0xffff;
      } while (iVar10 != 0);
      uVar14 = (uint)sta_stats[uVar17].rate_map_l;
      uVar20 = 1 - sta_stats[uVar17].p_type;
      uVar14 = uVar16 + (((int)uVar14 >> 1 & 1U) + ((int)uVar14 >> 2 & 1U) << (uVar20 & 0x1f)) +
                        (uVar14 & 1) + (((int)uVar14 >> 3 & 1U) << (uVar20 & 0x1f)) & 0xffff;
      goto LAB_230091b4;
    }
    sta_stats[uVar17].no_samples = 0;
  }
  assert_err("rc_ss->no_samples >= 1","module",0x8ff);
  if (10 < sta_stats[uVar17].no_samples) {
    assert_err("rc_ss->no_samples <= RC_MAX_N_SAMPLE","module",0x900);
  }
LAB_230091c8:
  rc_ss = sta_info_tab[sta_entry->staid].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x6e4);
  }
  uVar2 = rc_ss->no_samples;
  puVar21 = &rc_ss->rate_stats[0].rate_config;
  uVar20 = 0;
  puVar15 = puVar21;
  while (uVar20 != uVar2) {
    *puVar15 = 0xffff;
    uVar20 = uVar20 + 1 & 0xffff;
    puVar15 = puVar15 + 6;
  }
  uVar9 = rc_get_lowest_rate_config(rc_ss);
  rc_ss->rate_stats[0].rate_config = uVar9;
  uVar9 = rc_get_initial_rate_config(rc_ss);
  rc_ss->rate_stats[uVar20 - 1].rate_config = uVar9;
  uVar20 = 1;
LAB_23009232:
  do {
    uVar2 = rc_ss->no_samples;
    if ((int)(uVar2 - 1) <= (int)uVar20) {
      rc_ss->retry[0].idx = (uint16_t)(uVar2 - 1);
      rc_ss->retry[2].idx = uVar2 - 3;
      rc_ss->avg_ampdu_len = 0x10000;
      rc_ss->retry[1].idx = uVar2 - 2;
      rc_ss->fixed_rate_cfg = 0xffff;
      rc_ss->retry[0].tp = 0;
      rc_ss->retry[1].tp = 0;
      rc_ss->retry[2].tp = 0;
      rc_ss->retry[3].idx = 0;
      rc_ss->retry[3].tp = 0;
      rc_ss->info = '\0';
      rc_update_stats(rc_ss,true);
      rc_ss->sample_wait = '\x05';
      puVar12 = (uint *)&(ptVar18->field_0).field_0x14;
      do {
        psVar4 = __s->retry;
        puVar13 = puVar12 + 1;
        __s = (rc_sta_stats *)&__s->rate_stats[0].probability;
        *puVar12 = sta_stats[uVar17].rate_stats[*(byte *)&psVar4->idx].rate_config | 0x80000000;
        puVar12 = puVar13;
      } while (puVar13 != (uint *)&(ptVar18->field_0).field_0x24);
      sta_stats[uVar17].last_rc_time = _DAT_44b00120;
      *(undefined4 *)&ptVar18->field_0 = 0xbadcab1e;
      *(uint *)&(ptVar18->field_0).field_0xc = (uint)(byte)(bVar8 + 8) << 10;
      *(undefined4 *)&(ptVar18->field_0).field_0x10 = 0xffff0704;
      *(uint *)&(ptVar18->field_0).field_0x4 = uVar19;
      bVar8 = phy_get_ntx();
      *(int *)&(ptVar18->field_0).field_0x8 = (1 << (bVar8 + 1 & 0x1f)) + -1;
      ((sta_entry->pol_tbl).buf_ctrl)->mac_control_info = 0x2200;
      ((sta_entry->pol_tbl).buf_ctrl)->phy_control_info = sta_entry->paid_gid;
      (sta_entry->pol_tbl).upd_field = (sta_entry->pol_tbl).upd_field | 0x11;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar9 = rc_new_random_rate(rc_ss);
    uVar16 = 0;
    puVar15 = puVar21;
    while (uVar16 < rc_ss->no_samples) {
      if ((uint)*puVar15 == CONCAT22(extraout_var_07,uVar9)) goto LAB_23009232;
      uVar16 = uVar16 + 1;
      puVar15 = puVar15 + 6;
    }
    rc_ss->rate_stats[uVar20].rate_config = uVar9;
    uVar20 = uVar20 + 1 & 0xffff;
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rc_check(uint8_t sta_idx,_Bool *tx_ampdu)

{
  ushort uVar1;
  ushort uVar2;
  uint16_t uVar3;
  uint16_t rate_config;
  bool bVar4;
  rc_sta_stats *rc_ss;
  uint uVar5;
  _Bool _Var6;
  uint8_t uVar7;
  uint8_t uVar8;
  undefined3 in_register_00002029;
  uint uVar9;
  undefined3 extraout_var;
  uint32_t uVar10;
  uint32_t uVar11;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  byte bVar12;
  uint8_t *puVar13;
  uint uVar14;
  int iVar15;
  ushort uVar16;
  uint uVar17;
  
  uVar9 = CONCAT31(in_register_00002029,sta_idx);
  if (9 < uVar9) {
    return;
  }
  rc_ss = sta_info_tab[uVar9].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x826);
  }
  iVar15 = 0;
  if ((int)((100000 - _DAT_44b00120) + rc_ss->last_rc_time) < 0) {
    _Var6 = rc_update_stats(rc_ss,false);
    iVar15 = CONCAT31(extraout_var,_Var6);
    rc_ss->trial_status = '\0';
    rc_ss->sw_retry_step = '\0';
    rc_ss->info = rc_ss->info & 0xef;
    rc_ss->last_rc_time = _DAT_44b00120;
  }
  if (rc_ss->trial_status == '\x01') {
    if ((rc_ss->info & 0x40) == 0) {
      bVar12 = rc_ss->format_mod;
      uVar1 = rc_ss->retry[0].idx;
      uVar14 = (uint)uVar1;
      if (bVar12 < 2) {
        if ((ushort)(rc_ss->rate_stats[uVar14].probability + 0xe667) < 0xd99b) {
          uVar7 = '\n';
        }
        else {
          uVar7 = '\x05';
        }
      }
      else {
        uVar7 = ((char)*(undefined2 *)((int)&rc_ss->avg_ampdu_len + 2) + '\b') * '\x02';
      }
      rc_ss->sample_wait = uVar7;
      next = next * 0x41c64e6d + 0x3039;
      uVar5 = (next >> 0x10) % (uint)rc_ss->no_samples;
      if (uVar5 != uVar14) {
        uVar2 = rc_ss->retry[1].idx;
        if (((uVar5 != uVar2) && (uVar17 = (uint)rc_ss->retry[2].idx, uVar5 != uVar17)) &&
           (puVar13 = &rc_ss->rate_stats[uVar5 - 1].sample_skipped,
           *(ushort *)(puVar13 + 8) < 0xf334)) {
          uVar3 = *(uint16_t *)(puVar13 + 10);
          uVar10 = rc_get_duration(uVar3);
          rate_config = rc_ss->rate_stats[uVar14].rate_config;
          if (bVar12 < 2) {
            uVar11 = rc_get_duration(rate_config);
            if (uVar11 < uVar10) {
              uVar10 = 0;
              bVar4 = 0x13 < puVar13[0xc];
            }
            else {
              uVar10 = 0;
              bVar4 = true;
            }
          }
          else {
            uVar16 = 0x20;
            uVar11 = rc_get_duration(rc_ss->rate_stats[uVar2].rate_config);
            if (puVar13[0xd] == '\0') {
              uVar16 = *(ushort *)((int)&rc_ss->avg_ampdu_len + 2);
            }
            if (uVar11 <= uVar10) {
              uVar7 = rc_get_nss(rate_config);
              uVar8 = rc_get_nss(uVar3);
              if ((CONCAT31(extraout_var_00,uVar7) - 1U < CONCAT31(extraout_var_01,uVar8)) ||
                 (uVar11 = rc_get_duration(rc_ss->rate_stats[uVar17].rate_config), uVar11 <= uVar10)
                 ) {
                if (uVar16 <= puVar13[0xc]) {
                  bVar12 = rc_ss->sample_slow + 1;
                  rc_ss->sample_slow = bVar12;
                  if (bVar12 < 3) goto LAB_2300964c;
                  if (0xf < bVar12) {
                    rc_ss->sample_slow = '\x0f';
                  }
                }
                goto LAB_23009626;
              }
            }
LAB_2300964c:
            uVar10 = rc_calc_tp(rc_ss,(uint8_t)uVar5);
            bVar4 = true;
            if ((puVar13[0xe] & 0xf) < 10) {
              bVar4 = uVar16 <= puVar13[0xc];
            }
          }
          uVar11 = rc_ss->retry[1].tp;
          (rc_ss->max_tp_2_trial).idx = uVar2;
          (rc_ss->max_tp_2_trial).tp = uVar11;
          if (bVar4) {
            uVar11 = rc_ss->retry[0].tp;
            rc_ss->info = rc_ss->info & 0xfd;
            rc_ss->retry[1].tp = uVar11;
            rc_ss->retry[1].idx = uVar1;
            rc_ss->retry[0].tp = uVar10;
            rc_ss->retry[0].idx = (uint16_t)uVar5;
          }
          else {
            rc_ss->info = rc_ss->info | 2;
            rc_ss->retry[1].tp = uVar10;
            rc_ss->retry[1].idx = (uint16_t)uVar5;
          }
          rc_ss->trial_status = '\x02';
          goto LAB_2300958c;
        }
      }
    }
LAB_23009626:
    rc_ss->trial_status = '\0';
  }
  else {
    if (rc_ss->trial_status == '\x03') {
      if ((rc_ss->info & 2) == 0) {
        rc_ss->retry[0].idx = rc_ss->retry[1].idx;
        rc_ss->retry[0].tp = rc_ss->retry[1].tp;
      }
      uVar3 = (rc_ss->max_tp_2_trial).idx;
      rc_ss->trial_status = '\0';
      rc_ss->retry[1].idx = uVar3;
      uVar10 = (rc_ss->max_tp_2_trial).tp;
      (rc_ss->max_tp_2_trial).tp = 0;
      rc_ss->retry[1].tp = uVar10;
      (rc_ss->max_tp_2_trial).idx = 0xff;
      goto LAB_2300958c;
    }
  }
  if (iVar15 == 0) {
    return;
  }
LAB_2300958c:
  sta_info_tab[uVar9].pol_tbl.upd_field = sta_info_tab[uVar9].pol_tbl.upd_field | 1;
  return;
}



uint8_t rxu_cntrl_machdr_len_get(uint16_t frame_cntl)

{
  uint8_t uVar1;
  
  uVar1 = '\x18';
  if ((frame_cntl & 0x300) == 0x300) {
    uVar1 = '\x1e';
  }
  if ((frame_cntl & 0xfc) == 0x88) {
    uVar1 = uVar1 + '\x02';
  }
  if ((short)frame_cntl < 0) {
    uVar1 = uVar1 + '\x04';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



_Bool rxu_cntrl_protected_handle(uint8_t *frame,uint32_t statinfo)

{
  ushort *puVar1;
  uint uVar2;
  vif_info_tag *pvVar3;
  int iVar4;
  
  uVar2 = statinfo & 0x1c;
  puVar1 = (ushort *)(frame + DAT_4201b9d0);
  if (uVar2 == 0x18) {
    DAT_4201b9d0 = DAT_4201b9d0 + 8;
    DAT_4201b9dc = (uint)puVar1[3];
    DAT_4201b9d8 = (uint)puVar1[2] << 0x10 | (uint)*(byte *)(puVar1 + 1) | (*puVar1 & 0xff) << 8;
    DAT_4201b9f8 = DAT_4201b9f8 | 3;
    if ((statinfo & 0x400) == 0) {
      iVar4 = (uint)DAT_4201b9d1 * 0x1b0 + 0x40;
      pvVar3 = (vif_info_tag *)sta_info_tab;
    }
    else {
      iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201b9d2 * 0x5d8 + 0x420;
      pvVar3 = vif_info_tab;
    }
    rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key =
         (key_info_tag *)((int)pvVar3->txq_params + iVar4 + -8);
  }
  else {
    if (uVar2 == 0x1c) {
      if ((statinfo & 0x400) == 0) {
        iVar4 = (uint)DAT_4201b9d1 * 0x1b0 + 0x40;
        pvVar3 = (vif_info_tag *)sta_info_tab;
      }
      else {
        iVar4 = (uint)(puVar1[1] >> 0xe) * 0x68 + (uint)DAT_4201b9d2 * 0x5d8 + 0x420;
        pvVar3 = vif_info_tab;
      }
      rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key =
           (key_info_tag *)((int)pvVar3->txq_params + iVar4 + -8);
      DAT_4201b9d0 = DAT_4201b9d0 + 8;
      DAT_4201b9dc = (uint)puVar1[3];
      DAT_4201b9d8 = CONCAT22(puVar1[2],*puVar1);
      DAT_4201b9f8 = DAT_4201b9f8 | 2;
    }
    else {
      if (uVar2 != 0x14) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return false;
      }
      DAT_4201b9d0 = DAT_4201b9d0 + 4;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return true;
}



void rxu_mpdu_upload_and_indicate(rx_swdesc *p_rx_swdesc)

{
  byte bVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined2 *puVar3;
  undefined2 *puVar4;
  undefined2 *puVar5;
  uint uVar6;
  uint uVar7;
  uint32_t uVar8;
  
  DAT_4201b9fa = 0;
  p_rx_swdesc->dma_hdrdesc->flags =
       (uint)DAT_4201b9d1 << 0x10 | (uint)DAT_4201b9d2 << 8 | p_rx_swdesc->dma_hdrdesc->flags | 2;
  uVar8 = (p_rx_swdesc->dma_hdrdesc->hd).first_pbd_ptr;
  uVar2 = rxu_cntrl_machdr_len_get(**(uint16_t **)(uVar8 + 0x18));
  bVar1 = DAT_4201b9d0;
  uVar6 = (uint)DAT_4201b9d0 - CONCAT31(extraout_var,uVar2);
  uVar7 = uVar6 & 0xff;
  if (uVar7 != 0) {
    if ((uVar6 & 1) != 0) {
      assert_warn("(payl_offset & 0x1) == 0","module",0x167);
    }
    puVar3 = *(undefined2 **)(uVar8 + 0x18);
    puVar4 = puVar3 + (DAT_4201b9d0 >> 1) + 0x7fffffff;
    puVar5 = puVar3 + (CONCAT31(extraout_var,uVar2) >> 1 & 0xff) + 0x7fffffff;
    while (puVar3 <= puVar5) {
      *puVar4 = *puVar5;
      puVar4 = puVar4 + -1;
      puVar5 = puVar5 + -1;
    }
    (p_rx_swdesc->dma_hdrdesc->hd).frmlen = (p_rx_swdesc->dma_hdrdesc->hd).frmlen - (short)uVar7;
    DAT_4201b9fa = (undefined)uVar7;
    DAT_4201b9d0 = uVar2 + (DAT_4201b9d0 - bVar1);
  }
  mac_payload_offset = 0;
  rxl_mpdu_transfer(p_rx_swdesc);
  uVar8 = DAT_4201ba10;
  p_rx_swdesc->status = '\x03';
  p_rx_swdesc->host_id = uVar8;
  p_rx_swdesc->frame_len = (uint)(p_rx_swdesc->dma_hdrdesc->hd).frmlen;
  co_list_push_back((co_list *)&rxu_cntrl_desc_transfer::swdesc,(co_list_hdr *)p_rx_swdesc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool rxu_mgt_frame_check(rx_swdesc *swdesc,uint8_t sta_idx)

{
  char cVar1;
  ushort uVar2;
  bool bVar3;
  ushort uVar4;
  int8_t iVar5;
  ushort *bcn_addr;
  ushort uVar6;
  _Bool _Var7;
  ke_state_t kVar8;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 extraout_var_00;
  undefined2 *puVar9;
  byte bVar10;
  undefined3 in_register_0000202d;
  uint uVar11;
  uint8_t uVar12;
  co_list_hdr cVar13;
  char *pcVar14;
  uint uVar15;
  uint uVar16;
  ke_task_id_t dest_id;
  rx_dmadesc *prVar17;
  uint uVar18;
  vif_info_tag *vif;
  int8_t iStack73;
  undefined auStack72 [3];
  int8_t ppm;
  phy_channel_info info;
  
  uVar11 = CONCAT31(in_register_0000202d,sta_idx);
  prVar17 = swdesc->dma_hdrdesc;
  iStack73 = '\0';
  bcn_addr = *(ushort **)((prVar17->hd).first_pbd_ptr + 0x18);
  uVar2 = *bcn_addr;
  if ((uVar2 & 0x400) == 0) {
    _Var7 = true;
    if ((*(byte *)(bcn_addr + 0xb) & 0xf) != 0) goto LAB_23009c9a;
    if (uVar11 == 0xff) {
      uVar15 = 0xff;
      if (((prVar17->hd).statinfo & 0x600) == 0) {
        cVar13 = (co_list_hdr)vif_mgmt_env.used_list.first;
        if (((((uVar2 == 0xb0) || (bVar3 = true, uVar2 == 0)) &&
             (bVar3 = true, *(char *)(bcn_addr + 2) == *(char *)(bcn_addr + 8))) &&
            ((*(char *)((int)bcn_addr + 5) == *(char *)((int)bcn_addr + 0x11) &&
             (*(char *)(bcn_addr + 3) == *(char *)(bcn_addr + 9))))) &&
           ((*(char *)((int)bcn_addr + 7) == *(char *)((int)bcn_addr + 0x13) &&
            (*(char *)(bcn_addr + 4) == *(char *)(bcn_addr + 10))))) {
          bVar3 = *(char *)((int)bcn_addr + 9) != *(char *)((int)bcn_addr + 0x15);
        }
        while (uVar15 = uVar11, cVar13 != (co_list_hdr)0x0) {
          if (((*(char *)&((co_list_hdr *)((int)cVar13 + 0x50))->next == *(char *)(bcn_addr + 2)) &&
              (*(char *)((int)cVar13 + 0x51) == *(char *)((int)bcn_addr + 5))) &&
             ((*(char *)((int)cVar13 + 0x52) == *(char *)(bcn_addr + 3) &&
              (((*(char *)((int)cVar13 + 0x53) == *(char *)((int)bcn_addr + 7) &&
                (*(char *)&((co_list_hdr *)((int)cVar13 + 0x54))->next == *(char *)(bcn_addr + 4)))
               && (*(char *)((int)cVar13 + 0x55) == *(char *)((int)bcn_addr + 9))))))) {
            if (*(char *)((int)cVar13 + 0x56) == '\0') {
              if (bVar3) {
LAB_23009a66:
                uVar15 = (uint)*(byte *)((int)cVar13 + 0x57);
                break;
              }
            }
            else {
              if ((*(char *)((int)cVar13 + 0x56) == '\x02') && (!bVar3)) goto LAB_23009a66;
            }
          }
          cVar13 = *(co_list_hdr *)cVar13;
        }
      }
      DAT_4201b9d2 = (byte)uVar15;
    }
    phyif_utils_decode((phyif_utils_recvtable_t *)&(prVar17->hd).recvec1a,&iStack73);
    iVar5 = iStack73;
    bVar10 = DAT_4201b9d0;
    uVar4 = *bcn_addr;
    uVar18 = (uint)DAT_4201b9d0;
    uVar15 = (uint)DAT_4201b9d2;
    uVar2 = (prVar17->hd).frmlen;
    uVar16 = (uint)uVar2;
    if (uVar15 == 0xff) {
      if (uVar11 != 0xff) {
        DAT_4201b9d2 = sta_info_tab[uVar11].inst_nbr;
        uVar15 = (uint)DAT_4201b9d2;
        goto LAB_23009ab4;
      }
      uVar12 = '\x04';
      vif = (vif_info_tag *)0x0;
    }
    else {
LAB_23009ab4:
      vif = vif_info_tab + uVar15;
      uVar12 = vif_info_tab[uVar15].type;
    }
    uVar6 = uVar4 & 0xfc;
    if (uVar6 == 0x50) {
      if (vif == (vif_info_tag *)0x0) goto LAB_23009af0;
      bVar3 = true;
      dest_id = 4;
LAB_23009c10:
      puVar9 = (undefined2 *)
               ke_msg_alloc(0x2c00,dest_id,0xb,(uint16_t)((uVar16 + 0x1c) * 0x10000 >> 0x10));
      if (puVar9 != (undefined2 *)0x0) {
        phy_get_channel((phy_channel_info *)auStack72,'\0');
        if (!bVar3) {
          if ((bVar10 & 1) != 0) {
            assert_warn("(machdr_length & 0x1) == 0","module",0x64d);
          }
          uVar16 = uVar16 - uVar18 & 0xffff;
          bcn_addr = (ushort *)((int)bcn_addr + uVar18);
        }
        *puVar9 = (short)uVar16;
        uVar11 = 0;
        while (bVar10 = DAT_4201b9d2, (uVar16 + 3 & 0xfffffffc) != uVar11) {
          *(undefined4 *)((int)puVar9 + uVar11 + 0x1c) = *(undefined4 *)((int)bcn_addr + uVar11);
          uVar11 = uVar11 + 4;
        }
        puVar9[1] = uVar4;
        *(uint8_t *)((int)puVar9 + 7) = sta_idx;
        *(byte *)(puVar9 + 4) = bVar10;
        *(int8_t *)(puVar9 + 0xd) = iVar5;
        *(int8_t *)((int)puVar9 + 0x19) = iVar5;
        puVar9[2] = (short)(_auStack72 >> 0x10);
        *(char *)(puVar9 + 3) = (char)_auStack72;
        *(undefined *)(puVar9 + 0xc) = *(undefined *)((int)&(prVar17->hd).recvec1c + 3);
        if ((dest_id == 7) && ((uVar4 & 0xfc) == 0)) {
          *(uint32_t *)(puVar9 + 8) = (prVar17->hd).tsflo;
          *(uint32_t *)(puVar9 + 10) = (prVar17->hd).tsfhi;
          *(byte *)((int)puVar9 + 0x1b) = (byte)((prVar17->hd).recvec1a >> 0xc) & 0xf;
        }
        ke_msg_send(puVar9);
      }
      _Var7 = false;
      goto LAB_23009c9a;
    }
    if (uVar6 < 0x51) {
      if (uVar6 == 0x20) {
LAB_23009b3e:
        _Var7 = apm_embedded_enabled(vif);
        if (CONCAT31(extraout_var,_Var7) != 0) {
LAB_23009c0c:
          bVar3 = true;
          dest_id = 7;
          goto LAB_23009c10;
        }
      }
      else {
        if (uVar6 < 0x21) {
          if ((uVar4 & 0xfc) == 0) goto LAB_23009b3e;
          if (uVar6 != 0x10) goto LAB_23009af0;
        }
        else {
          if (uVar6 != 0x30) {
            if (uVar6 != 0x40) goto LAB_23009af0;
            goto LAB_23009b3e;
          }
        }
        if (uVar12 == '\0') goto LAB_23009bac;
      }
    }
    else {
      if (uVar6 == 0xb0) {
LAB_23009b6e:
        if (uVar12 != '\0') goto LAB_23009b3e;
LAB_23009bac:
        bVar3 = false;
        dest_id = 6;
        goto LAB_23009c10;
      }
      if (uVar6 < 0xb1) {
        if (uVar6 != 0x80) {
          if (uVar6 != 0xa0) goto LAB_23009af0;
LAB_23009b64:
          _Var7 = false;
          if (uVar11 == 0xff) goto LAB_23009c9a;
          goto LAB_23009b6e;
        }
        kVar8 = ke_state_get(4);
        bVar3 = CONCAT22(extraout_var_01,kVar8) != 1;
        if (bVar3) {
          dest_id = 0xff;
        }
        else {
          dest_id = 4;
        }
        bVar3 = !bVar3;
        if (uVar11 == 0xff) {
          kVar8 = ke_state_get(4);
          if ((CONCAT22(extraout_var_02,kVar8) != 1) &&
             (_Var7 = apm_embedded_enabled(vif), CONCAT31(extraout_var_00,_Var7) != 0))
          goto LAB_23009c0c;
        }
        else {
          if (vif->active != false) {
            me_beacon_check(DAT_4201b9d2,uVar2,(uint32_t)bcn_addr);
          }
        }
        if (dest_id != 0xff) goto LAB_23009c10;
      }
      else {
        if (uVar6 == 0xc0) goto LAB_23009b64;
        if ((uVar6 == 0xd0) && (pcVar14 = (char *)((int)bcn_addr + uVar18), uVar11 != 0xff)) {
          cVar1 = *pcVar14;
          if (cVar1 == '\a') {
            if (pcVar14[1] == '\0') {
              _Var7 = false;
              if ((sta_info_tab[uVar11].info.capa_flags & 2) == 0) goto LAB_23009c9a;
              bVar10 = pcVar14[2];
              uVar12 = -1;
              if (1 < bVar10) goto LAB_23009c9a;
            }
            else {
              if (pcVar14[1] != '\x01') goto LAB_23009af0;
              _Var7 = false;
              if ((sta_info_tab[uVar11].info.capa_flags & 2) == 0) goto LAB_23009c9a;
              uVar12 = -1;
              if ((pcVar14[2] & 1U) != 0) {
                uVar12 = '\0';
              }
              bVar10 = 0xff;
            }
            _Var7 = false;
            me_sta_bw_nss_max_upd(sta_idx,bVar10,uVar12);
            goto LAB_23009c9a;
          }
          if (cVar1 == '\b') {
            _Var7 = false;
            if ((int)(uVar16 - uVar18) < 4) goto LAB_23009c9a;
            if ((DAT_4201b9d2 != 0xff) &&
               ((byte)(vif_info_tab[DAT_4201b9d2].type | pcVar14[1]) == 0)) {
              dest_id = 6;
              goto LAB_23009ba6;
            }
          }
          else {
            if (cVar1 == '\x03') {
              dest_id = 8;
LAB_23009ba6:
              bVar3 = false;
              goto LAB_23009c10;
            }
          }
        }
      }
    }
LAB_23009af0:
    rxu_mpdu_upload_and_indicate(swdesc);
  }
  _Var7 = true;
LAB_23009c9a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var7;
}



void rxu_cntrl_init(void)

{
  co_list_init((co_list *)&rxu_cntrl_desc_transfer::swdesc);
  co_list_init((co_list *)&DAT_4201ba00);
  co_list_init((co_list *)&DAT_4201ba14);
  co_list_init((co_list *)&DAT_4201ba1c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  DAT_4201ba2a = 0xffff;
  return;
}



// WARNING: Variable defined which should be unmapped: mic
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool rxu_cntrl_frame_handle(rx_swdesc *swdesc)

{
  ushort uVar1;
  key_info_tag *pkVar2;
  ushort *puVar3;
  char cVar4;
  _Bool _Var5;
  vif_info_tag *vif;
  int iVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  byte bVar7;
  undefined *puVar8;
  uint32_t *puVar9;
  uint uVar10;
  uint64_t *puVar11;
  cm_ConnectionInfo_t *pcVar12;
  undefined *puVar13;
  uint uVar14;
  rx_dmadesc *prVar15;
  byte bVar16;
  uint uVar17;
  uint32_t uVar18;
  uint uVar19;
  void *pvVar20;
  uint32_t local_50;
  uint32_t rx_mic [2];
  rxu_mic_calc mic;
  
  prVar15 = swdesc->dma_hdrdesc;
  uVar14 = (prVar15->hd).statinfo;
  if ((int)(uVar14 << 0x12) < 0) {
    puVar3 = *(ushort **)((prVar15->hd).first_pbd_ptr + 8);
    uVar1 = *puVar3;
    uVar19 = (uint)uVar1;
    prVar15->flags = 0;
    DAT_4201b9d1 = 0xff;
    DAT_4201b9d2 = 0xff;
    rxu_cntrl_env = *puVar3;
    DAT_4201b9ca = puVar3[0xb];
    DAT_4201b9f8 = 0;
    DAT_4201b9cc = puVar3[0xb] >> 4;
    DAT_4201b9ce = (byte)puVar3[0xb] & 0xf;
    if ((*puVar3 & 0x88) == 0x88) {
      if ((*puVar3 & 0x300) == 0x300) {
        bVar16 = (byte)puVar3[0xf];
      }
      else {
        bVar16 = (byte)puVar3[0xc];
      }
      DAT_4201b9cf = bVar16 & 7;
    }
    else {
      DAT_4201b9cf = 0;
    }
    DAT_4201b9d0 = rxu_cntrl_machdr_len_get(*puVar3);
    if ((*(byte *)((int)puVar3 + 1) & 1) == 0) {
      DAT_4201b9ec = puVar3[2];
      DAT_4201b9ee = puVar3[3];
      DAT_4201b9f0 = puVar3[4];
    }
    else {
      DAT_4201b9ec = puVar3[8];
      DAT_4201b9ee = puVar3[9];
      DAT_4201b9f0 = puVar3[10];
    }
    if ((*puVar3 & 0x200) == 0) {
      DAT_4201b9f2 = puVar3[5];
      DAT_4201b9f4 = puVar3[6];
      DAT_4201b9f6 = puVar3[7];
    }
    else {
      if ((*puVar3 & 0x100) == 0) {
        DAT_4201b9f2 = puVar3[8];
        DAT_4201b9f4 = puVar3[9];
        DAT_4201b9f6 = puVar3[10];
      }
      else {
        DAT_4201b9f2 = puVar3[0xc];
        DAT_4201b9f4 = puVar3[0xd];
        DAT_4201b9f6 = puVar3[0xe];
      }
    }
    if ((int)(uVar14 << 6) < 0) {
      uVar17 = (uVar14 >> 0xf) - 8 & 0xff;
      cVar4 = sta_info_tab[uVar17].valid;
      if ((_Bool)cVar4 != false) {
        DAT_4201b9d2 = sta_info_tab[uVar17].inst_nbr;
        bVar16 = (byte)uVar17;
        DAT_4201b9d1 = bVar16;
        DAT_4201b9e0 = uVar14;
        if ((vif_info_tab[DAT_4201b9d2].type == '\x02') && ((DAT_4201b9ec & 1) == 0)) {
          DAT_4201b9d3 = hal_machw_search_addr((mac_addr *)&DAT_4201b9ec);
        }
        if ((uVar19 & 0x300) == 0x300) {
          prVar15->flags = prVar15->flags | 4;
        }
        if ((-1 < (int)((uint)rxu_cntrl_env << 0x11)) ||
           (_Var5 = rxu_cntrl_protected_handle((uint8_t *)puVar3,DAT_4201b9e0),
           CONCAT31(extraout_var_00,_Var5) != 0)) {
          uVar14 = uVar19 & 0xc;
          if ((uVar1 & 0xc) == 0) {
            if ((-1 < (int)(uVar19 << 0x14)) ||
               (sta_info_tab[uVar17].rx_nqos_last_seqcntl != DAT_4201b9ca)) {
              bVar16 = DAT_4201b9f8 & 2;
              sta_info_tab[uVar17].rx_nqos_last_seqcntl = DAT_4201b9ca;
              pkVar2 = rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key;
              uVar14 = DAT_4201b9dc;
              bVar7 = DAT_4201b9d1;
              if (bVar16 != 0) {
                uVar19 = *(uint *)((int)rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->rx_pn
                                  + 0x44);
                if ((DAT_4201b9dc <= uVar19) &&
                   ((uVar19 != DAT_4201b9dc ||
                    (DAT_4201b9d8 <=
                     *(uint *)(rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->rx_pn + 8)))))
                goto LAB_23009e1c;
                *(uint *)(rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->rx_pn + 8) =
                     DAT_4201b9d8;
                *(uint *)((int)pkVar2->rx_pn + 0x44) = uVar14;
                bVar7 = DAT_4201b9d1;
              }
LAB_2300a0ba:
              cVar4 = rxu_mgt_frame_check(swdesc,bVar7);
              goto LAB_2300a056;
            }
          }
          else {
            if (uVar14 == 8) {
              if ((uVar1 & 0x40) == 0) {
                if ((uVar1 & 0x80) == 0) {
                  iVar6 = uVar17 * 0x1b0 + 0x188;
                }
                else {
                  iVar6 = (DAT_4201b9cf + 0xc5 + uVar17 * 0xd8) * 2;
                }
                puVar3 = (ushort *)((int)&sta_info_tab[0].list_hdr.next + iVar6);
                if ((-1 < (int)(uVar19 << 0x14)) || (*puVar3 != DAT_4201b9ca)) {
                  *puVar3 = DAT_4201b9ca;
                  uVar19 = DAT_4201b9dc;
                  uVar10 = (uint)DAT_4201b9d2;
                  if ((DAT_4201b9f8 & 2) != 0) {
                    puVar11 = rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->rx_pn +
                              DAT_4201b9cf;
                    if ((DAT_4201b9dc <= *(uint *)((int)puVar11 + 4)) &&
                       ((*(uint *)((int)puVar11 + 4) != DAT_4201b9dc ||
                        (DAT_4201b9d8 <= *(uint *)puVar11)))) goto LAB_23009e1c;
                    *(uint *)puVar11 = DAT_4201b9d8;
                    *(uint *)((int)puVar11 + 4) = uVar19;
                  }
                  if ((vif_info_tab[uVar10].bss_info.is_supplicant_enabled != false) ||
                     (uap_conn_info != (cm_ConnectionInfo_t *)0x0)) {
                    pvVar20 = (void *)((uint)DAT_4201b9d0 +
                                      *(int *)((swdesc->dma_hdrdesc->hd).first_pbd_ptr + 8));
                    iVar6 = memcmp(pvVar20,&rxu_cntrl_rfc1042_hdr,6);
                    if ((iVar6 == 0) && (*(short *)((int)pvVar20 + 6) == -0x7178)) {
                      if (vif_info_tab[sta_info_tab[uVar17].inst_nbr].type == '\0') {
                        pcVar12 = &sta_conn_info;
                        bVar7 = sta_info_tab[uVar17].inst_nbr;
                        if (((sta_conn_info.suppData)->hashSsId).Len == '\0') goto LAB_23009e1c;
                      }
                      else {
                        uap_conn_info->staId = bVar16;
                        uap_conn_info->instNbr = sta_info_tab[uVar17].inst_nbr;
                        pcVar12 = uap_conn_info;
                        bVar16 = sta_conn_info.staId;
                        bVar7 = sta_conn_info.instNbr;
                      }
                      sta_conn_info.instNbr = bVar7;
                      sta_conn_info.staId = bVar16;
                      rx_mic[1] = (uint32_t)pcVar12;
                      ProcessEAPoLPkt((BufferDesc_t *)(rx_mic + 1),
                                      (IEEEtypes_MacAddr_t *)&DAT_4201b9f2,
                                      (IEEEtypes_MacAddr_t *)&DAT_4201b9ec);
                      goto LAB_23009e1c;
                    }
                  }
                  if (((5 < 0xd - rxl_cntrl_env.packet_stack_cnt) && ((rxu_cntrl_env & 0x400) == 0))
                     && (DAT_4201b9ce == 0)) {
                    if ((DAT_4201b9f8 & 1) != 0) {
                      me_mic_init((mic_calc *)(rx_mic + 1),
                                  (uint32_t *)
                                  &(rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->u).
                                   field_0x8,(mac_addr *)&DAT_4201b9ec,(mac_addr *)&DAT_4201b9f2,
                                  DAT_4201b9cf);
                      uVar19 = (uint)DAT_4201b9d0;
                      uVar18 = (swdesc->dma_hdrdesc->hd).first_pbd_ptr;
                      uVar17 = (-8 - uVar19) + (uint)(swdesc->dma_hdrdesc->hd).frmlen & 0xffff;
                      do {
                        uVar10 = uVar17;
                        if (0x350 < uVar17 + uVar19) {
                          uVar10 = 0x350 - uVar19 & 0xffff;
                        }
                        uVar17 = uVar17 - uVar10 & 0xffff;
                        me_mic_calc((mic_calc *)(rx_mic + 1),*(int *)(uVar18 + 8) + uVar19,uVar10);
                        if (uVar17 == 0) {
                          uVar19 = uVar19 + uVar10 & 0xffff;
                          puVar9 = &local_50;
                          goto LAB_2300a440;
                        }
                        uVar18 = *(uint32_t *)(uVar18 + 4);
                        uVar19 = 0;
                      } while (uVar18 != 0);
                      iVar6 = 0x369;
                      goto LAB_2300a41a;
                    }
LAB_2300a4fa:
                    uVar18 = (uint32_t)DAT_4201b9d0;
                    swdesc->dma_hdrdesc->flags =
                         (uint)DAT_4201b9d1 << 0x10 | (uint)DAT_4201b9d2 << 8 |
                         (uint)DAT_4201b9d3 << 0x18 | swdesc->dma_hdrdesc->flags;
                    prVar15 = swdesc->dma_hdrdesc;
                    puVar3 = *(ushort **)((prVar15->hd).first_pbd_ptr + 8);
                    uVar14 = prVar15->flags & 0xffffff8f;
                    prVar15->flags = uVar14;
                    if ((*puVar3 & 0xfc) == 0x88) {
                      if ((*puVar3 & 0x300) == 0x300) {
                        bVar16 = *(byte *)(puVar3 + 0xf);
                      }
                      else {
                        bVar16 = *(byte *)(puVar3 + 0xc);
                      }
                      uVar14 = (bVar16 & 7) << 4 | uVar14;
                      if ((bVar16 & 0x80) == 0) {
                        prVar15->flags = uVar14;
                        goto LAB_2300a56e;
                      }
                      prVar15->flags = uVar14 | 1;
                    }
                    else {
LAB_2300a56e:
                      pvVar20 = (void *)((int)puVar3 + (uVar18 & 0xfe));
                      iVar6 = memcmp(pvVar20,&rxu_cntrl_rfc1042_hdr,6);
                      if (((iVar6 == 0) && (*(short *)((int)pvVar20 + 6) != -0x7ec9)) ||
                         (iVar6 = memcmp(pvVar20,&rxu_cntrl_bridge_tunnel_hdr,6), iVar6 == 0)) {
                        uVar14 = uVar18 - 6;
                        puVar3 = (ushort *)((int)pvVar20 + -6);
                        DAT_4201b9f9 = 0;
                      }
                      else {
                        uVar14 = uVar18 - 0xe;
                        puVar3 = (ushort *)((int)pvVar20 + -0xe);
                        iVar6 = (swdesc->dma_hdrdesc->hd).frmlen - uVar18;
                        *(char *)((int)pvVar20 + -2) = (char)((uint)(iVar6 * 0x10000) >> 0x10);
                        *(char *)((int)pvVar20 + -1) = (char)((uint)iVar6 >> 8);
                        DAT_4201b9f9 = 1;
                      }
                      uVar18 = uVar14 & 0xff;
                      *puVar3 = DAT_4201b9ec;
                      puVar3[1] = DAT_4201b9ee;
                      puVar3[2] = DAT_4201b9f0;
                      puVar3[3] = DAT_4201b9f2;
                      puVar3[4] = DAT_4201b9f4;
                      puVar3[5] = DAT_4201b9f6;
                    }
                    (swdesc->dma_hdrdesc->hd).frmlen =
                         (swdesc->dma_hdrdesc->hd).frmlen - (short)uVar18;
                    DAT_4201b9fa = (undefined)uVar18;
                    swdesc->dma_hdrdesc->payl_offset = uVar18;
                    mac_payload_offset = uVar18;
                    rxl_mpdu_transfer(swdesc);
                    uVar18 = DAT_4201ba10;
                    swdesc->status = '\x03';
                    swdesc->host_id = uVar18;
                    swdesc->frame_len = (uint)(swdesc->dma_hdrdesc->hd).frmlen;
                    co_list_push_back((co_list *)&rxu_cntrl_desc_transfer::swdesc,
                                      (co_list_hdr *)swdesc);
                    goto LAB_2300a056;
                  }
                }
              }
              else {
                mm_cfg_element_keepalive_timestamp_update();
              }
            }
          }
        }
      }
    }
    else {
      if ((((((DAT_4201ba37 != '\0') && ((uVar14 & 0x200) == 0)) &&
            (DAT_4201ba30 == *(char *)(puVar3 + 5))) &&
           ((DAT_4201ba31 == *(char *)((int)puVar3 + 0xb) && (DAT_4201ba32 == *(char *)(puVar3 + 6))
            ))) && (DAT_4201ba33 == *(char *)((int)puVar3 + 0xd))) &&
         ((DAT_4201ba34 == *(char *)(puVar3 + 7) && (DAT_4201ba35 == *(char *)((int)puVar3 + 0xf))))
         ) {
        if ((*puVar3 & 0x1400) == 0x1000) {
          DAT_4201ba36 = 1;
        }
        else {
          DAT_4201ba36 = 0;
        }
      }
      if ((uVar1 & 0xc) == 0) {
        if ((((*(byte *)((int)puVar3 + 1) >> 3 & 1) == 0) || (DAT_4201ba2a != puVar3[0xb])) ||
           (iVar6 = memcmp(puVar3 + 5,&DAT_4201ba24,6), iVar6 != 0)) {
          DAT_4201ba2a = puVar3[0xb];
          memcpy(&DAT_4201ba24,puVar3 + 5,6);
          if ((-1 < (int)((uint)rxu_cntrl_env << 0x11)) ||
             (((uVar14 & 0x1c) == 0x14 &&
              (_Var5 = rxu_cntrl_protected_handle((uint8_t *)puVar3,uVar14),
              CONCAT31(extraout_var,_Var5) != 0)))) {
            bVar7 = 0xff;
            goto LAB_2300a0ba;
          }
        }
      }
      else {
        if ((((uVar19 & 0xc) != 8) ||
            (vif = vif_mgmt_get_first_ap_inf(), vif == (vif_info_tag *)0x0)) ||
           (((*(char *)(puVar3 + 2) != *(char *)(vif->mac_addr).array ||
             (((*(char *)((int)puVar3 + 5) != *(char *)((int)(vif->mac_addr).array + 1) ||
               (*(char *)(puVar3 + 3) != *(char *)((vif->mac_addr).array + 1))) ||
              (*(char *)((int)puVar3 + 7) != *(char *)((int)(vif->mac_addr).array + 3))))) ||
            ((*(char *)(puVar3 + 4) != *(char *)((vif->mac_addr).array + 2) ||
             (*(char *)((int)puVar3 + 9) != *(char *)((int)(vif->mac_addr).array + 5))))))) {
          rxu_mpdu_upload_and_indicate(swdesc);
          cVar4 = '\x01';
          goto LAB_2300a056;
        }
        apm_send_mlme(vif,0xc0,(mac_addr *)(puVar3 + 5),(cfm_func_ptr *)0x0,(void *)0x0,1);
      }
    }
  }
  goto LAB_23009e1c;
  while( true ) {
    uVar18 = *(uint32_t *)(uVar18 + 4);
    uVar19 = 0;
    puVar9 = (uint32_t *)puVar8;
    if (uVar18 == 0) break;
LAB_2300a440:
    iVar6 = *(int *)(uVar18 + 8);
    uVar17 = uVar14;
    if (0x350 < uVar14 + uVar19) {
      uVar17 = 0x350 - uVar19 & 0xffff;
    }
    uVar10 = 0;
    while (puVar8 = (undefined *)((int)puVar9 + uVar10), uVar10 != uVar17) {
      puVar13 = (undefined *)(uVar10 + iVar6 + uVar19);
      uVar10 = uVar10 + 1;
      *puVar8 = *puVar13;
    }
    uVar14 = uVar14 - uVar10 & 0xffff;
    if (uVar14 == 0) {
      me_mic_end((mic_calc *)(rx_mic + 1));
      if ((local_50 == rx_mic[1]) && (rx_mic[0] == mic.mic_calc.mic_key_least)) goto LAB_2300a4fa;
      pvVar20 = ke_msg_alloc(0x1406,0xd,5,0x18);
      pvVar20 = memcpy(pvVar20,&sta_info_tab[DAT_4201b9d1].mac_addr,6);
      uVar14 = DAT_4201b9dc;
      *(uint *)((int)pvVar20 + 8) = DAT_4201b9d8;
      *(uint *)((int)pvVar20 + 0xc) = uVar14;
      *(byte *)((int)pvVar20 + 0x10) = (byte)(DAT_4201b9e0 >> 10) & 1;
      *(byte *)((int)pvVar20 + 0x12) = DAT_4201b9d2;
      *(uint8_t *)((int)pvVar20 + 0x11) =
           rxu_cntrl_mic_check::lexical_block_1_0_0_0_0_0_0::key->key_idx;
      ke_msg_send(pvVar20);
      goto LAB_23009e1c;
    }
  }
  iVar6 = 0x392;
LAB_2300a41a:
  assert_rec("pd != NULL","module",iVar6);
LAB_23009e1c:
  cVar4 = '\0';
LAB_2300a056:
  if (rxu_cntrl_desc_transfer::swdesc != (rx_swdesc *)0x0) {
    ke_evt_set(0x20000000);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rxu_cntrl_monitor_pm(mac_addr *addr)

{
  if (DAT_4201ba37 == '\0') {
    _DAT_4201ba30 = addr->array[0];
    _DAT_4201ba32 = addr->array[1];
    _DAT_4201ba34 = addr->array[2];
    _DAT_4201ba36 = 0x100;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t rxu_cntrl_get_pm(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4201ba36 = 0;
  return DAT_4201ba36;
}



void rxu_cntrl_evt(int dummy)

{
  ke_evt_clear(0x80000);
  if (rxu_cntrl_desc_transfer::swdesc != (rx_swdesc *)0x0) {
    ke_evt_set(0x20000000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: pkt

void rxu_swdesc_upload_evt(int arg)

{
  uint uVar1;
  rx_swdesc *swdesc;
  int iVar2;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t uVar6;
  undefined local_48 [4];
  wifi_pkt pkt;
  
  ke_evt_clear(0x20000000);
  swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&rxu_cntrl_desc_transfer::swdesc);
  while (swdesc != (rx_swdesc *)0x0) {
    uVar1 = (uint)(swdesc->dma_hdrdesc->hd).frmlen;
    memset(local_48,0,0x28);
    puVar4 = (uint32_t *)local_48;
    uVar6 = (swdesc->dma_hdrdesc->hd).first_pbd_ptr;
    puVar5 = puVar4;
    while ((uVar1 != 0 && (puVar5 != pkt.pkt + 3))) {
      swdesc->pbd_count = swdesc->pbd_count + '\x01';
      uVar3 = *(uint32_t *)(uVar6 + 8);
      *puVar5 = uVar3;
      *(short *)(puVar4 + 8) = ((short)*(undefined4 *)(uVar6 + 0xc) + 1) - (short)uVar3;
      puVar5[4] = uVar6 + 0x1c;
      *(undefined4 *)(uVar6 + 0x14) = 1;
      if (uVar1 < 0x350) {
        uVar1 = 0;
      }
      else {
        uVar1 = uVar1 - 0x350;
      }
      uVar6 = *(uint32_t *)(uVar6 + 4);
      puVar5 = puVar5 + 1;
      puVar4 = (uint32_t *)((int)puVar4 + 2);
    }
    swdesc->use_in_tcpip = '\x01';
    swdesc->dma_hdrdesc->use_in_tcpip = 1;
    iVar2 = tcpip_stack_input(swdesc,swdesc->status,&(swdesc->dma_hdrdesc->hd).frmlen,
                              swdesc->dma_hdrdesc->payl_offset,(wifi_pkt *)local_48);
    if (iVar2 == 0) {
      vTaskEnterCritical();
      rxl_cntrl_env.packet_stack_cnt = rxl_cntrl_env.packet_stack_cnt + swdesc->pbd_count;
      vTaskExitCritical();
    }
    else {
      rxl_mpdu_free(swdesc);
    }
    swdesc = (rx_swdesc *)co_list_pop_front((co_list *)&rxu_cntrl_desc_transfer::swdesc);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_confirm(uint8_t status)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  
  if (scanu_env.joining == false) {
    puVar1 = (uint8_t *)ke_msg_alloc(0x1001,scanu_env.src_id,4,1);
    puVar2 = (uint8_t *)0x0;
  }
  else {
    puVar1 = (uint8_t *)ke_msg_alloc(0x1003,scanu_env.src_id,4,1);
    puVar2 = (uint8_t *)ke_msg_alloc(0x1003,0xd,4,1);
  }
  *puVar1 = status;
  ke_msg_free(&scanu_env.param[-1].add_ies);
  scanu_env.param = (scanu_start_req *)0x0;
  ke_msg_send(puVar1);
  if (puVar2 != (uint8_t *)0x0) {
    *puVar2 = status;
    ke_msg_send(puVar2);
  }
  ke_state_set(4,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_raw_send_cfm(uint8_t status,ke_task_id_t dst_id)

{
  undefined3 in_register_00002029;
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x1006,dst_id,4,4);
  *puVar1 = CONCAT31(in_register_00002029,status);
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_init(void)

{
  ke_state_set(4,0);
  memset(&scanu_env,0,0x194);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  scanu_env.dma_desc.dma_desc = &scanu_add_ie;
  scanu_env.dma_desc.cb = scanu_dma_cb;
  scanu_env.dma_desc.env = (void *)0x0;
  scanu_add_ie.dma_desc.dest = 0x42047ddc;
  return;
}



mac_scan_result * scanu_find_result(mac_addr *bssid_ptr,_Bool allocate)

{
  undefined3 in_register_0000202d;
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_env.scan_result;
  do {
    if (pmVar1->valid_flag == false) {
      if (CONCAT31(in_register_0000202d,allocate) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return pmVar1;
      }
    }
    else {
      if ((((*(char *)(pmVar1->bssid).array == *(char *)bssid_ptr->array) &&
           (*(char *)((int)(pmVar1->bssid).array + 1) == *(char *)((int)bssid_ptr->array + 1))) &&
          (*(char *)((pmVar1->bssid).array + 1) == *(char *)(bssid_ptr->array + 1))) &&
         (((*(char *)((int)(pmVar1->bssid).array + 3) == *(char *)((int)bssid_ptr->array + 3) &&
           (*(char *)((pmVar1->bssid).array + 2) == *(char *)(bssid_ptr->array + 2))) &&
          (*(char *)((int)(pmVar1->bssid).array + 5) == *(char *)((int)bssid_ptr->array + 5))))) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return pmVar1;
      }
    }
    pmVar1 = pmVar1 + 1;
    if (pmVar1 == (mac_scan_result *)&scanu_env.src_id) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (mac_scan_result *)0x0;
    }
  } while( true );
}



// WARNING: Restarted to delay deadcode elimination for space: ram

int scanu_frame_handler(rxu_mgt_ind *frame)

{
  undefined uVar1;
  uint8_t uVar2;
  _Bool _Var3;
  ushort uVar4;
  scanu_start_req *psVar5;
  sm_connect_req *psVar6;
  uchar uVar7;
  ke_state_t kVar8;
  uint16_t uVar9;
  uint32_t uVar10;
  undefined2 extraout_var;
  mac_scan_result *pmVar11;
  int iVar12;
  scan_chan_tag *psVar13;
  void *pvVar14;
  byte bVar15;
  undefined *puVar16;
  uint8_t *puVar17;
  undefined *puVar18;
  uint8_t *puVar19;
  SecurityMode_t *security_mode;
  char cVar20;
  uint16_t uVar21;
  uint uVar22;
  uint uVar23;
  mac_bss_info *bss;
  Cipher_t *mcstCipher;
  Cipher_t *mcstCipher_00;
  Cipher_t *ucstCipher;
  u32_l uVar24;
  mac_ssid *pmVar25;
  uint uVar26;
  uint8_t *addr;
  mac_rateset *mac_rate_set_ptr;
  Cipher_t *ucstCipher_00;
  undefined uStack100;
  undefined local_63 [3];
  mac_ssid ssid_buf;
  
  psVar5 = scanu_env.param;
  addr = &frame[2].inst_nbr;
  uVar26 = (uint)(scanu_env.param)->vif_idx;
  uVar10 = mac_ie_find((uint32_t)addr,frame->length - 0x24,'\0');
  if (uVar10 != 0) {
    uVar22 = (uint)*(byte *)(uVar10 + 1);
    if (uVar22 < 0x21) {
      if (uVar22 == 0) goto LAB_2300a9ca;
    }
    else {
      uVar22 = 0x20;
    }
    puVar16 = (undefined *)(uVar10 + 2);
    if (*(char *)(uVar10 + 2) != '\0') {
      uStack100 = (undefined)uVar22;
      puVar18 = &uStack100;
      uVar23 = uVar22;
      while( true ) {
        uVar23 = uVar23 - 1;
        puVar18 = puVar18 + 1;
        if (uVar23 == 0xffffffff) break;
        uVar1 = *puVar16;
        puVar16 = puVar16 + 1;
        *puVar18 = uVar1;
      }
      local_63[uVar22] = 0;
    }
  }
LAB_2300a9ca:
  kVar8 = ke_state_get(4);
  if (((CONCAT22(extraout_var,kVar8) != 1) ||
      (pmVar11 = scanu_find_result((mac_addr *)&frame[1].tsflo,true),
      pmVar11 == (mac_scan_result *)0x0)) ||
     ((((byte)scanu_env.bssid.array[0] & 1) == 0 &&
      (((((*(byte *)&frame[1].tsflo != (byte)scanu_env.bssid.array[0] ||
          (*(char *)((int)&frame[1].tsflo + 1) != scanu_env.bssid.array[0]._1_1_)) ||
         (*(char *)((int)&frame[1].tsflo + 2) != (char)scanu_env.bssid.array[1])) ||
        ((*(char *)((int)&frame[1].tsflo + 3) != scanu_env.bssid.array[1]._1_1_ ||
         (*(char *)&frame[1].tsfhi != (char)scanu_env.bssid.array[2])))) ||
       (*(char *)((int)&frame[1].tsfhi + 1) != scanu_env.bssid.array[2]._1_1_))))))
  goto LAB_2300b100;
  (pmVar11->bssid).array[0] = *(uint16_t *)&frame[1].tsflo;
  (pmVar11->bssid).array[1] = *(uint16_t *)((int)&frame[1].tsflo + 2);
  (pmVar11->bssid).array[2] = *(uint16_t *)&frame[1].tsfhi;
  pmVar11->beacon_period = frame[2].center_freq;
  uVar4 = *(ushort *)&frame[2].band;
  pmVar11->cap_info = uVar4;
  uVar21 = uVar4 & 1;
  if ((uVar4 & 1) == 0) {
    uVar21 = 2;
  }
  pmVar11->bsstype = uVar21;
  uVar21 = frame->length - 0x24;
  uVar10 = mac_ie_find((uint32_t)addr,uVar21,'\0');
  if (uVar10 == 0) {
    (pmVar11->ssid).length = '\0';
  }
  else {
    uVar22 = (uint)*(byte *)(uVar10 + 1);
    if (uVar22 < 0x21) {
      if (uVar22 == 0) goto LAB_2300aa9e;
    }
    else {
      uVar22 = 0x20;
    }
    puVar19 = (uint8_t *)(uVar10 + 2);
    if (*(char *)(uVar10 + 2) != '\0') {
      (pmVar11->ssid).length = (uint8_t)uVar22;
      puVar17 = (pmVar11->ssid).array;
      while (uVar22 = uVar22 - 1, uVar22 != 0xffffffff) {
        uVar2 = *puVar19;
        puVar19 = puVar19 + 1;
        *puVar17 = uVar2;
        puVar17 = puVar17 + 1;
      }
    }
  }
LAB_2300aa9e:
  pmVar11->ppm_rel = frame->ppm_rel;
  pmVar11->ppm_abs = frame->ppm_abs;
  if (psVar5->ssid_cnt != '\0') {
    uVar22 = 0;
    pmVar25 = psVar5->ssid;
    while ((int)uVar22 < (int)(uint)psVar5->ssid_cnt) {
      if (pmVar25->length == 0) goto LAB_2300ab3c;
      uVar23 = (uint)(pmVar11->ssid).length;
      if ((uVar23 == pmVar25->length) &&
         (iVar12 = memcmp(pmVar25->array,(pmVar11->ssid).array,uVar23), iVar12 == 0)) break;
      uVar22 = uVar22 + 1;
      pmVar25 = pmVar25 + 1;
    }
    if (psVar5->ssid_cnt == uVar22) goto LAB_2300b100;
  }
LAB_2300ab3c:
  uVar10 = mac_ie_find((uint32_t)addr,uVar21,'\x03');
  if (uVar10 == 0) {
    if (pmVar11->rssi < frame->rssi) {
      psVar13 = me_freq_to_chan_ptr(frame->band,frame->center_freq);
      pmVar11->chan = psVar13;
      cVar20 = frame->rssi;
      goto LAB_2300ab8c;
    }
  }
  else {
    bVar15 = *(byte *)(uVar10 + 2);
    uVar22 = (uint)bVar15;
    uVar2 = frame->band;
    if (uVar2 == '\0') {
      if (uVar22 - 1 < 0xe) {
        if (uVar22 == 0xe) {
          uVar9 = 0x9b4;
        }
        else {
          uVar9 = (ushort)bVar15 * 5 + 0x967;
        }
      }
      else {
LAB_2300afea:
        uVar9 = 0xffff;
      }
    }
    else {
      if ((uVar2 != '\x01') || (0xa4 < uVar22 - 1)) goto LAB_2300afea;
      uVar9 = (ushort)bVar15 * 5 + 5000;
    }
    psVar13 = me_freq_to_chan_ptr(uVar2,uVar9);
    pmVar11->chan = psVar13;
    cVar20 = frame->rssi;
    if (pmVar11->rssi < cVar20) {
LAB_2300ab8c:
      pmVar11->rssi = cVar20;
    }
  }
  if (scanu_env.joining != false) {
    bss = &vif_info_tab[uVar26].bss_info;
    vif_info_tab[uVar26].bss_info.bsstype = pmVar11->bsstype;
    mac_rate_set_ptr = &vif_info_tab[uVar26].bss_info.rate_set;
    *(undefined4 *)vif_info_tab[uVar26].bss_info.bssid.array = *(undefined4 *)(pmVar11->bssid).array
    ;
    vif_info_tab[uVar26].bss_info.bssid.array[2] = (pmVar11->bssid).array[2];
    vif_info_tab[uVar26].bss_info.cap_info = pmVar11->cap_info;
    vif_info_tab[uVar26].bss_info.beacon_period = pmVar11->beacon_period;
    memcpy(&vif_info_tab[uVar26].bss_info.ssid,&pmVar11->ssid,0x22);
    psVar13 = pmVar11->chan;
    vif_info_tab[uVar26].bss_info.valid_flags = 0;
    vif_info_tab[uVar26].bss_info.chan = psVar13;
    vif_info_tab[uVar26].bss_info.ppm_rel = pmVar11->ppm_rel;
    vif_info_tab[uVar26].bss_info.ppm_abs = pmVar11->ppm_abs;
    me_extract_rate_set((uint32_t)addr,uVar21,mac_rate_set_ptr);
    if (pmVar11->chan->band == '\0') {
      uVar9 = me_legacy_rate_bitfield_build(mac_rate_set_ptr,true);
      if ((uVar9 & 0xf) == 0) {
        vif_info_tab[uVar26].bss_info.high_11b_rate = '\x01';
      }
      else {
        iVar12 = __clzsi2(uVar9 & 0xf);
        vif_info_tab[uVar26].bss_info.high_11b_rate = '\x1f' - (char)iVar12;
      }
    }
    uVar10 = mac_vsie_find((uint32_t)addr,uVar21,"",'\x05');
    if (uVar10 == 0) {
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[0] = 0xa43;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[1] = 0xa43;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[2] = 0xa43;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[3] = 0xa43;
    }
    else {
      vif_info_tab[uVar26].bss_info.edca_param.qos_info = *(uint8_t *)(uVar10 + 8);
      vif_info_tab[uVar26].bss_info.cap_info = vif_info_tab[uVar26].bss_info.cap_info | 0x200;
      uVar22 = *(uint *)(uVar10 + 10);
      bVar15 = (byte)(uVar22 >> 3) & 2;
      vif_info_tab[uVar26].bss_info.edca_param.acm = bVar15;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[1] = uVar22 & 0xf | (uVar22 >> 8) << 4;
      uVar22 = *(uint *)(uVar10 + 0xe);
      bVar15 = (byte)(uVar22 >> 4) & 1 | bVar15;
      vif_info_tab[uVar26].bss_info.edca_param.acm = bVar15;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[0] = uVar22 & 0xf | (uVar22 >> 8) << 4;
      uVar22 = *(uint *)(uVar10 + 0x12);
      bVar15 = bVar15 | (byte)(uVar22 >> 2) & 4;
      vif_info_tab[uVar26].bss_info.edca_param.acm = bVar15;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[2] = uVar22 & 0xf | (uVar22 >> 8) << 4;
      uVar22 = *(uint *)(uVar10 + 0x16);
      vif_info_tab[uVar26].bss_info.edca_param.acm = bVar15 | (byte)(uVar22 >> 1) & 8;
      uVar23 = vif_info_tab[uVar26].bss_info.valid_flags;
      vif_info_tab[uVar26].bss_info.edca_param.ac_param[3] = uVar22 & 0xf | (uVar22 >> 8) << 4;
      vif_info_tab[uVar26].bss_info.valid_flags = uVar23 | 1;
    }
    uVar10 = 0;
    if (me_env.ht_supported != false) {
      uVar10 = vif_info_tab[uVar26].bss_info.valid_flags & 1;
      if (uVar10 != 0) {
        uVar10 = mac_ie_find((uint32_t)addr,uVar21,'-');
        if (uVar10 != 0) {
          vif_info_tab[uVar26].bss_info.ht_cap.ht_capa_info = *(uint16_t *)(uVar10 + 2);
          vif_info_tab[uVar26].bss_info.ht_cap.a_mpdu_param = *(uint8_t *)(uVar10 + 4);
          iVar12 = 0;
          do {
            vif_info_tab[uVar26].bss_info.ht_cap.mcs_rate[iVar12] =
                 *(uint8_t *)(uVar10 + 5 + iVar12);
            iVar12 = iVar12 + 1;
          } while (iVar12 != 0x10);
          vif_info_tab[uVar26].bss_info.ht_cap.ht_extended_capa = *(uint16_t *)(uVar10 + 0x15);
          vif_info_tab[uVar26].bss_info.ht_cap.tx_beamforming_capa =
               (uint)*(ushort *)(uVar10 + 0x17);
          vif_info_tab[uVar26].bss_info.ht_cap.asel_capa = *(uint8_t *)(uVar10 + 0x1b);
          vif_info_tab[uVar26].bss_info.valid_flags = vif_info_tab[uVar26].bss_info.valid_flags | 2;
        }
        uVar10 = mac_ie_find((uint32_t)addr,uVar21,'=');
      }
    }
    _Var3 = (sm_env.connect_param)->is_supplicant_enabled;
    vif_info_tab[uVar26].bss_info.is_supplicant_enabled = _Var3;
    if ((_Var3 != false) && (-1 < (int)vif_info_tab[uVar26].bss_info.valid_flags)) {
      security_mode = &vif_info_tab[uVar26].bss_info.wpa_wpa2_wep;
      memset(security_mode,0,2);
      mcstCipher = &vif_info_tab[uVar26].bss_info.rsn_mcstCipher;
      ucstCipher_00 = &vif_info_tab[uVar26].bss_info.rsn_ucstCipher;
      memset(mcstCipher,0,1);
      memset(ucstCipher_00,0,1);
      mcstCipher_00 = &vif_info_tab[uVar26].bss_info.wpa_mcstCipher;
      memset(mcstCipher_00,0,1);
      ucstCipher = &vif_info_tab[uVar26].bss_info.wpa_ucstCipher;
      memset(ucstCipher,0,1);
      vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len = '\0';
      vif_info_tab[uVar26].bss_info.is_pmf_required = false;
      vif_info_tab[uVar26].bss_info.is_wpa2_prefered = false;
      pvVar14 = (void *)mac_ie_find((uint32_t)addr,uVar21,'0');
      puVar19 = vif_info_tab[uVar26].bss_info.rsn_wpa_ie;
      if (pvVar14 != (void *)0x0) {
        uVar22 = *(byte *)((int)pvVar14 + 1) + 2 & 0xff;
        vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len = (uint8_t)uVar22;
        memcpy(puVar19,pvVar14,uVar22);
        uVar7 = process_rsn_ie(puVar19,mcstCipher,ucstCipher_00,
                               &vif_info_tab[uVar26].bss_info.is_pmf_required,security_mode,
                               *(_Bool *)(uVar26 * 0x5d8 + 0x4201a800));
        uVar22 = *(uint *)&vif_info_tab[uVar26].bss_info.wpa_ucstCipher;
        vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len = uVar7;
        printf("wpa2/wpa3 pairwise ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",uVar22 >> 0x13 & 1,
               uVar22 >> 0x12 & 1,uVar22 >> 0x11 & 1,uVar22 >> 0x10 & 1);
        uVar22 = *(uint *)&vif_info_tab[uVar26].bss_info.wpa_ucstCipher;
        printf("wpa2/wpa3 group ccmp:%d,tkip:%d,wep104:%d,wep:40:%d\r\n",uVar22 >> 0xb & 1,
               uVar22 >> 10 & 1,uVar22 >> 9 & 1,uVar22 >> 8 & 1);
        printf("wpa2/wpa3 is_pmf_required:%d\r\n",
               (uint)vif_info_tab[uVar26].bss_info.is_pmf_required);
      }
      pvVar14 = (void *)mac_vsie_find((uint32_t)addr,uVar21,"",'\x04');
      if (pvVar14 != (void *)0x0) {
        *(byte *)&vif_info_tab[uVar26].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar26].bss_info.wpa_wpa2_wep | 8;
        if (vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len == '\0') {
          uVar22 = *(byte *)((int)pvVar14 + 1) + 2 & 0xff;
          vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len = (uint8_t)uVar22;
          memcpy(puVar19,pvVar14,uVar22);
          uVar7 = process_wpa_ie(puVar19,mcstCipher_00,ucstCipher);
          vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len = uVar7;
        }
      }
      psVar6 = sm_env.connect_param;
      (sm_env.connect_param)->flags = 0;
      if ((*(uint *)&vif_info_tab[uVar26].bss_info.is_supplicant_enabled & 0x12800) == 0) {
        if ((vif_info_tab[uVar26].bss_info.cap_info & 0x10) == 0) {
          uVar24 = 2;
          goto LAB_2300afbc;
        }
        *(byte *)&vif_info_tab[uVar26].bss_info.wpa_wpa2_wep =
             *(byte *)&vif_info_tab[uVar26].bss_info.wpa_wpa2_wep | 2;
        psVar6->auth_type = '\x01';
      }
      else {
        uVar24 = 9;
LAB_2300afbc:
        psVar6->flags = uVar24;
      }
      memcpy(psVar6->ie_buf,puVar19,(uint)vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len);
      (sm_env.connect_param)->ie_len = (ushort)vif_info_tab[uVar26].bss_info.rsn_wpa_ie_len;
      uVar22 = *(uint *)&vif_info_tab[uVar26].bss_info.is_supplicant_enabled;
      printf("AP Security mode: wep:%d,wpa:%d,wpa2:%d,wpa3:%d\r\n",uVar22 >> 9 & 1,uVar22 >> 0xb & 1
             ,uVar22 >> 0xd & 1,uVar22 >> 0x10 & 1);
    }
    me_bw_check(uVar10,0,bss);
    me_extract_power_constraint((uint32_t)addr,uVar21,bss);
    me_extract_country_reg((uint32_t)addr,uVar21,bss);
    me_extract_mobility_domain((uint32_t)addr,uVar21,bss);
    vif_info_tab[uVar26].bss_info.valid_flags =
         vif_info_tab[uVar26].bss_info.valid_flags | 0x80000000;
  }
  if (pmVar11->valid_flag == false) {
    scanu_env.result_cnt = scanu_env.result_cnt + 1;
  }
  if (psVar5->ssid_cnt != '\0') {
    pmVar11->valid_flag = true;
  }
LAB_2300b100:
  ke_msg_forward_and_change_id(frame,0x1004,0xd,4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



mac_scan_result * scanu_search_by_bssid(mac_addr *bssid)

{
  mac_scan_result *pmVar1;
  
  pmVar1 = scanu_find_result(bssid,false);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar1;
}



mac_scan_result * scanu_search_by_ssid(mac_ssid *ssid,int *idx)

{
  scanu_env_tag *psVar1;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  int8_t iVar5;
  
  pmVar4 = (mac_scan_result *)0x0;
  if (ssid->length != '\0') {
    psVar1 = &scanu_env;
    iVar3 = 0;
    pmVar4 = (mac_scan_result *)0x0;
    iVar5 = -0x80;
    do {
      if (psVar1->scan_result[0].valid_flag == false) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return pmVar4;
      }
      if (((iVar5 < psVar1->scan_result[0].rssi) &&
          ((uint)ssid->length == (uint)psVar1->scan_result[0].ssid.length)) &&
         (iVar2 = memcmp(psVar1->scan_result[0].ssid.array,ssid->array,(uint)ssid->length),
         iVar2 == 0)) {
        iVar5 = psVar1->scan_result[0].rssi;
        pmVar4 = psVar1->scan_result;
        *idx = iVar3;
      }
      iVar3 = iVar3 + 1;
      psVar1 = (scanu_env_tag *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (iVar3 != 6);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar4;
}



void scanu_rm_exist_ssid(mac_ssid *ssid,int index)

{
  int iVar1;
  
  if ((index < 0) || (ssid == (mac_ssid *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (((scanu_env.scan_result[index].valid_flag != false) &&
      ((uint)ssid->length == (uint)scanu_env.scan_result[index].ssid.length)) &&
     (iVar1 = memcmp(scanu_env.scan_result[index].ssid.array,ssid->array,(uint)ssid->length),
     iVar1 == 0)) {
    memset(scanu_env.scan_result + index,0,0x38);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_scan_next(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  me_env_tag *pmVar11;
  int iVar12;
  undefined *puVar13;
  int iVar14;
  scanu_add_ie_tag *psVar15;
  uint8_t *puVar16;
  uint uVar17;
  int iVar18;
  int iVar19;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar17 = 0;
    puVar7 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar17 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar7 == scanu_env.band) goto LAB_2300b27a;
      uVar17 = uVar17 + 1;
      puVar7 = puVar7 + 6;
    }
    if ((scanu_env.param)->chan_cnt != uVar17) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2300b27a:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(u8_l *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(undefined2 *)((int)pvVar5 + 0x144) = *(undefined2 *)((psVar3->bssid).array + 4);
  *(u8_l *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar17 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar17].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar17,6);
      *(byte *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar17 = uVar17 + 1;
  }
  iVar18 = 0xfc;
  iVar19 = 0;
  while (iVar19 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar18),(void *)((int)&psVar3->chan[0].freq + iVar18),0x22);
    iVar19 = iVar19 + 1;
    iVar18 = iVar18 + 0x22;
  }
  uVar17 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < uVar17) {
    uVar17 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar18 = 4;
    iVar19 = 8;
  }
  else {
    iVar18 = 0;
    iVar19 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar12 = 0;
  do {
    iVar14 = iVar18 + iVar12;
    iVar2 = iVar12 + 2;
    iVar12 = iVar12 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar14];
  } while (iVar12 != 8);
  puVar13 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar17 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar15 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar13 = *(undefined *)psVar15->buf;
      psVar15 = (scanu_add_ie_tag *)((int)&(psVar15->dma_desc).src + 1);
      puVar13 = puVar13 + 1;
    }
    puVar13 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar17 = uVar17 - uVar6 & 0xffff;
  }
  if (iVar19 != 8) {
    uVar4 = iVar19 - 8U & 0xff;
    *puVar13 = 0x32;
    puVar13[1] = (char)uVar4;
    iVar18 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar16 = puVar13 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar16 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar16 = puVar16 + 1;
    }
    puVar13 = puVar13 + iVar18;
  }
  if (scanu_env.band == '\0') {
    *puVar13 = 3;
    puVar13[1] = 1;
    puVar13 = puVar13 + 3;
  }
  if ((uVar17 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = *(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar13 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar13 = puVar13 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar17 = uVar17 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar13 = 0x2d;
    puVar13[1] = 0x1a;
    puVar8 = puVar13 + 0x1c;
    pmVar11 = &me_env;
    puVar13 = puVar13 + 2;
    while (puVar8 != puVar13) {
      *puVar13 = *(undefined *)&(pmVar11->ht_cap).ht_capa_info;
      pmVar11 = (me_env_tag *)((int)&pmVar11->active_vifs + 1);
      puVar13 = puVar13 + 1;
    }
  }
  if (uVar17 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar13 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar17 != uVar4);
    puVar13 = puVar13 + uVar17;
  }
  *(short *)((int)pvVar5 + 0x14c) = (short)puVar13 + -0x7d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_dma_cb(void)

{
  byte bVar1;
  int iVar2;
  scanu_start_req *psVar3;
  uint uVar4;
  void *pvVar5;
  uint uVar6;
  uint8_t *puVar7;
  undefined *puVar8;
  undefined *puVar9;
  uint32_t *puVar10;
  me_env_tag *pmVar11;
  int iVar12;
  undefined *puVar13;
  int iVar14;
  scanu_add_ie_tag *psVar15;
  uint8_t *puVar16;
  uint uVar17;
  int iVar18;
  int iVar19;
  
  psVar3 = scanu_env.param;
  while( true ) {
    if (1 < scanu_env.band) {
      scanu_confirm('\0');
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar17 = 0;
    puVar7 = &(scanu_env.param)->chan[0].band;
    while ((int)uVar17 < (int)(uint)(scanu_env.param)->chan_cnt) {
      if (*puVar7 == scanu_env.band) goto LAB_2300b27a;
      uVar17 = uVar17 + 1;
      puVar7 = puVar7 + 6;
    }
    if ((scanu_env.param)->chan_cnt != uVar17) break;
    scanu_env.band = scanu_env.band + '\x01';
  }
LAB_2300b27a:
  pvVar5 = ke_msg_alloc(0x800,2,4,0x154);
  *(u8_l *)((int)pvVar5 + 0x14e) = psVar3->vif_idx;
  *(undefined4 *)((int)pvVar5 + 0x140) = *(undefined4 *)(psVar3->bssid).array;
  *(undefined2 *)((int)pvVar5 + 0x144) = *(undefined2 *)((psVar3->bssid).array + 4);
  *(u8_l *)((int)pvVar5 + 0x150) = psVar3->ssid_cnt;
  *(_Bool *)((int)pvVar5 + 0x151) = psVar3->no_cck;
  while ((int)uVar17 < (int)(uint)psVar3->chan_cnt) {
    if (*(uint8_t *)(&psVar3->chan[uVar17].freq + 1) == scanu_env.band) {
      bVar1 = *(byte *)((int)pvVar5 + 0x14f);
      memcpy((void *)((uint)bVar1 * 6 + (int)pvVar5),psVar3->chan + uVar17,6);
      *(byte *)((int)pvVar5 + 0x14f) = bVar1 + 1;
    }
    uVar17 = uVar17 + 1;
  }
  iVar18 = 0xfc;
  iVar19 = 0;
  while (iVar19 < (int)(uint)psVar3->ssid_cnt) {
    memcpy((void *)((int)pvVar5 + iVar18),(void *)((int)&psVar3->chan[0].freq + iVar18),0x22);
    iVar19 = iVar19 + 1;
    iVar18 = iVar18 + 0x22;
  }
  uVar17 = (uint)(scanu_env.param)->add_ie_len;
  puVar10 = scanu_add_ie.buf;
  if (200 < uVar17) {
    uVar17 = 0;
  }
  if ((scanu_env.band == '\x01') || ((scanu_env.param)->no_cck != false)) {
    iVar18 = 4;
    iVar19 = 8;
  }
  else {
    iVar18 = 0;
    iVar19 = 0xc;
  }
  scan_probe_req_ie.buf[0]._0_1_ = 1;
  scan_probe_req_ie.buf[0]._1_1_ = 8;
  iVar12 = 0;
  do {
    iVar14 = iVar18 + iVar12;
    iVar2 = iVar12 + 2;
    iVar12 = iVar12 + 1;
    *(uint8_t *)((int)scan_probe_req_ie.buf + iVar2) = mac_id2rate[iVar14];
  } while (iVar12 != 8);
  puVar13 = (undefined *)((int)scan_probe_req_ie.buf + 10);
  if ((uVar17 != 0) && ((char)scanu_add_ie.buf[0] == '\n')) {
    uVar6 = scanu_add_ie.buf[0]._1_1_ + 2 & 0xff;
    uVar4 = uVar6;
    psVar15 = &scanu_add_ie;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar13 = *(undefined *)psVar15->buf;
      psVar15 = (scanu_add_ie_tag *)((int)&(psVar15->dma_desc).src + 1);
      puVar13 = puVar13 + 1;
    }
    puVar13 = (undefined *)((int)scan_probe_req_ie.buf + uVar6 + 10);
    puVar10 = (uint32_t *)((int)scanu_add_ie.buf + uVar6);
    uVar17 = uVar17 - uVar6 & 0xffff;
  }
  if (iVar19 != 8) {
    uVar4 = iVar19 - 8U & 0xff;
    *puVar13 = 0x32;
    puVar13[1] = (char)uVar4;
    iVar18 = uVar4 + 2;
    puVar7 = mac_id2rate;
    puVar16 = puVar13 + 2;
    while( true ) {
      uVar4 = uVar4 - 1;
      if (uVar4 == 0xffffffff) break;
      *puVar16 = puVar7[8];
      puVar7 = puVar7 + 1;
      puVar16 = puVar16 + 1;
    }
    puVar13 = puVar13 + iVar18;
  }
  if (scanu_env.band == '\0') {
    *puVar13 = 3;
    puVar13[1] = 1;
    puVar13 = puVar13 + 3;
  }
  if ((uVar17 != 0) && (*(char *)puVar10 == ';')) {
    uVar4 = 0;
    uVar6 = *(byte *)((int)puVar10 + 1) + 2 & 0xff;
    while (uVar6 != uVar4) {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar13 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    }
    puVar13 = puVar13 + uVar6;
    puVar10 = (uint32_t *)((int)puVar10 + uVar6);
    uVar17 = uVar17 - uVar6 & 0xffff;
  }
  if (me_env.ht_supported != false) {
    *puVar13 = 0x2d;
    puVar13[1] = 0x1a;
    puVar8 = puVar13 + 0x1c;
    pmVar11 = &me_env;
    puVar13 = puVar13 + 2;
    while (puVar8 != puVar13) {
      *puVar13 = *(undefined *)&(pmVar11->ht_cap).ht_capa_info;
      pmVar11 = (me_env_tag *)((int)&pmVar11->active_vifs + 1);
      puVar13 = puVar13 + 1;
    }
  }
  if (uVar17 != 0) {
    uVar4 = 0;
    do {
      puVar8 = (undefined *)((int)puVar10 + uVar4);
      puVar9 = puVar13 + uVar4;
      uVar4 = uVar4 + 1;
      *puVar9 = *puVar8;
    } while (uVar17 != uVar4);
    puVar13 = puVar13 + uVar17;
  }
  *(short *)((int)pvVar5 + 0x14c) = (short)puVar13 + -0x7d04;
  *(undefined4 *)((int)pvVar5 + 0x148) = 0;
  ke_msg_send(pvVar5);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void scanu_start(void)

{
  scanu_env_tag *psVar1;
  
  if (scanu_env.joining == false) {
    psVar1 = &scanu_env;
    do {
      psVar1->scan_result[0].valid_flag = false;
      psVar1->scan_result[0].rssi = -0x80;
      psVar1 = (scanu_env_tag *)(psVar1->scan_result[0].ssid.array + 0x19);
    } while (psVar1 != (scanu_env_tag *)0x4201bb94);
    scanu_env.result_cnt = 0;
  }
  ke_state_set(4,1);
  if (((scanu_env.param)->add_ies != 0) && ((scanu_env.param)->add_ie_len < 0xc9)) {
    scanu_add_ie.dma_desc.src = (scanu_env.param)->add_ies;
    scanu_add_ie.dma_desc.length = (scanu_env.param)->add_ie_len;
    hal_dma_push(&scanu_env.dma_desc,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  scanu_scan_next();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint16_t txl_get_seq_ctrl(void)

{
  txl_cntrl_env.seqnbr = txl_cntrl_env.seqnbr + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return txl_cntrl_env.seqnbr * 0x10;
}



void sm_delete_resources(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,6,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send(pvVar3);
  }
  if (*(char *)&(vif->u).field_0x4 != -1) {
    puVar1 = (undefined *)ke_msg_alloc(0xc,0,6,1);
    *puVar1 = *(undefined *)&(vif->u).field_0x4;
    ke_msg_send(puVar1);
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  (vif->bss_info).valid_flags = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_frame_tx_cfm_handler(void *env,uint32_t status)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (((status & 0x40030000) != 0) && (CONCAT22(extraout_var,kVar1) - 5U < 2)) {
    txl_frame_push((txl_frame_desc_tag *)env,'\x03');
    *(undefined *)((int)env + 0x2d6) = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_init(void)

{
  sm_env.connect_param = (sm_connect_req *)0x0;
  ke_state_set(6,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_get_bss_params(mac_addr **bssid,scan_chan_tag **chan)

{
  byte bVar1;
  sm_connect_req *ssid;
  int iVar2;
  int iVar3;
  mac_scan_result *pmVar4;
  mac_addr *bssid_00;
  mac_addr *pmVar5;
  int local_34;
  int index;
  
  ssid = sm_env.connect_param;
  *bssid = (mac_addr *)0x0;
  *chan = (scan_chan_tag *)0x0;
  bssid_00 = (mac_addr *)&ssid->bssid;
  local_34 = -1;
  printf("===start sm_get_bss_params===\r\n");
  iVar2 = 0;
  pmVar5 = bssid_00;
  do {
    iVar3 = iVar2 + 1;
    printf("bssid[%d] = 0x%x\r\n",iVar2,(uint)pmVar5->array[0]);
    pmVar5 = (mac_addr *)(pmVar5->array + 1);
    iVar2 = iVar3;
  } while (iVar3 != 3);
  bVar1 = (ssid->bssid).array[0];
  if (((bVar1 & 1) == 0) &&
     ((((bVar1 != 0 || ((ssid->bssid).array[1] != '\0')) || ((ssid->bssid).array[2] != '\0')) ||
      ((((ssid->bssid).array[3] != '\0' || ((ssid->bssid).array[4] != '\0')) ||
       ((ssid->bssid).array[5] != '\0')))))) {
    printf("search bssid \r\n ");
    *bssid = bssid_00;
    pmVar4 = scanu_search_by_bssid(bssid_00);
    if (pmVar4 == (mac_scan_result *)0x0) goto LAB_2300b794;
  }
  else {
    printf("search ssid = %s\r\n",(ssid->ssid).array);
    pmVar4 = scanu_search_by_ssid((mac_ssid *)ssid,&local_34);
    printf("result ssid index = %d\r\n",local_34);
    if (pmVar4 == (mac_scan_result *)0x0) {
LAB_2300b794:
      if ((ssid->chan).freq != 0xffff) {
        *chan = &ssid->chan;
      }
      goto LAB_2300b756;
    }
    if (-1 < local_34) {
      *bssid = (mac_addr *)pmVar4;
      sm_env.exist_ssid_idx = local_34;
    }
  }
  *chan = pmVar4->chan;
LAB_2300b756:
  printf("===end sm_get_bss_params===\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void sm_scan_bss(mac_addr *bssid,scan_chan_tag *chan_1)

{
  u8_l uVar1;
  byte bVar2;
  undefined2 uVar3;
  sm_connect_req *__src;
  int iVar4;
  void *__dest;
  void *__src_00;
  undefined2 *puVar5;
  int *piVar6;
  undefined2 local_2c;
  undefined2 uStack42;
  uint8_t chan_cnt [2];
  scan_chan_tag *chan [2];
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1000,4,6,0x154);
  uVar1 = __src->vif_idx;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(u8_l *)((int)__dest + 0x14e) = uVar1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  if (bssid == (mac_addr *)0x0) {
    bssid = &mac_addr_bcst;
  }
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  uVar3 = me_env.chan._252_2_;
  if (chan_1 == (scan_chan_tag *)0x0) {
    _chan_cnt = 0x4201b004;
    *(undefined *)((int)__dest + 0x14f) = 0;
    puVar5 = &local_2c;
    local_2c = uVar3;
    piVar6 = (int *)chan_cnt;
    do {
      iVar4 = 0;
      while (iVar4 < (int)(uint)*(byte *)puVar5) {
        __src_00 = (void *)(iVar4 * 6 + *piVar6);
        if ((*(byte *)((int)__src_00 + 3) & 2) == 0) {
          bVar2 = *(byte *)((int)__dest + 0x14f);
          *(byte *)((int)__dest + 0x14f) = bVar2 + 1;
          memcpy((void *)((uint)bVar2 * 6 + (int)__dest),__src_00,6);
        }
        iVar4 = iVar4 + 1;
      }
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      piVar6 = piVar6 + 1;
    } while (puVar5 != &uStack42);
  }
  else {
    memcpy(__dest,chan_1,6);
    *(undefined *)((int)__dest + 0x14f) = 1;
  }
  ke_msg_send(__dest);
  ke_state_set(6,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_join_bss(mac_addr *bssid,scan_chan_tag *chan,_Bool passive)

{
  sm_connect_req *__src;
  void *__dest;
  undefined3 in_register_00002031;
  
  __src = sm_env.connect_param;
  __dest = ke_msg_alloc(0x1002,4,6,0x154);
  memcpy(__dest,chan,6);
  *(undefined *)((int)__dest + 0x14f) = 1;
  memcpy((void *)((int)__dest + 0xfc),__src,0x22);
  *(undefined *)((int)__dest + 0x150) = 1;
  *(undefined2 *)((int)__dest + 0x14c) = 0;
  *(undefined4 *)((int)__dest + 0x148) = 0;
  *(u8_l *)((int)__dest + 0x14e) = __src->vif_idx;
  memcpy((void *)((int)__dest + 0x140),bssid,6);
  if (CONCAT31(in_register_00002031,passive) != 0) {
    *(byte *)((int)__dest + 3) = *(byte *)((int)__dest + 3) | 1;
  }
  sm_env.join_passive = passive;
  ke_msg_send(__dest);
  ke_state_set(6,2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint8_t sm_add_chan_ctx(uint8_t *p_chan_idx)

{
  uint8_t uVar1;
  scan_chan_tag *psVar2;
  uint uVar3;
  undefined auStack28 [4];
  mm_chan_ctxt_add_req req;
  
  uVar3 = (uint)(sm_env.connect_param)->vif_idx;
  psVar2 = vif_info_tab[uVar3].bss_info.chan;
  auStack28[1] = vif_info_tab[uVar3].bss_info.phy_bw;
  auStack28[0] = psVar2->band;
  auStack28._2_2_ = psVar2->freq;
  req._0_4_ = *(undefined4 *)&vif_info_tab[uVar3].bss_info.center_freq1;
  req.center1_freq._0_1_ = psVar2->tx_power;
  uVar1 = chan_ctxt_add((mm_chan_ctxt_add_req *)auStack28,p_chan_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void sm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&sm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0x1a0);
  }
  ke_msg_send(pcVar1 + 3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_set_bss_param(void)

{
  sm_connect_req *psVar1;
  vif_info_tag *pvVar2;
  uint16_t uVar3;
  undefined *puVar4;
  void *__dest;
  undefined4 *puVar5;
  uint16_t *puVar6;
  undefined *puVar7;
  undefined2 extraout_var;
  uint32_t *puVar8;
  bool bVar9;
  uint32_t uVar10;
  uint uVar11;
  int iVar12;
  
  psVar1 = sm_env.connect_param;
  uVar11 = (uint)(sm_env.connect_param)->vif_idx;
  puVar4 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
  __dest = ke_msg_alloc(0x18,0,6,7);
  puVar5 = (undefined4 *)ke_msg_alloc(0x16,0,6,8);
  puVar6 = (uint16_t *)ke_msg_alloc(0x14,0,6,4);
  puVar7 = (undefined *)ke_msg_alloc(0x1411,5,6,2);
  co_list_init(&sm_env.bss_config);
  *puVar4 = 1;
  puVar4[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar4 + -0xc));
  pvVar2 = vif_info_tab + uVar11;
  memcpy(__dest,&vif_info_tab[uVar11].bss_info.bssid,6);
  *(u8_l *)((int)__dest + 6) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(uint8_t *)((int)puVar5 + 5) = (vif_info_tab[uVar11].bss_info.chan)->band;
  uVar3 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar11].bss_info.rate_set,true);
  *puVar5 = CONCAT22(extraout_var,uVar3);
  *(u8_l *)(puVar5 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar5 + -3));
  *puVar6 = vif_info_tab[uVar11].bss_info.beacon_period;
  iVar12 = 0;
  *(u8_l *)(puVar6 + 1) = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar6 + -6));
  do {
    puVar8 = (uint32_t *)ke_msg_alloc(0x1a,0,6,8);
    uVar10 = (pvVar2->bss_info).edca_param.ac_param[0];
    *(char *)((int)puVar8 + 5) = (char)iVar12;
    *puVar8 = uVar10;
    *(u8_l *)((int)puVar8 + 6) = psVar1->vif_idx;
    bVar9 = false;
    if ((ps_env.uapsd_timeout != 0) &&
       ((char)vif_info_tab[uVar11].bss_info.edca_param.qos_info < '\0')) {
      bVar9 = (mac_ac2uapsd[iVar12] & psVar1->uapsd_queues) != 0;
    }
    *(bool *)(puVar8 + 1) = bVar9;
    iVar12 = iVar12 + 1;
    co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar8 + -3));
    pvVar2 = (vif_info_tag *)&pvVar2->prevent_sleep;
  } while (iVar12 != 4);
  *puVar7 = 1;
  puVar7[1] = psVar1->vif_idx;
  co_list_push_back(&sm_env.bss_config,(co_list_hdr *)(puVar7 + -0xc));
  sm_send_next_bss_param();
  ke_state_set(6,4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_disconnect_process(vif_info_tag *vif,uint16_t reason)

{
  uint16_t *puVar1;
  
  puVar1 = (uint16_t *)ke_msg_alloc(0x1805,0xd,6,4);
  sm_delete_resources(vif);
  *puVar1 = reason;
  *(uint8_t *)(puVar1 + 1) = vif->index;
  if (sm_env.ft_over_ds != false) {
    *(undefined *)((int)puVar1 + 3) = 1;
  }
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_deauth_cfm(void *env,uint32_t status)

{
  sm_disconnect_process((vif_info_tag *)env,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_disconnect(uint8_t vif_index,uint16_t reason_code)

{
  byte bVar1;
  _Bool _Var2;
  uint16_t uVar3;
  undefined3 in_register_00002029;
  int iVar4;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  vif_info_tag *vif;
  tx_hw_desc *ptVar5;
  txl_buffer_tag *ptVar6;
  
  iVar4 = CONCAT31(in_register_00002029,vif_index);
  vif = vif_info_tab + iVar4;
  if ((vif_info_tab[iVar4].type == '\0') && (vif_info_tab[iVar4].active != false)) {
    bVar1 = *(byte *)&vif_info_tab[iVar4].u.field_0x4;
    ke_state_set(6,8);
    frame = txl_frame_get((uint)((vif_info_tab[iVar4].bss_info.chan)->band != '\0'),0x100);
    if (frame != (txl_frame_desc_tag *)0x0) {
      tpc_update_frame_tx_power(vif,frame);
      ptVar6 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar6[1].length = 0xc0;
      *(undefined *)((int)&ptVar6[1].length + 1) = 0;
      *(undefined *)((int)&ptVar6[1].length + 2) = 0;
      *(undefined *)((int)&ptVar6[1].length + 3) = 0;
      memcpy(&ptVar6[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
      memcpy((void *)((int)&ptVar6[1].lenpad + 2),&vif_info_tab[iVar4].mac_addr,6);
      memcpy(&ptVar6[1].next,&sta_info_tab[bVar1].mac_addr,6);
      uVar3 = txl_get_seq_ctrl();
      *(char *)((int)&ptVar6[1].txdesc + 2) = (char)uVar3;
      *(char *)((int)&ptVar6[1].txdesc + 3) = (char)(uVar3 >> 8);
      (frame->cfm).cfm_func = sm_deauth_cfm;
      (frame->cfm).env = vif;
      (frame->txdesc).host.vif_idx = vif_index;
      (frame->txdesc).host.staid = *(u8_l *)&vif_info_tab[iVar4].u.field_0x4;
      uVar3 = me_build_deauthenticate((uint32_t)ptVar6[1].dma_desc,reason_code);
      ptVar5 = (frame->txdesc).lmac.hw_desc;
      (ptVar5->thd).frmlen = CONCAT22(extraout_var_00,uVar3) + 0x1c;
      (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,uVar3);
      _Var2 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var2) != 0) goto LAB_2300bd30;
      vif = (vif_info_tag *)(frame->cfm).env;
    }
    sm_disconnect_process(vif,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_2300bd30:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_connect_ind(uint16_t status)

{
  sm_connect_req *ssid;
  sm_connect_ind *psVar1;
  int index;
  undefined2 in_register_0000202a;
  uint8_t uVar2;
  uint uVar3;
  chan_ctxt_tag *pcVar4;
  uint uVar5;
  
  index = sm_env.exist_ssid_idx;
  psVar1 = sm_env.connect_ind;
  ssid = sm_env.connect_param;
  uVar5 = (uint)(sm_env.connect_param)->vif_idx;
  (sm_env.connect_ind)->vif_idx = (sm_env.connect_param)->vif_idx;
  memcpy(&psVar1->bssid,&vif_info_tab[uVar5].bss_info.bssid,6);
  psVar1->ap_idx = *(u8_l *)&vif_info_tab[uVar5].u.field_0x4;
  printf("ind ix %p, chan_ctxt is %p\r\n",psVar1,vif_info_tab[uVar5].chan_ctxt);
  pcVar4 = vif_info_tab[uVar5].chan_ctxt;
  psVar1->ch_idx = '\0';
  if (pcVar4 == (chan_ctxt_tag *)0x0) {
    psVar1->band = '\0';
    psVar1->center_freq = 0;
    psVar1->center_freq1 = 0;
    psVar1->center_freq2 = 0;
    psVar1->width = '\0';
  }
  else {
    psVar1->band = ((vif_info_tab[uVar5].chan_ctxt)->channel).band;
    psVar1->center_freq = ((vif_info_tab[uVar5].chan_ctxt)->channel).prim20_freq;
    psVar1->center_freq1 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center1_freq;
    psVar1->center_freq2 = (uint)((vif_info_tab[uVar5].chan_ctxt)->channel).center2_freq;
    psVar1->width = ((vif_info_tab[uVar5].chan_ctxt)->channel).type;
  }
  uVar2 = '\0';
  uVar3 = vif_info_tab[uVar5].bss_info.valid_flags & 1;
  psVar1->qos = SUB41(uVar3,0);
  if (uVar3 != 0) {
    uVar2 = vif_info_tab[uVar5].bss_info.edca_param.acm;
  }
  psVar1->acm = uVar2;
  psVar1->roamed = false;
  if (CONCAT22(in_register_0000202a,status) == 0) {
    ke_state_set(6,0);
  }
  else {
    ke_state_set(6,8);
    printf("connect failure, ssid = %s, index = %d\r\n",(ssid->ssid).array,index);
    if (-1 < index) {
      printf("from sm_connect_ind to scanu_rm_exist_ssid\r\n");
      scanu_rm_exist_ssid((mac_ssid *)ssid,index);
      sm_env.exist_ssid_idx = -1;
    }
    sm_delete_resources(vif_info_tab + uVar5);
  }
  ke_msg_free(sm_env.connect_param[-1].phrase_pmk + 0x37);
  sm_env.connect_param = (sm_connect_req *)0x0;
  sm_env.ft_over_ds = false;
  psVar1->status_code = status;
  ke_msg_send(psVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  sm_env.connect_ind = (sm_connect_ind *)0x0;
  return;
}



void sm_supplicant_deauth_cfm(void *env,uint32_t status)

{
  if (-1 < (int)(status << 8)) {
    printf("sm deauth frame transmit failure\r\n");
  }
  sm_connect_ind(8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_auth_send(uint16_t auth_seq,uint32_t *challenge)

{
  byte bVar1;
  u8_l uVar2;
  sm_connect_req *psVar3;
  txl_buffer_tag *ptVar4;
  uint16_t uVar5;
  undefined2 in_register_0000202a;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar6;
  uint uVar7;
  int iVar8;
  
  psVar3 = sm_env.connect_param;
  uVar7 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = *(byte *)&vif_info_tab[uVar7].u.field_0x4;
  frame = txl_frame_get((uint)((vif_info_tab[uVar7].bss_info.chan)->band != '\0'),0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    tpc_update_frame_tx_power(vif_info_tab + uVar7,frame);
    ptVar4 = (frame->txdesc).lmac.buffer;
    *(undefined *)&ptVar4[1].length = 0xb0;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    *(undefined *)((int)&ptVar4[1].length + 2) = 0;
    *(undefined *)((int)&ptVar4[1].length + 3) = 0;
    memcpy(&ptVar4[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar4[1].lenpad + 2),&vif_info_tab[uVar7].mac_addr,6);
    memcpy(&ptVar4[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar5 = txl_get_seq_ctrl();
    *(char *)((int)&ptVar4[1].txdesc + 2) = (char)uVar5;
    *(char *)((int)&ptVar4[1].txdesc + 3) = (char)(uVar5 >> 8);
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar7].index;
    uVar2 = *(u8_l *)&vif_info_tab[uVar7].u.field_0x4;
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    (frame->txdesc).host.staid = uVar2;
    iVar8 = 0x18;
    if ((psVar3->auth_type == '\x01') && (CONCAT22(in_register_0000202a,auth_seq) == 3)) {
      txu_cntrl_protect_mgmt_frame((txdesc *)frame,(uint32_t)(ptVar4 + 1),0x18);
      iVar8 = (frame->txdesc).umac.head_len + 0x18;
    }
    uVar5 = me_build_authenticate
                      ((int)ptVar4[1].dma_desc + iVar8 + -0x18,(ushort)psVar3->auth_type,auth_seq,0,
                       challenge);
    bVar1 = (frame->txdesc).umac.tail_len;
    ptVar6 = (frame->txdesc).lmac.hw_desc;
    (frame->cfm).env = frame;
    iVar8 = CONCAT22(extraout_var,uVar5) + (uint)bVar1 + iVar8;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar6->thd).frmlen = iVar8 + 4;
    (ptVar6->thd).field_5 = (ptVar6->thd).field_4 + -1 + iVar8;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,5);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  sm_connect_ind(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: ie_addr

void sm_assoc_req_send(void)

{
  byte bVar1;
  u8_l uVar2;
  sm_connect_req *con_par;
  sm_connect_ind *psVar3;
  txl_buffer_tag *ptVar4;
  uint16_t uVar5;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  tx_hw_desc *ptVar6;
  undefined uVar7;
  sm_connect_ind *psVar8;
  uint uVar9;
  mac_addr *old_ap_addr_ptr;
  ushort uStack54;
  uint16_t ie_len;
  uint32_t uStack52;
  uint32_t ie_addr;
  
  con_par = sm_env.connect_param;
  uVar9 = (uint)(sm_env.connect_param)->vif_idx;
  bVar1 = *(byte *)&vif_info_tab[uVar9].u.field_0x4;
  frame = txl_frame_get((uint)((vif_info_tab[uVar9].bss_info.chan)->band != '\0'),0x100);
  psVar3 = sm_env.connect_ind;
  if (frame == (txl_frame_desc_tag *)0x0) {
    sm_connect_ind(4);
  }
  else {
    tpc_update_frame_tx_power(vif_info_tab + uVar9,frame);
    ptVar4 = (frame->txdesc).lmac.buffer;
    old_ap_addr_ptr = (mac_addr *)0x0;
    uVar7 = sm_env.ft_over_ds;
    if (sm_env.ft_over_ds != false) {
      uVar7 = 0x20;
      old_ap_addr_ptr = &sm_env.ft_old_bssid;
    }
    *(undefined *)&ptVar4[1].length = uVar7;
    *(undefined *)((int)&ptVar4[1].length + 1) = 0;
    *(undefined *)((int)&ptVar4[1].length + 2) = 0;
    *(undefined *)((int)&ptVar4[1].length + 3) = 0;
    memcpy(&ptVar4[1].lenheader,&sta_info_tab[bVar1].mac_addr,6);
    memcpy((void *)((int)&ptVar4[1].lenpad + 2),&vif_info_tab[uVar9].mac_addr,6);
    memcpy(&ptVar4[1].next,&sta_info_tab[bVar1].mac_addr,6);
    uVar5 = txl_get_seq_ctrl();
    *(char *)((int)&ptVar4[1].txdesc + 2) = (char)uVar5;
    *(char *)((int)&ptVar4[1].txdesc + 3) = (char)(uVar5 >> 8);
    uVar5 = me_build_associate_req
                      ((uint32_t)ptVar4[1].dma_desc,&vif_info_tab[uVar9].bss_info,old_ap_addr_ptr,
                       vif_info_tab[uVar9].index,(uint32_t *)&stack0xffffffcc,&uStack54,con_par);
    ptVar6 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = vif_info_tab[uVar9].index;
    uVar2 = *(u8_l *)&vif_info_tab[uVar9].u.field_0x4;
    (frame->cfm).env = frame;
    (frame->txdesc).host.staid = uVar2;
    (frame->cfm).cfm_func = sm_frame_tx_cfm_handler;
    (ptVar6->thd).field_5 = (ptVar6->thd).field_4 + 0x17 + CONCAT22(extraout_var,uVar5);
    (ptVar6->thd).frmlen = CONCAT22(extraout_var,uVar5) + 0x1c;
    psVar8 = psVar3;
    while (psVar8 != (sm_connect_ind *)((int)psVar3->assoc_ie_buf + (uStack54 - 0x14))) {
      *(undefined *)psVar8->assoc_ie_buf = *(undefined *)((uStack52 - (int)psVar3) + (int)psVar8);
      psVar8 = (sm_connect_ind *)((int)&psVar8->status_code + 1);
    }
    psVar3->assoc_req_ie_len = uStack54;
    txl_frame_push(frame,'\x03');
    ke_timer_set(0x1806,6,0x32000);
    ke_state_set(6,6);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_assoc_done(uint16_t aid)

{
  sm_connect_req *psVar1;
  uint16_t *puVar2;
  
  psVar1 = sm_env.connect_param;
  puVar2 = (uint16_t *)ke_msg_alloc(0x1e,0,6,4);
  *puVar2 = aid;
  *(undefined *)(puVar2 + 1) = 1;
  *(u8_l *)((int)puVar2 + 3) = psVar1->vif_idx;
  ke_msg_send(puVar2);
  ke_state_set(6,7);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_auth_handler(rxu_mgt_ind *param)

{
  uint16_t auth_seq;
  uint32_t *challenge;
  
  ke_timer_clear(0x1806,6);
  if (param[1].center_freq != 0) {
    if (((sm_env.connect_param)->auth_type != '\x01') ||
       ((sm_env.connect_param)->is_supplicant_enabled == false)) {
      printf("Authentication failure, Wlan802.11 status code = %d\r\n");
      sm_connect_ind(2);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    (sm_env.connect_param)->auth_type = '\0';
    challenge = (uint32_t *)0x0;
    auth_seq = 1;
LAB_2300c2aa:
    sm_auth_send(auth_seq,challenge);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (param[1].length != 0) {
    if (param[1].length != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (param[1].framectrl != 4) {
      if (param[1].framectrl != 2) {
        sm_connect_ind(3);
        assert_warn("0","module",0x374);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      if (param->length < 0x88) {
        printf("Drop illegal auth packet length %u\r\n");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      challenge = (uint32_t *)&param[1].inst_nbr;
      auth_seq = 3;
      goto LAB_2300c2aa;
    }
  }
  sm_assoc_req_send();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sm_assoc_rsp_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  sm_connect_ind *psVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t uStack50;
  char acStack49 [3];
  uint8_t idx;
  int8_t pwr;
  
  psVar5 = sm_env.connect_ind;
  uVar8 = (uint)(sm_env.connect_param)->vif_idx;
  uStack50 = '\0';
  bVar1 = *(byte *)&vif_info_tab[uVar8].u.field_0x4;
  ke_timer_clear(0x1806,6);
  uVar6 = (uint)param[1].framectrl;
  if (uVar6 == 0) {
    if (5 < param->length) {
      uVar6 = (uint)(ushort)(param->length - 6);
    }
    sm_assoc_done((ushort)(((uint)param[1].center_freq << 0x12) >> 0x12));
    me_init_rate(sta_info_tab + bVar1);
    acStack49[0] = (vif_info_tab[uVar8].bss_info.chan)->tx_power -
                   vif_info_tab[uVar8].bss_info.power_constraint;
    tpc_update_vif_tx_power(vif_info_tab + uVar8,acStack49,&uStack50);
    uVar2 = psVar5->assoc_req_ie_len;
    uVar7 = 0;
    while (uVar6 != uVar7) {
      iVar4 = uVar7 - 3;
      iVar3 = uVar7 + uVar2;
      uVar7 = uVar7 + 1;
      *(uint8_t *)((int)psVar5->assoc_ie_buf + iVar3) = param[1].sa[iVar4];
    }
    psVar5->assoc_rsp_ie_len = (u16_l)uVar6;
    if ((*(uint *)&vif_info_tab[uVar8].bss_info.is_supplicant_enabled & 0x12a00) != 0) {
      supplicantInitSession
                (&sta_conn_info,(CHAR *)vif_info_tab[uVar8].bss_info.ssid.array,
                 (ushort)vif_info_tab[uVar8].bss_info.ssid.length,
                 (CHAR *)&vif_info_tab[uVar8].bss_info.bssid,(UINT8 *)&vif_info_tab[uVar8].mac_addr)
      ;
    }
  }
  else {
    printf("Association failure, Wlan802.11 status code = %d\r\n",uVar6);
    sm_connect_ind(5);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int sm_deauth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  ushort reason;
  sm_connect_req *psVar2;
  ke_state_t kVar3;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  
  psVar2 = sm_env.connect_param;
  bVar1 = param->inst_nbr;
  kVar3 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar3) != 8) {
    kVar3 = ke_state_get(6);
    if (CONCAT22(extraout_var_00,kVar3) == 0) {
      if (vif_info_tab[bVar1].active == false) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      reason = param[1].length;
      ke_state_set(6,8);
      printf("Deauth by AP, Wlan802.11 reason code = %d\r\n",(uint)reason);
      sm_disconnect_process(vif_info_tab + bVar1,reason);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (psVar2->vif_idx == param->inst_nbr) {
      sm_connect_ind(6);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 2;
}



void sm_handle_supplicant_result(uint8_t sta_id,uint16_t reason_code)

{
  byte bVar1;
  txl_buffer_tag *ptVar2;
  _Bool _Var3;
  uint16_t uVar4;
  undefined3 in_register_00002029;
  int iVar5;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  tx_hw_desc *ptVar6;
  uint uVar7;
  
  iVar5 = CONCAT31(in_register_00002029,sta_id);
  bVar1 = sta_info_tab[iVar5].inst_nbr;
  uVar7 = (uint)bVar1;
  if (CONCAT22(in_register_0000202e,reason_code) == 0) {
    sta_info_tab[iVar5].ctrl_port_state = '\x02';
    uVar4 = 0;
  }
  else {
    if (CONCAT22(in_register_0000202e,reason_code) == 0xf) {
      printf(
            "4-way handshake timeout failure, wlan 802.11 reason code = %u,                try to transmit deauth frame\r\n"
            );
    }
    frame = txl_frame_get((uint)((vif_info_tab[uVar7].bss_info.chan)->band != '\0'),0x100);
    if (frame == (txl_frame_desc_tag *)0x0) {
      uVar4 = 10;
    }
    else {
      tpc_update_frame_tx_power(vif_info_tab + uVar7,frame);
      ptVar2 = (frame->txdesc).lmac.buffer;
      *(undefined *)&ptVar2[1].length = 0xc0;
      *(undefined *)((int)&ptVar2[1].length + 1) = 0;
      *(undefined *)((int)&ptVar2[1].length + 2) = 0;
      *(undefined *)((int)&ptVar2[1].length + 3) = 0;
      memcpy(&ptVar2[1].lenheader,&sta_info_tab[iVar5].mac_addr,6);
      memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif_info_tab[uVar7].mac_addr,6);
      memcpy(&ptVar2[1].next,&sta_info_tab[iVar5].mac_addr,6);
      uVar4 = txl_get_seq_ctrl();
      *(char *)((int)&ptVar2[1].txdesc + 2) = (char)uVar4;
      *(char *)((int)&ptVar2[1].txdesc + 3) = (char)(uVar4 >> 8);
      (frame->cfm).cfm_func = sm_supplicant_deauth_cfm;
      (frame->cfm).env = vif_info_tab + uVar7;
      (frame->txdesc).host.vif_idx = bVar1;
      (frame->txdesc).host.staid = sta_id;
      uVar4 = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,reason_code);
      ptVar6 = (frame->txdesc).lmac.hw_desc;
      (ptVar6->thd).frmlen = CONCAT22(extraout_var_00,uVar4) + 0x1c;
      (ptVar6->thd).field_5 = (ptVar6->thd).field_4 + 0x17 + CONCAT22(extraout_var_00,uVar4);
      _Var3 = txl_frame_push(frame,'\x03');
      if (CONCAT31(extraout_var,_Var3) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar4 = 9;
    }
  }
  sm_connect_ind(uVar4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t txu_cntrl_sec_hdr_append(txdesc *txdesc,uint32_t buf,_Bool umac_pol)

{
  uint8_t uVar1;
  ushort uVar2;
  u16_l *puVar3;
  undefined3 in_register_00002031;
  txl_buffer_control *ptVar4;
  uint uVar5;
  key_info_tag *pkVar6;
  
  uVar5 = (uint)(txdesc->host).staid;
  pkVar6 = *sta_info_tab[uVar5].sta_sec_info.cur_key;
  if (pkVar6 == (key_info_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint32_t)(u16_l *)buf;
  }
  if (((vif_info_tab[(txdesc->host).vif_idx].flags & 2) != 0) &&
     (uVar2 = (txdesc->host).ethertype,
     (uint)sta_info_tab[uVar5].ctrl_port_ethertype == ((uVar2 & 0xff) << 8 | (uint)(uVar2 >> 8)))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint32_t)(u16_l *)buf;
  }
  uVar1 = pkVar6->cipher;
  if (uVar1 == '\x01') {
    uVar2 = (txdesc->host).pn[0];
    *(ushort *)(buf - 8) = uVar2 & 0x7f00 | 0x2000 | uVar2 >> 8;
    uVar2 = (ushort)*(byte *)(txdesc->host).pn | (ushort)pkVar6->key_idx << 0xe;
LAB_2300c744:
    puVar3 = (u16_l *)(buf - 8);
    *(ushort *)(buf - 6) = uVar2 | 0x2000;
    *(u16_l *)(buf - 4) = (txdesc->host).pn[1];
    *(u16_l *)(buf - 2) = (txdesc->host).pn[2];
  }
  else {
    if (uVar1 != '\0') {
      if (uVar1 == '\x02') {
        *(u16_l *)(buf - 8) = (txdesc->host).pn[0];
        uVar2 = (ushort)pkVar6->key_idx << 0xe;
        goto LAB_2300c744;
      }
      puVar3 = (u16_l *)buf;
      if (uVar1 != '\x03') goto LAB_2300c6f6;
    }
    puVar3 = (u16_l *)(buf - 4);
    *puVar3 = (txdesc->host).pn[0];
    *(ushort *)(buf - 2) = (ushort)pkVar6->key_idx << 0xe | (txdesc->host).pn[1];
  }
LAB_2300c6f6:
  if (CONCAT31(in_register_00002031,umac_pol) == 0) {
    ptVar4 = &((txdesc->lmac).buffer)->buffer_control;
  }
  else {
    ptVar4 = (txdesc->umac).buf_control;
  }
  *(uint *)&(ptVar4->field_0).field_0xc =
       (uint)pkVar6->hw_key_idx | *(uint *)&(ptVar4->field_0).field_0xc & 0xffc00;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint32_t)puVar3;
}



int txu_cntrl_sechdr_len_compute(txdesc *txdesc,int *tail_len)

{
  byte bVar1;
  uint8_t uVar2;
  ushort uVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  key_info_tag *pkVar8;
  
  bVar1 = (txdesc->host).vif_idx;
  pkVar8 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  *tail_len = 0;
  if (pkVar8 == (key_info_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  if (((vif_info_tab[bVar1].flags & 2) != 0) &&
     (uVar3 = (txdesc->host).ethertype,
     (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype ==
     ((uVar3 & 0xff) << 8 | (uint)(uVar3 >> 8)))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uVar2 = pkVar8->cipher;
  if (uVar2 == '\x01') {
    iVar4 = 0xc;
LAB_2300c83a:
    *tail_len = iVar4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar4 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(uint *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar4;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,6);
    }
    iVar4 = 8;
  }
  else {
    if (uVar2 != '\0') {
      if (uVar2 == '\x02') {
        iVar4 = 8;
        goto LAB_2300c83a;
      }
      if (uVar2 != '\x03') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    *tail_len = 4;
    iVar4 = 4;
    if (((txdesc->host).flags & 1) == 0) {
      uVar7 = *(uint *)&pkVar8->tx_pn;
      iVar5 = *(int *)((int)&pkVar8->tx_pn + 4);
      uVar6 = uVar7 + 1;
      *(uint *)&pkVar8->tx_pn = uVar6;
      *(uint *)((int)&pkVar8->tx_pn + 4) = (uint)(uVar6 < uVar7) + iVar5;
      memcpy((txdesc->host).pn,&pkVar8->tx_pn,4);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



void txu_cntrl_frame_build(txdesc *txdesc,uint32_t buf)

{
  u8_l uVar1;
  byte bVar2;
  uint32_t uVar3;
  ushort *puVar4;
  undefined2 *buf_00;
  ushort *puVar5;
  uint uVar6;
  ushort uVar7;
  ushort uVar8;
  int iVar9;
  ushort *puVar10;
  uint uVar11;
  key_info_tag *pkVar12;
  
  uVar8 = (txdesc->host).ethertype;
  buf_00 = (undefined2 *)buf;
  if (0x5ff < ((uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8))) {
    buf_00 = (undefined2 *)(buf - 8);
    *buf_00 = 0xaaaa;
    *(undefined2 *)(buf - 6) = 3;
    *(undefined2 *)(buf - 4) = 0;
    *(u16_l *)(buf - 2) = (txdesc->host).ethertype;
  }
  uVar3 = txu_cntrl_sec_hdr_append(txdesc,(uint32_t)buf_00,true);
  uVar6 = (uint)(txdesc->host).staid;
  uVar1 = (txdesc->host).tid;
  uVar11 = (uint)(txdesc->host).vif_idx;
  pkVar12 = *sta_info_tab[uVar6].sta_sec_info.cur_key;
  puVar10 = (ushort *)(uVar3 - 0x1a);
  if (uVar1 == -1) {
    puVar10 = (ushort *)(uVar3 - 0x18);
  }
  puVar4 = puVar10 + 0xc;
  puVar5 = (ushort *)0x0;
  if (((txdesc->host).flags & 0x100) != 0) {
    puVar5 = puVar10 + -3;
    puVar10 = puVar5;
  }
  if (uVar1 == -1) {
    *(undefined *)puVar10 = 0;
    *(undefined *)((int)puVar10 + 1) = 0;
    *(undefined *)(puVar10 + 0xb) = 0;
    *(undefined *)((int)puVar10 + 0x17) = 0;
  }
  else {
    *(undefined *)puVar10 = 0x80;
    *(undefined *)((int)puVar10 + 1) = 0;
    *puVar4 = (ushort)(txdesc->host).tid;
    iVar9 = (uint)(txdesc->host).sn << 0x14;
    *(char *)(puVar10 + 0xb) = (char)((uint)iVar9 >> 0x10);
    *(char *)((int)puVar10 + 0x17) = (char)((uint)iVar9 >> 0x18);
    if (((txdesc->host).flags & 0x200) != 0) {
      *puVar4 = *puVar4 | 0x10;
    }
  }
  uVar7 = *puVar10;
  *(byte *)puVar10 = (byte)uVar7 | 8;
  *(char *)((int)puVar10 + 1) = (char)((uint)uVar7 >> 8);
  uVar8 = (txdesc->host).flags;
  if ((int)((uint)uVar8 << 0x14) < 0) {
    uVar7 = uVar7 & 0xfcff | 8;
LAB_2300c97c:
    *(char *)puVar10 = (char)uVar7;
    *(char *)((int)puVar10 + 1) = (char)(uVar7 >> 8);
  }
  else {
    if ((uVar8 & 0x100) != 0) {
      uVar7 = uVar7 | 0x308;
      goto LAB_2300c97c;
    }
    if (vif_info_tab[uVar11].type == '\0') {
      uVar7 = uVar7 | 0x108;
      goto LAB_2300c97c;
    }
    if (vif_info_tab[uVar11].type == '\x02') {
      uVar7 = uVar7 | 0x208;
      goto LAB_2300c97c;
    }
  }
  if (((txdesc->host).flags & 4) != 0) {
    uVar8 = *puVar10;
    *(char *)puVar10 = (char)uVar8;
    *(byte *)((int)puVar10 + 1) = (byte)((uint)uVar8 >> 8) | 0x20;
  }
  puVar10[5] = vif_info_tab[uVar11].mac_addr.array[0];
  puVar10[6] = vif_info_tab[uVar11].mac_addr.array[1];
  puVar10[7] = vif_info_tab[uVar11].mac_addr.array[2];
  bVar2 = *(byte *)((int)puVar10 + 1) & 3;
  if (bVar2 == 1) {
    puVar10[2] = sta_info_tab[uVar6].mac_addr.array[0];
    puVar10[3] = sta_info_tab[uVar6].mac_addr.array[1];
    puVar10[4] = sta_info_tab[uVar6].mac_addr.array[2];
    puVar10[8] = *(ushort *)(txdesc->host).eth_dest_addr.array;
    puVar10[9] = *(ushort *)((txdesc->host).eth_dest_addr.array + 2);
    uVar8 = *(ushort *)((txdesc->host).eth_dest_addr.array + 4);
  }
  else {
    if (bVar2 == 2) {
      puVar10[2] = *(ushort *)(txdesc->host).eth_dest_addr.array;
      puVar10[3] = *(ushort *)((txdesc->host).eth_dest_addr.array + 2);
      puVar10[4] = *(ushort *)((txdesc->host).eth_dest_addr.array + 4);
      puVar10[8] = *(ushort *)(txdesc->host).eth_src_addr.array;
      puVar10[9] = *(ushort *)((txdesc->host).eth_src_addr.array + 2);
      uVar8 = *(ushort *)((txdesc->host).eth_src_addr.array + 4);
    }
    else {
      if (bVar2 != 0) {
        puVar5[2] = sta_info_tab[uVar6].mac_addr.array[0];
        puVar5[3] = sta_info_tab[uVar6].mac_addr.array[1];
        puVar5[4] = sta_info_tab[uVar6].mac_addr.array[2];
        puVar5[8] = *(ushort *)(txdesc->host).eth_dest_addr.array;
        puVar5[9] = *(ushort *)((txdesc->host).eth_dest_addr.array + 2);
        puVar5[10] = *(ushort *)((txdesc->host).eth_dest_addr.array + 4);
        puVar5[0xc] = *(ushort *)(txdesc->host).eth_src_addr.array;
        puVar5[0xd] = *(ushort *)((txdesc->host).eth_src_addr.array + 2);
        puVar5[0xe] = *(ushort *)((txdesc->host).eth_src_addr.array + 4);
        goto LAB_2300ca20;
      }
      puVar10[2] = *(ushort *)(txdesc->host).eth_dest_addr.array;
      puVar10[3] = *(ushort *)((txdesc->host).eth_dest_addr.array + 2);
      puVar10[4] = *(ushort *)((txdesc->host).eth_dest_addr.array + 4);
      puVar10[8] = vif_info_tab[uVar11].bss_info.bssid.array[0];
      puVar10[9] = vif_info_tab[uVar11].bss_info.bssid.array[1];
      uVar8 = vif_info_tab[uVar11].bss_info.bssid.array[2];
    }
  }
  puVar10[10] = uVar8;
LAB_2300ca20:
  if ((pkVar12 != (key_info_tag *)0x0) &&
     (((vif_info_tab[uVar11].flags & 2) == 0 ||
      (uVar8 = (txdesc->host).ethertype,
      (uint)sta_info_tab[(txdesc->host).staid].ctrl_port_ethertype !=
      ((uVar8 & 0xff) << 8 | (uint)(uVar8 >> 8)))))) {
    uVar8 = *puVar10;
    *(char *)puVar10 = (char)uVar8;
    *(byte *)((int)puVar10 + 1) = (byte)((uint)uVar8 >> 8) | 0x40;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool txu_cntrl_push(txdesc *txdesc,uint8_t access_category)

{
  ushort uVar1;
  ushort uVar2;
  uint16_t uVar3;
  u16_l uVar4;
  char cVar5;
  uint uVar6;
  _Bool _Var7;
  uint8_t uVar8;
  undefined uVar9;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar11;
  uint uVar12;
  uint8_t uVar13;
  txl_buffer_control *ptVar14;
  uint8_t uStack36;
  int tail_len;
  undefined4 uVar10;
  
  uVar6 = (uint)(txdesc->host).vif_idx;
  _Var7 = txl_cntrl_tx_check(vif_info_tab + uVar6);
  iVar11 = CONCAT31(extraout_var,_Var7);
  if (iVar11 == 0) {
LAB_2300cd0e:
    txl_cntrl_inc_pck_cnt();
    txl_cfm_push(txdesc,0xc0000000,access_category);
    uVar9 = 0;
  }
  else {
    uVar1 = (txdesc->host).flags;
    if ((uVar1 & 8) == 0) {
      uVar6 = (uint)(txdesc->host).staid;
      uVar2 = (txdesc->host).ethertype;
      uVar8 = sta_info_tab[uVar6].ctrl_port_state;
      if ((uint)sta_info_tab[uVar6].ctrl_port_ethertype ==
          ((uVar2 & 0xff) << 8 | (uint)(uVar2 >> 8))) {
        (txdesc->host).flags = uVar1 & 0xfeff;
      }
      else {
        iVar11 = 0;
      }
      if ((uVar8 != '\x02') && ((uVar8 != '\x01' || (iVar11 == 0)))) goto LAB_2300cd0e;
      uVar12 = (uint)(txdesc->host).tid;
      cVar5 = '\x18';
      if ((uVar12 != 0xff) && (cVar5 = '\x1a', ((txdesc->host).flags & 1) == 0)) {
        uVar3 = sta_info_tab[uVar6].seq_nbr[uVar12];
        sta_info_tab[uVar6].seq_nbr[uVar12] = uVar3 + 1 & 0xfff;
        (txdesc->host).sn = uVar3;
      }
      if (((txdesc->host).flags & 0x100) != 0) {
        cVar5 = cVar5 + '\x06';
      }
      iVar11 = txu_cntrl_sechdr_len_compute(txdesc,(int *)&uStack36);
      uVar1 = (txdesc->host).ethertype;
      uVar8 = (char)iVar11 + cVar5;
      uVar13 = '\0';
      if (0x600 < ((uVar1 & 0xff) << 8 | (uint)(uVar1 >> 8))) {
        uVar8 = uVar8 + '\b';
        uVar13 = '\b';
      }
      uVar4 = (txdesc->host).packet_len;
      (txdesc->umac).head_len = uVar8;
      uVar8 = (txdesc->host).staid;
      (txdesc->umac).payl_len = uVar4;
      (txdesc->umac).hdr_len_802_2 = uVar13;
      (txdesc->umac).tail_len = uStack36;
      me_check_rc(uVar8,(_Bool *)0x0);
      ptVar14 = me_update_buffer_control(sta_info_tab + (txdesc->host).staid);
      (txdesc->umac).buf_control = ptVar14;
    }
    else {
      if (((uVar1 & 0x10) == 0) && (((vif_info_tab[uVar6].chan_ctxt)->channel).band == '\0')) {
        ptVar14 = &txl_buffer_control_24G;
      }
      else {
        ptVar14 = &txl_buffer_control_5G;
      }
      (txdesc->umac).buf_control = ptVar14;
      uVar8 = tpc_get_vif_tx_power_vs_rate
                        (*(uint32_t *)&(((txdesc->umac).buf_control)->field_0).field_0x14);
      uVar10 = CONCAT31(extraout_var_00,uVar8);
      *(undefined4 *)&(((txdesc->umac).buf_control)->field_0).field_0x24 = uVar10;
      *(undefined4 *)&(((txdesc->umac).buf_control)->field_0).field_0x28 = uVar10;
      *(undefined4 *)&(((txdesc->umac).buf_control)->field_0).field_0x2c = uVar10;
      *(undefined4 *)&(((txdesc->umac).buf_control)->field_0).field_0x30 = uVar10;
      (txdesc->umac).head_len = '\0';
      (txdesc->umac).tail_len = '\0';
    }
    uVar9 = txl_cntrl_push(txdesc,access_category);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)uVar9;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txu_cntrl_tkip_mic_append(txdesc *txdesc,uint8_t ac)

{
  uint8_t uVar1;
  byte bVar2;
  byte bVar3;
  txl_buffer_tag *ptVar4;
  uint32_t uVar5;
  int iVar6;
  key_info_tag *pkVar7;
  int iVar8;
  tx_pbd *ptVar9;
  undefined *puVar10;
  undefined *puVar11;
  tx_pbd *ptVar12;
  txl_buffer_tag *ptVar13;
  undefined auStack48 [4];
  mic_calc mic;
  
  pkVar7 = *sta_info_tab[(txdesc->host).staid].sta_sec_info.cur_key;
  if (pkVar7 != (key_info_tag *)0x0) {
    uVar1 = pkVar7->cipher;
    ptVar4 = (txdesc->lmac).buffer;
    if (uVar1 != '\x01') {
      if ((uVar1 == '\0') || (uVar1 == '\x03')) {
        ptVar9 = &ptVar4->tbd;
        do {
          ptVar12 = ptVar9;
          ptVar9 = (tx_pbd *)ptVar12->next;
        } while (ptVar9 != (tx_pbd *)0x0);
        ptVar12->next = (uint32_t)&ptVar4->tkip_mic_icv_pbd;
        (ptVar4->tkip_mic_icv_pbd).datastartptr = (uint32_t)ptVar4->tkip_mic_icv;
        (ptVar4->tkip_mic_icv_pbd).dataendptr = (uint32_t)(ptVar4->tkip_mic_icv + 3);
        (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
        (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
        (ptVar4->tkip_mic_icv_pbd).next = 0;
      }
LAB_2300ce34:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    ptVar9 = &ptVar4->tbd;
    do {
      ptVar12 = ptVar9;
      ptVar9 = (tx_pbd *)ptVar12->next;
    } while (ptVar9 != (tx_pbd *)0x0);
    bVar2 = (txdesc->umac).head_len;
    bVar3 = (txdesc->umac).hdr_len_802_2;
    ptVar12->next = (uint32_t)&ptVar4->tkip_mic_icv_pbd;
    (ptVar4->tkip_mic_icv_pbd).datastartptr = (uint32_t)ptVar4->tkip_mic_icv;
    (ptVar4->tkip_mic_icv_pbd).dataendptr = (uint32_t)(ptVar4->tkip_mic_icv + 0xb);
    (ptVar4->tkip_mic_icv_pbd).upatterntx = 0xcafefade;
    (ptVar4->tkip_mic_icv_pbd).bufctrlinfo = 0;
    (ptVar4->tkip_mic_icv_pbd).next = 0;
    ptVar13 = (txdesc->lmac).buffer;
    me_mic_init((mic_calc *)auStack48,(uint32_t *)&pkVar7->u,
                (mac_addr *)&(txdesc->host).eth_dest_addr,(mac_addr *)&(txdesc->host).eth_src_addr,
                (txdesc->host).tid);
    me_mic_calc((mic_calc *)auStack48,(int)ptVar4 + (uint)bVar2 + (0x14c - (uint)bVar3),
                (uint)(txdesc->umac).hdr_len_802_2);
    uVar5 = (ptVar13->tbd).next;
    while (uVar5 != 0) {
      iVar6 = *(int *)(uVar5 + 4);
      if (iVar6 == 0) {
        me_mic_end((mic_calc *)auStack48);
        iVar8 = *(int *)(uVar5 + 8);
        do {
          puVar10 = auStack48 + iVar6;
          puVar11 = (undefined *)(iVar8 + iVar6);
          iVar6 = iVar6 + 1;
          *puVar11 = *puVar10;
        } while (iVar6 != 8);
        goto LAB_2300ce34;
      }
      me_mic_calc((mic_calc *)auStack48,*(uint32_t *)(uVar5 + 8),
                  (*(int *)(uVar5 + 0xc) + 1) - *(uint32_t *)(uVar5 + 8));
      uVar5 = *(uint32_t *)(uVar5 + 4);
    }
    me_mic_end((mic_calc *)auStack48);
    ebreak();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txu_cntrl_cfm(txdesc *txdesc)

{
  ushort uVar1;
  tx_cfm_tag *ptVar2;
  uint32_t *puVar3;
  
  puVar3 = (uint32_t *)(txdesc->host).status_addr;
  ptVar2 = ((txdesc->lmac).hw_desc)->cfm_ptr;
  uVar1 = (txdesc->host).flags;
  if ((uVar1 & 8) == 0) {
    if ((uVar1 & 0x200) == 0) goto LAB_2300cefc;
  }
  else {
    if (((uVar1 & 0x20) != 0) && (-1 < (int)(ptVar2->status << 8))) {
      rxu_cntrl_get_pm();
    }
    if (((txdesc->host).flags & 0x200) == 0) goto LAB_2300cefc;
    if ((txdesc->host).staid == -1) {
      assert_err("txdesc->host.staid != INVALID_STA_IDX","module",0x3a9);
    }
    txl_frame_send_qosnull_frame((txdesc->host).staid,0x17,(cfm_func_ptr *)0x0,(void *)0x0);
  }
  sta_info_tab[(txdesc->host).staid].ps_service_period = 0;
LAB_2300cefc:
  ptVar2->status = ptVar2->status | 1;
  *(undefined2 *)&ptVar2->credits = 0x101;
  txdesc[-1].buf[0x6b] = 0;
  *puVar3 = ptVar2->status;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txu_cntrl_protect_mgmt_frame(txdesc *txdesc,uint32_t frame,uint16_t hdr_len)

{
  ushort uVar1;
  uint uVar2;
  undefined2 in_register_00002032;
  uint uStack20;
  int tail_len;
  
  uVar2 = (uint)(txdesc->umac).head_len;
  if (uVar2 == 0) {
    uVar2 = txu_cntrl_sechdr_len_compute(txdesc,(int *)&uStack20);
    (txdesc->umac).head_len = (uint8_t)uVar2;
    (txdesc->umac).tail_len = (uint8_t)uStack20;
  }
  else {
    uStack20 = (uint)(txdesc->umac).tail_len;
  }
  uVar1 = *(ushort *)frame;
  *(undefined *)frame = *(undefined *)frame;
  *(byte *)(frame + 1) = (byte)((uint)uVar1 >> 8) | 0x40;
  txu_cntrl_sec_hdr_append(txdesc,CONCAT22(in_register_00002032,hdr_len) + frame + uVar2,false);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int _aid_list_delete(uint8_t *mac)

{
  int iVar1;
  int iVar2;
  apm *paVar3;
  
  paVar3 = &apm_env;
  iVar1 = 0;
  do {
    if (paVar3->aid_list[0].used != '\0') {
      iVar2 = memcmp(paVar3->aid_list,mac,6);
      if (iVar2 == 0) {
        memset(paVar3->aid_list,0,6);
        apm_env.aid_list[iVar1].used = '\0';
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    iVar1 = iVar1 + 1;
    paVar3 = (apm *)((int)&(paVar3->bss_config).first + 3);
  } while (iVar1 != 10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void apm_sta_delete(uint8_t sta_idx,uint8_t *mac)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0x1409,5,7,2);
  puVar2 = (uint8_t *)ke_msg_alloc(0x1c09,0xd,7,1);
  _aid_list_delete(mac);
  mm_sec_machwkey_del(sta_idx + '\b');
  apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
  *puVar2 = sta_idx;
  ke_msg_send(puVar2);
  *puVar1 = sta_idx;
  puVar1[1] = '\0';
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_tx_cfm_handler(void *env,uint32_t status)

{
  if (-1 < (int)(status << 8)) {
    _aid_list_delete((uint8_t *)env);
    ke_msg_free((void *)((int)env + -0xc));
    printf("apm mlme assoc rsp send failed:%d,aid:%d\n",status,(uint)*(ushort *)((int)env + 0x44));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    apm_env.assoc_sta_count = apm_env.assoc_sta_count + -1;
    return;
  }
  if (*(short *)((int)env + 0x44) != 0) {
    ke_msg_send(env);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ke_msg_free((void *)((int)env + -0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_init(void)

{
  memset(&apm_env,0,0x60);
  apm_env.aging_sta_idx = '\0';
  apm_env._22_2_ = 0xc00;
  ke_state_set(7,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_start_cfm(uint8_t status)

{
  byte bVar1;
  uint16_t uVar2;
  apm_start_req *__src;
  undefined3 in_register_00002029;
  uint8_t *puVar3;
  void *pvVar4;
  uint uVar5;
  int iVar6;
  
  __src = apm_env.param;
  puVar3 = (uint8_t *)ke_msg_alloc(0x1c01,0xd,7,4);
  if (CONCAT31(in_register_00002029,status) == 0) {
    uVar5 = (uint)__src->vif_idx;
    pvVar4 = ke_msg_alloc(0x1e,0,7,4);
    iVar6 = uVar5 + 10;
    *(undefined *)((int)pvVar4 + 2) = 1;
    *(uint8_t *)((int)pvVar4 + 3) = vif_info_tab[uVar5].index;
    ke_msg_send(pvVar4);
    vif_info_tab[uVar5].flags = __src->flags;
    uVar2 = __src->ctrl_port_ethertype;
    *(undefined *)&vif_info_tab[uVar5].u.field_0x2ee = 0;
    *(uint16_t *)&vif_info_tab[uVar5].u.field_0x2f0 = uVar2;
    puVar3[2] = (vif_info_tab[uVar5].chan_ctxt)->idx;
    puVar3[3] = __src->vif_idx + '\n';
    memcpy(&sta_info_tab[iVar6].info,__src,0xd);
    sta_info_tab[iVar6].ctrl_port_state = '\x02';
    me_init_bcmc_rate(sta_info_tab + iVar6);
    bVar1 = sta_info_tab[iVar6].pol_tbl.upd_field;
    sta_info_tab[iVar6].mac_addr.array[0] = 1;
    sta_info_tab[iVar6].pol_tbl.upd_field = bVar1 | 0x10;
    sta_info_tab[iVar6].staid = __src->vif_idx + '\n';
  }
  *puVar3 = status;
  puVar3[1] = __src->vif_idx;
  ke_timer_set(0x1c0a,7,5000000);
  ke_msg_send(puVar3);
  ke_msg_free(__src[-1].phrase + 0x35);
  apm_env.param = (apm_start_req *)0x0;
  ke_state_set(7,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_send_next_bss_param(void)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = co_list_pop_front(&apm_env.bss_config);
  if (pcVar1 == (co_list_hdr *)0x0) {
    assert_err("msg != NULL","module",0xbf);
  }
  ke_msg_send(pcVar1 + 3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_set_bss_param(void)

{
  byte bVar1;
  apm_start_req *rateset;
  uint16_t uVar2;
  undefined *puVar3;
  void *__dest;
  undefined4 *puVar4;
  uint16_t *puVar5;
  undefined *puVar6;
  undefined2 extraout_var;
  
  rateset = apm_env.param;
  bVar1 = (apm_env.param)->vif_idx;
  puVar3 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  __dest = ke_msg_alloc(0x18,0,7,7);
  puVar4 = (undefined4 *)ke_msg_alloc(0x16,0,7,8);
  puVar5 = (uint16_t *)ke_msg_alloc(0x14,0,7,4);
  puVar6 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  *puVar3 = 1;
  puVar3[1] = vif_info_tab[bVar1].index;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar3 + -0xc));
  memcpy(__dest,&vif_info_tab[bVar1].mac_addr,6);
  *(uint8_t *)((int)__dest + 6) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)((int)__dest + -0xc));
  *(uint8_t *)((int)puVar4 + 5) = (rateset->chan).band;
  uVar2 = me_legacy_rate_bitfield_build((mac_rateset *)rateset,true);
  *puVar4 = CONCAT22(extraout_var,uVar2);
  *(uint8_t *)(puVar4 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar4 + -3));
  *puVar5 = rateset->bcn_int;
  *(uint8_t *)(puVar5 + 1) = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar5 + -6));
  *puVar6 = 1;
  puVar6[1] = rateset->vif_idx;
  co_list_push_back(&apm_env.bss_config,(co_list_hdr *)(puVar6 + -0xc));
  apm_send_next_bss_param();
  ke_state_set(7,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_stop(vif_info_tag *vif)

{
  undefined *puVar1;
  undefined *puVar2;
  void *pvVar3;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1413,5,7,2);
  puVar2 = (undefined *)ke_msg_alloc(0x1411,5,7,2);
  ke_timer_clear(0x1c0a,7);
  *puVar1 = 0;
  puVar1[1] = vif->index;
  ke_msg_send(puVar1);
  if (vif->active != false) {
    pvVar3 = ke_msg_alloc(0x1e,0,7,4);
    *(undefined *)((int)pvVar3 + 2) = 0;
    *(uint8_t *)((int)pvVar3 + 3) = vif->index;
    ke_msg_send(pvVar3);
  }
  if (vif->chan_ctxt != (chan_ctxt_tag *)0x0) {
    chan_ctxt_unlink(vif->index);
  }
  *puVar2 = 0;
  puVar2[1] = vif->index;
  ke_msg_send(puVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool apm_tx_int_ps_check(txdesc *txdesc)

{
  uint uVar1;
  _Bool _Var2;
  
  if (vif_info_tab[(txdesc->host).vif_idx].type == '\x02') {
    uVar1 = (uint)(txdesc->host).staid;
    _Var2 = true;
    if (((uVar1 < 0xc) && (sta_info_tab[uVar1].ps_state == '\x01')) &&
       ((sta_info_tab[uVar1].ps_service_period & 3U) == 0)) {
      (txdesc->host).flags = (txdesc->host).flags | 0x1000;
      _Var2 = false;
    }
  }
  else {
    _Var2 = true;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



void apm_tx_int_ps_postpone(txdesc *txdesc,sta_info_tag *sta)

{
  byte bVar1;
  sta_ps_traffic sVar2;
  sta_ps_traffic sVar3;
  uint16_t *puVar4;
  
  if ((int)((uint)(txdesc->host).flags << 0x13) < 0) {
    bVar1 = (sta->info).uapsd_queues;
    sVar2 = sta->traffic_avail;
    if ((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) {
      if ((sVar2 & PS_TRAFFIC_INT) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      sVar3 = PS_TRAFFIC_INT;
    }
    else {
      sVar3 = UAPSD_TRAFFIC_INT;
      if ((sVar2 & UAPSD_TRAFFIC_INT) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    sta->traffic_avail = sVar2 | sVar3;
    if (((mac_ac2uapsd[(txdesc->host).tid] & bVar1) == 0) || (bVar1 == 0xf)) {
      puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
      *puVar4 = sta->aid;
      *(uint8_t *)((int)puVar4 + 3) = sta->inst_nbr;
      *(undefined *)(puVar4 + 1) = 1;
      ke_msg_send(puVar4);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

txdesc * apm_tx_int_ps_get_postpone(vif_info_tag *vif,sta_info_tag *sta,int *stop)

{
  uint8_t uVar1;
  ushort uVar2;
  co_list_hdr cVar3;
  co_list_hdr element;
  uint16_t *puVar4;
  co_list_hdr *pcVar5;
  uint uVar6;
  int *piVar7;
  sta_ps_traffic sVar8;
  sta_ps_traffic sVar9;
  co_list_hdr prev_element;
  
  sVar8 = vif->type;
  if ((sVar8 == PS_TRAFFIC_INT) && (uVar6 = sta->ps_service_period, uVar6 != 0)) {
    sVar9 = PS_TRAFFIC_HOST;
    if ((uVar6 & 1) == 0) {
      sVar9 = UAPSD_TRAFFIC_HOST;
      sVar8 = UAPSD_TRAFFIC_INT;
    }
    if ((sVar8 & sta->traffic_avail) != 0) {
      cVar3 = (co_list_hdr)(sta->tx_desc_post).first;
      prev_element = (co_list_hdr)(co_list_hdr *)0x0;
      while( true ) {
        element = cVar3;
        if (element == (co_list_hdr)0x0) {
          assert_warn("txdesc","module",0x16f);
          *stop = 1;
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return (txdesc *)(co_list_hdr)0x0;
        }
        if (((mac_ac2uapsd[*(byte *)((int)element + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (uVar6 == 2)) break;
        cVar3 = *(co_list_hdr *)element;
        prev_element = element;
      }
      co_list_remove(&sta->tx_desc_post,(co_list_hdr *)prev_element,(co_list_hdr *)element);
      *(char *)((int)element + 0x2e) = ((sta->ps_service_period & 8U) != 0) + '\x03';
      if (prev_element == (co_list_hdr)0x0) {
        piVar7 = (int *)(sta->tx_desc_post).first;
      }
      else {
        piVar7 = (int *)*(co_list_hdr **)prev_element;
      }
      while (piVar7 != (int *)0x0) {
        if (((mac_ac2uapsd[*(byte *)((int)piVar7 + 0x2e)] & (sta->info).uapsd_queues) == 0) !=
            (sta->ps_service_period == 2)) goto LAB_2300d610;
        piVar7 = (int *)*piVar7;
      }
      sVar8 = ~sVar8 & sta->traffic_avail;
      sta->traffic_avail = sVar8;
      if ((sVar8 & sVar9) == 0) {
        puVar4 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
        *puVar4 = sta->aid;
        uVar1 = sta->inst_nbr;
        *(undefined *)(puVar4 + 1) = 0;
        *(uint8_t *)((int)puVar4 + 3) = uVar1;
        ke_msg_send(puVar4);
      }
      else {
LAB_2300d610:
        pcVar5 = ((co_list_hdr *)((int)element + 0x68))->next;
        uVar2 = *(ushort *)&pcVar5[0x53].next;
        *(char *)&pcVar5[0x53].next = (char)uVar2;
        *(byte *)((int)&pcVar5[0x53].next + 1) = (byte)((uint)uVar2 >> 8) | 0x20;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (txdesc *)element;
    }
    *stop = 1;
  }
  else {
    *stop = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (txdesc *)(co_list_hdr)0x0;
}



void apm_tx_int_ps_clear(vif_info_tag *vif,uint8_t sta_idx)

{
  sta_ps_traffic sVar1;
  uint8_t uVar2;
  uint16_t *puVar3;
  undefined3 in_register_0000202d;
  int iVar4;
  
  iVar4 = CONCAT31(in_register_0000202d,sta_idx);
  if (vif->type != '\x02') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  sta_mgmt_send_postponed_frame(vif,sta_info_tab + iVar4,0);
  sVar1 = sta_info_tab[iVar4].traffic_avail;
  if (((sVar1 & (PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) != 0) &&
     (sta_info_tab[iVar4].traffic_avail = sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT),
     (sVar1 & ~(PS_TRAFFIC_INT|UAPSD_TRAFFIC_INT)) == 0)) {
    puVar3 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
    *puVar3 = sta_info_tab[iVar4].aid;
    uVar2 = sta_info_tab[iVar4].inst_nbr;
    *(undefined *)(puVar3 + 1) = 0;
    *(uint8_t *)((int)puVar3 + 3) = uVar2;
    ke_msg_send(puVar3);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_sta_fw_delete(uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  
  apm_sta_delete(sta_idx,(uint8_t *)&sta_info_tab[CONCAT31(in_register_00002029,sta_idx)].mac_addr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_sta_add(uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint32_t *puVar2;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  puVar2 = (uint32_t *)ke_msg_alloc(0x1c08,0xd,7,0x1c);
  sta_info_tab[iVar1].ctrl_port_state = '\x02';
  *puVar2 = sta_info_tab[iVar1].info.capa_flags;
  memcpy(puVar2 + 1,&sta_info_tab[iVar1].mac_addr,6);
  *(uint8_t *)((int)puVar2 + 0xb) = sta_info_tab[iVar1].staid;
  *(uint8_t *)((int)puVar2 + 10) = sta_info_tab[iVar1].inst_nbr;
  *(int8_t *)(puVar2 + 3) = sta_info_tab[iVar1].rssi;
  puVar2[4] = sta_info_tab[iVar1].tsflo;
  puVar2[5] = sta_info_tab[iVar1].tsfhi;
  *(uint8_t *)(puVar2 + 6) = sta_info_tab[iVar1].data_rate;
  ke_msg_send(puVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_send_mlme(vif_info_tag *vif,uint16_t fctl,mac_addr *ra,cfm_func_ptr *cfm_func,void *env,
                  uint16_t status_code)

{
  uint8_t uVar1;
  txl_buffer_tag *ptVar2;
  uint16_t uVar3;
  txl_frame_desc_tag *frame;
  undefined2 in_register_0000202e;
  uint uVar5;
  int iVar6;
  tx_hw_desc *ptVar7;
  uint uVar4;
  
  uVar4 = CONCAT22(in_register_0000202e,fctl);
  frame = txl_frame_get((uint)(((vif->bss_info).chan)->band != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ptVar2 = (frame->txdesc).lmac.buffer;
  *(char *)((int)&ptVar2[1].length + 1) = (char)(fctl >> 8);
  *(char *)&ptVar2[1].length = (char)fctl;
  *(undefined *)((int)&ptVar2[1].length + 2) = 0;
  *(undefined *)((int)&ptVar2[1].length + 3) = 0;
  memcpy(&ptVar2[1].lenheader,ra,6);
  memcpy((void *)((int)&ptVar2[1].lenpad + 2),&vif->mac_addr,6);
  memcpy(&ptVar2[1].next,&vif->mac_addr,6);
  uVar5 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar5 + 1) * 0x10000 >> 0x10);
  iVar6 = (uVar5 + 1) * 0x100000;
  *(char *)((int)&ptVar2[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
  *(char *)((int)&ptVar2[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
  if (uVar4 == 0xb0) {
    uVar3 = me_build_authenticate((uint32_t)ptVar2[1].dma_desc,0,2,0,(uint32_t *)0x0);
    uVar4 = (uint)uVar3;
  }
  else {
    if (uVar4 == 0xc0) {
      uVar3 = me_build_deauthenticate((uint32_t)ptVar2[1].dma_desc,status_code);
      uVar4 = (uint)uVar3;
    }
    else {
      if (uVar4 == 0x50) {
        uVar3 = me_build_probe_rsp((uint32_t)ptVar2[1].dma_desc,vif->index);
        uVar4 = (uint)uVar3;
      }
      else {
        uVar5 = 0x18;
        if ((uVar4 & 0xffffffdf) != 0x10) goto LAB_2300d868;
        uVar3 = me_build_associate_rsp
                          ((uint32_t)ptVar2[1].dma_desc,vif->index,status_code,(me_sta_add_req *)env
                          );
        uVar4 = (uint)uVar3;
      }
    }
  }
  uVar5 = uVar4 + 0x18 & 0xffff;
LAB_2300d868:
  ptVar7 = (frame->txdesc).lmac.hw_desc;
  (ptVar7->thd).frmlen = uVar5 + 4;
  (ptVar7->thd).field_5 = (ptVar7->thd).field_4 + -1 + uVar5;
  uVar1 = vif->index;
  (frame->txdesc).umac.head_len = '\0';
  (frame->txdesc).umac.tail_len = '\0';
  (frame->txdesc).host.vif_idx = uVar1;
  (frame->txdesc).host.staid = -1;
  (frame->cfm).cfm_func = cfm_func;
  (frame->cfm).env = env;
  txl_frame_push(frame,'\x03');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool apm_embedded_enabled(vif_info_tag *vif)

{
  byte bVar1;
  
  if (vif != (vif_info_tag *)0x0) {
    bVar1 = 0;
    if (vif->type == '\x02') {
      bVar1 = apm_env.apm_emb_enabled;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)(bVar1 & 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return apm_env.apm_emb_enabled;
}



void apm_bcn_set(void)

{
  byte bVar1;
  apm_start_req *paVar2;
  _Bool _Var3;
  uint32_t *puVar4;
  undefined3 extraout_var;
  
  paVar2 = apm_env.param;
  puVar4 = (uint32_t *)ke_msg_alloc(0x3f,0,7,(apm_env.param)->bcn_len + 0xc);
  *puVar4 = paVar2->bcn_addr;
  *(uint16_t *)(puVar4 + 1) = paVar2->bcn_len;
  *(uint16_t *)((int)puVar4 + 6) = paVar2->tim_oft;
  *(uint8_t *)(puVar4 + 2) = paVar2->tim_len;
  bVar1 = paVar2->vif_idx;
  *(byte *)((int)puVar4 + 9) = bVar1;
  _Var3 = apm_embedded_enabled(vif_info_tab + bVar1);
  if (CONCAT31(extraout_var,_Var3) == 0) {
    memcpy(puVar4 + 3,(void *)&paVar2->field_0xa7,(uint)paVar2->bcn_len);
  }
  else {
    memcpy(puVar4 + 3,apm_env.bcn_buf,(uint)paVar2->bcn_len);
    ke_free(apm_env.bcn_buf);
    apm_env.bcn_buf = (uint8_t *)0x0;
  }
  ke_msg_send(puVar4);
  ke_state_set(7,2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_probe_req_handler(rxu_mgt_ind *param)

{
  uint8_t uVar1;
  uint32_t uVar2;
  int iVar3;
  vif_info_tag *vif;
  uint uVar4;
  scan_chan_tag *psVar5;
  uint uVar6;
  
  if (param->inst_nbr == 0xff) {
    vif = vif_mgmt_get_first_ap_inf();
    if (vif == (vif_info_tag *)0x0) goto LAB_2300da76;
  }
  else {
    vif = vif_info_tab + param->inst_nbr;
  }
  uVar2 = mac_ie_find((uint32_t)&param[1].rssi,param->length - 0x18,'\0');
  if ((uVar2 == 0) || (*(byte *)(uVar2 + 1) == 0)) {
    if (apm_env.hidden_ssid != '\0') goto LAB_2300da76;
  }
  else {
    uVar4 = (uint)(vif->bss_info).ssid.length;
    if ((uVar4 != *(byte *)(uVar2 + 1)) ||
       (iVar3 = memcmp((void *)(uVar2 + 2),(vif->bss_info).ssid.array,uVar4), iVar3 != 0))
    goto LAB_2300da76;
  }
  uVar2 = mac_ie_find((uint32_t)&param[1].rssi,param->length - 0x18,'\x03');
  if (uVar2 == 0) goto LAB_2300da50;
  psVar5 = (vif->bss_info).chan;
  uVar1 = psVar5->band;
  uVar4 = (uint)psVar5->freq;
  if (uVar1 == '\0') {
    uVar6 = 0;
    if (((uVar4 - 0x96c & 0xffff) < 0x49) && (uVar6 = 0xe, uVar4 != 0x9b4)) {
      iVar3 = -0x967;
LAB_2300dac6:
      uVar6 = (int)(uVar4 + iVar3) / 5;
    }
  }
  else {
    uVar6 = 0;
    if ((uVar1 == '\x01') && (uVar6 = 0, (uVar4 - 0x138d & 0xffff) < 0x335)) {
      iVar3 = -5000;
      goto LAB_2300dac6;
    }
  }
  if (*(byte *)(uVar2 + 2) != uVar6) {
LAB_2300da76:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_2300da50:
  apm_send_mlme(vif,0x50,(mac_addr *)(param[1].sa + 1),(cfm_func_ptr *)0x0,(void *)0x0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_auth_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  mac_addr *addr;
  uint8_t sta_idx;
  undefined3 extraout_var;
  
  bVar1 = param->inst_nbr;
  if (bVar1 != 0xff) {
    addr = (mac_addr *)(param[1].sa + 1);
    sta_idx = hal_machw_search_addr(addr);
    if (CONCAT31(extraout_var,sta_idx) != 0xff) {
      apm_sta_delete(sta_idx,(uint8_t *)addr);
    }
    apm_send_mlme(vif_info_tab + bVar1,0xb0,addr,(cfm_func_ptr *)0x0,(void *)0x0,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void apm_assoc_req_handler(rxu_mgt_ind *param,_Bool is_reassoc)

{
  uint8_t uVar1;
  IEEEtypes_Addr_t IVar2;
  uint8_t uVar3;
  rxu_mgt_ind *addr;
  int iVar4;
  byte bVar5;
  uint16_t uVar6;
  IEEEtypes_MacAddr_t *peerMacAddr;
  uint32_t uVar7;
  int iVar8;
  uint8_t *puVar9;
  undefined2 extraout_var;
  int iVar10;
  uint16_t uVar11;
  undefined3 in_register_0000202d;
  uint uVar12;
  mac_rateset *pmVar13;
  IEEEtypes_Addr_t *pIVar14;
  IEEEtypes_Addr_t *pIVar15;
  apm *paVar16;
  mac_addr *ra;
  uint uVar17;
  Cipher_t aCStack84 [4];
  Cipher_t sta_cipher;
  uint8_t local_4f [3];
  SecurityMode_t sta_sec;
  
  uVar17 = (uint)param->inst_nbr;
  if (uVar17 == 0xff) goto LAB_2300dc4a;
  peerMacAddr = (IEEEtypes_MacAddr_t *)ke_msg_alloc(0x1407,5,7,0x58);
  ra = (mac_addr *)(param[1].sa + 1);
  memset(peerMacAddr,0,0x58);
  memcpy(peerMacAddr,ra,6);
  peerMacAddr[0xc][1] = param->inst_nbr;
  *(uint32_t *)(peerMacAddr[0xc] + 4) = param->tsflo;
  *(uint32_t *)(peerMacAddr[0xd] + 2) = param->tsfhi;
  peerMacAddr[0xe][0] = param->rssi;
  peerMacAddr[0xe][1] = param->data_rate;
  if (CONCAT31(in_register_0000202d,is_reassoc) == 0) {
    addr = param + 2;
    uVar11 = param->length - 0x1c;
  }
  else {
    addr = (rxu_mgt_ind *)&param[2].band;
    uVar11 = param->length - 0x22;
  }
  uVar6 = 0x33;
  if (*(ushort *)&param[1].ppm_rel <= vif_info_tab[uVar17].bss_info.max_listen_interval) {
    uVar7 = mac_ie_find((uint32_t)addr,uVar11,'\0');
    if (((uVar7 == 0) ||
        (uVar12 = (uint)vif_info_tab[uVar17].bss_info.ssid.length, uVar12 != *(byte *)(uVar7 + 1)))
       || (iVar8 = memcmp((void *)(uVar7 + 2),vif_info_tab[uVar17].bss_info.ssid.array,uVar12),
          iVar8 != 0)) {
      uVar6 = 1;
    }
    else {
      uVar7 = mac_ie_find((uint32_t)addr,uVar11,'\x01');
      uVar6 = 0x12;
      if (uVar7 != 0) {
        uVar12 = (uint)*(byte *)(uVar7 + 1);
        puVar9 = (uint8_t *)(uVar7 + 2);
        _sta_cipher = _sta_cipher & 0xff00 | (ushort)*(byte *)(uVar7 + 1);
        pmVar13 = (mac_rateset *)&sta_cipher;
        while( true ) {
          uVar12 = uVar12 - 1;
          pmVar13 = (mac_rateset *)pmVar13->array;
          if (uVar12 == 0xffffffff) break;
          uVar1 = *puVar9;
          puVar9 = puVar9 + 1;
          pmVar13->length = uVar1;
        }
        uVar7 = mac_ie_find((uint32_t)addr,uVar11,'2');
        if (uVar7 != 0) {
          bVar5 = *(byte *)(uVar7 + 1);
          uVar12 = 0;
          while (bVar5 != uVar12) {
            local_4f[(byte)sta_cipher + uVar12] = *(uint8_t *)(uVar7 + 2 + uVar12);
            uVar12 = uVar12 + 1;
          }
          _sta_cipher = _sta_cipher & 0xff00 | (ushort)(byte)(bVar5 + (char)sta_cipher);
        }
        uVar6 = me_legacy_rate_bitfield_build((mac_rateset *)&sta_cipher,false);
        peerMacAddr[1][0] = '\0';
        uVar12 = 0;
        while (uVar12 < vif_info_tab[uVar17].bss_info.rate_set.length) {
          iVar4 = (int)vif_info_tab[uVar17].txq_params + (uVar12 - 8);
          bVar5 = me_rate_translate(*(uint8_t *)(iVar4 + 0x3b1));
          if ((CONCAT22(extraout_var,uVar6) >> (bVar5 & 0x1f) & 1U) == 0) {
            if (*(char *)(iVar4 + 0x3b1) < '\0') {
              uVar6 = 0x12;
              goto fail;
            }
          }
          else {
            bVar5 = peerMacAddr[1][0];
            peerMacAddr[1][bVar5 + 1] = *(IEEEtypes_Addr_t *)(iVar4 + 0x3b1);
            peerMacAddr[1][0] = bVar5 + 1;
          }
          uVar12 = uVar12 + 1 & 0xff;
        }
        uVar7 = mac_ie_find((uint32_t)addr,uVar11,'-');
        if (uVar7 != 0) {
          *(undefined2 *)(peerMacAddr[3] + 2) = *(undefined2 *)(uVar7 + 2);
          pIVar14 = (IEEEtypes_Addr_t *)(uVar7 + 5);
          peerMacAddr[3][4] = *(IEEEtypes_Addr_t *)(uVar7 + 4);
          pIVar15 = peerMacAddr[3] + 5;
          while (pIVar15 != peerMacAddr[6] + 3) {
            IVar2 = *pIVar14;
            pIVar14 = pIVar14 + 1;
            *pIVar15 = IVar2;
            pIVar15 = pIVar15 + 1;
          }
          *(undefined2 *)(peerMacAddr[6] + 4) = *(undefined2 *)(uVar7 + 0x15);
          *(uint *)(peerMacAddr[7] + 2) = (uint)*(ushort *)(uVar7 + 0x17);
          peerMacAddr[8][0] = *(IEEEtypes_Addr_t *)(uVar7 + 0x1b);
          *(uint *)(peerMacAddr[10] + 4) = *(uint *)(peerMacAddr[10] + 4) | 2;
        }
        uVar7 = mac_vsie_find((uint32_t)addr,uVar11,"",'\x04');
        if (uVar7 != 0) {
          bVar5 = *(byte *)(uVar7 + 8);
          *(uint *)(peerMacAddr[10] + 4) = *(uint *)(peerMacAddr[10] + 4) | 1;
          peerMacAddr[0xb][4] = bVar5 & 0xf;
          peerMacAddr[0xb][5] = bVar5 >> 4 & 6;
        }
        memset((mac_rateset *)&sta_cipher,0,2);
        memset(aCStack84,0,1);
        uVar7 = mac_ie_find((uint32_t)addr,uVar11,'0');
        if (uVar7 == 0) {
          uVar7 = mac_vsie_find((uint32_t)addr,uVar11,"",'\x04');
          if (uVar7 != 0) {
            _sta_cipher = _sta_cipher | 8;
            aCStack84[0] = (Cipher_t)((byte)aCStack84[0] | 4);
          }
        }
        else {
          _sta_cipher = _sta_cipher | 0x20;
          aCStack84[0] = (Cipher_t)((byte)aCStack84[0] | 8);
        }
        if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
          uVar6 = 0x2e;
          if ((_sta_cipher & 0x28) == 0) goto fail;
          InitStaKeyInfo(uap_conn_info,(SecurityMode_t *)(mac_rateset *)&sta_cipher,aCStack84,0,'\0'
                        );
          cm_SetPeerAddr(uap_conn_info,(IEEEtypes_MacAddr_t *)0x0,peerMacAddr);
        }
        uVar3 = apm_env.max_sta_supported;
        uVar1 = apm_env.assoc_sta_count;
        *(undefined2 *)(peerMacAddr[0xb] + 2) = 0;
        if (uVar1 < uVar3) {
          paVar16 = &apm_env;
          iVar4 = -1;
          do {
            if (paVar16->aid_list[0].used == '\0') {
              if (iVar4 == -1) {
                iVar4 = iVar8;
              }
            }
            else {
              iVar10 = memcmp(paVar16->aid_list,ra,6);
              if (iVar10 == 0) {
                apm_env.aid_list[iVar8].used = '\x01';
                iVar4 = iVar8;
                goto LAB_2300dee6;
              }
            }
            iVar8 = iVar8 + 1;
            paVar16 = (apm *)((int)&(paVar16->bss_config).first + 3);
          } while (iVar8 != 10);
          if (iVar4 != -1) {
            memcpy(apm_env.aid_list + iVar4,ra,6);
            apm_env.aid_list[iVar4].used = '\x01';
LAB_2300dee6:
            *(short *)(peerMacAddr[0xb] + 2) = (short)iVar4 + 1;
            apm_env.assoc_sta_count = apm_env.assoc_sta_count + '\x01';
            uVar6 = 0;
            goto fail;
          }
        }
        uVar6 = 0x11;
      }
    }
  }
fail:
  uVar11 = 0x30;
  if (CONCAT31(in_register_0000202d,is_reassoc) == 0) {
    uVar11 = 0x10;
  }
  apm_send_mlme(vif_info_tab + uVar17,uVar11,ra,apm_tx_cfm_handler,peerMacAddr,uVar6);
LAB_2300dc4a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_deauth_handler(rxu_mgt_ind *param)

{
  if ((param->inst_nbr != -1) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,param[1].sa + 1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_disassoc_handler(rxu_mgt_ind *param)

{
  byte bVar1;
  
  bVar1 = param->inst_nbr;
  if ((bVar1 != 0xff) && (param->sta_idx != -1)) {
    apm_sta_delete(param->sta_idx,(uint8_t *)(mac_addr *)(param[1].sa + 1));
    apm_send_mlme(vif_info_tab + bVar1,0xc0,(mac_addr *)(param[1].sa + 1),(cfm_func_ptr *)0x0,
                  (void *)0x0,2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_beacon_handler(rxu_mgt_ind *param)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void apm_sta_remove(uint8_t vif_idx,uint8_t sta_idx)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  apm_send_mlme(vif_info_tab + CONCAT31(in_register_00002029,vif_idx),0xc0,
                &sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr,(cfm_func_ptr *)0x0,
                (void *)0x0,2);
  apm_sta_delete(sta_idx,(uint8_t *)&sta_info_tab[CONCAT31(in_register_0000202d,sta_idx)].mac_addr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



char * cfg_api_element_dump(void *val,CFG_ELEMENT_TYPE type,char *strs)

{
  int iVar1;
  char *pcVar2;
  
  switch(type + ~CFG_ELEMENT_TYPE_UNKNOWN) {
  case CFG_ELEMENT_TYPE_UNKNOWN:
                    // WARNING: Load size is inaccurate
    if (*val == '\0') {
      pcVar2 = "False";
    }
    else {
      pcVar2 = "True";
    }
    iVar1 = snprintf(strs,0xf,"%s",pcVar2);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "Boolean";
    break;
  case CFG_ELEMENT_TYPE_BOOLEAN:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%d",(int)*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT8";
    break;
  case CFG_ELEMENT_TYPE_SINT8:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%u",(uint)*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT8";
    break;
  case CFG_ELEMENT_TYPE_UINT8:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%d",(int)*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT16";
    break;
  case CFG_ELEMENT_TYPE_SINT16:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%u",(uint)*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT16";
    break;
  case CFG_ELEMENT_TYPE_UINT16:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%ld",*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "SINT32";
    break;
  case CFG_ELEMENT_TYPE_SINT32:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%lu",*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "UINT32";
    break;
  case CFG_ELEMENT_TYPE_UINT32:
                    // WARNING: Load size is inaccurate
    iVar1 = snprintf(strs,0xf,"%lu",*val);
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    strs[iVar1] = '\0';
    pcVar2 = "STRING";
    break;
  default:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (char *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar2;
}



int cfg_api_element_general_set(cfg_element_entry *entry,void *arg1,void *arg2)

{
  undefined uVar1;
  undefined2 uVar2;
  ushort uVar3;
  undefined4 *puVar4;
  
  printf("  updating element: %s\r\n",entry->name);
  uVar3 = entry->type - 1;
  if (6 < uVar3) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  puVar4 = (undefined4 *)entry->val;
  switch(uVar3) {
  default:
                    // WARNING: Load size is inaccurate
    uVar1 = *arg1;
    break;
  case 1:
                    // WARNING: Load size is inaccurate
    uVar1 = *arg1;
    break;
  case 3:
                    // WARNING: Load size is inaccurate
    uVar2 = *arg1;
    goto LAB_2300e1dc;
  case 4:
                    // WARNING: Load size is inaccurate
    uVar2 = *arg1;
LAB_2300e1dc:
    *(undefined2 *)puVar4 = uVar2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  case 5:
  case 6:
                    // WARNING: Load size is inaccurate
    *puVar4 = *arg1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  *(undefined *)puVar4 = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int cfg_api_element_general_get(cfg_element_entry *entry,void *arg1,void *arg2)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int cfg_api_element_set(uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  cfg_element_entry *pcVar1;
  
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    if ((pcVar1->task == task) && (pcVar1->element == element)) {
      if (pcVar1->type == type) goto LAB_2300e244;
      printf("type %lu NOT matched on element: %lu %lu %u\r\n",type,task,element);
    }
    pcVar1 = pcVar1 + 1;
  }
  if (pcVar1 != (cfg_element_entry *)&_fsymc_info_bloop) {
LAB_2300e244:
    (*pcVar1->set)(pcVar1,arg1,arg2);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void co_list_init(co_list *list)

{
  list->first = (co_list_hdr *)0x0;
  list->last = (co_list_hdr *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void co_list_push_back(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x47);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (co_list_hdr *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void co_list_push_front(co_list *list,co_list_hdr *list_hdr)

{
  if (list_hdr == (co_list_hdr *)0x0) {
    assert_err("list_hdr != NULL","module",0x5e);
  }
  if (list->first == (co_list_hdr *)0x0) {
    list->last = list_hdr;
  }
  list_hdr->next = list->first;
  list->first = list_hdr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



co_list_hdr * co_list_pop_front(co_list *list)

{
  co_list_hdr *pcVar1;
  
  pcVar1 = list->first;
  if (pcVar1 != (co_list_hdr *)0x0) {
    list->first = pcVar1->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_extract(co_list *list,co_list_hdr *list_hdr)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x81);
  }
  cVar1 = (co_list_hdr)list->first;
  if (cVar1 != (co_list_hdr)0x0) {
    if (cVar1 == (co_list_hdr)list_hdr) {
      list->first = list_hdr->next;
    }
    else {
      do {
        cVar2 = cVar1;
        cVar1 = *(co_list_hdr *)cVar2;
        if (cVar1 == (co_list_hdr)0x0) goto LAB_2300e33c;
      } while (cVar1 != (co_list_hdr)list_hdr);
      if (list->last == list_hdr) {
        ((co_list_hdr *)&list->last)->next = (co_list_hdr *)cVar2;
      }
      *(co_list_hdr **)cVar2 = list_hdr->next;
    }
  }
LAB_2300e33c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

uint32_t co_list_cnt(co_list *list)

{
  uint32_t uVar1;
  int *piVar2;
  
  piVar2 = (int *)list->first;
  uVar1 = 0;
  while (piVar2 != (int *)0x0) {
    uVar1 = uVar1 + 1;
    piVar2 = (int *)*piVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert(co_list *list,co_list_hdr *element,
                   anon_subr__Bool_co_list_hdr_ptr_co_list_hdr_ptr *cmp)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar1 = (co_list_hdr)list->first;
  cVar4 = (co_list_hdr)(co_list_hdr *)0x0;
  while (cVar2 = cVar1, cVar2 != (co_list_hdr)0x0) {
    _Var3 = (*cmp)(element,(co_list_hdr *)cVar2);
    if (CONCAT31(extraout_var,_Var3) != 0) goto LAB_2300e398;
    cVar1 = *(co_list_hdr *)cVar2;
    cVar4 = cVar2;
  }
  list->last = element;
LAB_2300e398:
  element->next = (co_list_hdr *)cVar2;
  if (cVar4 == (co_list_hdr)0x0) {
    list->first = element;
  }
  else {
    *(co_list_hdr **)cVar4 = element;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void co_list_insert_after(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  co_list_hdr cVar1;
  
  cVar1 = (co_list_hdr)list->first;
  if (prev_element == (co_list_hdr *)0x0) {
    co_list_push_front(list,element);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  while( true ) {
    if (cVar1 == (co_list_hdr)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (cVar1 == (co_list_hdr)prev_element) break;
    cVar1 = *(co_list_hdr *)cVar1;
  }
  element->next = *(co_list_hdr **)cVar1;
  *(co_list_hdr **)cVar1 = element;
  if (element->next != (co_list_hdr *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  list->last = element;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void co_list_remove(co_list *list,co_list_hdr *prev_element,co_list_hdr *element)

{
  if (list == (co_list *)0x0) {
    assert_err("list != NULL","module",0x168);
  }
  if (prev_element == (co_list_hdr *)0x0) {
    if (element == (co_list_hdr *)0x0) goto LAB_2300e43c;
LAB_2300e456:
    list->first = element->next;
  }
  else {
    if (prev_element->next != element) {
      assert_err("(prev_element == NULL) || (prev_element->next == element)","module",0x169);
    }
    if (element == (co_list_hdr *)0x0) {
LAB_2300e43c:
      assert_err("element != NULL","module",0x16a);
      if (prev_element == (co_list_hdr *)0x0) goto LAB_2300e456;
    }
    prev_element->next = element->next;
    if (list->last == element) {
      list->last = prev_element;
    }
  }
  element->next = (co_list_hdr *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t co_crc32(uint32_t addr,uint32_t len,uint32_t crc)

{
  uint32_t uVar1;
  byte *pbVar2;
  
  uVar1 = 0;
  while (uVar1 != len) {
    pbVar2 = (byte *)(uVar1 + addr);
    uVar1 = uVar1 + 1;
    crc = crc << 8 ^ crc_tab[crc >> 0x18 ^ (uint)*pbVar2];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return crc;
}



void ke_evt_set(evt_field_t event)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ke_env.evt_field = ke_env.evt_field | event;
  return;
}



void ke_evt_clear(evt_field_t event)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ke_env.evt_field = ~event & ke_env.evt_field;
  return;
}



void bl_event_handle(int param)

{
  ke_evt_clear(0x40000000);
  bl_main_event_handle();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_fw_statistic_dump(int param)

{
  ke_evt_clear(0x20);
  bl_utils_dump();
  txl_frame_dump();
  ipc_emb_dump();
  txl_cntrl_env_dump();
  txl_cfm_dump();
  rxl_hwdesc_dump();
  rxl_cntrl_dump();
  hal_mib_dump();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl60x_fw_dump_statistic(int forced)

{
  if (forced != 0) {
    bl_fw_statistic_dump(0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ke_evt_set(0x20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ke_evt_schedule(void)

{
  int iVar1;
  evt_ptr_t *peVar2;
  
  while (ke_env.evt_field != 0) {
    iVar1 = __clzsi2(ke_env.evt_field);
    peVar2 = ke_evt_hdlr[iVar1].func;
    if ((0x1a < iVar1) || (peVar2 == (evt_ptr_t *)0x0)) {
      assert_err("(event < KE_EVT_MAX) && ke_evt_hdlr[event].func","module",0xdd);
    }
    (*peVar2)(ke_evt_hdlr[iVar1].param);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ke_init(void)

{
  ke_env.mblock_first = ke_mem_init();
  ke_env.queue_saved.first = (co_list_hdr *)0x0;
  ke_env.queue_saved.last = (co_list_hdr *)0x0;
  ke_env.queue_sent.first = (co_list_hdr *)0x0;
  ke_env.queue_sent.last = (co_list_hdr *)0x0;
  ke_env.queue_timer.first = (co_list_hdr *)0x0;
  ke_env.queue_timer.last = (co_list_hdr *)0x0;
  ke_evt_clear(0xffffffff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mblock_free * ke_mem_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ke_mem_heap._0_4_ = 0;
  ke_mem_heap._4_4_ = 0x1480;
  return (mblock_free *)ke_mem_heap;
}



void * ke_malloc(uint32_t size)

{
  mblock_free *pmVar1;
  uint uVar2;
  uint32_t uVar3;
  uint *puVar4;
  mblock_free *pmVar5;
  uint uVar6;
  
  uVar2 = size + 3 & 0xfffffffc;
  uVar6 = uVar2 + 4;
  if (uVar6 < 8) {
    assert_err("totalsize >= sizeof(struct mblock_free)","module",0x79);
  }
  pmVar1 = (mblock_free *)0x0;
  pmVar5 = ke_env.mblock_first;
  while (pmVar5 != (mblock_free *)0x0) {
    if ((uVar2 + 0xc <= pmVar5->size) &&
       ((pmVar1 == (mblock_free *)0x0 || (pmVar5->size < pmVar1->size)))) {
      pmVar1 = pmVar5;
    }
    pmVar5 = pmVar5->next;
  }
  if (pmVar1 == (mblock_free *)0x0) {
    assert_err("found != NULL","module",0x95);
  }
  uVar3 = pmVar1->size - uVar6;
  pmVar1->size = uVar3;
  puVar4 = (uint *)(uVar3 + (int)pmVar1);
  *puVar4 = uVar6;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return puVar4 + 1;
}



void ke_free(void *mem_ptr)

{
  mblock_free *pmVar1;
  mblock_free *pmVar2;
  uint32_t uVar3;
  mblock_free *pmVar4;
  int iVar5;
  mblock_free *pmVar6;
  
  pmVar2 = ke_env.mblock_first;
  pmVar4 = (mblock_free *)((int)mem_ptr + -4);
  iVar5 = *(int *)((int)mem_ptr + -4);
  if (mem_ptr <= ke_env.mblock_first) {
    assert_err("(uint32_t)mem_ptr > (uint32_t)node","module",0xc5);
  }
  pmVar6 = (mblock_free *)0x0;
  do {
    pmVar1 = pmVar2;
    if (pmVar1 == (mblock_free *)0x0) {
      pmVar6->next = pmVar4;
      *(undefined4 *)((int)mem_ptr + -4) = 0;
LAB_2300e75c:
      *(int *)mem_ptr = iVar5;
      return;
    }
    if ((mblock_free *)((int)&pmVar1->next + pmVar1->size) == pmVar4) {
      pmVar2 = pmVar1->next;
      uVar3 = pmVar1->size + iVar5;
      pmVar1->size = uVar3;
      if (pmVar2 != (mblock_free *)((int)&pmVar1->next + uVar3)) {
        return;
      }
      pmVar1->size = uVar3 + pmVar2->size;
      pmVar1->next = pmVar2->next;
      return;
    }
    if (pmVar4 < pmVar1) {
      if (pmVar6 == (mblock_free *)0x0) {
        assert_err("prev_node != NULL","module",0xe0);
      }
      pmVar6->next = pmVar4;
      if (pmVar1 == (mblock_free *)((int)&pmVar4->next + iVar5)) {
        *(mblock_free **)((int)mem_ptr + -4) = pmVar1->next;
        *(uint32_t *)mem_ptr = (int)pmVar1 + (pmVar1->size - (int)pmVar4);
        return;
      }
      *(mblock_free **)((int)mem_ptr + -4) = pmVar1;
      goto LAB_2300e75c;
    }
    pmVar2 = pmVar1->next;
    pmVar6 = pmVar1;
  } while( true );
}



void * ke_msg_alloc(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id,uint16_t param_len)

{
  undefined4 *puVar1;
  undefined2 in_register_00002036;
  
  puVar1 = (undefined4 *)ke_malloc(CONCAT22(in_register_00002036,param_len) + 0xc);
  if (puVar1 == (undefined4 *)0x0) {
    assert_err("msg != NULL","module",0x50);
  }
  *(ke_msg_id_t *)(puVar1 + 1) = id;
  *(ke_task_id_t *)((int)puVar1 + 6) = dest_id;
  *(ke_task_id_t *)(puVar1 + 2) = src_id;
  *(uint16_t *)((int)puVar1 + 10) = param_len;
  *puVar1 = 0;
  memset(puVar1 + 3,0,CONCAT22(in_register_00002036,param_len));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return puVar1 + 3;
}



void ke_msg_send(void *param_ptr)

{
  if (*(byte *)((int)param_ptr + -6) < 0xf) {
    if (*(byte *)((int)param_ptr + -6) < 0xd) {
      co_list_push_back(&ke_env.queue_sent,(co_list_hdr *)((int)param_ptr + -0xc));
      ke_evt_set(0x1000000);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  bl_rx_e2a_handler((void *)((int)param_ptr + -8));
  ke_free((co_list_hdr *)((int)param_ptr + -0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ke_msg_send_basic(ke_msg_id_t id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  void *pvVar1;
  
  pvVar1 = ke_msg_alloc(id,dest_id,src_id,0);
  ke_msg_send(pvVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ke_msg_forward_and_change_id
               (void *param_ptr,ke_msg_id_t msg_id,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  *(ke_msg_id_t *)((int)param_ptr + -8) = msg_id;
  *(ke_task_id_t *)((int)param_ptr + -6) = dest_id;
  *(ke_task_id_t *)((int)param_ptr + -4) = src_id;
  ke_msg_send(param_ptr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ke_msg_free(void *mem_ptr)

{
  mblock_free *pmVar1;
  mblock_free *pmVar2;
  uint32_t uVar3;
  mblock_free *pmVar4;
  int iVar5;
  mblock_free *pmVar6;
  
  pmVar2 = ke_env.mblock_first;
  pmVar4 = (mblock_free *)((int)mem_ptr + -4);
  iVar5 = *(int *)((int)mem_ptr + -4);
  if (mem_ptr <= ke_env.mblock_first) {
    assert_err("(uint32_t)mem_ptr > (uint32_t)node","module",0xc5);
  }
  pmVar6 = (mblock_free *)0x0;
  do {
    pmVar1 = pmVar2;
    if (pmVar1 == (mblock_free *)0x0) {
      pmVar6->next = pmVar4;
      *(undefined4 *)((int)mem_ptr + -4) = 0;
LAB_2300e75c:
      *(int *)mem_ptr = iVar5;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((mblock_free *)((int)&pmVar1->next + pmVar1->size) == pmVar4) {
      pmVar2 = pmVar1->next;
      uVar3 = pmVar1->size + iVar5;
      pmVar1->size = uVar3;
      if (pmVar2 != (mblock_free *)((int)&pmVar1->next + uVar3)) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      pmVar1->size = uVar3 + pmVar2->size;
      pmVar1->next = pmVar2->next;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (pmVar4 < pmVar1) {
      if (pmVar6 == (mblock_free *)0x0) {
        assert_err("prev_node != NULL","module",0xe0);
      }
      pmVar6->next = pmVar4;
      if (pmVar1 == (mblock_free *)((int)&pmVar4->next + iVar5)) {
        *(mblock_free **)((int)mem_ptr + -4) = pmVar1->next;
        *(uint32_t *)mem_ptr = (int)pmVar1 + (pmVar1->size - (int)pmVar4);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      *(mblock_free **)((int)mem_ptr + -4) = pmVar1;
      goto LAB_2300e75c;
    }
    pmVar2 = pmVar1->next;
    pmVar6 = pmVar1;
  } while( true );
}



_Bool cmp_dest_id(co_list_hdr *msg,uint32_t dest_id)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(*(ushort *)((int)&msg[1].next + 2) == dest_id);
}



_Bool ke_task_local(ke_task_id_t id)

{
  undefined2 in_register_0000202a;
  
  if (0xe < CONCAT22(in_register_0000202a,id)) {
    assert_err("id <= TASK_MAX","module",0xb6);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(CONCAT22(in_register_0000202a,id) < 0xd);
}



ke_msg_func_t * ke_handler_search(ke_msg_id_t msg_id,ke_state_handler *state_handler)

{
  undefined2 in_register_0000202a;
  ke_msg_func_t *pkVar1;
  int iVar2;
  
  iVar2 = state_handler->msg_cnt - 1;
  if (iVar2 == -1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (ke_msg_func_t *)0x0;
  }
  do {
    if ((uint)state_handler->msg_table[iVar2].id == CONCAT22(in_register_0000202a,msg_id)) {
      if (state_handler->msg_table[iVar2].func == (ke_msg_func_t *)0x0) {
        assert_err("state_handler->msg_table[i].func","module",0xf4);
      }
      pkVar1 = state_handler->msg_table[iVar2].func;
      goto LAB_2300e8f8;
    }
    iVar2 = iVar2 + -1;
  } while (iVar2 != -1);
  pkVar1 = (ke_msg_func_t *)0x0;
LAB_2300e8f8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pkVar1;
}



void ke_state_set(ke_task_id_t id,ke_state_t state_id)

{
  ushort *puVar1;
  uint uVar2;
  _Bool _Var3;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  co_list_hdr *list_hdr;
  undefined2 in_register_0000202e;
  uint uVar4;
  
  uVar2 = id & 0xff;
  uVar4 = CONCAT22(in_register_0000202a,id) >> 8;
  if (0xd < uVar2) {
    assert_err("type < TASK_MAX","module",0xb2);
  }
  _Var3 = ke_task_local((ke_task_id_t)uVar2);
  if (CONCAT31(extraout_var,_Var3) == 0) {
    assert_err("ke_task_local(type)","module",0xb3);
  }
  if (TASK_DESC[uVar2].idx_max <= uVar4) {
    assert_err("idx < TASK_DESC[type].idx_max","module",0xb4);
  }
  puVar1 = TASK_DESC[uVar2].state + uVar4;
  if (puVar1 == (ushort *)0x0) {
    assert_err("ke_stateid_ptr","module",0xb9);
  }
  if ((uint)*puVar1 != CONCAT22(in_register_0000202e,state_id)) {
    *puVar1 = state_id;
    while (list_hdr = ke_queue_extract(&ke_env.queue_saved,cmp_dest_id,
                                       CONCAT22(in_register_0000202a,id)),
          list_hdr != (co_list_hdr *)0x0) {
      co_list_push_back(&ke_env.queue_sent,list_hdr);
      ke_evt_set(0x1000000);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



ke_state_t ke_state_get(ke_task_id_t id)

{
  uint uVar1;
  _Bool _Var2;
  undefined2 in_register_0000202a;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = id & 0xff;
  uVar3 = CONCAT22(in_register_0000202a,id) >> 8;
  if (0xd < uVar1) {
    assert_err("type < TASK_MAX","module",0xd7);
  }
  _Var2 = ke_task_local((ke_task_id_t)uVar1);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    assert_err("ke_task_local(type)","module",0xd8);
  }
  if (TASK_DESC[uVar1].idx_max <= uVar3) {
    assert_err("idx < TASK_DESC[type].idx_max","module",0xd9);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TASK_DESC[uVar1].state[uVar3];
}



void ke_task_schedule(int dummy)

{
  ushort uVar1;
  ke_msg_id_t msg_id;
  _Bool _Var2;
  co_list_hdr *list_hdr;
  undefined3 extraout_var;
  int iVar3;
  ke_msg_func_t *pkVar4;
  ke_state_handler *pkVar5;
  uint uVar6;
  uint uVar7;
  
  list_hdr = co_list_pop_front(&ke_env.queue_sent);
  if (list_hdr == (co_list_hdr *)0x0) goto LAB_2300eb68;
  uVar1 = *(ushort *)((int)&list_hdr[1].next + 2);
  uVar7 = uVar1 & 0xff;
  msg_id = *(ke_msg_id_t *)&list_hdr[1].next;
  uVar6 = (uint)(uVar1 >> 8);
  if (0xd < uVar7) {
    assert_err("type < TASK_MAX","module",0x110);
  }
  _Var2 = ke_task_local((ke_task_id_t)uVar7);
  if (CONCAT31(extraout_var,_Var2) == 0) {
    assert_err("ke_task_local(type)","module",0x111);
  }
  if (TASK_DESC[uVar7].idx_max <= uVar6) {
    assert_err("idx < TASK_DESC[type].idx_max","module",0x112);
  }
  if (TASK_DESC + uVar7 == (ke_task_desc *)0x0) {
    assert_err("desc","module",0x116);
  }
  pkVar5 = TASK_DESC[uVar7].state_handler;
  if (((pkVar5 != (ke_state_handler *)0x0) &&
      (pkVar4 = ke_handler_search(msg_id,pkVar5 + TASK_DESC[uVar7].state[uVar6]),
      pkVar4 != (ke_msg_func_t *)0x0)) ||
     ((TASK_DESC[uVar7].default_handler != (ke_state_handler *)0x0 &&
      (pkVar4 = ke_handler_search(msg_id,TASK_DESC[uVar7].default_handler),
      pkVar4 != (ke_msg_func_t *)0x0)))) {
    iVar3 = (*pkVar4)(*(ke_msg_id_t *)&list_hdr[1].next,list_hdr + 3,
                      *(ke_task_id_t *)((int)&list_hdr[1].next + 2),
                      *(ke_task_id_t *)&list_hdr[2].next);
    if (iVar3 == 1) goto LAB_2300eb68;
    if (iVar3 == 2) {
      co_list_push_back(&ke_env.queue_saved,list_hdr);
      goto LAB_2300eb68;
    }
    if (iVar3 != 0) {
      assert_err("0","module",0x16c);
      goto LAB_2300eb68;
    }
  }
  ke_msg_free(list_hdr);
LAB_2300eb68:
  if (ke_env.queue_sent.first == (co_list_hdr *)0x0) {
    ke_evt_clear(0x1000000);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ke_msg_discard(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int ke_msg_save(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_hw_set(ke_timer *timer)

{
  if (timer == (ke_timer *)0x0) {
    _DAT_44b0808c = _DAT_44b0808c & 0xfffffeff;
  }
  else {
    _DAT_44b00148 = timer->time;
    if ((_DAT_44b0808c & 0x100) == 0) {
      _DAT_44b08088 = 0x100;
      _DAT_44b0808c = _DAT_44b0808c | 0x100;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool cmp_abs_time(co_list_hdr *timerA,co_list_hdr *timerB)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)((co_list_hdr *)0x11e1a300 <
                (co_list_hdr *)((int)timerA[2].next - (int)timerB[2].next));
}



_Bool cmp_timer_id(co_list_hdr *timer,uint32_t timer_task)

{
  if ((uint)*(ushort *)&timer[1].next == timer_task >> 0x10) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)((uint)*(ushort *)((int)&timer[1].next + 2) == (timer_task & 0xffff));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_set(ke_msg_id_t timer_id,ke_task_id_t task_id,uint32_t delay)

{
  bool bVar1;
  co_list_hdr *pcVar2;
  undefined2 in_register_0000202a;
  char *condition;
  co_list_hdr *element;
  undefined2 in_register_0000202e;
  int line;
  
  if (delay == 0) {
    line = 0x8c;
    condition = "delay > 0";
  }
  else {
    if (delay < 300000000) goto LAB_2300ecb6;
    line = 0x8d;
    condition = "delay < KE_TIMER_DELAY_MAX";
  }
  assert_err(condition,"module",line);
LAB_2300ecb6:
  bVar1 = false;
  if ((ke_env.queue_timer.first != (co_list_hdr *)0x0) &&
     ((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id))
     ) {
    bVar1 = (uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id);
  }
  element = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                             CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                             CONCAT22(in_register_0000202e,task_id));
  if (element == (co_list_hdr *)0x0) {
    element = (co_list_hdr *)ke_malloc(0xc);
    if (element == (co_list_hdr *)0x0) {
      assert_err("timer","module",0x9d);
    }
    *(ke_msg_id_t *)&element[1].next = timer_id;
    *(ke_task_id_t *)((int)&element[1].next + 2) = task_id;
  }
  pcVar2 = (co_list_hdr *)(delay + _DAT_44b00120);
  element[2].next = pcVar2;
  co_list_insert(&ke_env.queue_timer,element,cmp_abs_time);
  if ((bVar1) || (ke_env.queue_timer.first == element)) {
    ke_timer_hw_set((ke_timer *)ke_env.queue_timer.first);
  }
  if ((int)((int)pcVar2 - _DAT_44b00120) < 0) {
    ke_evt_set(0x4000000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_clear(ke_msg_id_t timer_id,ke_task_id_t task_id)

{
  co_list_hdr *pcVar1;
  undefined2 in_register_0000202a;
  co_list_hdr *mem_ptr;
  undefined2 in_register_0000202e;
  
  mem_ptr = ke_env.queue_timer.first;
  if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (((uint)*(ushort *)&ke_env.queue_timer.first[1].next == CONCAT22(in_register_0000202a,timer_id)
      ) && ((uint)*(ushort *)((int)&ke_env.queue_timer.first[1].next + 2) ==
            CONCAT22(in_register_0000202e,task_id))) {
    co_list_pop_front(&ke_env.queue_timer);
    pcVar1 = ke_env.queue_timer.first;
    ke_timer_hw_set((ke_timer *)ke_env.queue_timer.first);
    if ((pcVar1 != (co_list_hdr *)0x0) && ((int)((int)pcVar1[2].next - _DAT_44b00120) < 0)) {
      assert_err("!first || !ke_time_past(first->time)","module",0xd7);
    }
  }
  else {
    mem_ptr = ke_queue_extract(&ke_env.queue_timer,cmp_timer_id,
                               CONCAT22(in_register_0000202a,timer_id) << 0x10 |
                               CONCAT22(in_register_0000202e,task_id));
    if (mem_ptr == (co_list_hdr *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  ke_free(mem_ptr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ke_timer_schedule(int dummy)

{
  co_list_hdr *pcVar1;
  
  while( true ) {
    ke_evt_clear(0x4000000);
    pcVar1 = ke_env.queue_timer.first;
    if (ke_env.queue_timer.first == (co_list_hdr *)0x0) {
      ke_timer_hw_set((ke_timer *)0x0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((-1 < (int)ke_env.queue_timer.first[2].next + (-0x32 - _DAT_44b00120)) &&
       (ke_timer_hw_set((ke_timer *)ke_env.queue_timer.first),
       -1 < (int)((int)pcVar1[2].next - _DAT_44b00120))) break;
    pcVar1 = co_list_pop_front(&ke_env.queue_timer);
    ke_msg_send_basic(*(ke_msg_id_t *)&pcVar1[1].next,*(ke_task_id_t *)((int)&pcVar1[1].next + 2),
                      0xff);
    ke_free(pcVar1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl60x_current_time_us(longlong *time_now)

{
  undefined4 uVar1;
  
  uVar1 = _DAT_44b080a8;
  *(undefined4 *)time_now = _DAT_44b080a4;
  *(undefined4 *)((int)time_now + 4) = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t mac_ie_find(uint32_t addr,uint16_t buflen,uint8_t ie_id)

{
  undefined2 in_register_0000202e;
  byte *pbVar1;
  undefined3 in_register_00002031;
  
  pbVar1 = (byte *)(CONCAT22(in_register_0000202e,buflen) + addr);
  while( true ) {
    if (pbVar1 <= addr) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (uint32_t)(byte *)0x0;
    }
    if ((uint)*(byte *)addr == CONCAT31(in_register_00002031,ie_id)) break;
    addr = addr + *(byte *)(addr + 1) + 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint32_t)(byte *)addr;
}



uint32_t mac_vsie_find(uint32_t addr,uint16_t buflen,uint8_t *oui,uint8_t ouilen)

{
  uint8_t *puVar1;
  int iVar2;
  undefined2 in_register_0000202e;
  char *pcVar3;
  undefined3 in_register_00002035;
  int iVar4;
  
  pcVar3 = (char *)(CONCAT22(in_register_0000202e,buflen) + addr);
  while (addr < pcVar3) {
    if (*(char *)addr == -0x23) {
      iVar4 = 0;
      do {
        if (CONCAT31(in_register_00002035,ouilen) == iVar4) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return addr;
        }
        iVar2 = iVar4 + 2;
        puVar1 = oui + iVar4;
        iVar4 = iVar4 + 1;
      } while (*puVar1 == *(uint8_t *)(addr + iVar2));
    }
    addr = addr + *(byte *)(addr + 1) + 2;
  }
  if ((char *)addr != pcVar3) {
    puts("--->>> addr != end\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint32_t)(char *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint32_t)(char *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferDesc_t *
GetTxEAPOLBuffer(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **ppTxEapol,BufferDesc_t *pBufDesc)

{
  void *pvVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetTxEAPOLBuffer");
  if (pBufDesc == (BufferDesc_t *)0x0) {
    pBufDesc = (BufferDesc_t *)ke_malloc(0xc);
    if (pBufDesc != (BufferDesc_t *)0x0) {
      memset(pBufDesc,0,0xc);
      pvVar1 = ke_malloc(0x200);
      pBufDesc->Buffer = pvVar1;
      if (pvVar1 != (void *)0x0) goto LAB_2300efca;
    }
    pBufDesc = (BufferDesc_t *)0x0;
  }
  else {
LAB_2300efca:
    pBufDesc->intf = connPtr;
    *ppTxEapol = (EAPOL_KeyMsg_Tx_t *)pBufDesc->Buffer;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"GetTxEAPOLBuffer");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pBufDesc;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void UpdateEAPOLWcbLenAndTransmit(BufferDesc_t *pBufDesc,UINT16 frameLen)

{
  undefined2 in_register_0000202e;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"UpdateEAPOLWcbLenAndTransmit");
  txl_frame_send_eapol_frame
            (*(uint8_t *)(pBufDesc->intf + 1),(cfm_func_ptr *)0x0,(void *)0x0,
             (uint8_t *)((int)pBufDesc->Buffer + 0xe),CONCAT22(in_register_0000202e,frameLen) + 4);
  ke_free(pBufDesc->Buffer);
  ke_free(pBufDesc);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"UpdateEAPOLWcbLenAndTransmit");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN keyMgmtProcessMsgExt(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtProcessMsgExt");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtProcessMsgExt");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtInitSta(cm_ConnectionInfo_t *connPtr)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtInitSta");
  KeyMgmtSta_InitSession(&connPtr->suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtInitSta");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession(cm_ConnectionInfo_t *connPtr,CHAR *pBssid,UINT8 *pStaAddr)

{
  supplicantData *psVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession");
  psVar1 = connPtr->suppData;
  (psVar1->keyMgmtInfoSta).connPtr = (cm_ConnectionInfo *)connPtr;
  memcpy(connPtr->suppData->localStaAddr,pStaAddr,6);
  memcpy(connPtr->suppData->localBssid,pBssid,6);
  keyMgmtSta_StartSession_internal(&psVar1->keyMgmtInfoSta,10000000);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void init_customApp_mibs(supplicantData_t *suppData)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"init_customApp_mibs");
  memset(&suppData->customMIB_RSNStats,0,3);
  memset(&suppData->customMIB_RSNConfig,0,0x1c);
  (suppData->customMIB_RSNConfig).wpaType =
       (SecurityMode_t)((ushort)(suppData->customMIB_RSNConfig).wpaType | 1);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"init_customApp_mibs");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 supplicantIsEnabled(void *connectionPtr)

{
  byte bVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
  bVar1 = 0;
  if (*(int *)((int)connectionPtr + 8) != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantIsEnabled");
    bVar1 = (byte)((uint)*(undefined4 *)(*(int *)((int)connectionPtr + 8) + 0x34) >> 8) & 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (UINT8)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInitSession
               (cm_ConnectionInfo_t *connPtr,CHAR *pSsid,UINT16 len,CHAR *pBssid,UINT8 *pStaAddr)

{
  UINT8 UVar1;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInitSession");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    KeyMgmtInitSta(connPtr);
    memcpy((connPtr->suppData->hashSsId).SsId,pSsid,CONCAT22(in_register_00002032,len));
    (connPtr->suppData->hashSsId).Len = (IEEEtypes_Len_t)len;
    keyMgmtSta_StartSession(connPtr,pBssid,pStaAddr);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantInitSession");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantDisable(cm_ConnectionInfo_t *connPtr)

{
  UINT8 UVar1;
  undefined3 extraout_var;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantDisable");
  UVar1 = supplicantIsEnabled(connPtr);
  if (CONCAT31(extraout_var,UVar1) != 0) {
    mm_timer_clear(&(connPtr->suppData->keyMgmtInfoSta).rsnTimer);
    *(byte *)&connPtr->suppData->customMIB_RSNConfig =
         *(byte *)&connPtr->suppData->customMIB_RSNConfig & 0xfe;
    init_customApp_mibs((supplicantData_t *)connPtr->suppData);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantDisable");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantEnable(void *connectionPtr,int security_mode,void *mcstCipher,void *ucstCipher,
                     _Bool is_pmf_required)

{
  int iVar1;
  UINT8 *__src;
  undefined3 in_register_00002039;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantEnable");
  *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
       *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 1;
  if (security_mode - 4U < 3) {
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 0x20;
    *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) =
         *(byte *)(*(int *)((int)connectionPtr + 8) + 0x35) | 4;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x4e) | 1;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    if (CONCAT31(in_register_00002039,is_pmf_required) == 0) {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    }
    else {
      *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 6;
    }
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  else {
    if (security_mode != 3) goto LAB_2300f482;
    *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) =
         *(ushort *)(*(int *)((int)connectionPtr + 8) + 0x36) | 8;
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x38),mcstCipher,1);
    memcpy((void *)(*(int *)((int)connectionPtr + 8) + 0x39),ucstCipher,1);
    *(undefined *)(*(int *)((int)connectionPtr + 8) + 0x3d) = 2;
    iVar1 = *(int *)((int)connectionPtr + 8);
    __src = "";
  }
  memcpy((void *)(iVar1 + 0x3a),__src,3);
LAB_2300f482:
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantEnable");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtFormatWpaRsnIe
                 (cm_ConnectionInfo_t *connPtr,UINT8 *pos,IEEEtypes_MacAddr_t *pBssid,
                 IEEEtypes_MacAddr_t *pStaAddr,UINT8 *pPmkid,BOOLEAN addPmkid)

{
  uint16_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtFormatWpaRsnIe");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtFormatWpaRsnIe");
  uVar1 = mm_get_rsn_wpa_ie(connPtr->staId,pos);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (UINT16)uVar1;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg2(BufferDesc_t *pEAPoLBufDesc,UINT8 *pSNonce,UINT8 *pEAPOLMICKey,
                        UINT8 forceKeyDescVersion)

{
  EAPOL_KeyMsg_Tx_t *pEVar1;
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  UINT16 UVar3;
  BufferDesc_t *pBufDesc;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar2 = FAIL;
  }
  else {
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
               (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,pSNonce);
    pEVar1 = pEStack36;
    if ((pEStack36->keyMsg).desc_type != '\x01') {
      UVar3 = keyMgmtFormatWpaRsnIe
                        (connPtr,(pEStack36->keyMsg).key_data,
                         (IEEEtypes_MacAddr_t *)connPtr->suppData->localBssid,
                         (IEEEtypes_MacAddr_t *)connPtr->suppData->localStaAddr,(UINT8 *)0x0,0);
      *(char *)&(pEVar1->keyMsg).key_material_len = (char)UVar3;
      *(char *)((int)&(pEVar1->keyMsg).key_material_len + 1) = (char)(UVar3 >> 8);
    }
    UVar3 = KeyMgmtSta_PopulateEAPOLLengthMic(pEStack36,pEAPOLMICKey,'\x01',forceKeyDescVersion);
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,UVar3);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg2");
    SVar2 = FW_SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtStaHsk_Recvd_PWKMsg1
                  (BufferDesc_t *pEAPoLBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  int iVar1;
  int iVar2;
  Status_e SVar3;
  EAPOL_KeyMsg_t *pEVar4;
  BOOLEAN BVar5;
  UINT8 *pPMK;
  undefined3 extraout_var;
  int iVar6;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  BOOLEAN in_fa0;
  
  iVar6 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg1");
  iVar1 = *(int *)(iVar6 + 8);
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(iVar1 + 0x54);
  pEVar4 = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pEVar4 == (EAPOL_KeyMsg_t *)0x0) {
LAB_2300f69e:
    iVar2 = 0;
  }
  else {
    iVar2 = supplicantAkmIsWpaWpa2((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
    if (iVar2 != 0) {
      BVar5 = supplicantAkmIsWpaWpa2Psk((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      if ((BVar5 == 0) ||
         (pPMK = pmkCacheFindPSK((UINT8 *)(*(int *)(iVar6 + 8) + 6),
                                 *(UINT8 *)(*(int *)(iVar6 + 8) + 5)), pPMK == (UINT8 *)0x0))
      goto LAB_2300f69e;
      supplicantAkmUsesKdf((AkmSuite_t *)(*(int *)(iVar6 + 8) + 0x3a));
      KeyMgmtSta_DeriveKeys
                (pPMK,da,sa,(UINT8 *)pKeyMgmtInfoSta,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94)
                 ,(UINT8 *)(iVar1 + 0xa4),(KeyData_t *)(iVar1 + 0x128),in_fa0);
      iVar2 = 1;
    }
    SVar3 = GeneratePWKMsg2(pEAPoLBufDesc,(UINT8 *)(iVar1 + 0x74),(UINT8 *)(iVar1 + 0x94),'\0');
    if (CONCAT31(extraout_var,SVar3) == 0) {
      if (iVar2 == 1) {
        updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar4->replay_cnt);
        *(undefined4 *)(iVar1 + 0xcc) = 0;
      }
    }
    else {
      iVar2 = 0;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg1");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantInit(supplicantData_t *suppData)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantInit");
  init_customApp_mibs(suppData);
  memset(&suppData->currParams,0xff,4);
  memset(&suppData->keyMgmtInfoSta,0,0x144);
  (suppData->keyMgmtInfoSta).sta_MIC_Error.disableStaAsso = 0;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.MICCounterMeasureEnabled = 1;
  (suppData->keyMgmtInfoSta).sta_MIC_Error.status = NO_MIC_FAILURE;
  KeyMgmtResetCounter(&suppData->keyMgmtInfoSta);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantInit");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void allocSupplicantData(void *connectionPtr)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"allocSupplicantData");
  if (*(int *)((int)connectionPtr + 8) == 0) {
                    // WARNING: Load size is inaccurate
    if ((*connectionPtr == '\0') && (keyMgmt_SuppData[0].inUse == 0)) {
      keyMgmt_SuppData[0].inUse = 1;
      supplicantInit(keyMgmt_SuppData);
      *(supplicantData_t **)((int)connectionPtr + 8) = keyMgmt_SuppData;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"allocSupplicantData");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize(cm_ConnectionInfo_t *connPtr,UINT8 isPairwise)

{
  UINT16 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize");
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize");
  UVar1 = keyMgmtGetKeySize_internal(&connPtr->suppData->customMIB_RSNConfig,isPairwise);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar1;
}



// WARNING: Variable defined which should be unmapped: key_add_req

uint8_t add_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint32_t uVar1;
  uint32_t uVar2;
  size_t __n;
  uint8_t uVar3;
  UINT16 UVar4;
  apInfo_t *paVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  KeyData_t *__src;
  undefined auStack60 [4];
  mm_key_add_req key_add_req;
  
  iVar6 = CONCAT31(in_register_0000202d,pairwise);
  __n = 0x10;
  if (connPtr->conType == '\0') {
    UVar4 = keyMgmtGetKeySize(connPtr,pairwise);
    __n = UVar4 & 0xff;
  }
  memset(auStack60,0,0x2c);
  key_add_req.key.array[7]._3_1_ = iVar6 != 0;
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  if (iVar6 == 0) {
    auStack60[1] = 0xff;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
      auStack60[0] = (byte)(connPtr->suppData->keyMgmtInfoSta).GRKey.KeyIndex;
    }
    else {
      paVar5 = cm_GetApInfo(connPtr);
      __src = &(paVar5->bssData).grpKeyData;
      auStack60[0] = (byte)(paVar5->bssData).grpKeyData.KeyIndex;
    }
  }
  else {
    auStack60[1] = connPtr->staId;
    if (connPtr->conType == '\0') {
      __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
    }
    else {
      __src = (KeyData_t *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x20;
    }
  }
  memcpy(&key_add_req.key,__src,__n);
  uVar2 = key_add_req.key.array[6];
  uVar1 = key_add_req.key.array[3];
  key_add_req.key_idx = (uint8_t)__n;
  if (__n == 0x10) {
    key_add_req.key.array[7]._0_1_ = 2;
  }
  else {
    if (__n == 0x20) {
      key_add_req.key.array[7]._0_1_ = 1;
      if (iVar6 != 0) {
        key_add_req.key.array[3] = key_add_req.key.array[5];
        key_add_req.key.array[5] = uVar1;
        key_add_req.key.array[6] = key_add_req.key.array[4];
        key_add_req.key.array[4] = uVar2;
      }
    }
    else {
      if (__n == 0xd) {
        key_add_req.key.array[7]._0_1_ = 3;
      }
      else {
        if (__n == 5) {
          key_add_req.key.array[7]._0_1_ = 0;
        }
        else {
          assert_err("0","module",0x783);
        }
      }
    }
  }
  printf("set key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",
         (uint)auStack60[1],(uint)key_add_req.key.array[7]._1_1_,(uint)auStack60[0],
         (uint)(byte)key_add_req.key.array[7],(uint)key_add_req.key_idx);
  uVar3 = mm_sec_machwkey_wr((mm_key_add_req *)auStack60);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyGroupTxDone(void)

{
  cm_ConnectionInfo_t *connPtr;
  uint8_t uVar1;
  cm_ConnectionInfo_t **in_a0;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  connPtr = *in_a0;
  if (connPtr->gtkHwKeyId != -1) {
    mm_sec_machwkey_del(connPtr->gtkHwKeyId);
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  (connPtr->suppData->keyMgmtInfoSta).RSNDataTrafficEnabled = 1;
  if ((connPtr->suppData->keyMgmtInfoSta).RSNSecured == 0) {
    (connPtr->suppData->keyMgmtInfoSta).RSNSecured = 1;
    sm_handle_supplicant_result(connPtr->staId,0);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyGroupTxDone");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: pTxEapol
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GenerateGrpMsg2(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  UINT16 frameLen_00;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar1;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  UINT16 frameLen;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GenerateGrpMsg2");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack36,(BufferDesc_t *)0x0);
  if (pBufDesc != (BufferDesc_t *)0x0) {
    psVar1 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack36,pRxEapol,(IEEEtypes_MacAddr_t *)psVar1->localBssid,
               (IEEEtypes_MacAddr_t *)psVar1->localStaAddr,(UINT8 *)0x0);
    frameLen_00 = KeyMgmtSta_PopulateEAPOLLengthMic
                            (pEStack36,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    keyMgmtKeyGroupTxDone();
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen_00);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"GenerateGrpMsg2");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (Status_e)(pBufDesc == (BufferDesc_t *)0x0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_GrpMsg1(BufferDesc_t *pEAPoLBufDesc)

{
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar1;
  EAPOL_KeyMsg_t *pEVar2;
  undefined3 extraout_var;
  
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(pEAPoLBufDesc->intf + 8) + 0x54);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_GrpMsg1");
  pEVar2 = ProcessRxEAPOL_GrpMsg1(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar2 == (EAPOL_KeyMsg_t *)0x0) ||
     (SVar1 = GenerateGrpMsg2(pEAPoLBufDesc,pKeyMgmtInfoSta), CONCAT31(extraout_var,SVar1) != 0)) {
    pEVar2 = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar2->replay_cnt);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_GrpMsg1");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pEVar2;
}



// WARNING: Variable defined which should be unmapped: key_add_req
// WARNING: Could not reconcile some variable overlaps

uint8_t add_mfp_key_to_mac(cm_ConnectionInfo_t *connPtr,UINT8 pairwise)

{
  uint8_t uVar1;
  UINT16 UVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  KeyData_t *__src;
  undefined2 uStack60;
  mm_key_add_req key_add_req;
  
  UVar2 = keyMgmtGetKeySize(connPtr,pairwise);
  memset(&uStack60,0,0x2c);
  key_add_req.key.array[7]._1_1_ = connPtr->instNbr;
  key_add_req.key_idx = (uint8_t)(UVar2 & 0xff);
  key_add_req.key.array[7]._0_1_ = 5;
  uStack60 = 0xff04;
  if (CONCAT31(in_register_0000202d,pairwise) == 0) {
    if (connPtr->conType != '\0') goto LAB_2300fc4a;
    __src = &(connPtr->suppData->keyMgmtInfoSta).GRKey;
  }
  else {
    if (connPtr->conType != '\0') goto LAB_2300fc4a;
    __src = &(connPtr->suppData->keyMgmtInfoSta).PWKey;
  }
  memcpy(&key_add_req.key,__src,UVar2 & 0xff);
LAB_2300fc4a:
  printf("set mfp key:sta_idx:%d, inst_nbr:%d, key_idx:%d,cipher_suite:%d,key_len:%d\r\n",
         (uint)uStack60._1_1_,(uint)key_add_req.key.array[7]._1_1_,(uint)(byte)uStack60,
         (uint)(byte)key_add_req.key.array[7],(uint)key_add_req.key_idx);
  uVar1 = mm_sec_machwkey_wr((mm_key_add_req *)&uStack60);
  printf("mfp hw id: %d\n",CONCAT31(extraout_var,uVar1));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtPlumbPairwiseKey(cm_ConnectionInfo_t *connPtr)

{
  uint8_t uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtPlumbPairwiseKey");
  memcpy(&(connPtr->suppData->keyMgmtInfoSta).PWKey,&(connPtr->suppData->keyMgmtInfoSta).newPWKey,
         0x28);
  uVar1 = add_key_to_mac(connPtr,'\x01');
  connPtr->ptkHwKeyId = uVar1;
  if ((connPtr->suppData->customMIB_RSNConfig).AKM.akmType == AKM_SHA256_PSK) {
    uVar1 = add_mfp_key_to_mac(connPtr,'\x01');
    connPtr->mfpHwKeyId = uVar1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtPlumbPairwiseKey");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BufferReturnNotify_t * keyMgmtKeyPairwiseTxDone(void)

{
  cm_ConnectionInfo_t **in_a0;
  cm_ConnectionInfo_t *connPtr;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  connPtr = *in_a0;
  keyMgmtPlumbPairwiseKey(connPtr);
  (connPtr->suppData->keyMgmtInfoSta).pwkHandshakeComplete = 1;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairwiseTxDone");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (BufferReturnNotify_t *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e GeneratePWKMsg4(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta,
                        BOOLEAN groupKeyReceived)

{
  Status_e SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc;
  supplicantData *psVar2;
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pRxEapol;
  EAPOL_KeyMsg_Tx_t *pEStack52;
  EAPOL_KeyMsg_Tx_t *pTxEapol;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg4");
  connPtr = (cm_ConnectionInfo_t *)pEAPoLBufDesc->intf;
  pRxEapol = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  pBufDesc = GetTxEAPOLBuffer(connPtr,&pEStack52,(BufferDesc_t *)0x0);
  if (pBufDesc == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    psVar2 = connPtr->suppData;
    KeyMgmtSta_PrepareEAPOLFrame
              (pEStack52,pRxEapol,(IEEEtypes_MacAddr_t *)psVar2->localBssid,
               (IEEEtypes_MacAddr_t *)psVar2->localStaAddr,(UINT8 *)0x0);
    frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                         (pEStack52,pKeyMgmtInfoSta->EAPOL_MIC_Key,'\x01','\0');
    UpdateEAPOLWcbLenAndTransmit(pBufDesc,frameLen);
    if (groupKeyReceived == 0) {
      keyMgmtKeyPairwiseTxDone();
    }
    else {
      dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
      keyMgmtKeyPairwiseTxDone();
      keyMgmtKeyGroupTxDone();
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtKeyPairAndGroupTxDone");
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"GeneratePWKMsg4");
    SVar1 = FW_SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t * KeyMgmtStaHsk_Recvd_PWKMsg3(BufferDesc_t *pEAPoLBufDesc)

{
  int iVar1;
  keyMgmtInfoSta_t *pKeyMgmtInfoSta;
  Status_e SVar2;
  EAPOL_KeyMsg_t *pEVar3;
  undefined3 extraout_var;
  
  iVar1 = pEAPoLBufDesc->intf;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg3");
  pKeyMgmtInfoSta = (keyMgmtInfoSta_t *)(*(int *)(iVar1 + 8) + 0x54);
  pEVar3 = ProcessRxEAPOL_PwkMsg3(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if ((pEVar3 != (EAPOL_KeyMsg_t *)0x0) &&
     (SVar2 = GeneratePWKMsg4(pEAPoLBufDesc,pKeyMgmtInfoSta,(uint)(pEVar3->desc_type == '\x02')),
     CONCAT31(extraout_var,SVar2) == 0)) {
    updateApReplayCounter(pKeyMgmtInfoSta,(UINT8 *)pEVar3->replay_cnt);
    pEVar3 = (EAPOL_KeyMsg_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtStaHsk_Recvd_PWKMsg3");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pEVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ProcessKeyMgmtDataSta(BufferDesc_t *pBufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  void *pvVar1;
  
  pvVar1 = pBufDesc->Buffer;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessKeyMgmtDataSta");
  if ((*(byte *)((int)pvVar1 + 6) & 8) == 0) {
    KeyMgmtStaHsk_Recvd_GrpMsg1(pBufDesc);
  }
  else {
    if ((*(byte *)((int)pvVar1 + 5) & 1) == 0) {
      KeyMgmtStaHsk_Recvd_PWKMsg1(pBufDesc,sa,da);
    }
    else {
      KeyMgmtStaHsk_Recvd_PWKMsg3(pBufDesc);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessKeyMgmtDataSta");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 ProcessEAPoLPkt(BufferDesc_t *bufDesc,IEEEtypes_MacAddr_t *sa,IEEEtypes_MacAddr_t *da)

{
  UINT8 UVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLPkt");
  if (*(char *)((int)bufDesc->Buffer + 1) == '\x03') {
    dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
    if (*(char *)bufDesc->intf == '\x02') {
      ProcessKeyMgmtDataAp(bufDesc);
    }
    else {
      ProcessKeyMgmtDataSta(bufDesc,sa,da);
    }
    UVar1 = '\x01';
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLKeyPkt");
  }
  else {
    UVar1 = '\0';
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessEAPoLPkt");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar1;
}



uchar process_rsn_ie(uint8_t *rsn_ie,Cipher_t *mcstCipher,Cipher_t *ucstCipher,
                    _Bool *is_pmf_required,SecurityMode_t *security_mode,_Bool wpa2_prefered)

{
  int iVar1;
  UINT8 *__s2;
  Cipher_t CVar2;
  undefined3 in_register_0000203d;
  uint uVar3;
  uint8_t *puVar4;
  uint8_t *__dest;
  ushort auStack66 [2];
  uint16_t akmp_count;
  
  puVar4 = rsn_ie + 0xe;
  __dest = rsn_ie + 10;
  if (*(short *)(rsn_ie + 8) == 2) {
    rsn_ie[9] = '\0';
    rsn_ie[1] = rsn_ie[1] + -4;
    rsn_ie[8] = '\x01';
    iVar1 = memcmp(puVar4,"",4);
    if (iVar1 == 0) {
      memcpy(__dest,puVar4,4);
    }
    memcpy(puVar4,rsn_ie + 0x12,0xc);
  }
  memcpy(auStack66,puVar4,2);
  uVar3 = 0;
  while (uVar3 < auStack66[0]) {
    iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
    if (iVar1 == 0) {
      *(byte *)security_mode = *(byte *)security_mode | 0x20;
    }
    else {
      iVar1 = memcmp(__dest + (uVar3 + 1) * 4 + 2,"",4);
      if (iVar1 == 0) {
        *(byte *)&security_mode->field_0x1 = *(byte *)&security_mode->field_0x1 | 1;
      }
    }
    uVar3 = uVar3 + 1 & 0xff;
  }
  if (auStack66[0] == 2) {
    rsn_ie[1] = '\x14';
    auStack66[0] = 1;
    memcpy(puVar4,auStack66,2);
    puVar4 = rsn_ie + 0x14;
    if (CONCAT31(in_register_0000203d,wpa2_prefered) == 0) {
      __s2 = "";
    }
    else {
      __s2 = "";
    }
    iVar1 = memcmp(puVar4,__s2,4);
    if (iVar1 == 0) {
      memcpy(rsn_ie + 0x10,puVar4,6);
    }
    memcpy(puVar4,rsn_ie + 0x18,2);
  }
  if (((*(byte *)&security_mode->field_0x1 & 1) != 0) &&
     (((*(byte *)security_mode & 0x20) == 0 || (CONCAT31(in_register_0000203d,wpa2_prefered) == 0)))
     ) {
    *is_pmf_required = true;
    rsn_ie[0x14] = -0x40;
    rsn_ie[0x16] = '\0';
    rsn_ie[1] = rsn_ie[1] + '\x02';
    rsn_ie[0x17] = '\0';
    memcpy(rsn_ie + 0x18,"",4);
    rsn_ie[1] = rsn_ie[1] + '\x04';
  }
  iVar1 = memcmp(__dest,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*ucstCipher | 8);
LAB_230101f8:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(__dest,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*ucstCipher | 4);
      goto LAB_230101f8;
    }
  }
  puVar4 = rsn_ie + 4;
  iVar1 = memcmp(puVar4,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(puVar4,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(puVar4,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(puVar4,"",4);
        if (iVar1 != 0) goto LAB_2301021a;
        CVar2 = (Cipher_t)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_2301021a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uchar)(rsn_ie[1] + '\x02');
}



uchar process_wpa_ie(uint8_t *wpa_ie,Cipher_t *mcstCipher,Cipher_t *ucstCipher)

{
  int iVar1;
  Cipher_t CVar2;
  uint8_t *puVar3;
  uint8_t *__s1;
  
  puVar3 = wpa_ie + 0xe;
  if (*(short *)(wpa_ie + 0xc) == 2) {
    wpa_ie[1] = '\x16';
    __s1 = wpa_ie + 0x12;
    wpa_ie[0xc] = '\x01';
    wpa_ie[0xd] = '\0';
    iVar1 = memcmp(__s1,"",4);
    if (iVar1 == 0) {
      memcpy(puVar3,__s1,4);
    }
    memcpy(__s1,wpa_ie + 0x16,8);
  }
  iVar1 = memcmp(puVar3,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*ucstCipher | 8);
LAB_23010382:
    *ucstCipher = CVar2;
  }
  else {
    iVar1 = memcmp(puVar3,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*ucstCipher | 4);
      goto LAB_23010382;
    }
  }
  puVar3 = wpa_ie + 8;
  iVar1 = memcmp(puVar3,"",4);
  if (iVar1 == 0) {
    CVar2 = (Cipher_t)((byte)*mcstCipher | 8);
  }
  else {
    iVar1 = memcmp(puVar3,"",4);
    if (iVar1 == 0) {
      CVar2 = (Cipher_t)((byte)*mcstCipher | 4);
    }
    else {
      iVar1 = memcmp(puVar3,"",4);
      if (iVar1 == 0) {
        CVar2 = (Cipher_t)((byte)*mcstCipher | 2);
      }
      else {
        iVar1 = memcmp(puVar3,"",4);
        if (iVar1 != 0) goto LAB_230103a4;
        CVar2 = (Cipher_t)((byte)*mcstCipher | 1);
      }
    }
  }
  *mcstCipher = CVar2;
LAB_230103a4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uchar)(wpa_ie[1] + '\x02');
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtStaRsnSecuredTimeoutHandler(void *env)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtStaRsnSecuredTimeoutHandler");
  if ((env != (void *)0x0) && (*(int *)((int)env + 0x78) == 0)) {
    sm_handle_supplicant_result(*(uint8_t *)(*(int *)((int)env + 0x118) + 1),0xf);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtStaRsnSecuredTimeoutHandler");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantGenerateRand(UINT8 *dataOut,UINT32 length)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantGenerateRand");
  bl_rand_stream(dataOut,length);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantGenerateRand");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ComputeEAPOL_MIC(EAPOL_KeyMsg_t *pKeyMsg,UINT16 data_length,UINT8 *MIC_Key,UINT8 MIC_Key_length
                     ,UINT8 micKeyDescVersion)

{
  undefined2 in_register_0000202e;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  uint uVar1;
  uchar *output;
  int iStack24;
  int len;
  UINT8 *pMicData;
  
  uVar1 = CONCAT31(in_register_00002039,micKeyDescVersion);
  iStack24 = CONCAT22(in_register_0000202e,data_length);
  if (uVar1 == 0) {
    uVar1 = *(byte *)&(pKeyMsg->key_info).field_0x1 & 7;
  }
  output = pKeyMsg->key_MIC;
  len = (int)pKeyMsg;
  if (uVar1 == 1) {
    Bl_hmac_md5((UINT8 *)pKeyMsg,iStack24,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                output);
  }
  else {
    if (uVar1 == 2) {
      Bl_hmac_sha1((uchar **)&len,&iStack24,1,MIC_Key,CONCAT31(in_register_00002035,MIC_Key_length),
                   output,0x10);
    }
    else {
      bl_aes_cmac(MIC_Key,(UINT8 *)pKeyMsg,iStack24,output);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 keyMgmtGetKeySize_internal(RSNConfig_t *pRsnConfig,UINT8 isPairwise)

{
  Cipher_t CVar1;
  UINT16 UVar2;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize_internal");
  if (CONCAT31(in_register_0000202d,isPairwise) == 0) {
    CVar1 = pRsnConfig->mcstCipher;
    UVar2 = 0x10;
    if (((((byte)CVar1 & 8) == 0) && (UVar2 = 0xd, ((byte)CVar1 & 2) == 0)) &&
       (UVar2 = 0x20, ((byte)CVar1 & 1) != 0)) {
      UVar2 = 5;
    }
  }
  else {
    UVar2 = 0x20;
    if (((byte)pRsnConfig->ucstCipher & 8) != 0) {
      UVar2 = 0x10;
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtGetKeySize_internal");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar2;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int isApReplayCounterFresh(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT8 *pRxReplayCount)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"isApReplayCounterFresh");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar3 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar2 = pKeyMgmtInfoSta->apCounterHi;
  uVar1 = 1;
  if ((uVar3 <= uVar2) && (uVar1 = 0, uVar2 == uVar3)) {
    uVar1 = 1;
    uVar4 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
    uVar3 = pKeyMgmtInfoSta->apCounterLo;
    if ((uVar4 <= uVar3) && ((uVar1 = 0, uVar3 == uVar4 && ((uVar2 | uVar3) == 0)))) {
      uVar1 = (uint)(pKeyMgmtInfoSta->apCounterZeroDone == 0);
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"isApReplayCounterFresh");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Variable defined which should be unmapped: tmpLo
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void updateApReplayCounter(keyMgmtInfoSta_t *pKeyMgmtStaInfo,UINT8 *pRxReplayCount)

{
  uint uVar1;
  uint uVar2;
  uint uStack24;
  UINT32 tmpHi;
  UINT32 tmpLo;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"updateApReplayCounter");
  memcpy(&uStack24,pRxReplayCount,4);
  memcpy(&tmpHi,pRxReplayCount + 4,4);
  uVar2 = uStack24 * 0x1000000 + (uStack24 >> 0x18) + (uStack24 & 0xff00) * 0x100 +
          (uStack24 >> 8 & 0xff00);
  uVar1 = tmpHi * 0x1000000 + (tmpHi >> 0x18) + (tmpHi & 0xff00) * 0x100 + (tmpHi >> 8 & 0xff00);
  pKeyMgmtStaInfo->apCounterHi = uVar2;
  pKeyMgmtStaInfo->apCounterLo = uVar1;
  if ((uVar2 | uVar1) == 0) {
    pKeyMgmtStaInfo->apCounterZeroDone = 1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"updateApReplayCounter");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void formEAPOLEthHdr(EAPOL_KeyMsg_Tx_t *pTxEapol,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"formEAPOLEthHdr");
  memcpy(pTxEapol,da,6);
  memcpy((pTxEapol->ethHdr).sa,sa,6);
  *(undefined *)&(pTxEapol->ethHdr).type = 0x88;
  *(undefined *)((int)&(pTxEapol->ethHdr).type + 1) = 0x8e;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"formEAPOLEthHdr");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN IsEAPOL_MICValid(EAPOL_KeyMsg_t *pKeyMsg,UINT8 *pMICKey)

{
  UINT8 *__src;
  int iVar1;
  undefined auStack48 [4];
  UINT8 msgMIC [16];
  
  __src = pKeyMsg->key_MIC;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  memcpy(auStack48,__src,0x10);
  memset(__src,0,0x10);
  ComputeEAPOL_MIC(pKeyMsg,(UINT16)((CONCAT21((pKeyMsg->hdr_8021x).pckt_body_len,
                                              *(undefined *)
                                               ((int)&(pKeyMsg->hdr_8021x).pckt_body_len + 1)) + 4)
                                    * 0x10000 >> 0x10),pMICKey,'\x10','\0');
  iVar1 = memcmp(__src,auStack48,0x10);
  if (iVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"IsEAPOL_MICValid");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT16 KeyMgmtSta_PopulateEAPOLLengthMic
                 (EAPOL_KeyMsg_Tx_t *pTxEapol,UINT8 *pEAPOLMICKey,UINT8 eapolProtocolVersion,
                 UINT8 forceKeyDescVersion)

{
  undefined uVar1;
  UINT16 UVar2;
  UINT16 UVar3;
  
  UVar3 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PopulateEAPOLLengthMic");
  if (pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) {
    uVar1 = *(undefined *)((int)&(pTxEapol->keyMsg).key_material_len + 1);
    UVar2 = (pTxEapol->keyMsg).key_material_len;
    UVar3 = UVar2 + 0x5f;
    (pTxEapol->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len = (char)(UVar3 >> 8);
    *(char *)((int)&(pTxEapol->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)UVar3;
    *(undefined *)&(pTxEapol->keyMsg).key_material_len = uVar1;
    (pTxEapol->keyMsg).hdr_8021x.protocol_ver = eapolProtocolVersion;
    *(char *)((int)&(pTxEapol->keyMsg).key_material_len + 1) = (char)UVar2;
    ComputeEAPOL_MIC(&pTxEapol->keyMsg,UVar2 + 99,pEAPOLMICKey,'\x10',forceKeyDescVersion);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PopulateEAPOLLengthMic");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE(IEEEtypes_InfoElementHdr_t *pIe)

{
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE");
  if (((pIe->ElementId != ELEM_ID_VENDOR_SPECIFIC) || (pIe->Len < 8)) ||
     (iVar1 = memcmp(pIe + 1,"",3), iVar1 != 0)) {
    pIe = (IEEEtypes_InfoElementHdr_t *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (KDE_t *)pIe;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyKDE_DataType(UINT8 *pData,SINT32 dataLen,IEEEtypes_KDEDataType_e KDEDataType)

{
  IEEEtypes_InfoElementHdr_t *pIe;
  undefined3 in_register_00002031;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  pIe = (IEEEtypes_InfoElementHdr_t *)pData;
  if (pData != (UINT8 *)0x0) {
    while (2 < dataLen) {
      if (pIe->ElementId == ELEM_ID_VENDOR_SPECIFIC) {
        pData = (UINT8 *)parseKeyKDE(pIe);
        if (((KDE_t *)pData != (KDE_t *)0x0) &&
           ((uint)*(byte *)((int)pData + 5) == CONCAT31(in_register_00002031,KDEDataType)))
        goto LAB_23010a8e;
        if (pIe->Len == '\0') {
          dataLen = 2;
        }
      }
      dataLen = dataLen + (-2 - (uint)pIe->Len);
      pIe = (IEEEtypes_InfoElementHdr_t *)(&pIe[1].ElementId + pIe->Len);
    }
    pData = (UINT8 *)0x0;
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"parseKeyKDE_DataType");
  }
LAB_23010a8e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (KDE_t *)pData;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

KDE_t * parseKeyDataGTK(UINT8 *pKey,UINT16 len,KeyData_t *pGRKey)

{
  KDE_t *pKVar1;
  undefined2 in_register_0000202e;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"parseKeyDataGTK");
  pKVar1 = parseKeyKDE_DataType(pKey,CONCAT22(in_register_0000202e,len),KDE_DATA_TYPE_GTK);
  if (pKVar1 != (KDE_t *)0x0) {
    memcpy(pGRKey,&pKVar1[1].length,pKVar1->length - 6);
    pGRKey->KeyIndex = pKVar1->data[0] & 3;
    memcpy(auStack40,pGRKey->TxMICKey,8);
    memcpy(pGRKey->TxMICKey,pGRKey->RxMICKey,8);
    memcpy(pGRKey->RxMICKey,auStack40,8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"parseKeyDataGTK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pKVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_ApplyKEK(EAPOL_KeyMsg_t *pKeyMsg,KeyData_t *pGRKey,UINT8 *EAPOL_Encr_Key)

{
  byte bVar1;
  undefined uVar2;
  uint3 uVar3;
  UINT8 *cipher;
  uint uVar4;
  int iVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_ApplyKEK");
  bVar1 = pKeyMsg->key_RSC[1];
  cipher = pKeyMsg->key_data;
  pGRKey->TxIV16 = (ushort)bVar1 << 8;
  pGRKey->TxIV16 = CONCAT11(bVar1,pKeyMsg->key_RSC[0]);
  pGRKey->TxIV32 = 0xffffffff;
  uVar2 = *(undefined *)((int)&pKeyMsg->key_material_len + 1);
  uVar3 = CONCAT21(pKeyMsg->key_material_len,uVar2);
  uVar4 = uVar3 & 0xffff;
  *(char *)((int)&pKeyMsg->key_material_len + 1) = (char)(uVar4 >> 8);
  bVar1 = *(byte *)&(pKeyMsg->key_info).field_0x1;
  *(undefined *)&pKeyMsg->key_material_len = uVar2;
  if ((bVar1 & 7) == 1) {
    RC4_Encrypt(EAPOL_Encr_Key,pKeyMsg->EAPOL_key_IV,0x10,cipher,(ushort)uVar3,0x100);
  }
  else {
    BL_AesUnWrap(EAPOL_Encr_Key,'\x02',(uVar4 >> 3) - 1,cipher,(UINT8 *)0x0,cipher);
    iVar5 = pKeyMsg->key_material_len - 8;
    *(char *)&pKeyMsg->key_material_len = (char)((uint)(iVar5 * 0x10000) >> 0x10);
    *(char *)((int)&pKeyMsg->key_material_len + 1) = (char)((uint)iVar5 >> 8);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_ApplyKEK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN KeyMgmtSta_IsRxEAPOLValid(keyMgmtInfoSta_t *pKeyMgmtInfoSta,EAPOL_KeyMsg_t *pKeyMsg)

{
  BOOLEAN BVar1;
  int iVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
  if ((((pKeyMgmtInfoSta == (keyMgmtInfoSta_t *)0x0) || (pKeyMsg == (EAPOL_KeyMsg_t *)0x0)) ||
      (iVar2 = isApReplayCounterFresh(pKeyMgmtInfoSta,(UINT8 *)pKeyMsg->replay_cnt), iVar2 == 0)) ||
     (((*(byte *)&pKeyMsg->key_info & 1) != 0 &&
      ((((*(byte *)&(pKeyMsg->key_info).field_0x1 & 8) != 0 &&
        (iVar2 = memcmp(pKeyMsg->key_nonce,pKeyMgmtInfoSta,0x20), iVar2 != 0)) ||
       (BVar1 = IsEAPOL_MICValid(pKeyMsg,pKeyMgmtInfoSta->EAPOL_MIC_Key), BVar1 == 0)))))) {
    BVar1 = 0;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_IsRxEAPOLValid");
    BVar1 = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_PrepareEAPOLFrame
               (EAPOL_KeyMsg_Tx_t *pTxEapol,EAPOL_KeyMsg_t *pRxEapol,IEEEtypes_MacAddr_t *da,
               IEEEtypes_MacAddr_t *sa,UINT8 *pSNonce)

{
  byte bVar1;
  byte bVar2;
  UINT32 UVar3;
  byte bVar4;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PrepareEAPOLFrame");
  if ((pTxEapol != (EAPOL_KeyMsg_Tx_t *)0x0) && (pRxEapol != (EAPOL_KeyMsg_t *)0x0)) {
    memset(pTxEapol,0,0x72);
    formEAPOLEthHdr(pTxEapol,da,sa);
    (pTxEapol->keyMsg).desc_type = pRxEapol->desc_type;
    bVar4 = *(byte *)&(pRxEapol->key_info).field_0x1 & 8;
    bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
    bVar2 = *(byte *)&(pTxEapol->keyMsg).key_info;
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf7 | bVar4;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 | 1;
    *(byte *)&(pTxEapol->keyMsg).key_info = bVar2 & 0xfd | 1 | *(byte *)&pRxEapol->key_info & 2;
    UVar3 = pRxEapol->replay_cnt[0];
    *(char *)(pTxEapol->keyMsg).replay_cnt = (char)*(undefined3 *)pRxEapol->replay_cnt;
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 1) = (char)(UVar3 >> 8);
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 2) = (char)(UVar3 >> 0x10);
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 3) = (char)(UVar3 >> 0x18);
    UVar3 = pRxEapol->replay_cnt[1];
    *(char *)((pTxEapol->keyMsg).replay_cnt + 1) = (char)*(undefined3 *)(pRxEapol->replay_cnt + 1);
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 5) = (char)(UVar3 >> 8);
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 6) = (char)(UVar3 >> 0x10);
    *(char *)((int)(pTxEapol->keyMsg).replay_cnt + 7) = (char)(UVar3 >> 0x18);
    *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 =
         bVar1 & 0xf0 | bVar4 | *(byte *)&(pRxEapol->key_info).field_0x1 & 7;
    if (pSNonce != (UINT8 *)0x0) {
      memcpy((pTxEapol->keyMsg).key_nonce,pSNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_PrepareEAPOLFrame");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  BOOLEAN BVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if ((iVar1 == 0) || (iVar1 = memcmp(pAkm,"",3), iVar1 == 0)) {
    BVar2 = 1;
  }
  else {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2");
    BVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpa2(AkmSuite_t *pAkm)

{
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  iVar1 = memcmp(pAkm,"",3);
  if (iVar1 != 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpa2");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(iVar1 == 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmIsWpaWpa2Psk(AkmSuite_t *pAkm)

{
  uint uVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2Psk");
  uVar1 = supplicantAkmIsWpaWpa2(pAkm);
  if (uVar1 == 0) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmIsWpaWpa2Psk");
  }
  else {
    uVar1 = 1;
    if ((pAkm->akmType & 0xfb) != 2) {
      uVar1 = (uint)(pAkm->akmType == AKM_FT_PSK);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BOOLEAN supplicantAkmUsesKdf(AkmSuite_t *pAkm)

{
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantAkmUsesKdf");
  BVar1 = supplicantAkmIsWpa2(pAkm);
  if ((BVar1 == 0) || (BVar1 = 1, 3 < (byte)(pAkm->akmType + ~AKM_PSK))) {
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantAkmUsesKdf");
    BVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantConstructContext
               (IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
               UINT8 *pNonce2,UINT8 *pContext)

{
  int iVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantConstructContext");
  iVar1 = memcmp(pAddr1,pAddr2,6);
  if (iVar1 < 0) {
    memcpy(pContext,pAddr1,6);
  }
  else {
    memcpy(pContext,pAddr2,6);
    pAddr2 = pAddr1;
  }
  memcpy(pContext + 6,pAddr2,6);
  iVar1 = memcmp(pNonce1,pNonce2,0x20);
  if (iVar1 < 0) {
    memcpy(pContext + 0xc,pNonce1,0x20);
  }
  else {
    memcpy(pContext + 0xc,pNonce2,0x20);
    pNonce2 = pNonce1;
  }
  memcpy(pContext + 0x2c,pNonce2,0x20);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantConstructContext");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmt_DerivePTK(IEEEtypes_MacAddr_t *pAddr1,IEEEtypes_MacAddr_t *pAddr2,UINT8 *pNonce1,
                      UINT8 *pNonce2,UINT8 *pPTK,UINT8 *pPMK,BOOLEAN use_kdf)

{
  UINT8 *pContext;
  
  pContext = pPTK + 200;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmt_DerivePTK");
  supplicantConstructContext(pAddr1,pAddr2,pNonce1,pNonce2,pContext);
  if (use_kdf == 0) {
    Bl_PRF(pPMK,0x20,(uchar *)"Pairwise key expansion",0x16,pContext,0x4c,pPTK,0x40);
  }
  else {
    bl_sha256_crypto_kdf(pPMK,' ',"Pairwise key expansion",'\x16',pContext,0x4c,pPTK,0x180);
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmt_DerivePTK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_DeriveKeys
               (UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
               UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey,
               BOOLEAN use_kdf)

{
  BOOLEAN in_stack_00000000;
  UINT8 aUStack548 [4];
  UINT8 pBuf [500];
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_DeriveKeys");
  if (((pPMK != (UINT8 *)0x0) && (EAPOL_MIC_Key != (UINT8 *)0x0)) && (newPWKey != (KeyData_t *)0x0))
  {
    KeyMgmt_DerivePTK(sa,da,ANonce,SNonce,aUStack548,pPMK,in_stack_00000000);
    memcpy(EAPOL_MIC_Key,aUStack548,0x10);
    memcpy(EAPOL_Encr_Key,pBuf + 0xc,0x10);
    memcpy(newPWKey,pBuf + 0x1c,0x10);
    memcpy(newPWKey->RxMICKey,pBuf + 0x2c,8);
    memcpy(newPWKey->TxMICKey,pBuf + 0x34,8);
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_DeriveKeys");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SetEAPOLKeyDescTypeVersion
               (EAPOL_KeyMsg_Tx_t *pTxEapol,BOOLEAN isWPA2,BOOLEAN isKDF,BOOLEAN nonTKIP)

{
  byte bVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"SetEAPOLKeyDescTypeVersion");
  bVar1 = *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1;
  (pTxEapol->keyMsg).desc_type = '\x02';
  *(byte *)&(pTxEapol->keyMsg).key_info.field_0x1 = bVar1 & 0xf8 | (isKDF != 0) + 2U;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"SetEAPOLKeyDescTypeVersion");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
GetKeyMsgNonceFromEAPOL(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"GetKeyMsgNonceFromEAPOL");
  pKeyMsg = (EAPOL_KeyMsg_t *)pEAPoLBufDesc->Buffer;
  BVar1 = KeyMgmtSta_IsRxEAPOLValid(pKeyMgmtInfoSta,pKeyMsg);
  if (BVar1 == 0) {
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    if ((*(byte *)&pKeyMsg->key_info & 1) == 0) {
      memcpy(pKeyMgmtInfoSta,pKeyMsg->key_nonce,0x20);
      supplicantGenerateRand(pKeyMgmtInfoSta->SNonce,0x20);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"GetKeyMsgNonceFromEAPOL");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_PwkMsg3(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_PwkMsg3");
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_2301145c:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    (pKeyMgmtInfoSta->newPWKey).TxIV16 = 1;
    (pKeyMgmtInfoSta->newPWKey).TxIV32 = 0;
    if ((*(byte *)&pKeyMsg->key_info & 0x10) != 0) {
      mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
      KeyMgmtSta_ApplyKEK(pKeyMsg,&pKeyMgmtInfoSta->GRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_2301145c;
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,&pKeyMgmtInfoSta->GRKey);
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_PwkMsg3");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

EAPOL_KeyMsg_t *
ProcessRxEAPOL_GrpMsg1(BufferDesc_t *pEAPoLBufDesc,keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  EAPOL_KeyMsg_t *pKeyMsg;
  BOOLEAN BVar1;
  KeyData_t *pGRKey;
  UINT8 *__src;
  UINT8 *__src_00;
  undefined auStack40 [4];
  UINT8 buf [8];
  
  pKeyMsg = GetKeyMsgNonceFromEAPOL(pEAPoLBufDesc,pKeyMgmtInfoSta);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_GrpMsg1");
  if (pKeyMsg == (EAPOL_KeyMsg_t *)0x0) {
LAB_23011518:
    pKeyMsg = (EAPOL_KeyMsg_t *)0x0;
  }
  else {
    pGRKey = &pKeyMgmtInfoSta->GRKey;
    KeyMgmtSta_ApplyKEK(pKeyMsg,pGRKey,pKeyMgmtInfoSta->EAPOL_Encr_Key);
    pKeyMgmtInfoSta->RSNDataTrafficEnabled = 1;
    mm_timer_clear(&pKeyMgmtInfoSta->rsnTimer);
    if (pKeyMsg->desc_type == '\x02') {
      parseKeyDataGTK(pKeyMsg->key_data,pKeyMsg->key_material_len,pGRKey);
      BVar1 = keyMgmtProcessMsgExt(pKeyMgmtInfoSta,pKeyMsg);
      if (BVar1 == 0) goto LAB_23011518;
    }
    else {
      memcpy(pGRKey,pKeyMsg->key_data,(uint)pKeyMsg->key_material_len);
      __src_00 = (pKeyMgmtInfoSta->GRKey).TxMICKey;
      memcpy(auStack40,__src_00,8);
      __src = (pKeyMgmtInfoSta->GRKey).RxMICKey;
      memcpy(__src_00,__src,8);
      memcpy(__src,auStack40,8);
      (pKeyMgmtInfoSta->GRKey).KeyIndex = *(byte *)&(pKeyMsg->key_info).field_0x1 >> 4 & 3;
    }
    dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"ProcessRxEAPOL_GrpMsg1");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pKeyMsg;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtResetCounter(keyMgmtInfoSta_t *pKeyMgmtInfo)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtResetCounter");
  if (pKeyMgmtInfo != (keyMgmtInfoSta_t *)0x0) {
    pKeyMgmtInfo->staCounterHi = 0;
    pKeyMgmtInfo->staCounterLo = 0;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtResetCounter");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyMgmtSta_StartSession_internal(keyMgmtInfoSta_t *pKeyMgmtInfoSta,UINT32 expiry)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession_internal");
  if ((pKeyMgmtInfoSta->sta_MIC_Error).disableStaAsso == 0) {
    mm_timer_set(&pKeyMgmtInfoSta->rsnTimer,_DAT_44b00120 + expiry);
  }
  pKeyMgmtInfoSta->apCounterLo = 0;
  pKeyMgmtInfoSta->apCounterHi = 0;
  pKeyMgmtInfoSta->apCounterZeroDone = 0;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"keyMgmtSta_StartSession_internal");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void KeyMgmtSta_InitSession(keyMgmtInfoSta_t *pKeyMgmtInfoSta)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_InitSession");
  pKeyMgmtInfoSta->RSNDataTrafficEnabled = 0;
  pKeyMgmtInfoSta->RSNSecured = 0;
  pKeyMgmtInfoSta->pRxDecryptKey = (cipher_key_t *)0x0;
  pKeyMgmtInfoSta->pwkHandshakeComplete = 0;
  (pKeyMgmtInfoSta->rsnTimer).cb = keyMgmtStaRsnSecuredTimeoutHandler;
  (pKeyMgmtInfoSta->rsnTimer).env = pKeyMgmtInfoSta;
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"KeyMgmtSta_InitSession");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void set_psk(char *pSsid,UINT8 ssidLen,char *phrase)

{
  size_t sVar1;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"set_psk");
  memset(&nohostParams,0xff,0x43);
  sVar1 = strlen(phrase);
  pmkCacheSetPassphrase((UINT8 *)pSsid,ssidLen,(UINT8 *)phrase,(UINT8)sVar1);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"set_psk");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void remove_psk(char *pSsid,UINT8 ssidLen)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"remove_psk");
  pmkCacheDeletePSK((UINT8 *)pSsid,ssidLen);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"remove_psk");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_sha256_crypto_kdf
               (UINT8 *pKey,UINT8 key_len,char *label,UINT8 label_len,UINT8 *pContext,
               UINT16 context_len,UINT8 *pOutput,UINT16 output_len)

{
  UINT8 *mac;
  undefined3 in_register_0000202d;
  undefined2 in_register_0000203e;
  undefined2 in_register_00002046;
  UINT16 aUStack114 [8];
  ushort uStack98;
  UINT16 i;
  ushort *puStack96;
  UINT8 *vectors [4];
  size_t vectLen [4];
  
  uStack98 = 1;
  mac = pContext + CONCAT22(in_register_0000203e,context_len);
  aUStack114[0] = output_len;
  while ((uint)uStack98 <= (CONCAT22(in_register_00002046,output_len) + 0xff >> 8 & 0xffU)) {
    vectors[3] = (UINT8 *)0x2;
    puStack96 = &uStack98;
    vectors[0] = (UINT8 *)label;
    vectors[1] = pContext;
    vectors[2] = (UINT8 *)aUStack114;
    hmac_sha256_vector(pKey,CONCAT31(in_register_0000202d,key_len),4,(UINT8 **)&stack0xffffffa0,
                       (size_t *)(vectors + 3),mac);
    mac = mac + 0x20;
    uStack98 = uStack98 + 1;
  }
  memcpy(pOutput,pContext + CONCAT22(in_register_0000203e,context_len),(uint)(aUStack114[0] >> 3));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 * pmkCacheFindPSK(UINT8 *pSsid,UINT8 ssidLen)

{
  pmkElement_t *ppVar1;
  size_t sVar2;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSK");
  ppVar1 = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (ppVar1 == (pmkElement_t *)0x0) {
    if (PSKPassPhrase != '\0') {
      pmkCacheAddPSK(pSsid,ssidLen,(UINT8 *)0x0,'\0');
      ppVar1 = pmkCacheFindPSKElement(pSsid,ssidLen);
      sVar2 = strlen((char *)PSKPassPhrase);
      ppVar1 = (pmkElement_t *)ppVar1->PMK;
      pmkCacheGeneratePSK(pSsid,ssidLen,PSKPassPhrase,(UINT8)sVar2,(UINT8 *)ppVar1);
    }
  }
  else {
    ppVar1 = (pmkElement_t *)ppVar1->PMK;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (UINT8 *)ppVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheSetPassphrase(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen)

{
  pmkElement_t *pSsid_00;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheSetPassphrase");
  if (pPassphrase != (UINT8 *)0x0) {
    memcpy(PSKPassPhrase,pPassphrase,0x40);
    pmkCacheAddPSK(pSsid,ssidLen,pPassphrase,PassphraseLen);
    pSsid_00 = pmkCacheFindPSKElement(pSsid,ssidLen);
    pmkCacheGeneratePSK((UINT8 *)pSsid_00,pSsid_00->length,PSKPassPhrase,PassphraseLen,pSsid_00->PMK
                       );
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheSetPassphrase");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheInit(void)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheInit");
  memset(pmkCache,0,0x86);
  memset(PSKPassPhrase,0,0x40);
  replacementRankMax = '\0';
  dbg_test_print("%dms : Leave: %s\n","pmkCacheInit");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheRomInit(void)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheRomInit");
  ramHook_MAX_PMK_CACHE_ENTRIES = 2;
  ramHook_pmkCache = pmkCache;
  ramHook_PSKPassPhrase = PSKPassPhrase;
  dbg_test_print("%dms : Leave: %s\n","pmkCacheRomInit");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheNewElement(void)

{
  uint uVar1;
  pmkElement_t *__s;
  pmkElement_t *ppVar2;
  
  ppVar2 = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheNewElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    if (replacementRankMax == ramHook_MAX_PMK_CACHE_ENTRIES) {
      ramHook_pmkCache[uVar1].replacementRank = ramHook_pmkCache[uVar1].replacementRank + -1;
    }
    if (ppVar2 == (pmkElement_t *)0x0) {
      __s = ramHook_pmkCache + uVar1;
      if (__s->replacementRank == '\0') {
        memset(__s,0,0x43);
        if (replacementRankMax < ramHook_MAX_PMK_CACHE_ENTRIES) {
          replacementRankMax = replacementRankMax + '\x01';
        }
        ramHook_pmkCache[uVar1].replacementRank = replacementRankMax;
        ppVar2 = __s;
      }
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheNewElement");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheUpdateReplacementRank(pmkElement_t *pPMKElement)

{
  char cVar1;
  SINT8 SVar2;
  pmkElement_t *ppVar3;
  SINT32 SVar4;
  uint uVar5;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheUpdateReplacementRank");
  SVar4 = ramHook_MAX_PMK_CACHE_ENTRIES;
  ppVar3 = ramHook_pmkCache;
  SVar2 = replacementRankMax;
  if ((pPMKElement != (pmkElement_t *)0x0) && (pPMKElement->replacementRank != replacementRankMax))
  {
    uVar5 = 0;
    while ((int)uVar5 < SVar4) {
      cVar1 = ppVar3[uVar5].replacementRank;
      if (pPMKElement->replacementRank < cVar1) {
        ppVar3[uVar5].replacementRank = cVar1 + -1;
      }
      uVar5 = uVar5 + 1 & 0xff;
    }
    pPMKElement->replacementRank = SVar2;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheUpdateReplacementRank");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

pmkElement_t * pmkCacheFindPSKElement(UINT8 *pSsid,UINT8 ssidLen)

{
  uint uVar1;
  pmkElement_t *pPMKElement;
  pmkElement_t *__s1;
  int iVar2;
  undefined3 in_register_0000202d;
  
  pPMKElement = (pmkElement_t *)0x0;
  uVar1 = 0;
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSKElement");
  while ((int)uVar1 < ramHook_MAX_PMK_CACHE_ENTRIES) {
    __s1 = ramHook_pmkCache + uVar1;
    if (((__s1->replacementRank != '\0') &&
        ((uint)__s1->length == CONCAT31(in_register_0000202d,ssidLen))) &&
       (iVar2 = memcmp(__s1,pSsid,CONCAT31(in_register_0000202d,ssidLen)), iVar2 == 0)) {
      pPMKElement = ramHook_pmkCache + uVar1;
    }
    uVar1 = uVar1 + 1 & 0xff;
  }
  pmkCacheUpdateReplacementRank(pPMKElement);
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheFindPSKElement");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pPMKElement;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheAddPSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPSK,UINT8 pPSKLen)

{
  pmkElement_t *__dest;
  undefined3 in_register_0000202d;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheAddPSK");
  __dest = pmkCacheFindPSKElement(pSsid,ssidLen);
  if (__dest == (pmkElement_t *)0x0) {
    __dest = pmkCacheNewElement();
    memcpy(__dest,pSsid,CONCAT31(in_register_0000202d,ssidLen));
    __dest->length = ssidLen;
  }
  if (pPSK != (UINT8 *)0x0) {
    memcpy(__dest->PMK,pPSK,0x20);
    __dest->psk_length = pPSKLen;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheAddPSK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheDeletePSK(UINT8 *pSsid,UINT8 ssidLen)

{
  pmkElement_t *__s;
  
  __s = pmkCacheFindPSKElement(pSsid,ssidLen);
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheDeletePSK");
  if (__s != (pmkElement_t *)0x0) {
    memset(__s,0,0x43);
    replacementRankMax = replacementRankMax + -1;
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheDeletePSK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT8 pmkCacheGetHexNibble(UINT8 nibble)

{
  UINT8 UVar1;
  undefined3 in_register_00002029;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
  if (CONCAT31(in_register_00002029,nibble) < 0x61) {
    if (CONCAT31(in_register_00002029,nibble) < 0x41) {
      UVar1 = nibble + -0x30;
      dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheGetHexNibble");
    }
    else {
      UVar1 = nibble + -0x37;
    }
  }
  else {
    UVar1 = nibble + -0x57;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void pmkCacheGeneratePSK(UINT8 *pSsid,UINT8 ssidLen,UINT8 *pPassphrase,UINT8 PassphraseLen,
                        UINT8 *pPSK)

{
  UINT8 UVar1;
  byte bVar2;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  int iVar3;
  
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"pmkCacheGeneratePSK");
  if ((pPSK != (UINT8 *)0x0) && (pPassphrase != (UINT8 *)0x0)) {
    if (CONCAT31(in_register_00002035,PassphraseLen) - 8U < 0x38) {
      utils_wifi_psk_cal_fast_bin
                ((char *)pPassphrase,pSsid,CONCAT31(in_register_0000202d,ssidLen),pPSK);
    }
    else {
      if (CONCAT31(in_register_00002035,PassphraseLen) == 0x40) {
        iVar3 = 0;
        do {
          UVar1 = pmkCacheGetHexNibble(*pPassphrase);
          bVar2 = pmkCacheGetHexNibble(pPassphrase[1]);
          pPSK[iVar3 >> 1] = bVar2 | UVar1 << 4;
          iVar3 = iVar3 + 2;
          pPassphrase = pPassphrase + 2;
        } while (iVar3 != 0x40);
      }
    }
  }
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"pmkCacheGeneratePSK");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prepare_key(uchar *key_data_ptr,int key_data_len,rc4_key *key)

{
  byte bVar1;
  uchar *puVar2;
  rc4_key *prVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  
  iVar5 = 0;
  do {
    key->state[iVar5] = (uchar)iVar5;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x100);
  key->x = '\0';
  key->y = '\0';
  uVar7 = 0;
  uVar4 = 0;
  prVar3 = key;
  do {
    bVar1 = prVar3->state[0];
    puVar2 = prVar3->state;
    uVar6 = (uint)key_data_ptr[uVar4] + (uint)bVar1 + uVar7;
    uVar7 = uVar6 & 0xff;
    prVar3->state[0] = key->state[uVar6 & 0xff];
    key->state[uVar6 & 0xff] = bVar1;
    uVar4 = (int)(uVar4 + 1) % key_data_len & 0xff;
    prVar3 = (rc4_key *)(puVar2 + 1);
  } while ((rc4_key *)&key->x != (rc4_key *)(puVar2 + 1));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rc4(uchar *buffer_ptr,int buffer_len,int skip,rc4_key *key)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  byte *pbVar7;
  uint uVar8;
  
  bVar1 = key->x;
  uVar4 = (uint)key->y;
  iVar5 = 0;
  while (uVar8 = (uint)bVar1 + iVar5 & 0xff, iVar5 < skip) {
    bVar2 = key->state[uVar8 + 1 & 0xff];
    uVar4 = uVar4 + bVar2 & 0xff;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    key->state[uVar8 + 1 & 0xff] = key->state[uVar4];
    key->state[uVar4] = bVar2;
  }
  iVar5 = 0;
  while (uVar6 = uVar8 + iVar5 & 0xff, iVar5 < buffer_len) {
    pbVar7 = key->state + (uVar6 + 1 & 0xff);
    bVar1 = *pbVar7;
    uVar4 = uVar4 + bVar1 & 0xff;
    *pbVar7 = key->state[uVar4];
    key->state[uVar4] = bVar1;
    pbVar3 = buffer_ptr + iVar5;
    iVar5 = (iVar5 + 1) * 0x10000 >> 0x10;
    *pbVar3 = key->state[(uint)bVar1 + (uint)*pbVar7 & 0xff] ^ *pbVar3;
  }
  key->x = (uchar)uVar6;
  key->y = (uchar)uVar4;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void RC4_Encrypt(uchar *Encr_Key,uchar *IV,ushort iv_length,uchar *Data,ushort data_length,
                ushort skipBytes)

{
  undefined2 in_register_00002032;
  size_t __n;
  undefined2 in_register_0000203a;
  undefined2 in_register_0000203e;
  uchar auStack64 [4];
  uchar key [32];
  
  __n = CONCAT22(in_register_00002032,iv_length);
  if ((int)(__n + 0x10) < 0x21) {
    memcpy(auStack64,IV,__n);
    memcpy(auStack64 + __n,Encr_Key,0x10);
    prepare_key(auStack64,__n + 0x10,&rc4key);
    rc4(Data,CONCAT22(in_register_0000203a,data_length),CONCAT22(in_register_0000203e,skipBytes),
        &rc4key);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int sha256_compress(sha256_state *md,UINT8 *msgBuf,UINT8 *pScratchMem)

{
  UINT32 *pUVar1;
  UINT32 *pUVar2;
  int iVar3;
  uint uVar4;
  uint *puVar5;
  uint uVar6;
  int *piVar7;
  int *piVar8;
  int iVar9;
  int iVar10;
  uint uVar11;
  int *__dest;
  ushort *puVar12;
  ushort *puVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  __dest = (int *)(pScratchMem + 0x100);
  memcpy(__dest,md->state,0x20);
  puVar5 = (uint *)pScratchMem;
  puVar12 = (ushort *)msgBuf;
  do {
    puVar13 = puVar12 + 2;
    *puVar5 = (((uint)(*puVar12 >> 8) | (*puVar12 & 0xff) << 8) << 8 | (uint)*(byte *)(puVar12 + 1))
              << 8 | (uint)*(byte *)((int)puVar12 + 3);
    puVar5 = puVar5 + 1;
    puVar12 = puVar13;
  } while (puVar13 != (ushort *)(msgBuf + 0x40));
  piVar7 = (int *)(pScratchMem + 0x40);
  do {
    uVar6 = piVar7[-2];
    uVar4 = piVar7[-0xf];
    piVar8 = piVar7 + 1;
    *piVar7 = ((uVar6 << 0xf | uVar6 >> 0x11) ^ (uVar6 << 0xd | uVar6 >> 0x13) ^ uVar6 >> 10) +
              piVar7[-7] + piVar7[-0x10] +
              ((uVar4 >> 7 | uVar4 << 0x19) ^ (uVar4 << 0xe | uVar4 >> 0x12) ^ uVar4 >> 3);
    piVar7 = piVar8;
  } while (__dest != piVar8);
  iVar3 = 0;
  do {
    uVar4 = *(uint *)(pScratchMem + 0x110);
    uVar14 = *(uint *)(pScratchMem + 0x118);
    uVar15 = *(uint *)(pScratchMem + 0x114);
    uVar6 = *(uint *)(pScratchMem + 0x100);
    iVar9 = *(int *)((int)K + iVar3);
    uVar11 = *(uint *)(pScratchMem + 0x104);
    uVar16 = *(uint *)(pScratchMem + 0x108);
    iVar10 = *(int *)(pScratchMem + iVar3);
    *(uint *)(pScratchMem + 0x114) = uVar4;
    iVar10 = ((uVar4 >> 6 | uVar4 << 0x1a) ^ (uVar4 >> 0xb | uVar4 << 0x15) ^
             (uVar4 << 7 | uVar4 >> 0x19)) + ((uVar14 ^ uVar15) & uVar4 ^ uVar14) +
             *(int *)(pScratchMem + 0x11c) + iVar9 + iVar10;
    *(int *)(pScratchMem + 0x110) = *(int *)(pScratchMem + 0x10c) + iVar10;
    *(uint *)(pScratchMem + 0x104) = uVar6;
    *(uint *)(pScratchMem + 0x11c) = uVar14;
    *(uint *)(pScratchMem + 0x118) = uVar15;
    *(uint *)(pScratchMem + 0x10c) = uVar16;
    *(uint *)(pScratchMem + 0x108) = uVar11;
    *(uint *)(pScratchMem + 0x100) =
         iVar10 + ((uVar6 >> 2 | uVar6 << 0x1e) ^ (uVar6 >> 0xd | uVar6 << 0x13) ^
                  (uVar6 << 10 | uVar6 >> 0x16)) + (uVar6 & uVar11 | (uVar6 | uVar11) & uVar16);
    iVar3 = iVar3 + 4;
  } while (iVar3 != 0x100);
  pUVar1 = md->state;
  do {
    iVar3 = *__dest;
    pUVar2 = pUVar1 + 1;
    __dest = __dest + 1;
    *pUVar1 = *pUVar1 + iVar3;
    pUVar1 = pUVar2;
  } while (&md->curlen != pUVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void sha256_init(sha256_state *md)

{
  *(undefined4 *)&md->length = 0;
  md->state[0] = 0x6a09e667;
  md->state[1] = 0xbb67ae85;
  md->state[2] = 0x3c6ef372;
  md->state[3] = 0xa54ff53a;
  md->state[4] = 0x510e527f;
  md->state[5] = 0x9b05688c;
  md->state[6] = 0x1f83d9ab;
  md->curlen = 0;
  *(undefined4 *)((int)&md->length + 4) = 0;
  md->state[7] = 0x5be0cd19;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha256_vector(size_t num_elem,UINT8 **addr,size_t *len,UINT8 *mac,UINT8 *pScratchMem)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 *puVar6;
  uint uVar8;
  UINT8 *msgBuf;
  UINT8 *pScratchMem_00;
  int iVar9;
  undefined4 *puVar7;
  
  pScratchMem_00 = pScratchMem + 0x70;
  sha256_init((sha256_state *)pScratchMem);
  iVar9 = 0;
  do {
    uVar3 = *(uint *)(pScratchMem + 0x28);
    if (iVar9 == num_elem << 2) {
      if (uVar3 < 0x40) {
        uVar2 = uVar3 * 8 + *(uint *)pScratchMem;
        *(uint *)(pScratchMem + 4) =
             (uint)(uVar2 < *(uint *)pScratchMem) + *(int *)(pScratchMem + 4);
        *(uint *)pScratchMem = uVar2;
        *(uint *)(pScratchMem + 0x28) = uVar3 + 1;
        pScratchMem[uVar3 + 0x2c] = -0x80;
        if (0x38 < uVar3 + 1) {
          while (uVar3 = *(uint *)(pScratchMem + 0x28), uVar3 < 0x40) {
            *(uint *)(pScratchMem + 0x28) = uVar3 + 1;
            pScratchMem[uVar3 + 0x2c] = '\0';
          }
          sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
          *(undefined4 *)(pScratchMem + 0x28) = 0;
        }
        while (uVar3 = *(uint *)(pScratchMem + 0x28), uVar3 < 0x38) {
          *(uint *)(pScratchMem + 0x28) = uVar3 + 1;
          pScratchMem[uVar3 + 0x2c] = '\0';
        }
        uVar4 = *(undefined4 *)pScratchMem;
        pScratchMem[0x68] = (UINT8)((uint)uVar4 >> 0x18);
        pScratchMem[0x69] = (UINT8)((uint)uVar4 >> 0x10);
        pScratchMem[0x6b] = (UINT8)uVar4;
        uVar5 = *(undefined4 *)(pScratchMem + 4);
        pScratchMem[0x6a] = (UINT8)((uint)uVar4 >> 8);
        pScratchMem[100] = (UINT8)((uint)uVar5 >> 0x18);
        pScratchMem[0x65] = (UINT8)((uint)uVar5 >> 0x10);
        pScratchMem[0x67] = (UINT8)uVar5;
        pScratchMem[0x66] = (UINT8)((uint)uVar5 >> 8);
        sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
        puVar6 = (undefined4 *)(pScratchMem + 8);
        do {
          puVar7 = puVar6 + 1;
          uVar4 = *puVar6;
          *mac = (UINT8)((uint)uVar4 >> 0x18);
          mac[1] = (UINT8)((uint)uVar4 >> 0x10);
          mac[2] = (UINT8)((uint)uVar4 >> 8);
          mac[3] = (UINT8)uVar4;
          puVar6 = puVar7;
          mac = mac + 4;
        } while (puVar7 != (undefined4 *)(pScratchMem + 0x28));
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    msgBuf = *(UINT8 **)((int)addr + iVar9);
    uVar2 = *(uint *)((int)len + iVar9);
    if (uVar3 < 0x41) {
      while (iVar1 = *(int *)(pScratchMem + 0x28), uVar2 != 0) {
        if ((iVar1 == 0) && (0x3f < uVar2)) {
          iVar1 = sha256_compress((sha256_state *)pScratchMem,msgBuf,pScratchMem_00);
          if (iVar1 < 0) break;
          uVar8 = *(uint *)pScratchMem;
          msgBuf = msgBuf + 0x40;
          uVar3 = uVar8 + 0x200;
          *(uint *)pScratchMem = uVar3;
          *(uint *)(pScratchMem + 4) = (uint)(uVar3 < uVar8) + *(int *)(pScratchMem + 4);
          uVar2 = uVar2 - 0x40;
        }
        else {
          uVar3 = 0x40U - iVar1;
          if (uVar2 < 0x40U - iVar1) {
            uVar3 = uVar2;
          }
          memcpy(pScratchMem + 0x2c + iVar1,msgBuf,uVar3);
          iVar1 = *(int *)(pScratchMem + 0x28);
          msgBuf = msgBuf + uVar3;
          uVar2 = uVar2 - uVar3;
          *(uint *)(pScratchMem + 0x28) = iVar1 + uVar3;
          if (iVar1 + uVar3 == 0x40) {
            iVar1 = sha256_compress((sha256_state *)pScratchMem,pScratchMem + 0x2c,pScratchMem_00);
            if (iVar1 < 0) break;
            uVar8 = *(uint *)pScratchMem;
            *(undefined4 *)(pScratchMem + 0x28) = 0;
            uVar3 = uVar8 + 0x200;
            *(uint *)pScratchMem = uVar3;
            *(uint *)(pScratchMem + 4) = (uint)(uVar3 < uVar8) + *(int *)(pScratchMem + 4);
          }
        }
      }
    }
    iVar9 = iVar9 + 4;
  } while( true );
}



// WARNING: Variable defined which should be unmapped: pScratchMem

void hmac_sha256_vector(UINT8 *key,size_t key_len,size_t num_elem,UINT8 **addr,size_t *len,
                       UINT8 *mac)

{
  size_t *mac_00;
  UINT8 **ppUVar1;
  size_t **ppsVar2;
  UINT8 **len_00;
  UINT8 **ppUVar3;
  size_t *psVar4;
  int iVar5;
  size_t *psVar6;
  size_t sStack600;
  uint *apuStack596 [4];
  size_t *psStack580;
  UINT8 *_addr [6];
  size_t _len [6];
  UINT8 pScratchMem [500];
  
  mac_00 = (size_t *)(pScratchMem + 0x3c);
  sStack600 = key_len;
  apuStack596[0] = (uint *)key;
  if (0x40 < key_len) {
    apuStack596[0] = (uint *)key;
    sha256_vector(1,(UINT8 **)apuStack596,&sStack600,(UINT8 *)mac_00,pScratchMem + 0x5c);
    sStack600 = 0x20;
    apuStack596[0] = mac_00;
  }
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x36363636;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  len_00 = _addr + 5;
  _addr[5] = (UINT8 *)0x40;
  iVar5 = 0;
  ppsVar2 = &psStack580;
  ppUVar3 = len_00;
  while( true ) {
    ppsVar2 = ppsVar2 + 1;
    ppUVar3 = ppUVar3 + 1;
    if (iVar5 == num_elem << 2) break;
    *ppsVar2 = *(size_t **)((int)addr + iVar5);
    ppUVar1 = (UINT8 **)((int)len + iVar5);
    iVar5 = iVar5 + 4;
    *ppUVar3 = *ppUVar1;
  }
  sha256_vector(num_elem + 1,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  memset(_len + 5,0,0x40);
  memcpy(_len + 5,apuStack596[0],sStack600);
  psVar6 = _len + 5;
  do {
    psVar4 = psVar6 + 1;
    *psVar6 = *psVar6 ^ 0x5c5c5c5c;
    psVar6 = psVar4;
  } while (psVar4 != mac_00);
  psStack580 = _len + 5;
  _addr[5] = (UINT8 *)0x40;
  _len[0] = 0x20;
  _addr[0] = mac;
  sha256_vector(2,(UINT8 **)&psStack580,(size_t *)len_00,mac,pScratchMem + 0x5c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void KeyMgmtInit(cm_ConnectionInfo_t *connPtr)

{
  UINT8 ssidLen;
  apInfo_t *paVar1;
  size_t sVar2;
  UINT8 *pPassphrase;
  
  paVar1 = cm_GetApInfo(connPtr);
  ROM_InitGTK(&(paVar1->bssData).grpKeyData,(paVar1->bssData).GNonce,connPtr->localMacAddr);
  if ((paVar1->bssData).updatePassPhrase == 1) {
    ssidLen = (connPtr->comData).SsIdLen;
    pPassphrase = (paVar1->bssConfig).RsnConfig.PSKPassPhrase;
    sVar2 = strlen((char *)pPassphrase);
    pmkCacheGeneratePSK((UINT8 *)&connPtr->comData,ssidLen,pPassphrase,(UINT8)sVar2,
                        (paVar1->bssConfig).RsnConfig.PSKValue);
    (paVar1->bssData).updatePassPhrase = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BufferDesc_t *
PrepDefaultEapolMsg(cm_ConnectionInfo_t *connPtr,EAPOL_KeyMsg_Tx_t **pTxEapolPtr,
                   BufferDesc_t *pBufDesc)

{
  apSpecificData_t *paVar1;
  apInfo_t *paVar2;
  BufferDesc_t *pBVar3;
  uint nonTKIP;
  EAPOL_KeyMsg_Tx_t *pEStack36;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  
  paVar1 = cm_GetApData(connPtr);
  paVar2 = cm_GetApInfo(connPtr);
  pBVar3 = GetTxEAPOLBuffer(connPtr,&pEStack36,pBufDesc);
  if (pBVar3 != (BufferDesc_t *)0x0) {
    memset(pEStack36,0,0x72);
    formEAPOLEthHdr(pEStack36,(IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                    (IEEEtypes_MacAddr_t *)connPtr->localMacAddr);
    nonTKIP = 1;
    if (((byte)(paVar1->staData).keyMgmtInfo.rom.staUcstCipher & 8) == 0) {
      nonTKIP = (byte)(paVar2->bssConfig).RsnConfig.mcstCipher >> 3 & 1;
    }
    SetEAPOLKeyDescTypeVersion
              (pEStack36,*(uint *)&(paVar1->staData).keyMgmtInfo.rom >> 0x15 & 1,0,nonTKIP);
    *pTxEapolPtr = pEStack36;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pBVar3;
}



// WARNING: Variable defined which should be unmapped: replay_cnt

Status_e GeneratePWKMsg1(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  Status_e SVar1;
  apSpecificData_t *paVar2;
  BufferDesc_t *pBufDesc_00;
  UINT16 frameLen;
  EAPOL_KeyMsg_Tx_t *pEStack28;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  paVar2 = cm_GetApData(connPtr);
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack28,pBufDesc);
  if (pBufDesc_00 == (BufferDesc_t *)0x0) {
    SVar1 = FAIL;
  }
  else {
    replay_cnt[0] = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = replay_cnt[0];
    if (replay_cnt[0] == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    supplicantGenerateRand((UINT8 *)&connPtr->TxRxCipherKeyBuf,0x20);
    PopulateKeyMsg(pEStack28,&(paVar2->staData).keyMgmtInfo.rom.staUcstCipher,0x800,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    frameLen = (pEStack28->keyMsg).key_material_len + 0x5f;
    (pEStack28->keyMsg).hdr_8021x.protocol_ver = (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion;
    (pEStack28->keyMsg).hdr_8021x.pckt_type = IEEE_8021X_PACKET_TYPE_EAPOL_KEY;
    *(char *)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len = (char)(frameLen >> 8);
    *(char *)((int)&(pEStack28->keyMsg).hdr_8021x.pckt_body_len + 1) = (char)frameLen;
    UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,frameLen);
    SVar1 = FW_SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SVar1;
}



Status_e GeneratePWKMsg3(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  UINT16 frameLen;
  BufferDesc_t *pBufDesc_00;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  uint8_t *pWPA2;
  Cipher_t *Cipher;
  EAPOL_KeyMsg_Tx_t *pEStack44;
  EAPOL_KeyMsg_Tx_t *tx_eapol_ptr;
  UINT32 replay_cnt [2];
  
  pBufDesc_00 = PrepDefaultEapolMsg(connPtr,&pEStack44,pBufDesc);
  if (pBufDesc_00 != (BufferDesc_t *)0x0) {
    paVar2 = cm_GetApData(connPtr);
    paVar3 = cm_GetApInfo(connPtr);
    replay_cnt[0] = (paVar2->staData).keyMgmtInfo.counterLo + 1;
    (paVar2->staData).keyMgmtInfo.counterLo = replay_cnt[0];
    if (replay_cnt[0] == 0) {
      (paVar2->staData).keyMgmtInfo.counterHi = (paVar2->staData).keyMgmtInfo.counterHi + 1;
    }
    tx_eapol_ptr = (EAPOL_KeyMsg_Tx_t *)(paVar2->staData).keyMgmtInfo.counterHi;
    Cipher = &(paVar2->staData).keyMgmtInfo.rom.staUcstCipher;
    PopulateKeyMsg(pEStack44,Cipher,
                   ((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) << 10 | 0x880,
                   (UINT32 *)&tx_eapol_ptr,(UINT8 *)&connPtr->TxRxCipherKeyBuf);
    SVar1 = (paVar2->staData).keyMgmtInfo.rom.staSecType;
    pWPA2 = (uint8_t *)0x0;
    if ((((ushort)SVar1 & 8) == 0) && (((ushort)SVar1 & 0x20) != 0)) {
      pWPA2 = int_rsn_ie;
    }
    BVar4 = KeyData_UpdateKeyMaterial
                      (pEStack44,&(paVar2->staData).keyMgmtInfo.rom.staSecType,(void *)0x0,pWPA2);
    if (BVar4 != 0) {
      if (((ushort)(paVar2->staData).keyMgmtInfo.rom.staSecType & 0x20) == 0) {
LAB_230128b6:
        frameLen = KeyMgmtSta_PopulateEAPOLLengthMic
                             (pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key,
                              (paVar2->staData).keyMgmtInfo.EAPOLProtoVersion,
                              *(byte *)&(pEStack44->keyMsg).key_info.field_0x1 & 7);
        UpdateEAPOLWcbLenAndTransmit(pBufDesc_00,frameLen);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return FW_SUCCESS;
      }
      prepareKDE(pEStack44,&(paVar3->bssData).grpKeyData,(Cipher_t *)&(paVar3->bssConfig).RsnConfig)
      ;
      BVar4 = Encrypt_keyData(pEStack44,(paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,Cipher);
      if (BVar4 != 0) goto LAB_230128b6;
    }
    vPortFree(pBufDesc_00->Buffer);
    vPortFree(pBufDesc_00);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FAIL;
}



Status_e ProcessPWKMsg4(BufferDesc_t *pBufDesc)

{
  SecurityMode_t SVar1;
  cm_ConnectionInfo_t *connPtr;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  BOOLEAN BVar4;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar3 = cm_GetApData(connPtr);
  BVar4 = IsEAPOL_MICValid((EAPOL_KeyMsg_t *)pBufDesc->Buffer,
                           (paVar3->staData).keyMgmtInfo.EAPOL_MIC_Key);
  if (BVar4 == 0) {
    SVar2 = FAIL;
  }
  else {
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x44 = 1;
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x45 = 0;
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x40 = 0;
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x41 = 0;
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x42 = 0;
    *(undefined *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x43 = 0;
    add_key_to_mac(connPtr,'\x01');
    apm_sta_add(connPtr->staId);
    SVar1 = (paVar3->staData).keyMgmtInfo.rom.staSecType;
    (paVar3->staData).keyMgmtInfo.numHskTries = '\0';
    SVar2 = FW_SUCCESS;
    if (((ushort)SVar1 & 0x20) != 0) {
      (paVar3->staData).keyMgmtInfo.rom.keyMgmtState = HSK_END;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SVar2;
}



Status_e GenerateApEapolMsg(cm_ConnectionInfo_t *connPtr,keyMgmtState_e msgState,
                           BufferDesc_t *pBufDesc)

{
  IEEEtypes_PwrMgmtMode_e IVar1;
  uint uVar2;
  int iVar3;
  Status_e SVar4;
  apSpecificData_t *paVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_0000202d;
  
  uVar2 = CONCAT31(in_register_0000202d,msgState);
  paVar5 = cm_GetApData(connPtr);
  if ((msgState & 1) == 0) {
    uVar2 = uVar2 - 1 & 0xff;
  }
  IVar1 = (paVar5->staData).pwrSaveInfo.mode;
  (paVar5->staData).keyMgmtInfo.rom.keyMgmtState = (keyMgmtState_e)uVar2;
  if (IVar1 != PWR_MODE_PWR_SAVE) {
    if (uVar2 == 1) {
      SVar4 = GeneratePWKMsg1(connPtr,pBufDesc);
      iVar3 = CONCAT31(extraout_var,SVar4);
    }
    else {
      if (uVar2 != 3) {
        iVar3 = 1;
        if (pBufDesc != (BufferDesc_t *)0x0) {
          vPortFree(pBufDesc->Buffer);
          vPortFree(pBufDesc);
        }
        goto LAB_230129d2;
      }
      SVar4 = GeneratePWKMsg3(connPtr,pBufDesc);
      iVar3 = CONCAT31(extraout_var_00,SVar4);
    }
    if (iVar3 != 0) goto LAB_230129d2;
    (paVar5->staData).keyMgmtInfo.rom.keyMgmtState =
         (paVar5->staData).keyMgmtInfo.rom.keyMgmtState + MSG1_PENDING;
  }
  iVar3 = 0;
  (paVar5->staData).keyMgmtInfo.numHskTries = (paVar5->staData).keyMgmtInfo.numHskTries + '\x01';
LAB_230129d2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (Status_e)iVar3;
}



Status_e ProcessPWKMsg2(BufferDesc_t *pBufDesc)

{
  cm_ConnectionInfo_t *connPtr;
  EAPOL_KeyMsg_t *pKeyMsg;
  Status_e SVar1;
  apSpecificData_t *paVar2;
  apInfo_t *paVar3;
  BOOLEAN BVar4;
  UINT8 *EAPOL_MIC_Key;
  BOOLEAN in_fa0;
  
  connPtr = (cm_ConnectionInfo_t *)pBufDesc->intf;
  paVar2 = cm_GetApData(connPtr);
  paVar3 = cm_GetApInfo(connPtr);
  pKeyMsg = (EAPOL_KeyMsg_t *)pBufDesc->Buffer;
  EAPOL_MIC_Key = (paVar2->staData).keyMgmtInfo.EAPOL_MIC_Key;
  KeyMgmtAp_DerivePTK((paVar3->bssConfig).RsnConfig.PSKValue,
                      (IEEEtypes_MacAddr_t *)connPtr->peerMacAddr,
                      (IEEEtypes_MacAddr_t *)(connPtr->comData).BssId,
                      (UINT8 *)&connPtr->TxRxCipherKeyBuf,pKeyMsg->key_nonce,EAPOL_MIC_Key,
                      (paVar2->staData).keyMgmtInfo.EAPOL_Encr_Key,
                      (KeyData_t *)&(connPtr->TxRxCipherKeyBuf).cipher_key.ckd.field_0x20,in_fa0);
  BVar4 = IsEAPOL_MICValid(pKeyMsg,EAPOL_MIC_Key);
  if (BVar4 != 0) {
    (paVar2->staData).keyMgmtInfo.numHskTries = '\0';
    rsn_len = pKeyMsg[1].hdr_8021x.protocol_ver + '\x02';
    SVar1 = GenerateApEapolMsg(connPtr,MSG3_PENDING,(BufferDesc_t *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FAIL;
}



BOOLEAN SendEAPOLMsgUsingBufDesc(cm_ConnectionInfo_t *connPtr,BufferDesc_t *pBufDesc)

{
  keyMgmtState_e msgState;
  bool bVar1;
  apSpecificData_t *paVar2;
  
  paVar2 = cm_GetApData(connPtr);
  msgState = (paVar2->staData).keyMgmtInfo.rom.keyMgmtState;
  bVar1 = (msgState & 1) != 0;
  if (bVar1) {
    GenerateApEapolMsg(connPtr,msgState,pBufDesc);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



// WARNING: Variable defined which should be unmapped: rxCounterLo

Status_e ProcessKeyMgmtDataAp(BufferDesc_t *pBufDesc)

{
  keyMgmtState_e kVar1;
  Status_e SVar2;
  apSpecificData_t *paVar3;
  void *pvVar4;
  uint uStack24;
  UINT32 rxCounterHi;
  UINT32 rxCounterLo;
  
  paVar3 = cm_GetApData((cm_ConnectionInfo_t *)pBufDesc->intf);
  pvVar4 = pBufDesc->Buffer;
  if ((*(byte *)((int)pvVar4 + 5) & 4) == 0) {
    memcpy(&uStack24,(void *)((int)pvVar4 + 9),4);
    memcpy(&rxCounterHi,(void *)((int)pvVar4 + 0xd),4);
    if (((paVar3->staData).keyMgmtInfo.counterHi ==
         (uStack24 >> 8 & 0xff00) +
         (uStack24 & 0xff00) * 0x100 + uStack24 * 0x1000000 + (uStack24 >> 0x18)) &&
       ((paVar3->staData).keyMgmtInfo.counterLo ==
        (rxCounterHi >> 8 & 0xff00) +
        rxCounterHi * 0x1000000 + (rxCounterHi >> 0x18) + (rxCounterHi & 0xff00) * 0x100)) {
      kVar1 = (paVar3->staData).keyMgmtInfo.rom.keyMgmtState;
      if (kVar1 == WAITING_4_MSG2) {
        SVar2 = ProcessPWKMsg2(pBufDesc);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return SVar2;
      }
      if (kVar1 == WAITING_4_MSG4) {
        SVar2 = ProcessPWKMsg4(pBufDesc);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return SVar2;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FAIL;
}



void InitStaKeyInfo(void *pConn,SecurityMode_t *secType,Cipher_t *pwCipher,UINT16 staRsnCap,
                   UINT8 akmType)

{
  apKeyMgmtInfoSta_t *pKeyMgmtInfo;
  apSpecificData_t *paVar1;
  
  paVar1 = cm_GetApData((cm_ConnectionInfo_t *)pConn);
  pKeyMgmtInfo = &(paVar1->staData).keyMgmtInfo;
  memset(pKeyMgmtInfo,0,0x48);
  InitKeyMgmtInfo((apKeyMgmtInfoStaRom_t *)pKeyMgmtInfo,secType,pwCipher,staRsnCap,akmType);
  (paVar1->staData).keyMgmtInfo.EAPOLProtoVersion = '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void RemoveAPKeyInfo(void *pConn)

{
  if (*(uint8_t *)((int)pConn + 3) != -1) {
    mm_sec_machwkey_del(*(uint8_t *)((int)pConn + 3));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void InitGroupKey(cm_ConnectionInfo_t *connPtr)

{
  uint8_t uVar1;
  apInfo_t *paVar2;
  int iVar3;
  undefined3 extraout_var;
  UINT32 UVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  (paVar2->bssData).grpRekeyBcnCntConfigured = 0;
  (paVar2->bssData).grpRekeyBcnCntRemaining = 0;
  KeyMgmtInit(connPtr);
  UVar4 = (paVar2->bssConfig).RsnConfig.GrpReKeyTime;
  if (UVar4 != 0) {
    iVar3 = UVar4 * 0x1e848 + -0x7d;
    __udivdi3();
    (paVar2->bssData).grpRekeyBcnCntConfigured = iVar3 + 1U;
    (paVar2->bssData).grpRekeyBcnCntRemaining = iVar3 + 1U;
  }
  uVar1 = add_key_to_mac(connPtr,'\0');
  connPtr->gtkHwKeyId = uVar1;
  printf("gtkHwKeyId is %d\r\n",CONCAT31(extraout_var,uVar1));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: inp_data

void GenerateGTK_internal(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  size_t prefix_len;
  uchar auStack140 [4];
  UINT8 prefix [20];
  UINT8 GTK [32];
  UINT8 grpMasterKey [32];
  UINT8 inp_data [38];
  
  memcpy(auStack140,"Group key expansion",0x14);
  if ((grpKeyData != (KeyData_t *)0x0) && (nonce != (UINT8 *)0x0)) {
    memcpy(grpMasterKey + 0x1c,StaMacAddr,6);
    supplicantGenerateRand(nonce,0x20);
    memcpy(inp_data + 2,nonce,0x20);
    supplicantGenerateRand(GTK + 0x1c,0x20);
    prefix_len = strlen((char *)auStack140);
    Bl_PRF(GTK + 0x1c,0x20,auStack140,prefix_len,grpMasterKey + 0x1c,0x26,prefix + 0x10,0x20);
    memcpy(grpKeyData,prefix + 0x10,0x10);
    memcpy(grpKeyData->TxMICKey,GTK + 0xc,8);
    memcpy(grpKeyData->RxMICKey,GTK + 0x14,8);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void PopulateKeyMsg(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,Cipher_t *Cipher,UINT16 Type,UINT32 *replay_cnt,
                   UINT8 *Nonce)

{
  byte bVar1;
  undefined2 in_register_00002032;
  int iVar2;
  undefined uVar3;
  byte bVar4;
  uint uVar5;
  
  uVar5 = CONCAT22(in_register_00002032,Type);
  if ((tx_eapol_ptr == (EAPOL_KeyMsg_Tx_t *)0x0) || (Cipher == (Cipher_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (((byte)*Cipher & 4) == 0) {
    if (((byte)*Cipher & 8) != 0) {
      *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
      uVar3 = 0x10;
      goto LAB_23012cc4;
    }
  }
  else {
    *(undefined *)&(tx_eapol_ptr->keyMsg).key_length = 0;
    uVar3 = 0x20;
LAB_23012cc4:
    *(undefined *)((int)&(tx_eapol_ptr->keyMsg).key_length + 1) = uVar3;
  }
  bVar1 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1;
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x80;
  if ((int)(uVar5 << 0x14) < 0) {
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 0x88;
    if ((Type & 0x80) == 0) goto LAB_23012d0e;
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info;
    *(byte *)&(tx_eapol_ptr->keyMsg).key_info.field_0x1 = bVar1 | 200;
    bVar4 = bVar4 & 0xed | 1 | (byte)((uVar5 >> 0xf) << 1);
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
  }
  else {
    bVar1 = (byte)((uVar5 >> 0xf) << 4);
    bVar4 = *(byte *)&(tx_eapol_ptr->keyMsg).key_info & 0xec | 3;
  }
  *(byte *)&(tx_eapol_ptr->keyMsg).key_info = bVar1 | bVar4;
LAB_23012d0e:
  uVar5 = *replay_cnt;
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)(tx_eapol_ptr->keyMsg).replay_cnt = (char)iVar2;
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)((uint)iVar2 >> 8);
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 2) = (char)((uint)iVar2 >> 0x10);
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 3) = (char)((uint)iVar2 >> 0x18);
  uVar5 = replay_cnt[1];
  iVar2 = uVar5 * 0x1000000 + (uVar5 >> 0x18) + (uVar5 & 0xff00) * 0x100 + (uVar5 >> 8 & 0xff00);
  *(char *)((tx_eapol_ptr->keyMsg).replay_cnt + 1) = (char)iVar2;
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 5) = (char)((uint)iVar2 >> 8);
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 6) = (char)((uint)iVar2 >> 0x10);
  *(char *)((int)(tx_eapol_ptr->keyMsg).replay_cnt + 7) = (char)((uint)iVar2 >> 0x18);
  memcpy((tx_eapol_ptr->keyMsg).key_nonce,Nonce,0x20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prepareKDE(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,KeyData_t *grKey,Cipher_t *cipher)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  UINT8 *pUVar4;
  UINT8 *__dest;
  
  if (tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) {
    if ((grKey != (KeyData_t *)0x0) && (cipher != (Cipher_t *)0x0)) {
      pUVar4 = (tx_eapol_ptr->keyMsg).key_data + *(byte *)&(tx_eapol_ptr->keyMsg).key_material_len;
      *pUVar4 = -0x23;
      pUVar4[1] = '\x16';
      pUVar4[2] = '\0';
      pUVar4[3] = '\x0f';
      pUVar4[4] = -0x54;
      pUVar4[5] = '\x01';
      pUVar4[6] = pUVar4[6] & 0xfc | 1;
      memcpy(pUVar4 + 8,grKey,0x10);
      __dest = pUVar4 + 0x18;
      if (((byte)*cipher & 4) != 0) {
        pUVar4[1] = pUVar4[1] + '\x10';
        memcpy(__dest,grKey->TxMICKey,8);
        memcpy(pUVar4 + 0x20,grKey->RxMICKey,8);
        __dest = pUVar4 + 0x28;
      }
      uVar1 = (tx_eapol_ptr->keyMsg).key_material_len + 2 + (uint)pUVar4[1];
      uVar2 = uVar1 & 0xffff;
      *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
      *(char *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(uVar2 >> 8);
      uVar1 = -uVar2 & 7;
      if (uVar1 != 0) {
        *__dest = -0x23;
        memset(__dest + 1,0,uVar1 - 1);
        iVar3 = uVar1 + (tx_eapol_ptr->keyMsg).key_material_len;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)((uint)(iVar3 * 0x10000) >> 0x10);
        *(char *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)((uint)iVar3 >> 8);
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BOOLEAN Encrypt_keyData(EAPOL_KeyMsg_Tx_t *tx_eapol_ptr,UINT8 *EAPOL_Encr_Key,Cipher_t *cipher)

{
  void *pv;
  UINT8 *cipher_00;
  uint uVar1;
  uint __n;
  UINT8 *plain;
  UINT8 aUStack48 [4];
  UINT8 key [16];
  
  if (((tx_eapol_ptr != (EAPOL_KeyMsg_Tx_t *)0x0) && (EAPOL_Encr_Key != (UINT8 *)0x0)) &&
     (cipher != (Cipher_t *)0x0)) {
    if (((byte)*cipher & 8) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (byte)*cipher >> 2 & 1;
    }
    pv = pvPortMalloc(0xc);
    if (pv != (void *)0x0) {
      cipher_00 = (UINT8 *)pvPortMalloc(400);
      *(UINT8 **)((int)pv + 8) = cipher_00;
      if (cipher_00 != (UINT8 *)0x0) {
        memcpy(aUStack48,EAPOL_Encr_Key,0x10);
        plain = (tx_eapol_ptr->keyMsg).key_data;
        BL_AesWrap(aUStack48,'\x02',(uint)((tx_eapol_ptr->keyMsg).key_material_len >> 3),plain,
                   (UINT8 *)0x0,cipher_00);
        uVar1 = (tx_eapol_ptr->keyMsg).key_material_len + 8;
        __n = uVar1 & 0xffff;
        *(char *)&(tx_eapol_ptr->keyMsg).key_material_len = (char)(uVar1 * 0x10000 >> 0x10);
        *(char *)((int)&(tx_eapol_ptr->keyMsg).key_material_len + 1) = (char)(__n >> 8);
        memcpy(plain,cipher_00,__n);
        vPortFree(*(void **)((int)pv + 8));
        vPortFree(pv);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 1;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void KeyMgmtAp_DerivePTK(UINT8 *pPMK,IEEEtypes_MacAddr_t *da,IEEEtypes_MacAddr_t *sa,UINT8 *ANonce,
                        UINT8 *SNonce,UINT8 *EAPOL_MIC_Key,UINT8 *EAPOL_Encr_Key,KeyData_t *newPWKey
                        ,BOOLEAN use_kdf)

{
  undefined auStack24 [4];
  UINT8 tmp [8];
  
  KeyMgmtSta_DeriveKeys(pPMK,da,sa,ANonce,SNonce,EAPOL_MIC_Key,EAPOL_Encr_Key,newPWKey,use_kdf);
  memcpy(auStack24,newPWKey->RxMICKey,8);
  memcpy(newPWKey->RxMICKey,newPWKey->TxMICKey,8);
  memcpy(newPWKey->TxMICKey,auStack24,8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BOOLEAN KeyData_CopyWPAWP2(EAPOL_KeyMsg_Tx_t *pTxEAPOL,void *pIe)

{
  size_t __n;
  
  if (pIe != (void *)0x0) {
    __n = *(byte *)((int)pIe + 1) + 2;
    *(char *)&(pTxEAPOL->keyMsg).key_material_len = (char)__n;
    *(char *)((int)&(pTxEAPOL->keyMsg).key_material_len + 1) = (char)(__n >> 8);
    memcpy((pTxEAPOL->keyMsg).key_data,pIe,__n);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



BOOLEAN KeyData_UpdateKeyMaterial
                  (EAPOL_KeyMsg_Tx_t *pTxEAPOL,SecurityMode_t *pSecType,void *pWPA,void *pWPA2)

{
  BOOLEAN BVar1;
  uint uVar2;
  
  if (((*(byte *)pSecType & 0x18) != 0) ||
     (uVar2 = 1, pWPA = pWPA2, (*(byte *)pSecType & 0x20) != 0)) {
    BVar1 = KeyData_CopyWPAWP2(pTxEAPOL,pWPA);
    uVar2 = (uint)(BVar1 != 0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



void ROM_InitGTK(KeyData_t *grpKeyData,UINT8 *nonce,IEEEtypes_Addr_t *StaMacAddr)

{
  grpKeyData->TxIV32 = 0;
  *(undefined4 *)&grpKeyData->TxIV16 = 0x10001;
  GenerateGTK_internal(grpKeyData,nonce,StaMacAddr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void InitKeyMgmtInfo(apKeyMgmtInfoStaRom_t *pKeyMgmtInfo,SecurityMode_t *secType,Cipher_t *pwCipher,
                    UINT16 staRsnCap,UINT8 akmType)

{
  pKeyMgmtInfo->keyMgmtState = MSG1_PENDING;
  memcpy(&pKeyMgmtInfo->staSecType,secType,2);
  memcpy(&pKeyMgmtInfo->staUcstCipher,pwCipher,1);
  pKeyMgmtInfo->staAkmType = akmType;
  if ((*(byte *)secType & 0x20) != 0) {
    pKeyMgmtInfo->staRsnCap = staRsnCap;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



apInfo_t * cm_GetApInfo(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return *(apInfo_t **)&connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (apInfo_t *)connPtr;
}



apSpecificData_t * cm_GetApData(cm_ConnectionInfo_t *connPtr)

{
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    if (connPtr->conType == '\x02') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (apSpecificData_t *)&connPtr->specDat;
    }
    connPtr = (cm_ConnectionInfo_t *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (apSpecificData_t *)connPtr;
}



Status_e cm_AllocAPResources(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  BufferDesc_t *pBVar2;
  void *pvVar3;
  
  paVar1 = cm_GetApData(connPtr);
  if (paVar1->apInfoBuffDesc == (BufferDesc_t *)0x0) {
    pBVar2 = (BufferDesc_t *)pvPortMalloc(0xc);
    if (pBVar2 == (BufferDesc_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return FAIL;
    }
    pvVar3 = pvPortMalloc(0x120);
    pBVar2->Buffer = pvVar3;
    paVar1->apInfoBuffDesc = pBVar2;
    paVar1->apInfo = (apInfo_t *)pBVar2->Buffer;
    InitializeAp(connPtr);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FW_SUCCESS;
}



Status_e cm_AllocResources(cm_ConnectionInfo_t *connPtr)

{
  Status_e SVar1;
  
  if (connPtr->conType == '\x02') {
    SVar1 = cm_AllocAPResources(connPtr);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FW_SUCCESS;
}



cm_ConnectionInfo_t *
cm_InitConnection(UINT8 conType,UINT8 bssType,UINT8 bssNum,IEEEtypes_MacAddr_t *bssId,
                 IEEEtypes_MacAddr_t *peerMacAddr,UINT8 channel,mdev_t *hostMdev)

{
  Status_e SVar1;
  cm_ConnectionInfo_t *connPtr;
  undefined3 extraout_var;
  IEEEtypes_Addr_t *__s;
  
  connPtr = (cm_ConnectionInfo_t *)pvPortMalloc(0xec);
  if (connPtr != (cm_ConnectionInfo_t *)0x0) {
    memset(connPtr,0,0xec);
    connPtr->conType = conType;
    SVar1 = cm_AllocResources(connPtr);
    if (CONCAT31(extraout_var,SVar1) == 1) {
      vPortFree(connPtr);
      connPtr = (cm_ConnectionInfo_t *)0x0;
    }
    else {
      if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(connPtr->peerMacAddr,peerMacAddr,6);
      }
      __s = (connPtr->comData).BssId;
      memset(__s,0,6);
      memset(&connPtr->comData,0,0x20);
      (connPtr->comData).SsIdLen = '\0';
      if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
        memcpy(__s,bssId,6);
        memcpy(connPtr->localMacAddr,bssId,6);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return connPtr;
}



void cm_DeleteConnection(cm_ConnectionInfo_t *connPtr)

{
  apSpecificData_t *paVar1;
  
  if (connPtr->conType == '\x02') {
    paVar1 = cm_GetApData(connPtr);
    if (paVar1->apInfoBuffDesc != (BufferDesc_t *)0x0) {
      vPortFree(paVar1->apInfoBuffDesc->Buffer);
      vPortFree(paVar1->apInfoBuffDesc);
      paVar1->apInfoBuffDesc = (BufferDesc_t *)0x0;
      paVar1->apInfo = (apInfo_t *)0x0;
    }
  }
  vPortFree(connPtr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cm_SetPeerAddr(cm_ConnectionInfo_t *connPtr,IEEEtypes_MacAddr_t *bssId,
                   IEEEtypes_MacAddr_t *peerMacAddr)

{
  if (bssId != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy((connPtr->comData).BssId,bssId,6);
  }
  if (peerMacAddr != (IEEEtypes_MacAddr_t *)0x0) {
    memcpy(connPtr->peerMacAddr,peerMacAddr,6);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cm_SetComData(cm_ConnectionInfo_t *connPtr,char *ssid)

{
  size_t sVar1;
  uint uVar2;
  
  if (ssid != (char *)0x0) {
    sVar1 = strlen(ssid);
    (connPtr->comData).SsIdLen = (IEEEtypes_Len_t)sVar1;
    memcpy(&connPtr->comData,ssid,0x20);
    uVar2 = (uint)(connPtr->comData).SsIdLen;
    if (uVar2 < 0x20) {
      (connPtr->comData).SsId[uVar2] = '\0';
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void assert_rec(char *condition,char *file,int line)

{
  if (mac_hw_reset != '\x01') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((int)ke_env.evt_field < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  hal_machw_disable_int();
  ke_evt_set(0x80000000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void assert_err(char *condition,char *file,int line)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void assert_warn(char *condition,char *file,int line)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void coex_dump_pta(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void coex_dump_wifi(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void coex_wifi_rf_forece_enable(int enable)

{
  if (enable != 0) {
    enable = 1;
  }
  rfc_coex_force_to(enable,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void coex_wifi_pti_forece_enable(int enable)

{
  if (enable == 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xffffffef;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 | 0xf0000010;
  }
  if ((int)(_DAT_44b00400 << 4) < 0) {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff;
  }
  else {
    _DAT_44b00400 = _DAT_44b00400 & 0xfbffffff | 0x4000000;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void coex_wifi_pta_forece_enable(int enable)

{
  TickType_t TVar1;
  uint32_t uVar2;
  
  if (coex_wifi_pta_forece_enable::pta_status != enable) {
    if (coex_wifi_pta_forece_enable::pta_status == 0) {
      TVar1 = xTaskGetTickCount();
      pds_slept_time = (pds_slept_time - coex_wifi_pta_forece_enable::time_sleep) + TVar1;
    }
    else {
      if (coex_wifi_pta_forece_enable::pta_status == 1) {
        TVar1 = xTaskGetTickCount();
        pds_woken_time = (pds_woken_time - coex_wifi_pta_forece_enable::time_sleep) + TVar1;
        uVar2 = bl_nap_calculate();
        if (1000 < uVar2) {
          AON_LowPower_Enter_PDS0();
          vTaskDelay(uVar2 / 1000);
          AON_LowPower_Exit_PDS0();
        }
      }
    }
    coex_wifi_pta_forece_enable::pta_status = enable;
    coex_wifi_pta_forece_enable::time_sleep = xTaskGetTickCount();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wifi_main(void *param)

{
  int iVar1;
  uint uVar2;
  
  rfc_init(40000000);
  _DAT_44b00400 = _DAT_44b00400 | 1;
  mpif_clk_init();
  sysctrl_init();
  intc_init();
  ipc_emb_init();
  bl_init();
  _DAT_44b00404 = 0x24f037;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  do {
    if (_DAT_44b00120 << 0xc < 0) {
      _DAT_44900084 = _DAT_44900084 | 1;
    }
    else {
      _DAT_44900084 = _DAT_44900084 & 0xfffffffe;
    }
    if (ke_env.evt_field == 0) {
      ipc_emb_wait();
    }
    if ((packets_num_12624 & 0xf) == 0) {
      uVar2 = _DAT_40007018 >> 0x18 & 7;
      if (uVar2 != 0) {
        if (uVar2 != 3) {
          _DAT_40000014 = _DAT_40000014 | 0x40000;
        }
        if ((uVar2 != 0) && (uVar2 != 3)) {
          _DAT_40002040 = _DAT_40002040 & 0xfffffffc;
          _DAT_40002044 = _DAT_40002044 & 0xfffffffe;
        }
      }
      if ((_DAT_40007018 >> 0x18 & 4) != 0) {
        _DAT_40000014 = _DAT_40000014 | 0x5c2000;
        _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe | 4;
      }
    }
    packets_num_12624 = packets_num_12624 + 1;
    ke_evt_schedule();
    iVar1 = bl_sleep();
    coex_wifi_pta_forece_enable((uint)(iVar1 == 0));
  } while( true );
}



void ipc_emb_notify(void)

{
  int iStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    assert_err("NULL != xTaskToNotify","module",0x93);
  }
  if (TrapNetCounter == 0) {
    xTaskGenericNotify(xTaskToNotify,0,eIncrement,(uint32_t *)0x0);
  }
  else {
    vTaskNotifyGiveFromISR(xTaskToNotify,&iStack20);
    if (iStack20 != 0) {
      vTaskSwitchContext();
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ipc_emb_wait(void)

{
  ulTaskNotifyTake(1,0xffffffff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ipc_emb_counter = ipc_emb_counter + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_init(void)

{
  xTaskToNotify = xTaskGetCurrentTaskHandle();
  memset(&ipc_emb_env,0,0x20);
  ipc_emb_env.txdesc = ipc_shared_env.txdesc0;
  if (_DAT_44800140 != 0x49504332) {
    assert_err("ipc_emb_signature_get() == IPC_EMB_SIGNATURE_RESET","module",0xbb);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4480010c = 0x1f03;
  _DAT_44800114 = 0x3ff2a04;
  _DAT_44800118 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c & 0x1f00;
  if (uVar1 != 0) {
    ke_evt_set(uVar1 >> 1);
    _DAT_44800108 = uVar1;
    _DAT_44800110 = uVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_tx_evt(int queue_idx)

{
  txdesc_host *ptVar1;
  txdesc_host *ptVar2;
  txdesc *ptVar3;
  txdesc *ptVar4;
  uint event;
  txdesc *txdesc;
  
  event = ipc_emb_evt_bit[queue_idx];
  ke_evt_clear(event);
  ptVar1 = ipc_emb_env.txdesc;
  while( true ) {
    ptVar2 = ptVar1 + (ipc_emb_env.txdesc_idx & 3);
    if (ptVar2->ready != 0xffffffff) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_4480010c = 0x100;
      return;
    }
    if (((event & 0x800) == 0) && ((ke_env.evt_field & 0x440800) != 0)) break;
    txdesc = (txdesc *)ptVar2->pad_txdesc;
    _DAT_44800108 = 0x100;
    memset(txdesc,0,0x2cc);
    ptVar2->pad_txdesc[0x1c] = (uint32_t)(ptVar2->pad_txdesc + 0x2e);
    ptVar2->pad_txdesc[0x1b] = (uint32_t)(ptVar2->pad_txdesc + 0x1c);
    ptVar3 = (txdesc *)&ptVar2->host;
    do {
      ptVar4 = (txdesc *)&ptVar3->host;
      (ptVar3->umac).buf_control = (txl_buffer_control *)(ptVar3->list_hdr).next;
      ptVar3 = ptVar4;
    } while (txdesc != ptVar4);
    ptVar2->pad_txdesc[0x19] = 0;
    *(undefined4 *)(*(int *)ptVar2->pad_txdesc[0x1b] + 0x10) = 0;
    ptVar2->pad_txdesc[0x27] = 0;
    ptVar2->pad_txdesc[0x28] = 0;
    ptVar2->pad_txdesc[0x29] = 0;
    ptVar2->pad_txdesc[0x15] = 0;
    txu_cntrl_push(txdesc,'\0');
    ptVar2->ready = 1;
    ipc_emb_env.txdesc_idx = ipc_emb_env.txdesc_idx + 1;
  }
  ke_evt_set(event);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_cfmback_irq(void)

{
  uint uVar1;
  
  uVar1 = _DAT_4480011c;
  if ((_DAT_4480011c & 0x20) != 0) {
    _DAT_44800110 = 0x20;
    _DAT_44800108 = 0x20;
    ke_evt_set(0x40000);
  }
  if ((uVar1 & 0x10) != 0) {
    _DAT_44800110 = 0x10;
    _DAT_44800108 = 0x10;
    ke_evt_set(0x80000);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_txcfm_ind(uint32_t queue_bits)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44800100 = queue_bits << 7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_irq(void)

{
  if ((_DAT_4480011c & 2) != 0) {
    ke_evt_set(0x2000000);
    _DAT_44800110 = 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_msg_evt(int dummy)

{
  int iVar1;
  undefined4 *puVar2;
  uint8_t uVar3;
  undefined4 *puVar4;
  int iVar5;
  
  do {
    if ((_DAT_44800104 & 2) == 0) {
      ke_evt_clear(0x2000000);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_4480010c = 2;
      return;
    }
    _DAT_44800108 = 2;
    puVar2 = (undefined4 *)ke_malloc(ipc_shared_env.msg_a2e_buf.msg[1]._2_2_ + 0xc);
    if (puVar2 == (undefined4 *)0x0) {
      assert_err("kmsg_dst != NULL","module",0x1d9);
    }
    *puVar2 = 0;
    *(undefined2 *)(puVar2 + 1) = (undefined2)ipc_shared_env.msg_a2e_buf.msg[0];
    *(undefined2 *)((int)puVar2 + 6) = ipc_shared_env.msg_a2e_buf.msg[0]._2_2_;
    *(undefined2 *)(puVar2 + 2) = 0xd;
    *(ushort *)((int)puVar2 + 10) = ipc_shared_env.msg_a2e_buf.msg[1]._2_2_;
    iVar5 = 0xc;
    while (iVar5 + -0xc < (int)(uint)*(ushort *)((int)puVar2 + 10)) {
      iVar1 = iVar5 + -4;
      puVar4 = (undefined4 *)((int)puVar2 + iVar5);
      iVar5 = iVar5 + 4;
      *puVar4 = *(undefined4 *)((int)ipc_shared_env.msg_a2e_buf.msg + iVar1);
    }
    uVar3 = ipc_emb_env.ipc_msgacke2a_cnt + '\x01';
    ipc_shared_env.msg_a2e_buf.msg[1]._0_2_ = (ushort)ipc_emb_env.ipc_msgacke2a_cnt;
    ipc_emb_env.ipc_msgacke2a_cnt = uVar3;
    if (*(ushort *)((int)puVar2 + 6) < 0xf) {
      if (0xc < *(ushort *)((int)puVar2 + 6)) goto LAB_2301395c;
    }
    else {
      assert_err("id <= TASK_MAX","module",0xb6);
LAB_2301395c:
      assert_err("ke_task_local(kmsg_dst->dest_id)","module",0x1ed);
    }
    _DAT_44800100 = 4;
    ke_msg_send(puVar2 + 3);
  } while( true );
}



void ipc_emb_msg_dma_int_handler(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_emb_dbg_dma_int_handler(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44800100 = 1;
  _DAT_44a00020 = 0x80;
  return;
}



void ipc_emb_dump(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_set_channel(uint8_t bandwidth,uint16_t channel_freq)

{
  undefined2 in_register_0000202e;
  
  rfc_config_channel(CONCAT22(in_register_0000202e,channel_freq));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_dump_status(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_txcbwmax_setf(uint8_t txcbwmax)

{
  if ((txcbwmax & 0xfc) != 0) {
    assert_err("(((uint32_t)txcbwmax << 24) & ~((uint32_t)0x03000000)) == 0","module",0xb58);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44c00824 = _DAT_44c00824 & 0xfcffffff | (uint)txcbwmax << 0x18;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_config_rxgain(int offset)

{
  if (rxgain_offset_vs_temperature != offset) {
    rxgain_offset_vs_temperature = (int8_t)offset;
    _DAT_44c0c080 =
         (rxgain_offset_vs_temperature + 0x19) * 0x1000000 |
         (rxgain_offset_vs_temperature + 0x12) * 0x10000 & 0xff0000U |
         (rxgain_offset_vs_temperature + 0xb) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 3U & 0xff;
    _DAT_44c0c084 =
         (rxgain_offset_vs_temperature + 0x35) * 0x1000000 |
         (rxgain_offset_vs_temperature + 0x2d) * 0x10000 & 0xff0000U |
         (rxgain_offset_vs_temperature + 0x27) * 0x100 & 0xffffU |
         (int)rxgain_offset_vs_temperature + 0x20U & 0xff;
    _DAT_44c0c088 = (int)rxgain_offset_vs_temperature + 0x3bU & 0xff | _DAT_44c0c088 & 0xffffff00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void agc_config(void)

{
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffefbff;
  _DAT_44c0b3a4 = _DAT_44c0b3a4 & 0xffff0000;
  _DAT_44c0b394 = _DAT_44c0b394 & 0xff00ffff | 0xf80000;
  _DAT_44c0b398 = _DAT_44c0b398 & 0xffff00ff | 0x9e00;
  _DAT_44c0b3c4 = _DAT_44c0b3c4 & 0xffffff00 | 0xce;
  _DAT_44c0b364 = _DAT_44c0b364 & 0xe0c0c0c0 | 0x83c3839;
  _DAT_44c0b368 = _DAT_44c0b368 & 0xffc00c00 | 0x70070;
  _DAT_44c0b36c = _DAT_44c0b36c & 0xf800f800 | 0x7280512;
  _DAT_44c0b370 = _DAT_44c0b370 & 0xff80ffff | 0x580000;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffffff | 0x18000000;
  _DAT_44c0b380 = _DAT_44c0b380 & 0x3ff | 0x77f8400;
  _DAT_44c0b384 = _DAT_44c0b384 & 0x3ff | 0xe7750800;
  _DAT_44c0b388 = _DAT_44c0b388 & 0x3ff | 0x3d7a9400;
  _DAT_44c0b38c = _DAT_44c0b38c & 0x23ff | 0x64038800;
  _DAT_44c0c830 = _DAT_44c0c830 & 0x23ff | 0xfc1d9400;
  _DAT_44c0c814 = _DAT_44c0c814 & 0xffffffc0 | 8;
  _DAT_44c0c040 = _DAT_44c0c040 & 0xfe007fff | 0xc18000;
  _DAT_44c0c044 = _DAT_44c0c044 & 0xffff0000 | 0x800;
  phy_config_rxgain(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44c0b3a0 = _DAT_44c0b3a0 & 0xffffff00 | 0x9e;
  _DAT_44c0b3c0 = _DAT_44c0b3c0 & 0xffff0000 | 0xa3a4;
  _DAT_44c0c82c = _DAT_44c0c82c & 0xff007700 | 0x2009b5;
  _DAT_44c0c838 = _DAT_44c0c838 & 0x7ff80000 | 0x80000100;
  _DAT_44c0c83c = _DAT_44c0c83c & 0x7ff00000 | 0x8000017c;
  _DAT_44c0c840 = _DAT_44c0c840 & 0x7fc00000 | 0x80000100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mdm_reset(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44c00888 = 0;
  return;
}



void phy_powroffset_set(int8_t *power_offset)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_offset + iVar3;
    piVar2 = poweroffset + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 0xe);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_hw_set_channel(uint8_t band,uint16_t freq,uint16_t freq1,uint8_t chantype)

{
  uint8_t channel;
  undefined3 in_register_00002029;
  int iVar1;
  undefined2 in_register_0000202e;
  int iVar2;
  undefined3 in_register_00002035;
  
  iVar2 = CONCAT22(in_register_0000202e,freq);
  iVar1 = CONCAT31(in_register_00002029,band);
  if (CONCAT31(in_register_00002035,chantype) != 0) {
    assert_err("chantype == PHY_CHNL_BW_20","module",0x144);
  }
  if (iVar1 != 0) {
    assert_err("band == PHY_BAND_2G4","module",0x145);
  }
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffffeff;
  _DAT_44c00820 = _DAT_44c00820 | 1;
  _DAT_44c00800 = 0;
  mdm_reset();
  _DAT_44c00838 = 0xb4;
  _DAT_44c0088c = 0x1c13;
  _DAT_44c00898 = 0x2d00438;
  _DAT_44c00858 = _DAT_44c00858 & 0xffffff00;
  _DAT_44c0081c = 0xf07;
  _DAT_44c00834 = _DAT_44c00834 & 0xffffff | 0x6000000;
  _DAT_44c00818 = 0x1880c06;
  _DAT_44c00860 = 0x7f03;
  _DAT_44c0b340 = 0;
  _DAT_44c0b344 = 0;
  _DAT_44c0b348 = 0;
  mdm_txcbwmax_setf(chantype);
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b118 = 1;
  }
  rf_set_channel(chantype,freq1);
  if (iVar1 == 0) {
    channel = '\0';
    if ((0x48 < (iVar2 - 0x96cU & 0xffff)) || (channel = '\x0e', iVar2 == 0x9b4)) goto LAB_230140e2;
    iVar1 = -0x967;
  }
  else {
    channel = '\0';
    if ((iVar1 != 1) || (channel = '\0', 0x334 < (iVar2 - 0x138dU & 0xffff))) goto LAB_230140e2;
    iVar1 = -5000;
  }
  channel = (uint8_t)((iVar2 + iVar1) / 5);
LAB_230140e2:
  rfc_apply_tx_power_offset(channel,poweroffset);
  trpc_update_vs_channel((int8_t)freq1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void phy_get_channel(phy_channel_info *info,uint8_t index)

{
  info->info1 = (uint)phy_env[0].chnl_type << 8 | (uint)phy_env[0].chnl_prim20_freq << 0x10 |
                (uint)phy_env[0].band;
  info->info2 = phy_env[0]._6_4_;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void phy_set_channel(uint8_t band,uint8_t type,uint16_t prim20_freq,uint16_t center1_freq,
                    uint16_t center2_freq,uint8_t index)

{
  undefined3 in_register_00002029;
  
  if ((((ushort)(center1_freq - 0x96c) < 0x49) || (CONCAT31(in_register_00002029,band) != 0)) &&
     (CONCAT31(in_register_00002029,band) < 2)) {
    phy_hw_set_channel(band,prim20_freq,center1_freq,type);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    phy_env[0].chnl_prim20_freq = prim20_freq;
    phy_env[0].chnl_center1_freq = center1_freq;
    phy_env[0].band = band;
    phy_env[0].chnl_type = type;
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_get_version(uint32_t *version_1,uint32_t *version_2)

{
  *version_1 = _DAT_44c00000;
  *version_2 = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_vht_supported(void)

{
  _Bool _Var1;
  
  _Var1 = true;
  if (-1 < _DAT_44c00000 << 9) {
    _Var1 = (_Bool)((byte)((uint)_DAT_44c00000 >> 0x19) & 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_init(phy_cfg_tag *config)

{
  uint uVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t uVar3;
  uint32_t *puVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  
  _DAT_44c00800 = 0;
  mdm_reset();
  _DAT_44c00820 = 0x20d;
  uVar1 = ((_DAT_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)rxnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xa09);
  }
  _DAT_44c00820 = uVar1 | _DAT_44c00820 & 0xffffff8f;
  uVar1 = ((_DAT_44c00000 >> 0xc & 0xf) - 1 & 0xff) << 0xc;
  if ((uVar1 & 0xf8000) != 0) {
    assert_err("(((uint32_t)rxndpnstsmax << 12) & ~((uint32_t)0x00007000)) == 0","module",0x987);
  }
  _DAT_44c00820 = _DAT_44c00000 >> 0x13 & 0x100 | uVar1 | _DAT_44c00820 & 0xffff8eff;
  _Var2 = phy_vht_supported();
  _DAT_44c00820 =
       (_DAT_44c00000 >> 0x1e & 1) << 0x14 |
       (_DAT_44c00000 >> 0x1e & 1) << 0x10 |
       (CONCAT31(extraout_var,_Var2) << 1 | _DAT_44c00820 & 0xfffffffd) & 0xffeeffff;
  _DAT_44c03024 = _DAT_44c03024 & 0xffc0ffff | 0x2d0000;
  _DAT_44c0089c = 0xffffffff;
  _DAT_44c00824 = 0x20d;
  uVar1 = ((_DAT_44c00000 >> 8 & 0xf) - 1 & 0xff) << 4;
  if ((uVar1 & 0xffffff8f) != 0) {
    assert_err("(((uint32_t)txnssmax << 4) & ~((uint32_t)0x00000070)) == 0","module",0xc0e);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xffffff8f;
  uVar1 = ((_DAT_44c00000 >> 4 & 0xf) - 1 & 0xff) << 0x14;
  if ((uVar1 & 0xf800000) != 0) {
    assert_err("(((uint32_t)ntxmax << 20) & ~((uint32_t)0x00700000)) == 0","module",0xb72);
  }
  _DAT_44c00824 = uVar1 | _DAT_44c00824 & 0xff8fffff;
  mdm_txcbwmax_setf((byte)(_DAT_44c00000 >> 0x18) & 3);
  _DAT_44c00824 = _DAT_44c00000 >> 0x12 & 0x100 | _DAT_44c00824 & 0xfffffeff;
  _Var2 = phy_vht_supported();
  _DAT_44c00824 =
       (_DAT_44c00000 >> 0x1f) << 0x10 |
       (CONCAT31(extraout_var_00,_Var2) << 1 | _DAT_44c00824 & 0xfffffffd) & 0xfffeffff;
  _DAT_44c00834 = _DAT_44c00834 | 1;
  _DAT_44c00818 = _DAT_44c00818 & 0xfffbffff;
  _DAT_44c00830 = _DAT_44c00830 & 0xffff0000 | 0x1b0f;
  _DAT_44c0083c = 0x4920492;
  _DAT_44c00874 = _DAT_44c00874 & 0xf7ffffff | 0x8000000;
  _DAT_44c0b500 = _DAT_44c0b500 & 0xffffcfff | 0x2000;
  if (_DAT_44c0b000 << 10 < 0) {
    _DAT_44c0b110 = _DAT_44c0b110 & 0xfffffff0;
    _DAT_44c0b118 = 0;
  }
  _DAT_44c0b004 = 1;
  _DAT_44c0b390 = _DAT_44c0b390 & 0xfffffffc | 1;
  _DAT_44c0b3bc = 4000000;
  _DAT_44c0b414 = _DAT_44c0b414 | 0x100;
  agc_config();
  _DAT_44c0b390 = _DAT_44c0b390 & 0xffffefff;
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff;
  puVar6 = agcmem;
  puVar4 = (uint32_t *)&DAT_54c0a000;
  do {
    uVar3 = *puVar6;
    puVar5 = puVar4 + 1;
    puVar6 = puVar6 + 1;
    *puVar4 = uVar3;
    puVar4 = puVar5;
  } while (puVar5 != (uint32_t *)0x54c0a800);
  _DAT_44c00874 = _DAT_44c00874 & 0xdfffffff;
  _DAT_44c0b390 = _DAT_44c0b390 & 0xffffefff;
  _DAT_44c0c020 = _DAT_44c0c020 & 0xfc00ffff | 0x140000;
  phy_env[0].cfg = config->parameters[0];
  phy_env[0]._4_4_ = 0xff00ff;
  phy_env[0]._8_4_ = 0x50000ff;
  trpc_init();
  pa_init();
  phy_tcal_reset();
  phy_tcal_start();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_nss(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(((byte)((uint)_DAT_44c00000 >> 8) & 0xf) - 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t phy_get_ntx(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(((byte)(_DAT_44c00000 >> 4) & 0xf) - 1);
}



void phy_stop(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool phy_ldpc_tx_supported(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)((byte)((uint)_DAT_44c00000 >> 0x1a) & 1);
}



uint8_t phy_get_mac_freq(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '(';
}



void phy_get_rf_gain_idx(int8_t *power,uint8_t *idx)

{
  uint32_t uVar1;
  
  uVar1 = rfc_get_power_level(2,*power * 10);
  *idx = (uint8_t)uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void phy_get_rf_gain_capab(int8_t *max,int8_t *min)

{
  int8_t iVar1;
  
  iVar1 = trpc_get_rf_max_power();
  *max = iVar1;
  iVar1 = trpc_get_rf_min_power();
  *min = iVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mpif_clk_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void phy_mdm_isr(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void phy_rc_isr(void)

{
  _DAT_44c0b420 = _DAT_44c0b41c;
  if ((_DAT_44c0b41c & 0x100) != 0) {
    mdm_reset();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44c0b420 = _DAT_44c0b41c;
  return;
}



void pa_init(void)

{
  int iVar1;
  pa_state_t *ppVar2;
  pa_state_t *ppVar3;
  
  ppVar3 = pa_env;
  do {
    ppVar3->rss_state = '\0';
    ppVar3->rss_count = 0;
    ppVar3->last_update = 0;
    ppVar3->input_buffer_ptr = '\0';
    ppVar3->ce_state = '\0';
    ppVar3->ce = 0.0;
    ppVar3->ce_num_up_cmds = '\0';
    ppVar3->ce_num_dn_cmds = '\0';
    iVar1 = 8;
    ppVar2 = ppVar3;
    do {
      ppVar2->input_buffer[0].new = '\0';
      ppVar2->input_buffer[0].rssi = '\0';
      ppVar2->input_buffer[0].lna = '\0';
      ppVar2->input_buffer[0].ppm = 0.0;
      iVar1 = iVar1 + -1;
      ppVar2 = (pa_state_t *)&ppVar2->input_buffer[0].ppm;
    } while (iVar1 != 0);
    ppVar3 = ppVar3 + 1;
  } while (ppVar3 != (pa_state_t *)&tcal_env);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void pa_input(uint8_t id,rx_hd *rhd)

{
  undefined3 in_register_00002029;
  uint uVar1;
  int8_t iVar2;
  int iVar3;
  DFtype DVar4;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 4) {
    iVar3 = (int)pa_env[uVar1].input_buffer_ptr;
    pa_env[uVar1].last_update = rhd->tsflo;
    pa_env[uVar1].input_buffer[iVar3].new = '\x01';
    pa_env[uVar1].input_buffer[iVar3].rssi = *(int8_t *)((int)&rhd->recvec1c + 3);
    pa_env[uVar1].input_buffer[iVar3].lna = (char)((int)(rhd->recvec1d << 0x14) >> 0x1c);
    if (((rhd->recvec1b & 0x70000) == 0) && ((rhd->recvec1a >> 0xc & 0xf) < 4)) {
      __floatsidf((int)*(char *)((int)&rhd->recvec2a + 3));
      DVar4 = __muldf3();
    }
    else {
      __floatsidf(-(int)*(short *)((int)&rhd->recvec2a + 3));
      __muldf3();
      DVar4 = __divdf3();
    }
    __truncdfsf2();
    *(DFtype *)&pa_env[uVar1].input_buffer[iVar3].ppm = DVar4;
    iVar2 = '\0';
    if (iVar3 != 7) {
      iVar2 = (int8_t)((uint)((iVar3 + 1) * 0x1000000) >> 0x18);
    }
    pa_env[uVar1].input_buffer_ptr = iVar2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void pa_adapt(uint8_t id)

{
  char cVar1;
  bool bVar2;
  int iVar3;
  uint8_t uVar4;
  undefined3 in_register_00002029;
  SFtype a;
  SFtype a_00;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  float fVar13;
  DFtype DVar14;
  
  a = (SFtype)CONCAT31(in_register_00002029,id);
  if (3 < (uint)a) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar5 = pa_adapt::count + 1;
  iVar12 = (int)pa_env[(int)a].input_buffer_ptr;
  if (iVar12 == 0) {
    iVar7 = (int)a * 0x8c + 0x5c;
  }
  else {
    iVar7 = (int)a * 0x8c + 8 + (iVar12 + -1) * 0xc;
  }
  pa_adapt::count = uVar5;
  if ((&pa_env[0].input_buffer[0].rssi)[iVar7] != '\0') {
    iVar11 = (int)*(char *)((int)pa_env[0].input_buffer + iVar7 + -8);
    if (pa_env[(int)a].rss_state == '\0') {
      if (pa_env[(int)a].rss_count < 7) {
        pa_env[(int)a].rss_count = pa_env[(int)a].rss_count + 1;
      }
      else {
        pa_env[(int)a].rss_state = '\x01';
        iVar9 = 1;
        iVar10 = 100;
        iVar3 = -100;
        iVar8 = 0;
        do {
          iVar6 = (int)pa_env[(int)a].input_buffer[(iVar12 - iVar9) % 8].rssi;
          iVar8 = iVar8 + iVar6;
          if (iVar3 < iVar6) {
            iVar3 = iVar6;
          }
          if (iVar6 < iVar10) {
            iVar10 = iVar6;
          }
          iVar9 = iVar9 + 1;
        } while (iVar9 != 7);
        pa_env[(int)a].rss = (int8_t)(((iVar8 - iVar3) - iVar10) / 4);
      }
    }
    else {
      if (pa_env[(int)a].rss_hit_count < 5) {
        if (iVar11 + 100U < 0x65) {
          cVar1 = pa_env[(int)a].rss;
          iVar12 = iVar11 - cVar1;
          if (iVar12 + 10U < 0x15) {
            pa_env[(int)a].rss_hit_count = '\0';
            pa_env[(int)a].rss = (char)(iVar12 >> 2) + cVar1;
          }
          else {
            pa_env[(int)a].rss_hit_count = pa_env[(int)a].rss_hit_count + 1;
          }
        }
      }
      else {
        pa_env[(int)a].rss_hit_count = '\0';
        pa_env[(int)a].rss_state = '\0';
        pa_env[(int)a].rss_count = 0;
      }
    }
    if ((uVar5 & 0xf) == 0xf) {
      if ((iVar11 - pa_env[(int)a].rss) + 10U < 0x15) {
        fVar13 = (float)*(undefined8 *)((int)pa_env[0].input_buffer + iVar7 + -4);
        if (fVar13 < 0.0) {
          bVar2 = fVar13 < -2.0;
        }
        else {
          bVar2 = 2.0 < fVar13;
        }
        if (bVar2) {
          a_00 = a;
          __extendsfdf2(a);
          if (iVar11 < -0x55) {
            __extendsfdf2(a_00);
          }
          else {
            __extendsfdf2(a_00);
          }
          __muldf3();
          DVar14 = __adddf3();
          fVar13 = SUB84(DVar14,0);
          __truncdfsf2();
          pa_env[(int)a].ce = fVar13;
        }
      }
      fVar13 = pa_env[(int)a].ce;
      if (fVar13 < 0.0) {
        bVar2 = -5.0 < fVar13;
      }
      else {
        bVar2 = fVar13 < 5.0;
      }
      if (!bVar2) {
        if ((0.0 < pa_env[(int)a].ce) &&
           (uVar4 = hal_get_capcode(), CONCAT31(extraout_var,uVar4) != 0)) {
          uVar4 = hal_get_capcode();
          hal_set_capcode(CONCAT31(extraout_var_00,uVar4) - 1);
        }
        if ((pa_env[(int)a].ce < 0.0) &&
           (uVar4 = hal_get_capcode(), CONCAT31(extraout_var_01,uVar4) < 0x3f)) {
          uVar4 = hal_get_capcode();
          hal_set_capcode(CONCAT31(extraout_var_02,uVar4) + 1);
        }
        pa_env[(int)a].ce = 0.0;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t hal_get_capcode(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)((byte)(_DAT_4000f884 >> 0x16) & 0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_set_capcode(uint32_t capcode)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f884 = capcode << 0x10 | capcode << 0x16 | _DAT_4000f884 & 0xf000ffff;
  return;
}



_Bool hal_get_temperature(int16_t *temperature)

{
  *temperature = hal_env.temperature;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return true;
}



void hal_set_temperature(int16_t temperature)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  hal_env.temperature = temperature;
  return;
}



void trpc_update_power(int8_t (*power_rate_table) [8])

{
  int iVar1;
  int iVar2;
  int iVar3;
  int8_t (*paiVar4) [8];
  int8_t *piVar5;
  
  paiVar4 = txpwr_vs_rate_table;
  iVar2 = 0;
  do {
    iVar3 = 0;
    do {
      iVar1 = iVar3 + iVar2;
      piVar5 = *paiVar4 + iVar3;
      iVar3 = iVar3 + 1;
      *piVar5 = (*power_rate_table)[iVar1];
    } while (iVar3 != 8);
    iVar2 = iVar2 + 8;
    paiVar4 = paiVar4[1];
  } while (iVar2 != 0x18);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trpc_power_get(int8_t *power_rate_table)

{
  memcpy(power_rate_table,txpwr_vs_rate_table,0x18);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trpc_update_power_11b(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int8_t *piVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    piVar1 = power_rate_table + iVar3;
    piVar2 = txpwr_vs_rate_table + iVar3;
    iVar3 = iVar3 + 1;
    *piVar2 = *piVar1;
  } while (iVar3 != 4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trpc_update_power_11g(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t (*paiVar3) [8];
  
  iVar2 = 0;
  paiVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    paiVar3[1][0] = *piVar1;
    paiVar3 = (int8_t (*) [8])(*paiVar3 + 1);
  } while (iVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trpc_update_power_11n(int8_t *power_rate_table)

{
  int8_t *piVar1;
  int iVar2;
  int8_t (*paiVar3) [8];
  
  iVar2 = 0;
  paiVar3 = txpwr_vs_rate_table;
  do {
    piVar1 = power_rate_table + iVar2;
    iVar2 = iVar2 + 1;
    paiVar3[2][0] = *piVar1;
    paiVar3 = (int8_t (*) [8])(*paiVar3 + 1);
  } while (iVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trpc_init(void)

{
  int32_t iVar1;
  
  DAT_4201d148 = 0x98a;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trpc_get_power_idx::pwr_dbm_bottom = (int8_t)iVar1;
  DAT_4201d146 = 0x1e;
  DAT_4201d14a = 0x19;
  return;
}



int8_t trpc_get_rf_max_power(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return trpc_env;
}



int8_t trpc_get_rf_min_power(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return trpc_get_power_idx::pwr_dbm_bottom;
}



uint8_t trpc_get_power_idx(uint8_t formatmod,uint8_t mcs,int8_t pwr_dbm)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  undefined3 in_register_00002031;
  char cVar4;
  uint uVar5;
  int8_t iVar6;
  uint uVar7;
  int iVar8;
  
  uVar1 = CONCAT31(in_register_00002029,formatmod);
  uVar5 = 2;
  if (uVar1 < 3) {
    uVar5 = (uint)formatmod;
  }
  iVar8 = 3;
  if (uVar1 != 0) {
    iVar8 = 7;
  }
  uVar2 = SEXT14(trpc_env);
  uVar7 = (uint)DAT_4201d146;
  if ((int)uVar2 < (int)(char)DAT_4201d146) {
    uVar7 = uVar2;
  }
  if ((int)CONCAT31(in_register_00002031,pwr_dbm) < (int)(char)uVar7) {
    uVar7 = CONCAT31(in_register_00002031,pwr_dbm);
  }
  iVar3 = CONCAT31(in_register_0000202d,mcs);
  if (iVar8 < CONCAT31(in_register_0000202d,mcs)) {
    iVar3 = iVar8;
  }
  cVar4 = txpwr_vs_rate_table[uVar5][iVar3];
  if ((char)uVar7 < txpwr_vs_rate_table[uVar5][iVar3]) {
    cVar4 = (char)uVar7;
  }
  iVar6 = trpc_get_power_idx::pwr_dbm_bottom;
  if (trpc_get_power_idx::pwr_dbm_bottom < cVar4) {
    iVar6 = cVar4;
  }
  __floatsidf((int)(iVar6 * -0x1fe + uVar2) / 0x200);
  __adddf3();
  uVar5 = __fixdfsi();
  iVar8 = 3;
  if (uVar1 != 0) {
    iVar8 = 0;
  }
  uVar5 = iVar8 + (uVar5 & 0xff) & 0xff;
  if (0xf < uVar5) {
    uVar5 = 0xf;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(uVar5 << 2);
}



uint8_t trpc_get_default_power_idx(uint8_t formatmod,uint8_t mcs)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  uVar3 = (uint)formatmod;
  if (2 < CONCAT31(in_register_00002029,formatmod)) {
    uVar3 = 2;
  }
  iVar4 = 3;
  if (CONCAT31(in_register_00002029,formatmod) != 0) {
    iVar4 = 7;
  }
  iVar2 = CONCAT31(in_register_0000202d,mcs);
  if (iVar4 < CONCAT31(in_register_0000202d,mcs)) {
    iVar2 = iVar4;
  }
  uVar1 = trpc_get_power_idx((uint8_t)uVar3,(uint8_t)iVar2,txpwr_vs_rate_table[uVar3][iVar2]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void trpc_update_vs_channel(int8_t channel_MHz)

{
  undefined3 in_register_00002029;
  int32_t iVar1;
  
  DAT_4201d148 = (undefined2)CONCAT31(in_register_00002029,channel_MHz);
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trpc_get_power_idx::pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void trpc_update_vs_temperature(int8_t temperature)

{
  int32_t iVar1;
  
  DAT_4201d14a._0_1_ = temperature;
  iVar1 = rf_pri_get_txgain_max();
  trpc_env = (undefined)iVar1;
  iVar1 = rf_pri_get_txgain_min();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trpc_get_power_idx::pwr_dbm_bottom = (int8_t)iVar1;
  return;
}



void phy_tcal_reset(void)

{
  memset(&tcal_env,0,0x38);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  tcal_env.prev_temperature = 0x19;
  tcal_env.last_action_temperature[0] = 0x19;
  tcal_env.last_action_temperature[1] = 0x19;
  tcal_env.last_action_temperature[2] = 0x19;
  tcal_env.last_action_temperature[3] = 0x19;
  tcal_env.enabled = true;
  return;
}



void phy_tcal_start(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  tcal_env.enabled = true;
  return;
}



void phy_tcal_txpwr(int16_t curr_temperature)

{
  undefined2 in_register_0000202a;
  
  rf_pri_tx_gain_comp(CONCAT22(in_register_0000202a,curr_temperature));
  trpc_update_vs_temperature((int8_t)curr_temperature);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: curr_temperature

void phy_tcal_handle(void)

{
  _Bool _Var1;
  undefined3 extraout_var;
  uint uVar2;
  int iVar3;
  uint32_t uVar4;
  ushort auStack18 [2];
  int16_t curr_temperature;
  
  _Var1 = hal_get_temperature((int16_t *)auStack18);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    phy_tcal_txpwr(auStack18[0]);
    uVar2 = (uint)auStack18[0];
    if (0x7d < (short)auStack18[0]) {
      uVar2 = 0x7d;
    }
    if ((short)uVar2 < -0x28) {
      uVar2 = 0xffffffd8;
    }
    auStack18[0] = (ushort)uVar2;
    iVar3 = (int)((uVar2 - 0x19) * 0x10000) >> 0x10;
    uVar4 = SEXT24((short)auStack18[0]);
    if (iVar3 < 1) {
      iVar3 = iVar3 * -6 >> 8;
    }
    else {
      iVar3 = (iVar3 * 6 >> 8) * -0x10000 >> 0x10;
    }
    if (iVar3 != tcal_env.last_action_out[2]) {
      phy_config_rxgain(iVar3);
      tcal_env.last_action_temperature[2] = uVar4;
      tcal_env.last_action_out[2] = iVar3;
    }
    tcal_env.prev_temperature = auStack18[0];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void phy_tcal_callback(int16_t temperature)

{
  hal_set_temperature(temperature);
  if (tcal_env.enabled != false) {
    phy_tcal_handle();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_ctrl_en_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001004 = x << 1 | _DAT_40001004 & 0xfffffffd;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_fsm_st_dbg_en_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000126c = x << 3 | _DAT_4000126c & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc3_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001630 = (x & 0x7f) << 0x18 | _DAT_40001630 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc2_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001630 = (x & 0x7f) << 0x10 | _DAT_40001630 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc1_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001630 = (x & 0x7f) << 8 | _DAT_40001630 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc0_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001630 = x & 0x7f | _DAT_40001630 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc7_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001634 = (x & 0x7f) << 0x18 | _DAT_40001634 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc6_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001634 = (x & 0x7f) << 0x10 | _DAT_40001634 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc5_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001634 = (x & 0x7f) << 8 | _DAT_40001634 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc4_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001634 = x & 0x7f | _DAT_40001634 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc11_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001638 = (x & 0x7f) << 0x18 | _DAT_40001638 & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc10_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001638 = (x & 0x7f) << 0x10 | _DAT_40001638 & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc9_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001638 = (x & 0x7f) << 8 | _DAT_40001638 & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc8_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001638 = x & 0x7f | _DAT_40001638 & 0xffffff80;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc15_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000163c = (x & 0x7f) << 0x18 | _DAT_4000163c & 0x80ffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc14_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000163c = (x & 0x7f) << 0x10 | _DAT_4000163c & 0xff80ffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc13_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000163c = (x & 0x7f) << 8 | _DAT_4000163c & 0xffff80ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_dvga_gain_qdb_gc12_setf(uint32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000163c = x & 0x7f | _DAT_4000163c & 0xffffff80;
  return;
}



void wait_us(uint32_t us)

{
  bool bVar1;
  uint32_t n;
  int iStack4;
  
  iStack4 = us << 4;
  do {
    bVar1 = iStack4 != 0;
    iStack4 = iStack4 + -1;
  } while (bVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void _print_channel_info(void)

{
  int iVar1;
  
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  iVar1 = 8;
  do {
    iVar1 = iVar1 + -1;
    wait_us(1000);
  } while (iVar1 != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_init(uint32_t xtalfreq_hz)

{
  uint uVar1;
  uint32_t uVar2;
  USItype UVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint uVar6;
  undefined4 uVar7;
  uint uVar8;
  uint uStack88;
  uint32_t rfg_index;
  uint32_t dg;
  
  _DAT_40001220 = _DAT_40001220 & 0xf3ffffff | 0x8000000;
  if (xtalfreq_hz == 32000000) {
    uVar2 = 2;
    goto LAB_230150e2;
  }
  if (xtalfreq_hz < 0x1e84801) {
    uVar2 = 0;
    if ((xtalfreq_hz == 24000000) || (uVar2 = 1, xtalfreq_hz == 26000000)) goto LAB_230150e2;
  }
  else {
    if (xtalfreq_hz != 40000000) {
      uVar2 = 5;
      if (xtalfreq_hz == 52000000) goto LAB_230150e2;
      if (xtalfreq_hz == 38400000) {
        uVar2 = 3;
        goto LAB_230150e2;
      }
    }
  }
  uVar2 = 4;
LAB_230150e2:
  rf_pri_xtalfreq(uVar2);
  uVar7 = 1;
  rf_pri_init(inited == '\0','\x01');
  inited = '\x01';
  uVar1 = xtalfreq_hz / 1000000;
  __floatunsidf(uVar1);
  uVar8 = (uint)_DAT_400011c4 & 0xe0000000;
  uVar2 = 0x964;
  xtalfreq_MHz._0_4_ = uVar1;
  xtalfreq_MHz._4_4_ = uVar7;
  __extendsfdf2(_DAT_400011c4);
  __adddf3();
  UVar3 = __fixunsdfsi();
  _DAT_400011c4 = (SFtype)(UVar3 & 0x1fffffff | uVar8);
  uVar1 = (uint)_DAT_400011c8 & 0xfff00000;
  __extendsfdf2(_DAT_400011c8);
  __adddf3();
  UVar3 = __fixunsdfsi();
  _DAT_400011c8 = (SFtype)(UVar3 & 0xfffff | uVar1);
  uVar1 = (uint)_DAT_400011cc & 0xfff00000;
  __extendsfdf2(_DAT_400011cc);
  uVar8 = 0;
  __adddf3();
  UVar3 = __fixunsdfsi();
  _DAT_400011cc = (SFtype)(UVar3 & 0xfffff | uVar1);
  uVar1 = 0;
  do {
    uVar4 = rf_pri_get_vco_freq_cw(uVar2);
    uVar5 = rf_pri_get_vco_idac_cw(uVar2);
    if (uVar2 == 0x964) {
      uVar4 = uVar4 + 1;
    }
    uVar6 = uVar4 << 8 | uVar5;
    if ((uVar8 & 1) != 0) {
      uVar6 = uVar1 | uVar6 << 0x10;
      *(uint *)(&DAT_4000113c + ((int)uVar8 >> 1) * 4) = uVar6;
    }
    if (uVar2 == 0x9b4) {
      *(uint *)(&DAT_4000113c + ((int)uVar8 >> 1) * 4) = uVar6;
    }
    uVar2 = uVar2 + 4;
    uVar8 = uVar8 + 1;
    uVar1 = uVar6;
  } while (uVar2 != 0x9b8);
  rf_pri_query_txgain_table(0,&uStack88,&rfg_index);
  _DAT_40001640 = uStack88 & 7 | _DAT_40001640 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc0_setf(rfg_index);
  rf_pri_query_txgain_table(1,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 4 | _DAT_40001640 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc1_setf(rfg_index);
  rf_pri_query_txgain_table(2,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 8 | _DAT_40001640 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc2_setf(rfg_index);
  rf_pri_query_txgain_table(3,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 0xc | _DAT_40001640 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc3_setf(rfg_index);
  rf_pri_query_txgain_table(4,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 0x10 | _DAT_40001640 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc4_setf(rfg_index);
  rf_pri_query_txgain_table(5,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 0x14 | _DAT_40001640 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc5_setf(rfg_index);
  rf_pri_query_txgain_table(6,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 0x18 | _DAT_40001640 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc6_setf(rfg_index);
  rf_pri_query_txgain_table(7,&uStack88,&rfg_index);
  _DAT_40001640 = (uStack88 & 7) << 0x1c | _DAT_40001640 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc7_setf(rfg_index);
  rf_pri_query_txgain_table(8,&uStack88,&rfg_index);
  _DAT_40001644 = uStack88 & 7 | _DAT_40001644 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc8_setf(rfg_index);
  rf_pri_query_txgain_table(9,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 4 | _DAT_40001644 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc9_setf(rfg_index);
  rf_pri_query_txgain_table(10,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 8 | _DAT_40001644 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc10_setf(rfg_index);
  rf_pri_query_txgain_table(0xb,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 0xc | _DAT_40001644 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc11_setf(rfg_index);
  rf_pri_query_txgain_table(0xc,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 0x10 | _DAT_40001644 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc12_setf(rfg_index);
  rf_pri_query_txgain_table(0xd,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 0x14 | _DAT_40001644 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc13_setf(rfg_index);
  rf_pri_query_txgain_table(0xe,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 0x18 | _DAT_40001644 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc14_setf(rfg_index);
  rf_pri_query_txgain_table(0xf,&uStack88,&rfg_index);
  _DAT_40001644 = (uStack88 & 7) << 0x1c | _DAT_40001644 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc15_setf(rfg_index);
  _DAT_40001004 = _DAT_40001004 & 0xfffff7ff;
  rf_fsm_st_dbg_en_setf(0);
  _DAT_40001268 = _DAT_40001268 & 0xffff0000 | 0x1040;
  rf_fsm_ctrl_en_setf(1);
  _DAT_40001600 = _DAT_40001600 & 0x80ffffff | 0x80000000;
  _DAT_4000100c = _DAT_4000100c | 0x26;
  _DAT_44c0c218 = _DAT_44c0c218 & 0xffff0000;
  _DAT_44c03030 = 0;
  _DAT_44c03034 = 0xa027f7f;
  _DAT_44c03038 = 0x23282317;
  _DAT_44c0303c = 0x7f020a17;
  _DAT_44c03040 = 0x7f;
  _DAT_40001220 = _DAT_40001220 & 0xf7ffffff;
  _DAT_40001004 = _DAT_40001004 & 0xfffffff3;
  _DAT_4000e41c = _DAT_4000e41c & 0xffffffbf;
  wait_us(1);
  _DAT_40001004 = _DAT_40001004 & 0xfffffff3 | 4;
  wait_us(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000e41c = _DAT_4000e41c | 0x40;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_rxdfe_set_notch0(uint8_t en,uint8_t alpha,int8_t nrmfc)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001700 = (en & 1) << 6 | (uint)(byte)nrmfc << 8 | alpha & 7 | _DAT_40001700 & 0xffff00b8;
  return;
}



// WARNING: Variable defined which should be unmapped: ncf_freq_hz
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_config_channel(uint32_t channel_freq)

{
  SItype SVar1;
  uint8_t uStack21;
  uint8_t ncf_on;
  SItype SStack20;
  int32_t ncf_freq_hz;
  
  _DAT_40001228 = _DAT_40001228 | 8;
  _DAT_4000100c = _DAT_4000100c | 0x241;
  _DAT_40001264 = channel_freq & 0xfff | _DAT_40001264 & 0xfffff000;
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff | 0x20000;
  wait_us(10);
  _DAT_40001268 = _DAT_40001268 & 0xfffdffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 1;
  wait_us(10);
  rf_fsm_st_dbg_en_setf(1);
  wait_us(10);
  _DAT_4000126c = _DAT_4000126c & 0xfffffff8 | 2;
  wait_us(100);
  rf_fsm_st_dbg_en_setf(0);
  wait_us(10);
  _print_channel_info();
  rf_pri_update_param(channel_freq);
  rf_pri_get_notch_param(channel_freq,&uStack21,(int32_t *)&stack0xffffffec);
  __floatsidf(SStack20);
  __divdf3();
  __muldf3();
  __adddf3();
  SVar1 = __fixdfsi();
  rfc_rxdfe_set_notch0(uStack21,'\x01',(int8_t)SVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001228 = _DAT_40001228 & 0xfffffff7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_coex_force_to(uint32_t force_enable,uint32_t bbmode)

{
  rf_fsm_ctrl_en_setf(0);
  wait_us(10);
  _DAT_40001220 =
       (uint)(force_enable != 0) << 0x1b | (bbmode & 1) << 0x1a | _DAT_40001220 & 0xf3ffffff;
  wait_us(10);
  rf_fsm_ctrl_en_setf(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t rfc_get_power_level(uint32_t formatmod,int32_t power)

{
  uint32_t uVar1;
  
  uVar1 = 0;
  if ((formatmod != 0) && (uVar1 = 1, formatmod != 1)) {
    uVar1 = 2;
  }
  uVar1 = rf_pri_get_txgain_index(power,uVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1 << 2;
}



void rfc_apply_tx_dvga(int8_t *dvga_qdb)

{
  rf_tx_dvga_gain_qdb_gc0_setf((int)*dvga_qdb);
  rf_tx_dvga_gain_qdb_gc1_setf((int)dvga_qdb[1]);
  rf_tx_dvga_gain_qdb_gc2_setf((int)dvga_qdb[2]);
  rf_tx_dvga_gain_qdb_gc3_setf((int)dvga_qdb[3]);
  rf_tx_dvga_gain_qdb_gc4_setf((int)dvga_qdb[4]);
  rf_tx_dvga_gain_qdb_gc5_setf((int)dvga_qdb[5]);
  rf_tx_dvga_gain_qdb_gc6_setf((int)dvga_qdb[6]);
  rf_tx_dvga_gain_qdb_gc7_setf((int)dvga_qdb[7]);
  rf_tx_dvga_gain_qdb_gc8_setf((int)dvga_qdb[8]);
  rf_tx_dvga_gain_qdb_gc9_setf((int)dvga_qdb[9]);
  rf_tx_dvga_gain_qdb_gc10_setf((int)dvga_qdb[10]);
  rf_tx_dvga_gain_qdb_gc11_setf((int)dvga_qdb[0xb]);
  rf_tx_dvga_gain_qdb_gc12_setf((int)dvga_qdb[0xc]);
  rf_tx_dvga_gain_qdb_gc13_setf((int)dvga_qdb[0xd]);
  rf_tx_dvga_gain_qdb_gc14_setf((int)dvga_qdb[0xe]);
  rf_tx_dvga_gain_qdb_gc15_setf((int)dvga_qdb[0xf]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: dg
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rfc_apply_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  uint uStack56;
  uint32_t rfg_index;
  uint32_t dg;
  
  rf_pri_update_tx_power_offset(channel,power_offset);
  rf_pri_query_txgain_table(0,&uStack56,&rfg_index);
  _DAT_40001640 = uStack56 & 7 | _DAT_40001640 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc0_setf(rfg_index);
  rf_pri_query_txgain_table(1,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 4 | _DAT_40001640 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc1_setf(rfg_index);
  rf_pri_query_txgain_table(2,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 8 | _DAT_40001640 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc2_setf(rfg_index);
  rf_pri_query_txgain_table(3,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0xc | _DAT_40001640 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc3_setf(rfg_index);
  rf_pri_query_txgain_table(4,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x10 | _DAT_40001640 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc4_setf(rfg_index);
  rf_pri_query_txgain_table(5,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x14 | _DAT_40001640 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc5_setf(rfg_index);
  rf_pri_query_txgain_table(6,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x18 | _DAT_40001640 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc6_setf(rfg_index);
  rf_pri_query_txgain_table(7,&uStack56,&rfg_index);
  _DAT_40001640 = (uStack56 & 7) << 0x1c | _DAT_40001640 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc7_setf(rfg_index);
  rf_pri_query_txgain_table(8,&uStack56,&rfg_index);
  _DAT_40001644 = uStack56 & 7 | _DAT_40001644 & 0xfffffff8;
  rf_tx_dvga_gain_qdb_gc8_setf(rfg_index);
  rf_pri_query_txgain_table(9,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 4 | _DAT_40001644 & 0xffffff8f;
  rf_tx_dvga_gain_qdb_gc9_setf(rfg_index);
  rf_pri_query_txgain_table(10,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 8 | _DAT_40001644 & 0xfffff8ff;
  rf_tx_dvga_gain_qdb_gc10_setf(rfg_index);
  rf_pri_query_txgain_table(0xb,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0xc | _DAT_40001644 & 0xffff8fff;
  rf_tx_dvga_gain_qdb_gc11_setf(rfg_index);
  rf_pri_query_txgain_table(0xc,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x10 | _DAT_40001644 & 0xfff8ffff;
  rf_tx_dvga_gain_qdb_gc12_setf(rfg_index);
  rf_pri_query_txgain_table(0xd,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x14 | _DAT_40001644 & 0xff8fffff;
  rf_tx_dvga_gain_qdb_gc13_setf(rfg_index);
  rf_pri_query_txgain_table(0xe,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x18 | _DAT_40001644 & 0xf8ffffff;
  rf_tx_dvga_gain_qdb_gc14_setf(rfg_index);
  rf_pri_query_txgain_table(0xf,&uStack56,&rfg_index);
  _DAT_40001644 = (uStack56 & 7) << 0x1c | _DAT_40001644 & 0x8fffffff;
  rf_tx_dvga_gain_qdb_gc15_setf(rfg_index);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_set_gain_table_regs(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001118 =
       ((tx_pwr_table[12][2] << 0x18 |
        (tx_pwr_table[12][3] << 0x10 |
        (tx_pwr_table[14][0] << 0xe |
        (tx_pwr_table[14][1] << 0xc |
        (tx_pwr_table[14][2] << 8 | (_DAT_40001118 & 0xffffffe0 | tx_pwr_table[14][3]) & 0xfffff8ff)
        & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff |
       tx_pwr_table[12][1] << 0x1c) & 0x3fffffff | tx_pwr_table[12][0] << 0x1e;
  _DAT_4000111c =
       (tx_pwr_table[8][1] << 0x1c |
       (tx_pwr_table[8][2] << 0x18 |
       (tx_pwr_table[8][3] << 0x10 |
       (tx_pwr_table[10][0] << 0xe |
       (tx_pwr_table[10][1] << 0xc |
       (tx_pwr_table[10][2] << 8 | (_DAT_4000111c & 0xffffffe0 | tx_pwr_table[10][3]) & 0xfffff8ff)
       & 0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff |
       tx_pwr_table[8][0] << 0x1e;
  _DAT_40001120 =
       tx_pwr_table[4][0] << 0x1e |
       (tx_pwr_table[4][1] << 0x1c |
       (tx_pwr_table[4][2] << 0x18 |
       (tx_pwr_table[4][3] << 0x10 |
       (tx_pwr_table[6][0] << 0xe |
       (tx_pwr_table[6][1] << 0xc |
       (tx_pwr_table[6][2] << 8 | (_DAT_40001120 & 0xffffffe0 | tx_pwr_table[6][3]) & 0xfffff8ff) &
       0xffffcfff) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff) & 0xcfffffff) & 0x3fffffff;
  _DAT_40001124 =
       (tx_pwr_table[0][1] << 0x1c |
       ((tx_pwr_table[0][3] << 0x10 |
        (tx_pwr_table[2][0] << 0xe |
        ((tx_pwr_table[2][2] << 8 | (_DAT_40001124 & 0xffffffe0 | tx_pwr_table[2][3]) & 0xfffff8ff)
         & 0xffffcfff | tx_pwr_table[2][1] << 0xc) & 0xffff3fff) & 0xffe0ffff) & 0xf8ffffff |
       tx_pwr_table[0][2] << 0x18) & 0xcfffffff) & 0x3fffffff | tx_pwr_table[0][0] << 0x1e;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_manu_pu(uint32_t mode)

{
  int iVar1;
  uint uVar2;
  
  if (mode == 5) {
    _DAT_40001030 = _DAT_40001030 & 0xcefff8ff;
    iVar1 = -0x39009000;
  }
  else {
    if (5 < mode) {
      if (7 < mode) goto LAB_23015d76;
      _DAT_40001030 = _DAT_40001030 & 0x8f090ff;
      uVar2 = 0xf00000;
      goto LAB_23015daa;
    }
    if (mode != 4) {
LAB_23015d76:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
      _DAT_4000100c = 0;
      _DAT_40001030 = _DAT_40001030 & 0x2df0feff | 0x25f06e00;
      return;
    }
    _DAT_40001030 = _DAT_40001030 & 0x2cf8f8ff;
    iVar1 = 0x24f87000;
  }
  uVar2 = iVar1 - 0x800;
LAB_23015daa:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001004 = _DAT_40001004 & 0xfffffffd;
  _DAT_4000100c = 0;
  _DAT_40001030 = _DAT_40001030 | uVar2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_save_state_for_cal(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  state_adda1 = _DAT_4000108c;
  state_dfe_ctrl_0 = _DAT_40001600;
  state_dfe_ctrl_3 = _DAT_4000160c;
  state_dfe_ctrl_6 = _DAT_40001618;
  state_dfe_ctrl_7 = _DAT_4000161c;
  state_fbdv = _DAT_400010b8;
  state_pa1 = _DAT_40001064;
  state_pucr1 = _DAT_40001030;
  state_rbb3 = _DAT_40001084;
  state_rf_fsm_ctrl_hw = _DAT_40001004;
  state_rf_resv_reg_1 = _DAT_400010f0;
  state_rfcal_ctrlen = _DAT_4000101c;
  state_rfctrl_hw_en = _DAT_4000100c;
  state_rfif_dfe_ctrl0 = _DAT_40001220;
  state_sdm1 = _DAT_400010c0;
  state_sdm2 = _DAT_400010c4;
  state_singen_ctrl0 = _DAT_4000120c;
  state_singen_ctrl2 = _DAT_40001214;
  state_singen_ctrl3 = _DAT_40001218;
  state_sram_ctrl0 = _DAT_4000123c;
  state_sram_ctrl1 = _DAT_40001240;
  state_sram_ctrl2 = _DAT_40001244;
  state_tbb = _DAT_40001070;
  state_ten_ac = _DAT_40001058;
  state_trx_gain1 = _DAT_40001048;
  state_vco2 = _DAT_400010a4;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_state_for_cal(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001004 = state_rf_fsm_ctrl_hw;
  _DAT_4000100c = state_rfctrl_hw_en;
  _DAT_4000101c = state_rfcal_ctrlen;
  _DAT_40001030 = state_pucr1;
  _DAT_40001048 = state_trx_gain1;
  _DAT_40001058 = state_ten_ac;
  _DAT_40001064 = state_pa1;
  _DAT_40001070 = state_tbb;
  _DAT_40001084 = state_rbb3;
  _DAT_4000108c = state_adda1;
  _DAT_400010a4 = state_vco2;
  _DAT_400010b8 = state_fbdv;
  _DAT_400010c0 = state_sdm1;
  _DAT_400010c4 = state_sdm2;
  _DAT_400010f0 = state_rf_resv_reg_1;
  _DAT_4000120c = state_singen_ctrl0;
  _DAT_40001214 = state_singen_ctrl2;
  _DAT_40001218 = state_singen_ctrl3;
  _DAT_40001220 = state_rfif_dfe_ctrl0;
  _DAT_4000123c = state_sram_ctrl0;
  _DAT_40001240 = state_sram_ctrl1;
  _DAT_40001244 = state_sram_ctrl2;
  _DAT_40001600 = state_dfe_ctrl_0;
  _DAT_4000160c = state_dfe_ctrl_3;
  _DAT_40001618 = state_dfe_ctrl_6;
  _DAT_4000161c = state_dfe_ctrl_7;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_start(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000120c = _DAT_4000120c & 0x7fffffff | 0x80000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_pm_pwr(void)

{
  int iVar1;
  int iVar2;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff | 0x20100000) << 3));
  iVar1 = (_DAT_40001620 << 7) >> 0x10;
  iVar2 = (_DAT_40001624 << 7) >> 0x10;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  return iVar1 * iVar1 + iVar2 * iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_start_txdfe(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001220 = _DAT_40001220 & 0xffffe67f | 0x1182;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_pm_pwr_avg(uint32_t iq,uint32_t acc_len)

{
  int iVar1;
  
  do {
  } while (-1 < (int)((_DAT_40001618 & 0xdfefffff) << 3));
  iVar1 = _DAT_40001624;
  if (iq != 0) {
    iVar1 = _DAT_40001620;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001618 = _DAT_40001618 & 0xdfefffff;
  _DAT_4000161c = acc_len << 0x10 | _DAT_4000161c & 0xffff;
  return (iVar1 << 7) >> 7;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config_hw(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001180 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->txcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->txcal & 0x3f | _DAT_40001180 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 1) & 0x3f) << 0x10;
  _DAT_40001184 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 2) & 0x3f | _DAT_40001184 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x10;
  _DAT_40001188 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 4) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 4) & 0x3f | _DAT_40001188 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 5) & 0x3f) << 0x10;
  _DAT_4000118c =
       (*(uint *)(rf_calib_data->txcal + 7) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->txcal + 6) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->txcal + 6) & 0x3f | _DAT_4000118c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->txcal + 7) & 0x3f) << 0x10;
  _DAT_40001190 =
       (*(uint *)rf_calib_data->txcal >> 0xc & 0x7ff) << 0x10 | _DAT_40001190 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[0].field_0x4 & 0x3ff;
  _DAT_40001194 =
       (*(uint *)(rf_calib_data->txcal + 1) >> 0xc & 0x7ff) << 0x10 | _DAT_40001194 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[1].field_0x4 & 0x3ff;
  _DAT_40001198 =
       (*(uint *)(rf_calib_data->txcal + 2) >> 0xc & 0x7ff) << 0x10 | _DAT_40001198 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[2].field_0x4 & 0x3ff;
  _DAT_4000119c =
       (*(uint *)(rf_calib_data->txcal + 3) >> 0xc & 0x7ff) << 0x10 | _DAT_4000119c & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  _DAT_400011a0 =
       (*(uint *)(rf_calib_data->txcal + 4) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a0 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[4].field_0x4 & 0x3ff;
  _DAT_400011a4 =
       (*(uint *)(rf_calib_data->txcal + 5) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a4 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[5].field_0x4 & 0x3ff;
  _DAT_400011a8 =
       (*(uint *)(rf_calib_data->txcal + 6) >> 0xc & 0x7ff) << 0x10 | _DAT_400011a8 & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[6].field_0x4 & 0x3ff;
  _DAT_400011ac =
       (*(uint *)(rf_calib_data->txcal + 7) >> 0xc & 0x7ff) << 0x10 | _DAT_400011ac & 0xf800fc00 |
       *(uint *)&rf_calib_data->txcal[7].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint16_t rf_pri_fcal_meas(uint32_t cw)

{
  _DAT_400010a0 = cw | _DAT_400010a0 & 0xffffff00;
  BL602_Delay_US(100);
  do {
  } while (-1 < (int)((_DAT_400010ac | 0x10) << 0xb));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_400010ac = _DAT_400010ac & 0xffffffef;
  return (uint16_t)((uint)_DAT_400010a8 >> 0x10);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t rbb_fc)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001080 = rbb_fc << 8 | rbb_fc << 0x18 | _DAT_40001080 & 0xc0ffc0ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal_config(uint32_t iq,uint32_t rbb_fc)

{
  if (iq != 0) {
    rf_pri_rccal_config(rbb_fc);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001080 = rbb_fc << 0x10 | _DAT_40001080 & 0xffc0ffc0 | rbb_fc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal_config(uint32_t param_ind,int32_t val)

{
  uint uVar1;
  
  if (param_ind == 2) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    _DAT_40001600 = val << 0xc | _DAT_40001600 & 0xff800fff | 0x800000;
    return;
  }
  if (param_ind != 3) {
    if (param_ind == 0) {
      _DAT_40001070 = _DAT_40001070 & 0xc0ffffff;
      uVar1 = val << 0x18;
    }
    else {
      if (param_ind != 1) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      _DAT_40001070 = _DAT_40001070 & 0xffc0ffff;
      uVar1 = val << 0x10;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    _DAT_40001070 = uVar1 | _DAT_40001070;
    return;
  }
  if (val < 0) {
    val = val + 0x400;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001600 = val | _DAT_40001600 & 0xfffffc00 | 0x400;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int32_t rf_pri_txcal_search_core
                  (uint32_t param_ind,uint32_t center,uint32_t delta,uint32_t meas_freq)

{
  uint32_t val;
  uint32_t val_00;
  uint32_t uVar1;
  uint uVar2;
  uint32_t uVar3;
  
  rf_pri_txcal_config(param_ind,center);
  BL602_Delay_US(10);
  _DAT_40001618 = meas_freq << 10 | _DAT_40001618 & 0xfff00000;
  uVar1 = rf_pri_pm_pwr();
  do {
    val = center - delta;
    val_00 = center + delta;
    if (param_ind < 2) {
      if ((int)val < 0) {
        val = 0;
      }
      if (0x3f < (int)val_00) {
        val_00 = 0x3f;
      }
    }
    else {
      if (param_ind == 2) {
        if ((int)val < 0) {
          val = 0;
        }
        if (0x7ff < (int)val_00) {
          val_00 = 0x7ff;
        }
      }
      else {
        if ((int)val < -0x200) {
          val = 0xfffffe00;
        }
        if (0x1ff < (int)val_00) {
          val_00 = 0x1ff;
        }
      }
    }
    rf_pri_txcal_config(param_ind,val);
    delta = (int)delta >> 1;
    BL602_Delay_US(10);
    uVar2 = rf_pri_pm_pwr();
    if (uVar1 <= uVar2) {
      rf_pri_txcal_config(param_ind,val_00);
      BL602_Delay_US(10);
      uVar3 = rf_pri_pm_pwr();
      val = center;
      uVar2 = uVar1;
      if (uVar3 < uVar1) {
        val = val_00;
        uVar2 = uVar3;
      }
    }
    center = val;
    uVar1 = uVar2;
  } while (delta != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return val;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_singen_config(uint32_t fcw)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000120c = fcw << 0x10 | _DAT_4000120c & 0xfc00ffff;
  _DAT_40001214 = _DAT_40001214 & 0x3fffff;
  _DAT_40001218 = _DAT_40001218 & 0x3fffff | 0xc0000000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_rccal_iq(uint32_t iq)

{
  uint uVar1;
  uint32_t uVar2;
  USItype UVar3;
  uint32_t uVar4;
  uint uVar5;
  int iVar6;
  
  if (iq == 0) {
    _DAT_4000160c = _DAT_4000160c & 0xfbffffff | 0x400;
  }
  else {
    _DAT_4000160c = _DAT_4000160c & 0xfffffbff | 0x4000000;
  }
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x3100;
  rf_pri_singen_config(3);
  _DAT_40001214 = _DAT_40001214 & 0xfffff800 | 0x3ff;
  _DAT_40001218 = _DAT_40001218 & 0xfffff800 | 0x3ff;
  rf_pri_singen_start();
  rf_pri_start_txdfe();
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0xc00;
  rf_pri_pm_pwr_avg(iq,0x400);
  uVar2 = rf_pri_pm_pwr();
  __floatunsidf(uVar2);
  __muldf3();
  UVar3 = __fixunsdfsi();
  _DAT_40001048 = _DAT_40001048 & 0xffff8cff | 0x6200;
  rf_pri_singen_config(0xb5);
  rf_pri_singen_start();
  rf_pri_start_txdfe();
  _DAT_40001618 = _DAT_40001618 & 0xfff00000 | 0x2d400;
  uVar2 = 0;
  uVar1 = 6;
  uVar5 = 0x20;
  do {
    rf_pri_rccal_config(iq,uVar5 + uVar2);
    uVar4 = rf_pri_pm_pwr();
    if (UVar3 < uVar4) {
      uVar2 = uVar5 + uVar2;
    }
    uVar1 = uVar1 - 1;
    uVar5 = uVar5 >> 1;
  } while (uVar1 != 0);
  iVar6 = 0x3f;
  do {
    rf_pri_rccal_config(iq,uVar2);
    uVar4 = rf_pri_pm_pwr();
    if (UVar3 < uVar4) {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      uVar2 = uVar2 + 1;
      if (uVar1 == 5) {
LAB_230167c0:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 3;
      }
    }
    else {
      uVar1 = uVar1 * 2 & 0xf;
      uVar2 = uVar2 - 1;
      if (uVar1 == 10) goto LAB_230167c0;
    }
    iVar6 = iVar6 + -1;
    if (iVar6 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 2;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_config_channel(void)

{
  _DAT_400010a0 =
       ((ushort)rf_calib_data->lo[9] >> 8 & 0x1f) << 0x10 |
       (ushort)rf_calib_data->lo[9] & 0xff | _DAT_400010a0 & 0xffe0ff00;
  _DAT_400010bc = (((ushort)rf_calib_data->lo[9] & 0xff) >> 4) << 0x14 | _DAT_400010bc & 0xff0fffff;
  _DAT_400010c4 = _DAT_400010c4 & 0xc0000000 | channel_div_table[9];
  _DAT_400010c0 = _DAT_400010c0 & 0xffffefff;
  while( true ) {
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(10);
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
    _DAT_400010b0 = _DAT_400010b0 | 0x10000000;
    BL602_Delay_US(10);
    _DAT_400010b0 = _DAT_400010b0 & 0xefffffff;
    BL602_Delay_US(0x32);
    if ((_DAT_400010b4 & 0x1100000) == 0) break;
    printf(".");
  }
  printf("LO locked %ld %ld\r\n",(ushort)rf_calib_data->lo[9] & 0xff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t rf_pri_roscal_iq(uint32_t iq)

{
  uint uVar1;
  int32_t iVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  
  uVar1 = 6;
  uVar3 = 0;
  uVar4 = 0x20;
  do {
    uVar6 = uVar4 + uVar3;
    if (iq == 0) {
      _DAT_4000107c = uVar6 | _DAT_4000107c & 0xffffffc0;
    }
    else {
      _DAT_4000107c = uVar6 * 0x100 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar3 = uVar6;
    }
    uVar1 = uVar1 - 1;
    uVar4 = uVar4 >> 1;
  } while (uVar1 != 0);
  iVar5 = 0x3f;
  do {
    if (iq == 0) {
      _DAT_4000107c = _DAT_4000107c & 0xffffffc0 | uVar3;
    }
    else {
      _DAT_4000107c = uVar3 << 8 | _DAT_4000107c & 0xffffc0ff;
    }
    iVar2 = rf_pri_pm_pwr_avg(iq,0x400);
    if (iVar2 < 1) {
      uVar1 = uVar1 * 2 & 0xf;
      uVar3 = uVar3 + 1;
      if (uVar1 == 10) break;
    }
    else {
      uVar1 = uVar1 * 2 + 1 & 0xf;
      uVar3 = uVar3 - 1;
      if (uVar1 == 5) break;
    }
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



void rf_pri_chipv(uint8_t chipv)

{
  regs_to_opti *prVar1;
  undefined3 in_register_00002029;
  undefined4 uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  int iVar5;
  uint32_t (*pauVar6) [4];
  int iVar7;
  uint32_t (*pauVar8) [4];
  int iVar9;
  uint32_t (*pauVar10) [4];
  
  if (CONCAT31(in_register_00002029,chipv) == 0) {
    tmxcss._0_4_ = 0x60003;
    tmxcss[2] = 6;
    iVar5 = 0x1c;
    do {
      iVar7 = iVar5 + -0x1c;
      do {
        uVar2 = *(undefined4 *)((int)tx_pwr_table_a0 + iVar7);
        *(undefined4 *)((int)tx_pwr_table + iVar7) = uVar2;
        *(undefined4 *)((int)tx_pwr_table_origin + iVar7) = uVar2;
        iVar7 = iVar7 + 4;
      } while (iVar5 != iVar7);
      iVar5 = iVar5 + 0x1c;
    } while (iVar5 != 0x1dc);
    iVar5 = 0;
    do {
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os_a0 + iVar5);
      puVar4 = (undefined4 *)((int)tx_pwr_ch_os + iVar5);
      iVar5 = iVar5 + 4;
      *puVar4 = *puVar3;
    } while (iVar5 != 0x38);
    pauVar6 = txcal_para;
    pauVar10 = txcal_para_a0;
    do {
      pauVar8 = pauVar10[1];
      (*pauVar6)[0] = (*pauVar10)[0];
      (*pauVar6)[1] = (*pauVar10)[1];
      (*pauVar6)[2] = (*pauVar10)[2];
      (*pauVar6)[3] = (*pauVar10)[3];
      pauVar6 = pauVar6[1];
      pauVar10 = pauVar8;
    } while (pauVar8 != txcal_para_a1);
    opti_regs->vbcore = 10;
    prVar1 = opti_regs;
    opti_regs->iet = 3;
    prVar1->vbcore_11n = 10;
    prVar1->iet_11n = 3;
    prVar1->vbcore_11g = 10;
    prVar1->iet_11g = 3;
    prVar1->vbcore_11b = 10;
    prVar1->iet_11b = 3;
    prVar1->lo_fbdv_halfstep_en = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->lo_fbdv_halfstep_en_tx = 0;
    prVar1->clkpll_reset_postdiv = 0;
    prVar1->clkpll_dither_sel = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (CONCAT31(in_register_00002029,chipv) == 1) {
    tmxcss._0_4_ = 0x50005;
    tmxcss[2] = 5;
    iVar5 = 0x1c;
    do {
      iVar7 = iVar5 + -0x1c;
      do {
        iVar9 = iVar7;
        uVar2 = *(undefined4 *)((int)tx_pwr_table_a1 + iVar9);
        *(undefined4 *)((int)tx_pwr_table + iVar9) = uVar2;
        *(undefined4 *)((int)tx_pwr_table_origin + iVar9) = uVar2;
        iVar7 = iVar9 + 4;
      } while (iVar9 + 4 != iVar5);
      iVar5 = iVar9 + 0x20;
    } while (iVar5 != 0x1dc);
    iVar5 = 0;
    do {
      puVar3 = (undefined4 *)((int)tx_pwr_ch_os_a1 + iVar5);
      puVar4 = (undefined4 *)((int)tx_pwr_ch_os + iVar5);
      iVar5 = iVar5 + 4;
      *puVar4 = *puVar3;
    } while (iVar5 != 0x38);
    pauVar6 = txcal_para;
    pauVar10 = txcal_para_a1;
    do {
      pauVar8 = pauVar10[1];
      (*pauVar6)[0] = (*pauVar10)[0];
      (*pauVar6)[1] = (*pauVar10)[1];
      (*pauVar6)[2] = (*pauVar10)[2];
      (*pauVar6)[3] = (*pauVar10)[3];
      pauVar6 = pauVar6[1];
      pauVar10 = pauVar8;
    } while (pauVar8 != (uint32_t (*) [4])intc_irq_handlers);
    opti_regs->vbcore = 0xc;
    prVar1 = opti_regs;
    opti_regs->iet = 5;
    prVar1->vbcore_11n = 0xc;
    prVar1->iet_11n = 5;
    prVar1->vbcore_11g = 0xc;
    prVar1->iet_11g = 5;
    prVar1->vbcore_11b = 0xc;
    prVar1->iet_11b = 5;
    prVar1->lo_fbdv_halfstep_en = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->lo_fbdv_halfstep_en_tx = 1;
    prVar1->clkpll_reset_postdiv = 1;
    prVar1->clkpll_dither_sel = 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_pri_update_tx_power_offset(uint8_t channel,int8_t *power_offset)

{
  char cVar1;
  undefined3 in_register_00002029;
  int32_t (*paiVar2) [7];
  int32_t (*paiVar3) [7];
  
  cVar1 = power_offset[CONCAT31(in_register_00002029,channel)];
  memcpy(tx_pwr_table,tx_pwr_table_origin,0x1c0);
  paiVar2 = tx_pwr_table;
  do {
    paiVar3 = paiVar2[1];
    (*paiVar2)[5] = (*paiVar2)[5] + (int)cVar1 % 4;
    (*paiVar2)[6] = (*paiVar2)[6] + ((int)cVar1 / 4) * -10;
    paiVar2 = paiVar3;
  } while (paiVar3 != tx_pwr_table_origin);
  rf_pri_set_gain_table_regs();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_pri_get_notch_param(uint32_t chanfreq_MHz,uint8_t *ncf_on,int32_t *ncf_freq_Hz)

{
  uint uVar1;
  int32_t iVar2;
  
  uVar1 = 0xd;
  if (chanfreq_MHz < 0x9a9) {
    uVar1 = (chanfreq_MHz - 0x96c) / 5;
  }
  iVar2 = rx_notch_para_40M[uVar1][1];
  *ncf_on = (uint8_t)rx_notch_para_40M[uVar1][0];
  *ncf_freq_Hz = iVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_update_param(uint32_t chanfreq_MHz)

{
  ushort uVar1;
  int iVar2;
  int32_t *piVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int32_t iVar7;
  int iVar8;
  uint32_t uVar9;
  int32_t *piVar10;
  
  index_os_pre = 0;
  index_os_pre_mdb = 0;
  dvga_os_pre = 0;
  up_dn = 0;
  if ((chanfreq_MHz < 0x96c) || (chanfreq_MHz < 0x971)) {
    iVar5 = 0;
LAB_23016cce:
    uVar9 = Tchannels[iVar5];
    iVar8 = 0;
    if (uVar9 != chanfreq_MHz) {
      iVar8 = chanfreq_MHz - uVar9;
    }
    iVar6 = iVar5 + 1;
    iVar4 = (uint)((Tchannel_os[iVar6] - Tchannel_os[iVar5]) * iVar8) / (Tchannels[iVar6] - uVar9) +
            Tchannel_os[iVar5];
    iVar5 = (uint)((Tchannel_os_low[iVar6] - Tchannel_os_low[iVar5]) * iVar8) /
            (Tchannels[iVar6] - uVar9) + Tchannel_os_low[iVar5];
  }
  else {
    if (chanfreq_MHz < 0x97b) {
      iVar5 = 1;
      goto LAB_23016cce;
    }
    if (chanfreq_MHz < 0x98a) {
      iVar5 = 2;
      goto LAB_23016cce;
    }
    if (chanfreq_MHz < 0x999) {
      iVar5 = 3;
      goto LAB_23016cce;
    }
    iVar4 = 8;
    iVar5 = 7;
    if (chanfreq_MHz < 0x9a8) {
      iVar5 = 4;
      goto LAB_23016cce;
    }
  }
  piVar3 = temps;
  piVar10 = temps;
  iVar8 = 0;
  iVar6 = 10;
  do {
    iVar2 = (piVar10[4] + iVar8) - (0x14 - iVar5);
    iVar8 = 0;
    if (iVar6 < iVar2) {
      iVar8 = iVar2 - iVar6;
      iVar2 = iVar6;
    }
    piVar10[3] = iVar2;
    iVar6 = iVar6 + -5;
    piVar10 = piVar10 + -1;
  } while (iVar6 != -10);
  iVar8 = 0x38;
  iVar5 = 0;
  do {
    iVar7 = (piVar3[5] - iVar5) + (0x14 - iVar4);
    if (0x5f < iVar7) {
      iVar7 = iVar7 + (5 - iVar4 / 4);
    }
    piVar3[6] = iVar7;
    iVar6 = piVar3[6];
    iVar5 = 0;
    if (iVar6 < iVar8) {
      iVar5 = iVar8 - iVar6;
      iVar6 = iVar8;
    }
    piVar3[6] = iVar6;
    iVar8 = iVar8 + 5;
    piVar3 = piVar3 + 1;
  } while (iVar8 != 0x5b);
  uVar1 = tmxcss[2];
  if (chanfreq_MHz < 0x986) {
    uVar1 = tmxcss[1];
  }
  _DAT_4000106c = (uint)uVar1 | _DAT_4000106c & 0xfffffff8;
  tx_pwr_os = tx_pwr_ch_os[6];
  if (chanfreq_MHz != 0x98a) {
    if (chanfreq_MHz < 0x98b) {
      tx_pwr_os = tx_pwr_ch_os[2];
      if (chanfreq_MHz != 0x976) {
        if (chanfreq_MHz < 0x977) {
          tx_pwr_os = tx_pwr_ch_os[0];
          if ((chanfreq_MHz != 0x96c) && (tx_pwr_os = tx_pwr_ch_os[1], chanfreq_MHz != 0x971)) {
LAB_23016e34:
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            temps[4] = 0xf;
            temps[5] = 0x33;
            tx_pwr_os = 0;
            return;
          }
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[4];
          if (((chanfreq_MHz != 0x980) && (tx_pwr_os = tx_pwr_ch_os[5], chanfreq_MHz != 0x985)) &&
             (tx_pwr_os = tx_pwr_ch_os[3], chanfreq_MHz != 0x97b)) goto LAB_23016e34;
        }
      }
    }
    else {
      tx_pwr_os = tx_pwr_ch_os[10];
      if (chanfreq_MHz != 0x99e) {
        if (chanfreq_MHz < 0x99f) {
          tx_pwr_os = tx_pwr_ch_os[8];
          if (((chanfreq_MHz != 0x994) && (tx_pwr_os = tx_pwr_ch_os[9], chanfreq_MHz != 0x999)) &&
             (tx_pwr_os = tx_pwr_ch_os[7], chanfreq_MHz != 0x98f)) goto LAB_23016e34;
        }
        else {
          tx_pwr_os = tx_pwr_ch_os[12];
          if (((chanfreq_MHz != 0x9a8) && (tx_pwr_os = tx_pwr_ch_os[13], chanfreq_MHz != 0x9b4)) &&
             (tx_pwr_os = tx_pwr_ch_os[11], chanfreq_MHz != 0x9a3)) goto LAB_23016e34;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  temps[4] = 0xf;
  temps[5] = 0x33;
  return;
}



void rf_pri_xtalfreq(uint32_t xtalfreq)

{
  if (xtalfreq == 0) {
    channel_div_table[0] = 0x21638e39;
    channel_div_table[1] = 0x2171c71c;
    channel_div_table[2] = 0x21800000;
    channel_div_table[3] = 0x218e38e4;
    channel_div_table[4] = 0x219c71c7;
    channel_div_table[5] = 0x21aaaaab;
    channel_div_table[6] = 0x21b8e38e;
    channel_div_table[7] = 0x21c71c72;
    channel_div_table[8] = 0x21d55555;
    channel_div_table[9] = 0x21e38e39;
    channel_div_table[10] = 0x21f1c71c;
    channel_div_table[11] = 0x22000000;
    channel_div_table[12] = 0x220e38e4;
    channel_div_table[13] = 0x221c71c7;
    channel_div_table[14] = 0x222aaaab;
    channel_div_table[15] = 0x2238e38e;
    channel_div_table[16] = 0x22471c72;
    channel_div_table[17] = 0x22555555;
    channel_div_table[18] = 0x22638e39;
    channel_div_table[19] = 0x2271c71c;
    channel_div_table[20] = 0x22800000;
    fcal_div = 0x500;
    rx_notch_para_40M[4][0] = 1;
    rx_notch_para_40M[6][0] = 1;
    rx_notch_para_40M[7][0] = 1;
    rx_notch_para_40M[12][0] = 1;
    rx_notch_para_40M[1][1] = 7000000;
    rx_notch_para_40M[2][1] = (int32_t)&DAT_001e8480;
    rx_notch_para_40M[3][1] = -3000000;
    rx_notch_para_40M[4][1] = -8000000;
    rx_notch_para_40M[6][1] = 6000000;
    rx_notch_para_40M[7][1] = 1000000;
    rx_notch_para_40M[8][1] = -4000000;
    rx_notch_para_40M[9][1] = -9000000;
    rx_notch_para_40M[0][0] = 0;
    rx_notch_para_40M[10][0] = 0;
    rx_notch_para_40M[0][1] = 0;
    rx_notch_para_40M[10][1] = 0;
    rx_notch_para_40M[11][1] = 5000000;
LAB_2301713a:
    channel_cnt_range[2] = 0xace7;
    channel_cnt_range._0_4_ = 0xa6e7a6a7;
    rx_notch_para_40M[11][0] = 1;
    rx_notch_para_40M[9][0] = 1;
    rx_notch_para_40M[5][1] = 0;
    rx_notch_para_40M[5][0] = 0;
    rx_notch_para_40M[3][0] = 1;
    rx_notch_para_40M[2][0] = 1;
    rx_notch_para_40M[1][0] = 1;
    channel_cnt_table[20] = 0xac80;
    channel_cnt_table._36_4_ = 0xac39abf2;
    channel_cnt_table._32_4_ = 0xababab64;
    channel_cnt_table._28_4_ = 0xab1caad5;
    channel_cnt_table._24_4_ = 0xaa8eaa47;
    channel_cnt_table._20_4_ = 0xaa00a9b9;
    channel_cnt_table._16_4_ = 0xa972a92b;
    channel_cnt_table._12_4_ = 0xa8e4a89c;
    channel_cnt_table._8_4_ = 0xa855a80e;
    channel_cnt_table._4_4_ = 0xa7c7a780;
    channel_cnt_table._0_4_ = 0xa739a6f2;
LAB_2301713c:
    rx_notch_para_40M[8][0] = 1;
    rx_notch_para_40M[12][1] = 0;
  }
  else {
    if (xtalfreq == 1) {
      channel_div_table[0] = 0x1ed20d21;
      channel_div_table[1] = 0x1edf2df3;
      channel_div_table[2] = 0x1eec4ec5;
      channel_div_table[3] = 0x1ef96f97;
      channel_div_table[4] = 0x1f069069;
      channel_div_table[5] = 0x1f13b13b;
      channel_div_table[6] = 0x1f20d20d;
      channel_div_table[7] = 0x1f2df2df;
      channel_div_table[8] = 0x1f3b13b1;
      channel_div_table[9] = 0x1f483483;
      channel_div_table[10] = 0x1f555555;
      channel_div_table[11] = 0x1f627627;
      channel_div_table[12] = 0x1f6f96f9;
      channel_div_table[13] = 0x1f7cb7cb;
      channel_div_table[14] = 0x1f89d89e;
      channel_div_table[15] = 0x1f96f970;
      channel_div_table[16] = 0x1fa41a42;
      channel_div_table[17] = 0x1fb13b14;
      channel_div_table[18] = 0x1fbe5be6;
      channel_div_table[19] = 0x1fcb7cb8;
      channel_div_table[20] = 0x1fd89d8a;
      channel_cnt_table._0_4_ = 0xa743a6fc;
      channel_cnt_table._4_4_ = 0xa7d1a78a;
      channel_cnt_table._8_4_ = 0xa860a819;
      channel_cnt_table._12_4_ = 0xa8eea8a7;
      channel_cnt_table._16_4_ = 0xa97ca935;
      channel_cnt_table._20_4_ = 0xaa0aa9c3;
      channel_cnt_table._24_4_ = 0xaa99aa52;
      channel_cnt_table._28_4_ = 0xab27aae0;
      channel_cnt_table._32_4_ = 0xabb5ab6e;
      channel_cnt_table._36_4_ = 0xac43abfc;
      channel_cnt_table[20] = 0xac8b;
      channel_cnt_range._0_4_ = 0xa6f1a6b1;
      channel_cnt_range[2] = 0xacf2;
      fcal_div = 0x56b;
      rx_notch_para_40M[0][1] = 6000000;
      rx_notch_para_40M[1][1] = 1000000;
      rx_notch_para_40M[2][1] = -4000000;
      rx_notch_para_40M[3][1] = -9000000;
      rx_notch_para_40M[5][1] = 7000000;
      rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[7][1] = -3000000;
      rx_notch_para_40M[8][1] = -8000000;
      rx_notch_para_40M[10][1] = 8000000;
      rx_notch_para_40M[11][1] = 3000000;
      rx_notch_para_40M[4][0] = 0;
      rx_notch_para_40M[9][0] = 0;
      rx_notch_para_40M[9][1] = 0;
      rx_notch_para_40M[12][1] = -2000000;
      rx_notch_para_40M[8][0] = xtalfreq;
      rx_notch_para_40M[12][0] = xtalfreq;
    }
    else {
      if (xtalfreq != 2) {
        if (xtalfreq == 3) {
          channel_div_table[0] = 0x14de38e4;
          channel_div_table[1] = 0x14e71c72;
          channel_div_table[2] = 0x14f00000;
          channel_div_table[3] = 0x14f8e38e;
          channel_div_table[4] = 0x1501c71c;
          channel_div_table[5] = 0x150aaaab;
          channel_div_table[6] = 0x15138e39;
          channel_div_table[7] = 0x151c71c7;
          channel_div_table[8] = 0x15255555;
          channel_div_table[9] = 0x152e38e4;
          channel_div_table[10] = 0x15371c72;
          channel_div_table[11] = 0x15400000;
          channel_div_table[12] = 0x1548e38e;
          channel_div_table[13] = 0x1551c71c;
          channel_div_table[14] = 0x155aaaab;
          channel_div_table[15] = 0x15638e39;
          channel_div_table[16] = 0x156c71c7;
          channel_div_table[17] = 0x15755555;
          channel_div_table[18] = 0x157e38e4;
          channel_div_table[19] = 0x15871c72;
          channel_div_table[20] = 0x15900000;
          fcal_div = 0x800;
          rx_notch_para_40M[0][0] = 1;
          rx_notch_para_40M[10][0] = 1;
          rx_notch_para_40M[0][1] = 7200000;
          rx_notch_para_40M[1][1] = 2200000;
          rx_notch_para_40M[2][1] = -2800000;
          rx_notch_para_40M[3][1] = -7800000;
          rx_notch_para_40M[8][1] = 5600000;
          rx_notch_para_40M[9][1] = 600000;
          rx_notch_para_40M[10][1] = -4400000;
          rx_notch_para_40M[4][0] = 0;
          rx_notch_para_40M[6][0] = 0;
          rx_notch_para_40M[7][0] = 0;
          rx_notch_para_40M[12][0] = 0;
          rx_notch_para_40M[4][1] = 0;
          rx_notch_para_40M[6][1] = 0;
          rx_notch_para_40M[7][1] = 0;
          rx_notch_para_40M[11][1] = -9400000;
          goto LAB_2301713a;
        }
        if (xtalfreq == 4) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          channel_cnt_table._0_4_ = 0xa732a6eb;
          channel_cnt_table._4_4_ = 0xa7c0a779;
          channel_cnt_table._8_4_ = 0xa84fa808;
          channel_cnt_table._12_4_ = 0xa8dda896;
          channel_cnt_table._16_4_ = 0xa96ba924;
          channel_cnt_table._20_4_ = 0xa9f9a9b2;
          channel_cnt_table._24_4_ = 0xaa87aa40;
          channel_cnt_table._28_4_ = 0xab16aacf;
          channel_cnt_table._32_4_ = 0xaba4ab5d;
          channel_cnt_table._36_4_ = 0xac32abeb;
          channel_cnt_table[20] = 0xac79;
          channel_div_table[0] = 0x14088889;
          channel_div_table[1] = 0x14111111;
          channel_div_table[2] = 0x1419999a;
          channel_div_table[3] = 0x14222222;
          channel_div_table[4] = 0x142aaaab;
          channel_div_table[5] = 0x14333333;
          channel_div_table[6] = 0x143bbbbc;
          channel_div_table[7] = 0x14444444;
          channel_div_table[8] = 0x144ccccd;
          channel_div_table[9] = 0x14555555;
          channel_div_table[10] = 0x145dddde;
          channel_div_table[11] = 0x14666666;
          channel_div_table[12] = 0x146eeeef;
          channel_div_table[13] = 0x14777777;
          channel_div_table[14] = 0x14800000;
          channel_div_table[15] = 0x14888889;
          channel_div_table[16] = 0x14911111;
          channel_div_table[17] = 0x1499999a;
          channel_div_table[18] = 0x14a22222;
          channel_div_table[19] = 0x14aaaaab;
          channel_div_table[20] = 0x14b33333;
          rx_notch_para_40M[0][0] = 0;
          rx_notch_para_40M[0][1] = 0;
          rx_notch_para_40M[1][0] = 0;
          rx_notch_para_40M[1][1] = 0;
          rx_notch_para_40M[2][0] = 0;
          rx_notch_para_40M[2][1] = 0;
          rx_notch_para_40M[3][0] = 0;
          rx_notch_para_40M[3][1] = 0;
          rx_notch_para_40M[4][0] = 1;
          rx_notch_para_40M[4][1] = 8000000;
          rx_notch_para_40M[5][0] = 1;
          rx_notch_para_40M[5][1] = 3000000;
          rx_notch_para_40M[6][0] = 1;
          rx_notch_para_40M[6][1] = -2000000;
          rx_notch_para_40M[7][0] = 1;
          rx_notch_para_40M[7][1] = -7000000;
          rx_notch_para_40M[8][0] = 0;
          rx_notch_para_40M[8][1] = 0;
          rx_notch_para_40M[9][0] = 0;
          rx_notch_para_40M[9][1] = 0;
          rx_notch_para_40M[10][0] = 0;
          rx_notch_para_40M[10][1] = 0;
          rx_notch_para_40M[11][0] = 0;
          rx_notch_para_40M[11][1] = 0;
          rx_notch_para_40M[12][0] = 1;
          rx_notch_para_40M[12][1] = 8000000;
          rx_notch_para_40M[13][0] = 1;
          rx_notch_para_40M[13][1] = -4000000;
          channel_cnt_range._0_4_ = 0xa6e0a6a0;
          channel_cnt_range[2] = 0xace0;
          fcal_div = 0x855;
          return;
        }
        if (xtalfreq != 5) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        channel_div_table[0] = 0xf690690;
        channel_div_table[1] = 0xf6f96f9;
        channel_div_table[2] = 0xf762762;
        channel_div_table[3] = 0xf7cb7cb;
        channel_div_table[4] = 0xf834835;
        channel_div_table[5] = 0xf89d89e;
        channel_div_table[6] = 0xf906907;
        channel_div_table[7] = 0xf96f970;
        channel_div_table[8] = 0xf9d89d9;
        channel_div_table[9] = 0xfa41a42;
        channel_div_table[10] = 0xfaaaaab;
        channel_div_table[11] = 0xfb13b14;
        channel_div_table[12] = 0xfb7cb7d;
        channel_div_table[13] = 0xfbe5be6;
        channel_div_table[14] = 0xfc4ec4f;
        channel_div_table[15] = 0xfcb7cb8;
        channel_div_table[16] = 0xfd20d21;
        channel_div_table[17] = 0xfd89d8a;
        channel_div_table[18] = 0xfdf2df3;
        channel_div_table[19] = 0xfe5be5c;
        channel_div_table[20] = 0xfec4ec5;
        channel_cnt_table._0_4_ = 0xa734a6ed;
        channel_cnt_table._4_4_ = 0xa7c2a77b;
        channel_cnt_table._8_4_ = 0xa850a809;
        channel_cnt_table._12_4_ = 0xa8dea897;
        channel_cnt_table._16_4_ = 0xa96da925;
        channel_cnt_table._20_4_ = 0xa9fba9b4;
        channel_cnt_table._24_4_ = 0xaa89aa42;
        channel_cnt_table._28_4_ = 0xab17aad0;
        channel_cnt_table._32_4_ = 0xaba5ab5e;
        channel_cnt_table._36_4_ = 0xac34abec;
        channel_cnt_table[20] = 0xac7b;
        channel_cnt_range._0_4_ = 0xa6e2a6a2;
        channel_cnt_range[2] = 0xace2;
        fcal_div = 0xad5;
        rx_notch_para_40M[5][0] = 1;
        rx_notch_para_40M[6][0] = 1;
        rx_notch_para_40M[7][0] = 1;
        rx_notch_para_40M[5][1] = 7000000;
        rx_notch_para_40M[6][1] = (int32_t)&DAT_001e8480;
        rx_notch_para_40M[7][1] = -3000000;
        rx_notch_para_40M[0][0] = 0;
        rx_notch_para_40M[1][0] = 0;
        rx_notch_para_40M[2][0] = 0;
        rx_notch_para_40M[3][0] = 0;
        rx_notch_para_40M[4][0] = 0;
        rx_notch_para_40M[9][0] = 0;
        rx_notch_para_40M[10][0] = 0;
        rx_notch_para_40M[11][0] = 0;
        rx_notch_para_40M[12][0] = 0;
        rx_notch_para_40M[0][1] = 0;
        rx_notch_para_40M[1][1] = 0;
        rx_notch_para_40M[2][1] = 0;
        rx_notch_para_40M[3][1] = 0;
        rx_notch_para_40M[4][1] = 0;
        rx_notch_para_40M[8][1] = -8000000;
        rx_notch_para_40M[9][1] = 0;
        rx_notch_para_40M[10][1] = 0;
        rx_notch_para_40M[11][1] = 0;
        goto LAB_2301713c;
      }
      channel_div_table[0] = 0x190aaaab;
      channel_div_table[1] = 0x19155555;
      channel_div_table[2] = 0x19200000;
      channel_div_table[3] = 0x192aaaab;
      channel_div_table[4] = 0x19355555;
      channel_div_table[5] = 0x19400000;
      channel_div_table[6] = 0x194aaaab;
      channel_div_table[7] = 0x19555555;
      channel_div_table[8] = 0x19600000;
      channel_div_table[9] = 0x196aaaab;
      channel_div_table[10] = 0x19755555;
      channel_div_table[11] = 0x19800000;
      channel_div_table[12] = 0x198aaaab;
      channel_div_table[13] = 0x19955555;
      channel_div_table[14] = 0x19a00000;
      channel_div_table[15] = 0x19aaaaab;
      channel_div_table[16] = 0x19b55555;
      channel_div_table[17] = 0x19c00000;
      channel_div_table[18] = 0x19caaaab;
      channel_div_table[19] = 0x19d55555;
      channel_div_table[20] = 0x19e00000;
      channel_cnt_table._0_4_ = 0xa741a6fa;
      channel_cnt_table._4_4_ = 0xa7d0a788;
      channel_cnt_table._8_4_ = 0xa85ea817;
      channel_cnt_table._12_4_ = 0xa8eca8a5;
      channel_cnt_table._16_4_ = 0xa97aa933;
      channel_cnt_table._20_4_ = 0xaa09a9c1;
      channel_cnt_table._24_4_ = 0xaa97aa50;
      channel_cnt_table._28_4_ = 0xab25aade;
      channel_cnt_table._32_4_ = 0xabb3ab6c;
      channel_cnt_table._36_4_ = 0xac42abfa;
      channel_cnt_table[20] = 0xac89;
      channel_cnt_range._0_4_ = 0xa6efa6af;
      channel_cnt_range[2] = 0xacf0;
      fcal_div = 0x6ab;
      rx_notch_para_40M[4][0] = 1;
      rx_notch_para_40M[9][0] = 1;
      rx_notch_para_40M[12][0] = 1;
      rx_notch_para_40M[2][1] = 10000000;
      rx_notch_para_40M[3][1] = 5000000;
      rx_notch_para_40M[5][1] = -5000000;
      rx_notch_para_40M[6][1] = -10000000;
      rx_notch_para_40M[9][1] = 7000000;
      rx_notch_para_40M[10][1] = (int32_t)&DAT_001e8480;
      rx_notch_para_40M[11][1] = -3000000;
      rx_notch_para_40M[8][0] = 0;
      rx_notch_para_40M[0][1] = 0;
      rx_notch_para_40M[1][1] = 0;
      rx_notch_para_40M[7][1] = 0;
      rx_notch_para_40M[8][1] = 0;
      rx_notch_para_40M[12][1] = -8000000;
    }
    rx_notch_para_40M[4][1] = 0;
    rx_notch_para_40M[0][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[1][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[2][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[3][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[5][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[6][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[7][0] = rx_notch_para_40M[8][0];
    rx_notch_para_40M[10][0] = rx_notch_para_40M[12][0];
    rx_notch_para_40M[11][0] = rx_notch_para_40M[12][0];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  rx_notch_para_40M[13][0] = 0;
  rx_notch_para_40M[13][1] = 0;
  return;
}



uint32_t rf_pri_get_vco_freq_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (ushort)rf_calib_data->lo[iVar1] & 0xff;
}



uint32_t rf_pri_get_vco_idac_cw(uint32_t chanfreq_MHz)

{
  int iVar1;
  
  __floatunsidf(chanfreq_MHz - 0x964 >> 2);
  __adddf3();
  iVar1 = __fixdfsi();
  if (0x14 < iVar1) {
    iVar1 = 0x14;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (ushort)rf_calib_data->lo[iVar1] >> 8 & 0x1f;
}



int32_t rf_pri_get_txgain_max(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return tx_pwr_os_temperature + tx_pwr_table[0][6] + tx_pwr_os;
}



int32_t rf_pri_get_txgain_min(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return tx_pwr_os_temperature + tx_pwr_table[15][6] + tx_pwr_os;
}



uint32_t rf_pri_get_txgain_index(int32_t pwr,uint32_t mode)

{
  int32_t (*paiVar1) [7];
  uint32_t uVar2;
  
  if (mode == 0) {
    pwr = pwr + -0x1e;
  }
  paiVar1 = tx_pwr_table;
  uVar2 = 0;
  do {
    if ((*paiVar1)[6] + tx_pwr_os + tx_pwr_os_temperature <= pwr) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar2;
    }
    uVar2 = uVar2 + 1;
    paiVar1 = paiVar1[1];
  } while (uVar2 != 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xf;
}



void rf_pri_query_txgain_table(uint32_t index,uint32_t *rfg_index,uint32_t *dg)

{
  if (0xf < index) {
    index = 0xf;
  }
  *rfg_index = 7 - (index >> 1);
  *dg = tx_pwr_table[index][5];
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_pri_update_dvga_os(int8_t dvga_os)

{
  int iVar1;
  int32_t (*paiVar2) [7];
  int8_t *piVar3;
  
  paiVar2 = tx_pwr_table;
  iVar1 = 0;
  do {
    piVar3 = temps_dvga + iVar1;
    iVar1 = iVar1 + 1;
    *piVar3 = (char)(*paiVar2)[5] + dvga_os;
    paiVar2 = paiVar2[1];
  } while (iVar1 != 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_pri_tx_gain_comp(int32_t Tsens)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  int32_t *piVar4;
  uint uVar5;
  
  if (up_dn == 1) {
    if ((Tthr <= Tsens) || (Tsens <= Tthr + -5)) {
LAB_23017d2a:
      piVar4 = temps;
      iVar3 = 0xc;
      do {
        if (piVar4[0xc] <= Tsens) break;
        iVar3 = iVar3 + -1;
        piVar4 = piVar4 + -1;
      } while (iVar3 != -1);
      if (iVar3 < 0) {
        iVar3 = 0;
      }
      uVar5 = iVar3 - 4;
      iVar2 = temps[iVar3];
      Tthr = iVar2;
      if (Tsens < 0x23) {
        if (iVar2 < Tsens) {
          Tthr = temps[iVar3 + 1];
          if (0x22 < temps[iVar3 + 1]) {
            Tthr = iVar2;
          }
        }
        else {
          uVar5 = iVar3 - 5;
        }
      }
      else {
        if (iVar2 < 0x24) {
          Tthr = temps[iVar3 + 1];
        }
      }
      if (index_os_pre_mdb < (int)uVar5) {
        up_dn = 1;
      }
      else {
        if ((int)uVar5 < index_os_pre_mdb) {
          up_dn = -1;
        }
      }
      if ((int)uVar5 < 1) {
        uVar1 = 0;
        index_os_pre = uVar5;
        if (uVar5 != 0) {
          uVar1 = 0xffffffff;
          if ((uVar5 & 1) != 0) {
            uVar1 = 1;
          }
          index_os_pre = (int)(uVar5 - 1) / 2;
        }
      }
      else {
        uVar1 = uVar5 + 1 & 1;
        if (uVar1 == 0) {
          uVar1 = 0xffffffff;
        }
        index_os_pre = (int)(uVar5 + 1) >> 1;
      }
      tx_pwr_os_temperature = index_os_pre * -10;
      dvga_os_pre = uVar1;
      index_os_pre_mdb = uVar5;
      goto LAB_23017cfe;
    }
  }
  else {
    if (((up_dn != -1) || (Tsens <= Tthr)) || (Tthr + 5 <= Tsens)) goto LAB_23017d2a;
  }
  tx_pwr_os_temperature = index_os_pre * -10;
  uVar1 = SEXT14((char)dvga_os_pre);
LAB_23017cfe:
  rf_pri_update_dvga_os((int8_t)uVar1);
  rfc_apply_tx_dvga(temps_dvga);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_txcal(void)

{
  int32_t iVar1;
  uint32_t uVar2;
  uint uVar3;
  uint val;
  rf_calib3_tag *prVar4;
  int iVar5;
  uint32_t (*pauVar6) [4];
  int32_t (*paiVar7) [7];
  uint uVar8;
  uint uVar9;
  int iVar10;
  
  _DAT_40001014 = _DAT_40001014 & 0xff0fffff | 0x500000;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(5);
  rf_pri_config_channel();
  _DAT_4000101c = _DAT_4000101c | 0x3000;
  _DAT_40001084 = _DAT_40001084 | 0x80000000;
  _DAT_40001064 = _DAT_40001064 | 0x400000;
  iVar5 = 7;
  _DAT_4000106c = (uint)tmxcss[0] | _DAT_4000106c & 0xfffffff8;
  rf_pri_singen_config(0x3d);
  pauVar6 = txcal_para;
  paiVar7 = tx_pwr_table;
  do {
    _DAT_40001064 = (*pauVar6)[0] << 0x1c | _DAT_40001064 & 0xfc3ffff | (*pauVar6)[2] << 0x12;
    _DAT_40001058 = (*pauVar6)[1] << 0x10 | _DAT_40001058 & 0xfff8ffff;
    _DAT_40001048 =
         (*paiVar7)[0] << 0x1c | _DAT_40001048 & 0xce08ffff | (*paiVar7)[3] << 0x14 | 0x70000;
    BL602_Delay_US(10);
    uVar8 = (*pauVar6)[3];
    uVar9 = uVar8;
    do {
      uVar9 = uVar9 >> 1;
      _DAT_40001214 = uVar8 | _DAT_40001214 & 0xfffff800;
      _DAT_40001218 = uVar8 | _DAT_40001218 & 0xfffff800;
      rf_pri_singen_start();
      rf_pri_start_txdfe();
      BL602_Delay_US(10);
      iVar1 = rf_pri_pm_pwr_avg(1,0x400);
      iVar10 = iVar1 >> 10;
      printf("amp=%ld,step=%ld,adc_mean_i=%ld\r\n",uVar8,uVar9,iVar10);
      if (iVar10 < 0x141) {
        uVar3 = uVar9;
        if (0xbf < iVar10) break;
      }
      else {
        uVar3 = -uVar9;
      }
      uVar8 = uVar8 + uVar3;
    } while (uVar9 != 0);
    rf_pri_pm_pwr_avg(1,0x1000);
    uVar2 = rf_pri_txcal_search_core(0,0x20,0x10,0x3d);
    rf_pri_txcal_config(0,uVar2);
    uVar9 = rf_pri_txcal_search_core(1,0x20,0x10,0x3d);
    _DAT_40001070 = uVar9 << 0x10 | _DAT_40001070 & 0xffc0ffff;
    uVar8 = rf_pri_txcal_search_core(0,uVar2,2,0x3d);
    rf_pri_txcal_config(0,uVar8);
    uVar2 = rf_pri_txcal_search_core(2,0x400,0x80,0x7a);
    rf_pri_txcal_config(2,uVar2);
    iVar1 = rf_pri_txcal_search_core(3,0,0x40,0x7a);
    rf_pri_txcal_config(3,iVar1);
    uVar3 = rf_pri_txcal_search_core(2,uVar2,0x40,0x7a);
    rf_pri_txcal_config(2,uVar3);
    val = rf_pri_txcal_search_core(3,0,0x20,0x7a);
    rf_pri_txcal_config(3,val);
    prVar4 = rf_calib_data->rxcal + iVar5 + 3;
    *(uint *)(prVar4 + 1) = *(uint *)(prVar4 + 1) & 0xffffffc0 | uVar8 & 0x3f;
    *(uint *)(prVar4 + 1) = *(uint *)(prVar4 + 1) & 0xfffff03f | (uVar9 & 0x3f) << 6;
    *(uint *)(prVar4 + 1) = *(uint *)(prVar4 + 1) & 0xff800fff | (uVar3 & 0x7ff) << 0xc;
    *(uint *)&prVar4[1].field_0x4 = *(uint *)&prVar4[1].field_0x4 & 0xfffffc00 | val & 0x3ff;
    printf("tosdac_i=%ld,tosdac_q=%ld,tx_iq_gain_comp=%ld,tx_iq_phase_comp=%ld\r\n",uVar8,uVar9,
           uVar3);
    iVar5 = iVar5 + -1;
    pauVar6 = pauVar6[1];
    paiVar7 = paiVar7[2];
    if (iVar5 == -1) {
      rf_pri_txcal_config_hw();
      _DAT_4000101c = _DAT_4000101c & 0xffffcfff;
      rf_pri_restore_state_for_cal();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_40001014 = _DAT_40001014 | 0xf00000;
      _DAT_40001070 =
           (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
           (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
      _DAT_40001600 =
           *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff |
           *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00;
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_roscal(void)

{
  uint32_t uVar1;
  uint uVar2;
  
  _DAT_40001014 = _DAT_40001014 & 0xffff3fff;
  if ((_DAT_40001020 & 0x100) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x4000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(3);
    _DAT_4000101c = _DAT_4000101c | 0x200;
    rf_pri_config_channel();
    _DAT_40001048 = _DAT_40001048 & 0xffff8fff | 0x6300;
    uVar1 = rf_pri_roscal_iq(1);
    uVar2 = uVar1 & 0x3f;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xffffffc0 | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffc0ffff | uVar1 << 0x10;
    printf("rosdac_i_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xffffffc0 | uVar2;
    _DAT_4000116c = uVar1 | _DAT_4000116c & 0xffffffc0;
    printf("rosdac_i_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 << 0x10 | _DAT_40001168 & 0xffc0ffff;
    printf("rosdac_i_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xffffffc0 | uVar2;
    _DAT_40001168 = uVar1 | _DAT_40001168 & 0xffffffc0;
    printf("rosdac_i_gc0=%ld\r\n",uVar1);
    uVar1 = rf_pri_roscal_iq(0);
    uVar2 = (uVar1 & 0x3f) << 6;
    *(uint *)(rf_calib_data->rxcal + 3) = *(uint *)(rf_calib_data->rxcal + 3) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xc0ffffff | uVar1 << 0x18;
    printf("rosdac_q_gc3=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 2) = *(uint *)(rf_calib_data->rxcal + 2) & 0xfffff03f | uVar2;
    _DAT_4000116c = _DAT_4000116c & 0xffffc0ff | uVar1 << 8;
    printf("rosdac_q_gc2=%ld\r\n",uVar1);
    *(uint *)(rf_calib_data->rxcal + 1) = *(uint *)(rf_calib_data->rxcal + 1) & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 0x18 | _DAT_40001168 & 0xc0ffffff;
    printf("rosdac_q_gc1=%ld\r\n",uVar1);
    *(uint *)rf_calib_data->rxcal = *(uint *)rf_calib_data->rxcal & 0xfffff03f | uVar2;
    _DAT_40001168 = uVar1 << 8 | _DAT_40001168 & 0xffffc0ff;
    printf("rosdac_q_gc0=%ld\r\n",uVar1);
    rf_pri_restore_state_for_cal();
    _DAT_40001014 = _DAT_40001014 | 0xc000;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_rccal(void)

{
  rf_calib_data_tag *prVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint uVar4;
  uint uVar5;
  
  _DAT_40001014 = _DAT_40001014 & 0xfff3ffff;
  if ((_DAT_40001020 & 0x400) != 0) {
    _DAT_40001014 = _DAT_40001014 | 0x40000;
    rf_pri_save_state_for_cal();
    rf_pri_manu_pu(4);
    _DAT_40001084 = _DAT_40001084 & 0xfcffffff | 0x2000000;
    _DAT_4000108c = _DAT_4000108c | 0x1000;
    _DAT_4000101c = _DAT_4000101c | 0x800;
    uVar2 = rf_pri_rccal_iq(1);
    uVar3 = rf_pri_rccal_iq(0);
    prVar1 = rf_calib_data;
    uVar5 = _DAT_40001080;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 | _DAT_40001080 >> 0x18 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f | (uVar5 >> 0x10 & 0x3f) << 6;
    *(uint *)&(prVar1->cal).field_0x4 =
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff | (uVar5 >> 8 & 0x3f) << 0xc;
    *(uint *)&(prVar1->cal).field_0x4 =
         (uVar5 & 0x3f) << 0x12 | *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    printf("rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(prVar1->cal).field_0x4 & 0x3f,*(uint *)&(prVar1->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(prVar1->cal).field_0x4 >> 0x12 & 0x3f);
    prVar1 = rf_calib_data;
    uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f;
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f;
    }
    if (uVar5 < (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f)) {
      uVar5 = *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
    }
    uVar4 = 0x18;
    if (0x27 < uVar5) {
      uVar4 = 0x3f - uVar5;
    }
    uVar4 = uVar4 & 0xff;
    *(uint *)&(rf_calib_data->cal).field_0x4 =
         *(uint *)&(rf_calib_data->cal).field_0x4 & 0xffffffc0 |
         *(int *)&(rf_calib_data->cal).field_0x4 + uVar4 & 0x3f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 6) + uVar4 & 0x3f) << 6 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffff03f;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0xc) + uVar4 & 0x3f) << 0xc |
         *(uint *)&(prVar1->cal).field_0x4 & 0xfffc0fff;
    *(uint *)&(prVar1->cal).field_0x4 =
         ((*(uint *)&(prVar1->cal).field_0x4 >> 0x12) + uVar4 & 0x3f) << 0x12 |
         *(uint *)&(prVar1->cal).field_0x4 & 0xff03ffff;
    rf_pri_rccal_config(*(uint *)&(prVar1->cal).field_0x4 & 0x3f);
    rf_pri_rccal_config(0,*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f);
    printf("new rbb_cap1_fc_i=%ld,rbb_cap2_fc_i=%ld,rbb_cap1_fc_q=%ld,rbb_cap2_fc_q=%ld\r\n",
           *(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f,
           *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f);
    rf_pri_restore_state_for_cal();
    if ((uVar2 == 2) || (uVar3 == 2)) {
      _DAT_40001014 = _DAT_40001014 & 0xfff3ffff | 0x80000;
    }
    else {
      _DAT_40001014 = _DAT_40001014 | 0xc0000;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_lo_acal(void)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  uint32_t *puVar4;
  uint uVar5;
  
  _DAT_40001014 = _DAT_40001014 & 0xffffff3f | 0x40;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(6);
  puVar4 = channel_div_table;
  iVar3 = 0;
  do {
    _DAT_4000101c = _DAT_4000101c | 0x10;
    _DAT_400010a4 = _DAT_400010a4 & 0xfffff8ff | 0x400;
    uVar5 = 3;
    uVar1 = 0x10;
    _DAT_400010a0 = (ushort)rf_calib_data->lo[iVar3] & 0xff | _DAT_400010a0 & 0xffe0ff00 | 0x100000;
    _DAT_400010c4 = *puVar4;
    BL602_Delay_US(1);
    while (_DAT_400010a0 = _DAT_400010a0 & 0xffe0ffff | uVar1 << 0x10, uVar5 != 0xffffffff) {
      BL602_Delay_US(1);
      iVar2 = 1 << (uVar5 & 0x1f);
      if ((int)(_DAT_400010a4 << 0x13) < 0) {
        iVar2 = -iVar2;
      }
      uVar1 = uVar1 + iVar2;
      uVar5 = uVar5 - 1;
    }
    BL602_Delay_US(1);
    if ((-1 < (int)(_DAT_400010a4 << 0x13)) && (uVar1 < 0x1f)) {
      uVar1 = uVar1 + 1;
    }
    (rf_calib_data->lo + iVar3 + -6)[6] =
         (rf_calib2_tag)
         ((ushort)(rf_calib_data->lo + iVar3 + -6)[6] & 0xe0ff | (ushort)((uVar1 & 0x1f) << 8));
    printf("%ldth channel,vco_idac_cw=%ld\r\n",iVar3,uVar1);
    iVar3 = iVar3 + 1;
    puVar4 = puVar4 + 1;
  } while (iVar3 != 0x15);
  rf_pri_restore_state_for_cal();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001014 = _DAT_40001014 | 0xc0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_fcal(void)

{
  int iVar1;
  uint cw;
  uint16_t uVar2;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint16_t *puVar7;
  uint uVar8;
  
  uVar6 = (uint)channel_cnt_range[0];
  uVar8 = (uint)channel_cnt_range[1];
  uVar5 = (uint)channel_cnt_range[2];
  _DAT_40001014 = _DAT_40001014 & 0xffffffcf | 0x10;
  rf_pri_save_state_for_cal();
  rf_pri_manu_pu(7);
  _DAT_4000101c = _DAT_4000101c | 8;
  _DAT_400010a0 = _DAT_400010a0 & 0xffffff00 | 0x80;
  _DAT_400010a8 = (uint)fcal_div | _DAT_400010a8 & 0xffff0000;
  _DAT_400010c4 = 0x1000000;
  _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff | 0x1000;
  _DAT_400010b8 = _DAT_400010b8 & 0xffffcfff | 0x10000;
  BL602_Delay_US(10);
  _DAT_400010c0 = _DAT_400010c0 | 0x10000;
  _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
  BL602_Delay_US(0x32);
  _DAT_400010a4 = _DAT_400010a4 & 0xfffffffc | 2;
  BL602_Delay_US(0x32);
  do {
    uVar4 = 6;
    cw = 0x80;
    while (uVar4 != 0xffffffff) {
      uVar2 = rf_pri_fcal_meas(cw);
      if (CONCAT22(extraout_var,uVar2) < uVar6) {
        iVar3 = -(1 << (uVar4 & 0x1f));
      }
      else {
        if (CONCAT22(extraout_var,uVar2) <= uVar8) break;
        iVar3 = 1 << (uVar4 & 0x1f);
      }
      cw = cw + iVar3 & 0xffff;
      uVar4 = uVar4 - 1;
    }
    if (0xe < cw) break;
    printf("Unexpected cw %ld\r\n",cw);
    _DAT_400010c0 = _DAT_400010c0 & 0xfffeffff;
    _DAT_400010b8 = _DAT_400010b8 | 0x10000;
    BL602_Delay_US(0x32);
    _DAT_400010c0 = _DAT_400010c0 | 0x10000;
    _DAT_400010b8 = _DAT_400010b8 & 0xfffeffff;
    BL602_Delay_US(0x32);
  } while( true );
  uVar6 = cw + 1 & 0xffff;
  channel_cnt_opt_table[0] = rf_pri_fcal_meas(uVar6);
  puVar7 = channel_cnt_opt_table;
  do {
    uVar6 = uVar6 - 1 & 0xffff;
    uVar2 = rf_pri_fcal_meas(uVar6);
    puVar7[1] = uVar2;
    if (uVar5 < CONCAT22(extraout_var_00,uVar2)) break;
    puVar7 = puVar7 + 1;
  } while (uVar6 != (cw - 0x26 & 0xffff));
  iVar3 = 0;
  uVar5 = 0;
  puVar7 = channel_cw_table;
  do {
    while (channel_cnt_opt_table[uVar5] < *(ushort *)((int)channel_cnt_table + iVar3)) {
      uVar5 = (int)(((uVar5 & 0xffff) + 1) * 0x10000) >> 0x10;
    }
    *(short *)((int)channel_cw_table + iVar3) = ((short)cw + 2) - (short)uVar5;
    if ((int)uVar5 < 1) {
      uVar5 = 0;
    }
    else {
      uVar5 = (int)(((uVar5 & 0xffff) - 1) * 0x10000) >> 0x10;
    }
    iVar3 = iVar3 + 2;
  } while (iVar3 != 0x2a);
  rf_pri_restore_state_for_cal();
  iVar3 = 0;
  do {
    iVar1 = iVar3 + -6;
    iVar3 = iVar3 + 1;
    (rf_calib_data->lo + iVar1)[6] =
         (rf_calib2_tag)((ushort)(rf_calib_data->lo + iVar1)[6] & 0xff00 | *puVar7 & 0xff);
    printf("%ldth channel,lo_vco_freq_cw=%ld\r\n");
    puVar7 = puVar7 + 1;
  } while (iVar3 != 0x15);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001014 = _DAT_40001014 | 0x30;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_full_cal(void)

{
  _DAT_40001220 = _DAT_40001220 & 0xffffff9f | 0x61;
  rf_pri_start_txdfe();
  rf_pri_fcal();
  rf_pri_lo_acal();
  rf_pri_roscal();
  rf_pri_rccal();
  rf_pri_txcal();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000100c = _DAT_4000100c | 6;
  _DAT_40001220 = _DAT_40001220 & 0xffffe61c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_restore_cal_reg(void)

{
  _DAT_40001168 =
       (*(uint *)(rf_calib_data->rxcal + 1) >> 6 & 0x3f) << 0x18 |
       (*(uint *)rf_calib_data->rxcal >> 6 & 0x3f) << 8 |
       *(uint *)rf_calib_data->rxcal & 0x3f | _DAT_40001168 & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 1) & 0x3f) << 0x10;
  _DAT_4000116c =
       (*(uint *)(rf_calib_data->rxcal + 3) >> 6 & 0x3f) << 0x18 |
       (*(uint *)(rf_calib_data->rxcal + 2) >> 6 & 0x3f) << 8 |
       *(uint *)(rf_calib_data->rxcal + 2) & 0x3f | _DAT_4000116c & 0xc0c0c0c0 |
       (*(uint *)(rf_calib_data->rxcal + 3) & 0x3f) << 0x10;
  _DAT_40001080 =
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 6 & 0x3f) << 0x10 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 >> 0xc & 0x3f) << 8 |
       (*(uint *)&(rf_calib_data->cal).field_0x4 & 0x3f) << 0x18 | _DAT_40001080 & 0xc0c0c0c0 |
       *(uint *)&(rf_calib_data->cal).field_0x4 >> 0x12 & 0x3f;
  rf_pri_txcal_config_hw();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40001070 =
       (*(uint *)(rf_calib_data->txcal + 3) >> 6 & 0x3f) << 0x10 |
       (*(uint *)(rf_calib_data->txcal + 3) & 0x3f) << 0x18 | _DAT_40001070 & 0xc0c0ffff;
  _DAT_40001600 =
       *(uint *)(rf_calib_data->txcal + 3) & 0x7ff000 | _DAT_40001600 & 0xff800c00 |
       *(uint *)&rf_calib_data->txcal[3].field_0x4 & 0x3ff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_pri_init(uint8_t reset,uint8_t chipv)

{
  undefined3 in_register_00002029;
  
  rf_pri_chipv(chipv);
  init_fast = (uint32_t)(CONCAT31(in_register_00002029,reset) == 0);
  _DAT_4000f814 = _DAT_4000f814 & 0xfffff0ff | 0x300;
  _DAT_4000f030 = _DAT_4000f030 & 0xf0ffffff | 0x8000000;
  _DAT_40001030 = _DAT_40001030 | 0x1001;
  _DAT_4000f884 = _DAT_4000f884 | 4;
  if (init_fast == 0) {
    BL602_Delay_MS(10);
  }
  _DAT_40001064 = _DAT_40001064 & 0xffff8008 | opti_regs->vbcore << 8 | opti_regs->iet << 4 | 0x4002
  ;
  _DAT_40001128 =
       _DAT_40001128 & 0xff800fff | opti_regs->vbcore_11n << 0x10 | opti_regs->iet_11n << 0xc |
       0x400000;
  _DAT_4000112c =
       (_DAT_4000112c & 0xfffff800 | opti_regs->vbcore_11g << 4 | opti_regs->iet_11g) & 0xff800fff |
       0x400 | opti_regs->vbcore_11b << 0x10 | opti_regs->iet_11b << 0xc | 0x400000;
  _DAT_40001090 = _DAT_40001090 | 0x10000;
  _DAT_400010b8 = opti_regs->lo_fbdv_halfstep_en << 4 | _DAT_400010b8 & 0xffffffef;
  _DAT_40001138 =
       (_DAT_40001138 & 0xfffffffc | opti_regs->lo_fbdv_halfstep_en_tx << 1 |
       opti_regs->lo_fbdv_halfstep_en_tx) & 0xfffcfff7 | 0x300;
  _DAT_40001130 = _DAT_40001130 & 0xfffefffe;
  _DAT_4000e400 = opti_regs->clkpll_reset_postdiv << 1 | _DAT_4000e400 & 0xfffffffd;
  _DAT_4000e418 = opti_regs->clkpll_dither_sel << 0x18 | _DAT_4000e418 & 0xfcffffff;
  _DAT_4000108c = _DAT_4000108c & 0xfffffffc | 2;
  _DAT_4000f030 = _DAT_4000f030 & 0xfff0ffff | 0xc0000;
  rf_pri_set_gain_table_regs();
  _DAT_4000e404 = _DAT_4000e404 | 0x10000;
  _DAT_4000e41c = _DAT_4000e41c | 0xff;
  if (CONCAT31(in_register_00002029,reset) == 0) {
    rf_pri_restore_cal_reg();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  rf_pri_full_cal();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rf_pri_update_power_offset(int32_t *power_offset)

{
  undefined4 uVar1;
  int iVar2;
  
  iVar2 = 0;
  do {
    uVar1 = *(undefined4 *)((int)power_offset + iVar2);
    *(undefined4 *)((int)tx_pwr_ch_os_a1 + iVar2) = uVar1;
    *(undefined4 *)((int)tx_pwr_ch_os + iVar2) = uVar1;
    iVar2 = iVar2 + 4;
  } while (iVar2 != 0x38);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int phyif_utils_decode(phyif_utils_recvtable_t *vec,int8_t *ppm)

{
  char cVar1;
  int8_t iVar2;
  SItype SVar3;
  
  cVar1 = *(char *)((int)&vec->recvtable5 + 3);
  if (((*(ushort *)((int)&vec->recvtable2 + 2) & 7) < 2) && ((vec->recvtable1 >> 0xc & 0xf) < 4)) {
    __floatsidf(-(int)cVar1);
    __muldf3();
    SVar3 = __fixdfsi();
    iVar2 = (int8_t)SVar3;
  }
  else {
    iVar2 = (int8_t)((int)CONCAT11(*(undefined *)&vec->recvtable6,cVar1) / 0x7a);
  }
  *ppm = iVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sysctrl_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44900068 = 0x8000000c;
  _DAT_449000e0 = _DAT_449000e0 | 0x1ff00;
  return;
}



void intc_spurious(void)

{
  assert_err("0","module",0x36);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void intc_enable_irq(int index)

{
  *(int *)(((index >> 5) + 0x11244004) * 4) = 1 << (index & 0x1fU);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void intc_init(void)

{
  intc_enable_irq(0x3f);
  intc_enable_irq(0x3e);
  intc_enable_irq(0x3d);
  intc_enable_irq(0x18);
  intc_enable_irq(0x19);
  intc_enable_irq(0x1a);
  intc_enable_irq(0x1b);
  intc_enable_irq(0x1c);
  intc_enable_irq(0x1d);
  intc_enable_irq(0x1e);
  intc_enable_irq(0x1f);
  intc_enable_irq(0x20);
  intc_enable_irq(0x21);
  intc_enable_irq(0x23);
  intc_enable_irq(0x37);
  intc_enable_irq(0x35);
  intc_enable_irq(0x32);
  intc_enable_irq(0x34);
  intc_enable_irq(0x36);
  intc_enable_irq(10);
  intc_enable_irq(0xb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void mac_irq(void)

{
  void_fn *pvVar1;
  
  if ((_DAT_44910000 == 0) && (_DAT_44910004 == 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  pvVar1 = intc_irq_handlers[_DAT_44910040];
  if (pvVar1 == (void_fn *)0x0) {
    assert_err("intc_irq_handlers[irq_idx] != NULL","module",0x9d);
  }
  (*pvVar1)();
  ipc_emb_notify();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_handler(void)

{
  ipc_host_disable_irq_e2a();
  ke_evt_set(0x40000000);
  ipc_emb_notify();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_pwr_mgt_setf(uint8_t pwrmgt)

{
  uint uVar1;
  undefined3 in_register_00002029;
  
  uVar1 = CONCAT31(in_register_00002029,pwrmgt) << 2;
  if ((uVar1 & 0xfffffffb) != 0) {
    assert_err("(((uint32_t)pwrmgt << 2) & ~((uint32_t)0x00000004)) == 0","module",0x952);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = _DAT_44b0004c & 0xfffffffb | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

chan_ctxt_tag * chan_get_next_chan(void)

{
  int iVar1;
  int iVar2;
  chan_ctxt_tag *pcVar3;
  uint uVar4;
  ushort uVar5;
  
  iVar2 = _DAT_44b00120;
  iVar1 = DAT_4201d1e8;
  if (DAT_4201d1f8 != (chan_ctxt_tag *)0x0) {
    if ((DAT_4201d1e8 != 0) && (*(char *)(DAT_4201d1e8 + 10) == '\x02')) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return DAT_4201d1f8;
    }
    if (-1 < (_DAT_44b00120 + 0x1400) - DAT_4201d21c) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return DAT_4201d1f8;
    }
    if (DAT_4201d1f8->status == '\x04') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return DAT_4201d1f8;
    }
  }
  pcVar3 = DAT_4201d1f8;
  if ((DAT_4201d1e8 != 0) && (*(int *)(DAT_4201d1e8 + 4) - DAT_4201d21c < 0)) {
    pcVar3 = vif_info_tab[*(byte *)(DAT_4201d1e8 + 8)].chan_ctxt;
    if (pcVar3 == (chan_ctxt_tag *)0x0) {
      assert_err("p_next_chan_entry","module",0x129);
    }
    if (-1 < (iVar2 + 0x1400) - *(int *)(iVar1 + 4)) goto LAB_230190f4;
    uVar4 = 0;
    if (pcVar3->nb_res_slots < pcVar3->nb_rem_slots) {
      uVar4 = (uint)(ushort)(pcVar3->nb_rem_slots - pcVar3->nb_res_slots);
    }
    if (((uint)(*(int *)(iVar1 + 4) - iVar2) >> 10 & 0xffff) <= uVar4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return pcVar3;
    }
  }
  uVar5 = 0;
  if (chan_ctxt_pool[0].status != '\0') {
    pcVar3 = chan_ctxt_pool;
    uVar5 = chan_ctxt_pool[0].nb_rem_slots;
  }
  if ((chan_ctxt_pool[1].status != '\0') && (uVar5 <= chan_ctxt_pool[1].nb_rem_slots)) {
    pcVar3 = chan_ctxt_pool + 1;
    uVar5 = chan_ctxt_pool[1].nb_rem_slots;
  }
  if ((chan_ctxt_pool[2].status != '\0') && (uVar5 <= chan_ctxt_pool[2].nb_rem_slots)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return chan_ctxt_pool + 2;
  }
LAB_230190f4:
  if (pcVar3 == (chan_ctxt_tag *)0x0) {
    assert_err("p_next_chan_entry","module",0x175);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_conn_less_delay_prog(void)

{
  DAT_4201d248 = DAT_4201d248 | 0x10;
  mm_timer_set((mm_timer_tag *)&DAT_4201d230,_DAT_44b00120 + 30000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_upd_nb_rem_slots(uint32_t current_time)

{
  ushort uVar1;
  ushort uVar2;
  int in_a1;
  uint uVar3;
  
  uVar1 = *(ushort *)current_time;
  uVar3 = (uint)(in_a1 - DAT_4201d244) >> 10 & 0xffff;
  uVar2 = (ushort)uVar3;
  if (uVar1 < uVar3) {
    uVar2 = uVar1;
  }
  *(ushort *)current_time = uVar1 - uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool chan_tbtt_detect_conflict(void)

{
  _Bool _Var1;
  int in_a0;
  int in_a1;
  
  if (((in_a0 - in_a1 < 0) || (_Var1 = true, (in_a1 + 0x2800) - in_a0 < 0)) &&
     (_Var1 = false, -1 < in_a1 - in_a0)) {
    _Var1 = (_Bool)((byte)~(byte)((uint)((in_a0 - in_a1) + 0x2800) >> 0x18) >> 7);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var1;
}



void chan_tbtt_insert(chan_tbtt_tag *p_tbtt_entry)

{
  bool bVar1;
  co_list_hdr list_hdr;
  char cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  co_list_hdr cVar4;
  uint uVar5;
  uint uVar6;
  co_list_hdr prev_element;
  co_list_hdr cVar7;
  
  list_hdr = (co_list_hdr)0x0;
  cVar2 = '\0';
  cVar4 = DAT_4201d1e8;
  prev_element = (co_list_hdr)0x0;
  while (cVar4 != (co_list_hdr)0x0) {
    if (cVar4 == (co_list_hdr)p_tbtt_entry) {
      assert_err("p_elem != p_tbtt_entry","module",0x668);
    }
    uVar5 = p_tbtt_entry->time;
    uVar6 = *(uint *)((int)cVar4 + 4);
    cVar7 = cVar4;
    if (*(char *)((int)cVar4 + 10) == '\x02') {
      if ((uVar5 < uVar6) ||
         (_Var3 = chan_tbtt_detect_conflict(), CONCAT31(extraout_var_00,_Var3) != 0)) {
LAB_23019264:
        cVar2 = '\x01';
        bVar1 = false;
        list_hdr = (co_list_hdr)p_tbtt_entry;
        goto LAB_230192ac;
      }
    }
    else {
      _Var3 = chan_tbtt_detect_conflict();
      if (CONCAT31(extraout_var,_Var3) == 0) {
        if (uVar5 < uVar6) break;
      }
      else {
        if (p_tbtt_entry->priority <= *(byte *)((int)cVar4 + 9)) goto LAB_23019264;
        if (list_hdr == (co_list_hdr)0x0) {
          list_hdr = cVar4;
        }
        cVar2 = cVar2 + '\x01';
        cVar7 = prev_element;
      }
    }
    cVar4 = *(co_list_hdr *)cVar4;
    prev_element = cVar7;
  }
  bVar1 = true;
LAB_230192ac:
  while (cVar2 = cVar2 + -1, cVar2 != -1) {
    if (list_hdr == (co_list_hdr)0x0) {
      assert_err("p_delay_elem","module",0x6b1);
    }
    if (list_hdr != (co_list_hdr)p_tbtt_entry) {
      if (*(char *)((int)list_hdr + 10) == '\x01') {
        mm_timer_clear((mm_timer_tag *)&DAT_4201d200);
        *(undefined *)((int)list_hdr + 10) = 0;
      }
      co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)list_hdr);
    }
    co_list_push_back((co_list *)&DAT_4201d1f0,(co_list_hdr *)list_hdr);
    list_hdr = *(co_list_hdr *)list_hdr;
  }
  if (!bVar1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  co_list_insert_after
            ((co_list *)&DAT_4201d1e8,(co_list_hdr *)prev_element,(co_list_hdr *)p_tbtt_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_upd_ctxt_status(chan_ctxt_tag *p_chan_entry,uint8_t next_status)

{
  undefined3 in_register_0000202d;
  int iVar1;
  uint uVar2;
  int iVar3;
  uint32_t value;
  
  iVar1 = CONCAT31(in_register_0000202d,next_status);
  if (iVar1 == 2) {
    value = 0;
    if (2 < p_chan_entry->idx) goto LAB_23019324;
    iVar3 = 4000;
  }
  else {
    value = 0;
    if (iVar1 != 4) goto LAB_23019324;
    if (p_chan_entry->idx < 3) {
      if (1 < DAT_4201d24a) {
        if ((p_chan_entry->nb_res_slots < p_chan_entry->nb_rem_slots) &&
           (uVar2 = (uint)(ushort)(p_chan_entry->nb_rem_slots - p_chan_entry->nb_res_slots),
           4 < uVar2)) {
          iVar3 = uVar2 << 10;
          DAT_4201d244 = _DAT_44b00120;
          goto LAB_23019322;
        }
      }
      iVar1 = 5;
      value = 0;
      goto LAB_23019324;
    }
    iVar3 = (uint)p_chan_entry->nb_rem_slots << 10;
  }
LAB_23019322:
  value = iVar3 + _DAT_44b00120;
LAB_23019324:
  p_chan_entry->status = (uint8_t)iVar1;
  if (value != 0) {
    DAT_4201d228 = p_chan_entry;
    mm_timer_set((mm_timer_tag *)&DAT_4201d220,value);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (iVar1 != 3) {
    mm_timer_clear((mm_timer_tag *)&DAT_4201d220);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_switch_start(chan_ctxt_tag *p_chan_entry)

{
  code **ppcVar1;
  
  if (DAT_4201d1f8 == p_chan_entry) {
    if ((1 < DAT_4201d24a) && (DAT_4201d1f8->idx < 3)) {
      chan_upd_ctxt_status(p_chan_entry,'\x04');
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
      DAT_4201d1fc = p_chan_entry;
      chan_upd_ctxt_status(p_chan_entry,'\x02');
      ppcVar1 = (code **)ke_msg_alloc(0x60,0,0xff,4);
      *ppcVar1 = chan_goto_idle_cb;
      ke_msg_send(ppcVar1);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_conn_less_delay_evt(void *env)

{
  chan_ctxt_tag *p_chan_entry;
  
  if ((DAT_4201d248 & 1) == 0) {
    if ((DAT_4201d248 & 2) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((DAT_4201d248 & 8) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_SCAN_BIT)) == 0","module",0x2ce);
    }
    p_chan_entry = chan_ctxt_pool + 3;
    DAT_4201d248 = DAT_4201d248 & 0xfd | 8;
  }
  else {
    if ((DAT_4201d248 & 4) != 0) {
      assert_err("(chan_env.status & CO_BIT(CHAN_ENV_ROC_BIT)) == 0","module",0x2c0);
    }
    p_chan_entry = chan_ctxt_pool + 4;
    DAT_4201d248 = DAT_4201d248 & 0xfe | 4;
  }
  if (DAT_4201d1fc != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  chan_switch_start(p_chan_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_switch_evt(void *env)

{
  ushort uVar1;
  undefined4 uVar2;
  ushort uVar3;
  chan_ctxt_tag *p_chan_entry;
  
  uVar2 = _DAT_44b00120;
  if ((1 < DAT_4201d24a) && ((DAT_4201d248 & 0xc) == 0)) {
    p_chan_entry = vif_info_tab[*(byte *)((int)env + 8)].chan_ctxt;
    if ((DAT_4201d1fc == (chan_ctxt_tag *)0x0) || (DAT_4201d1fc == p_chan_entry)) {
      *(undefined *)((int)env + 9) = 0;
      chan_upd_nb_rem_slots(DAT_4201d1f8 + 0x12);
      uVar1 = p_chan_entry->nb_res_slots;
      uVar3 = uVar1;
      if (10 < uVar1) {
        uVar3 = 10;
      }
      p_chan_entry->nb_res_slots = uVar1 - uVar3;
      DAT_4201d244 = uVar2;
      *(undefined *)((int)env + 10) = 2;
      if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
        chan_switch_start(p_chan_entry);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_tbtt_schedule(chan_tbtt_tag *p_tbtt_entry)

{
  void *pvVar1;
  chan_tbtt_tag *p_tbtt_entry_00;
  uint uVar2;
  uint32_t uVar3;
  
  if (p_tbtt_entry != (chan_tbtt_tag *)0x0) {
    chan_tbtt_insert(p_tbtt_entry);
    while (DAT_4201d1f0 != 0) {
      p_tbtt_entry_00 = (chan_tbtt_tag *)co_list_pop_front((co_list *)&DAT_4201d1f0);
      uVar2 = (uint)p_tbtt_entry_00->vif_index;
      if (vif_info_tab[uVar2].type == '\0') {
        uVar3 = sta_info_tab[*(byte *)&vif_info_tab[uVar2].u.field_0x4].bcn_int;
      }
      else {
        uVar3 = (uint)*(ushort *)&vif_info_tab[uVar2].u.field_0x2e2 << 10;
      }
      p_tbtt_entry_00->time = uVar3 + p_tbtt_entry_00->time;
      if (p_tbtt_entry_00->priority < 5) {
        p_tbtt_entry_00->priority = p_tbtt_entry_00->priority + 1;
      }
      chan_tbtt_insert(p_tbtt_entry_00);
    }
  }
  pvVar1 = DAT_4201d1e8;
  if ((DAT_4201d1e8 != (void *)0x0) && (*(char *)((int)DAT_4201d1e8 + 10) == '\0')) {
    if ((*(int *)((int)DAT_4201d1e8 + 4) - _DAT_44b00120) + -2000 < 0) {
      chan_tbtt_switch_evt(DAT_4201d1e8);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    DAT_4201d208 = DAT_4201d1e8;
    *(undefined *)((int)DAT_4201d1e8 + 10) = 1;
    mm_timer_set((mm_timer_tag *)&DAT_4201d200,*(uint32_t *)((int)pvVar1 + 4));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_cde_evt(void *env)

{
  int iVar1;
  uint uVar2;
  chan_ctxt_tag *p_chan_entry;
  int iVar3;
  co_list_hdr *pcVar4;
  co_list_hdr cVar5;
  undefined2 uVar6;
  uint uVar7;
  
  iVar3 = _DAT_44b00120;
  p_chan_entry = DAT_4201d1fc;
  if ((1 < DAT_4201d24a) && (uVar2 = DAT_4201d248 & 0x2c, (DAT_4201d248 & 0x2c) == 0)) {
    mm_timer_set((mm_timer_tag *)&DAT_4201d210,DAT_4201d240 + _DAT_44b00120);
    DAT_4201d244 = iVar3;
    uVar7 = 0;
    cVar5 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar5 != (co_list_hdr)0x0) {
      pcVar4 = ((co_list_hdr *)((int)cVar5 + 0x40))->next;
      if (pcVar4 != (co_list_hdr *)0x0) {
        uVar2 = uVar2 + 1 & 0xff;
        if (((td_env[*(byte *)((int)cVar5 + 0x57)].status & 3) != 0) ||
           (*(char *)&((co_list_hdr *)((int)cVar5 + 0x58))->next == '\0')) {
          uVar7 = uVar7 + 1 & 0xff;
        }
        *(undefined2 *)&pcVar4[4].next = 0;
        *(undefined2 *)&pcVar4[5].next = 0;
      }
      cVar5 = *(co_list_hdr *)cVar5;
    }
    if (uVar2 != DAT_4201d240 / 0xc800) {
      assert_warn("nb_vifs == (chan_env.cde_dur_us / (CHAN_VIF_NB_SLOTS * CHAN_SLOT_DURATION_US))",
                  "module",0x268);
    }
    if ((uVar7 == 0) || (uVar2 == uVar7)) {
      uVar7 = 0;
      iVar3 = 0x32;
    }
    else {
      iVar3 = 10;
      uVar7 = ((uVar2 - uVar7) * 0x280000 >> 0x10) / uVar7;
    }
    cVar5 = (co_list_hdr)vif_mgmt_env.used_list.first;
    while (cVar5 != (co_list_hdr)0x0) {
      pcVar4 = ((co_list_hdr *)((int)cVar5 + 0x40))->next;
      if (pcVar4 != (co_list_hdr *)0x0) {
        if (((td_env[*(byte *)((int)cVar5 + 0x57)].status & 3) != 0) ||
           (iVar1 = iVar3, *(char *)&((co_list_hdr *)((int)cVar5 + 0x58))->next == '\0')) {
          iVar1 = uVar7 + 0x32;
        }
        uVar6 = (undefined2)(((uint)*(ushort *)&pcVar4[4].next + iVar1) * 0x10000 >> 0x10);
        *(undefined2 *)&pcVar4[4].next = uVar6;
        *(undefined2 *)((int)&pcVar4[4].next + 2) = uVar6;
        if (*(char *)((int)cVar5 + 0x56) == '\0') {
          uVar2 = sta_info_tab[*(byte *)&((co_list_hdr *)((int)cVar5 + 0x60))->next].bcn_int;
        }
        else {
          uVar2 = (uint)*(ushort *)((int)cVar5 + 0x33e) << 10;
        }
        uVar2 = DAT_4201d240 / uVar2;
        if (uVar2 == 0) {
          uVar2 = 1;
        }
        *(ushort *)&pcVar4[5].next = ((ushort)uVar2 & 0xff) * 10 + *(short *)&pcVar4[5].next;
      }
      cVar5 = *(co_list_hdr *)cVar5;
    }
    if (DAT_4201d1f8 != (chan_ctxt_tag *)0x0) {
      chan_upd_ctxt_status(DAT_4201d1f8,'\x01');
    }
    p_chan_entry = chan_get_next_chan();
    if (env == (void *)0x0) {
      chan_switch_start(p_chan_entry);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  DAT_4201d1fc = p_chan_entry;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_pre_switch_channel(void)

{
  chan_ctxt_tag *pcVar1;
  chan_ctxt_tag *pcVar2;
  co_list_hdr cVar3;
  vif_info_tag *p_vif_entry;
  
  mm_timer_clear((mm_timer_tag *)&DAT_4201d220);
  if ((DAT_4201d248 & 0x20) != 0) {
    if ((1 < DAT_4201d24a) && (DAT_4201d1fc != (chan_ctxt_tag *)0x0)) {
      DAT_4201d1fc->status = '\x01';
      DAT_4201d1fc = (chan_ctxt_tag *)0x0;
    }
    DAT_4201d248 = DAT_4201d248 & 0xdf;
  }
  if ((DAT_4201d248 & 8) == 0) {
    if ((DAT_4201d248 & 4) != 0) {
      pcVar2 = (chan_ctxt_tag *)0x4201d1bc;
      goto LAB_23019864;
    }
    if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
      if (1 < DAT_4201d24a) {
        chan_cde_evt((void *)0x1);
        goto LAB_2301988c;
      }
      pcVar2 = chan_ctxt_op_evt::p_chan_entry;
      if (DAT_4201d24a != 1) goto LAB_2301988c;
      goto LAB_2301986c;
    }
  }
  else {
    pcVar2 = (chan_ctxt_tag *)0x4201d1a0;
LAB_23019864:
    if (DAT_4201d1fc != (chan_ctxt_tag *)0x0) {
      DAT_4201d1fc->status = '\x01';
    }
LAB_2301986c:
    DAT_4201d1fc = pcVar2;
  }
LAB_2301988c:
  pcVar2 = DAT_4201d1fc;
  if (DAT_4201d1fc == (chan_ctxt_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  phy_set_channel((DAT_4201d1fc->channel).band,(DAT_4201d1fc->channel).type,
                  (DAT_4201d1fc->channel).prim20_freq,(DAT_4201d1fc->channel).center1_freq,
                  (DAT_4201d1fc->channel).center2_freq,'\0');
  tpc_update_tx_power((pcVar2->channel).tx_power);
  _DAT_44b000dc = 0x10;
  DAT_4201d1f8 = pcVar2;
  DAT_4201d1fc = (chan_ctxt_tag *)0x0;
  chan_upd_ctxt_status(pcVar2,'\x04');
  pcVar1 = DAT_4201d1f8;
  cVar3 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if (pcVar2->idx == '\x03') {
    _DAT_44b00220 = 0;
    ke_msg_send_basic(0x61,2,0xff);
LAB_23019986:
    if (pcVar2->idx < 3) goto LAB_23019990;
  }
  else {
    if (pcVar2->idx != '\x04') {
      if ((ps_env.ps_on == false) || ((ps_env.prevent_sleep & 8) != 0)) {
        blmac_pwr_mgt_setf('\0');
        while (cVar3 != (co_list_hdr)0x0) {
          if (((pcVar1 == (chan_ctxt_tag *)((co_list_hdr *)((int)cVar3 + 0x40))->next) &&
              (*(char *)((int)cVar3 + 0x56) == '\0')) &&
             (*(char *)&((co_list_hdr *)((int)cVar3 + 0x58))->next != '\0')) {
            txl_frame_send_null_frame
                      (*(uint8_t *)&((co_list_hdr *)((int)cVar3 + 0x60))->next,(cfm_func_ptr *)0x0,
                       (void *)0x0);
          }
          cVar3 = *(co_list_hdr *)cVar3;
        }
      }
      p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
      if (pcVar2->idx < 3) {
        while (p_vif_entry != (vif_info_tag *)0x0) {
          if (pcVar2 == p_vif_entry->chan_ctxt) {
            td_env[p_vif_entry->index].has_active_chan = true;
            vif_mgmt_send_postponed_frame(p_vif_entry);
          }
          p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
        }
        goto LAB_23019986;
      }
    }
  }
  ps_env.prevent_sleep = ps_env.prevent_sleep | 2;
  DAT_4201d24b = (byte)(_DAT_44b0004c >> 2) & 1;
  blmac_pwr_mgt_setf('\0');
LAB_23019990:
  mm_active();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_goto_idle_cb(void)

{
  undefined uVar1;
  co_list_hdr *pcVar2;
  co_list_hdr cVar3;
  uint8_t uVar4;
  undefined3 extraout_var;
  int iVar5;
  
  mm_force_idle_req();
  pcVar2 = DAT_4201d1f8;
  cVar3 = (co_list_hdr)vif_mgmt_env.used_list.first;
  if (((DAT_4201d1f8 != (co_list_hdr *)0x0) && ((DAT_4201d248 & 0x20) == 0)) &&
     ((ps_env.ps_on == false || ((ps_env.prevent_sleep & 8) != 0)))) {
    iVar5 = 0;
    blmac_pwr_mgt_setf('\x01');
    while (cVar3 != (co_list_hdr)0x0) {
      if ((((pcVar2 == ((co_list_hdr *)((int)cVar3 + 0x40))->next) &&
           (*(char *)((int)cVar3 + 0x56) == '\0')) &&
          (*(char *)&((co_list_hdr *)((int)cVar3 + 0x58))->next != '\0')) &&
         (*(char *)&((co_list_hdr *)((int)cVar3 + 0x60))->next != -1)) {
        uVar1 = *(undefined *)((int)&pcVar2[5].next + 2);
        *(undefined *)((int)&pcVar2[5].next + 2) = 6;
        uVar4 = txl_frame_send_null_frame
                          (*(uint8_t *)&((co_list_hdr *)((int)cVar3 + 0x60))->next,chan_tx_cfm,
                           (void *)0x0);
        if (CONCAT31(extraout_var,uVar4) == 0) {
          iVar5 = iVar5 + 1;
        }
        *(undefined *)((int)&pcVar2[5].next + 2) = uVar1;
      }
      cVar3 = *(co_list_hdr *)cVar3;
    }
    DAT_4201d249 = (undefined)iVar5;
    if (iVar5 != 0) {
      chan_upd_ctxt_status(DAT_4201d1fc,'\x03');
      mm_active();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  chan_pre_switch_channel();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_tx_cfm(void *dummy,uint32_t status)

{
  if (DAT_4201d249 == '\0') {
    assert_err("chan_env.cfm_cnt","module",0x48f);
  }
  DAT_4201d249 = DAT_4201d249 + -1;
  if (DAT_4201d249 == '\0') {
    mm_force_idle_req();
    chan_pre_switch_channel();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_ctxt_op_evt(void *env)

{
  byte bVar1;
  undefined4 uVar2;
  chan_ctxt_tag *p_chan_entry;
  
  bVar1 = *(byte *)((int)env + 0x16);
  if (1 < bVar1) {
    if (bVar1 < 4) {
      DAT_4201d248 = DAT_4201d248 | 0x20;
    }
    else {
      if (bVar1 == 4) {
        if (*(byte *)((int)env + 0x17) < 3) {
          *(undefined *)((int)env + 0x16) = 1;
          uVar2 = _DAT_44b00120;
          p_chan_entry = chan_ctxt_op_evt::p_chan_entry;
          if ((DAT_4201d24a != 1) && (p_chan_entry = (chan_ctxt_tag *)env, 1 < DAT_4201d24a)) {
            chan_upd_nb_rem_slots((int)env + 0x12);
            DAT_4201d244 = uVar2;
            p_chan_entry = chan_get_next_chan();
          }
        }
        else {
          ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffd;
          blmac_pwr_mgt_setf(DAT_4201d24b);
          DAT_4201d1f8 = 0;
          if (*(char *)((int)env + 0x17) == '\x03') {
            DAT_4201d248 = DAT_4201d248 & 0xf7;
            ke_msg_send_basic(0x62,2,0xff);
          }
          else {
            if (*(char *)((int)env + 0x17) == '\x04') {
              if (*(short *)((int)env + 0xe) == 0) {
                DAT_4201d248 = DAT_4201d248 & 0xbf;
              }
              DAT_4201d248 = DAT_4201d248 & 0xfb;
            }
          }
          *(undefined *)((int)env + 0x17) = 0xff;
          if ((DAT_4201d248 & 3) == 0) {
            DAT_4201d248 = DAT_4201d248 & 0xef;
          }
          else {
            chan_conn_less_delay_prog();
          }
          p_chan_entry = chan_ctxt_op_evt::p_chan_entry;
          if (DAT_4201d24a != 1) {
            if (1 < DAT_4201d24a) {
              chan_cde_evt((void *)0x0);
              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
              return;
            }
            mm_force_idle_req();
            mm_back_to_host_idle();
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return;
          }
        }
        chan_switch_start(p_chan_entry);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_init(void)

{
  chan_ctxt_tag *list_hdr;
  int iVar1;
  
  list_hdr = chan_ctxt_pool;
  memset(&chan_env,0,0x74);
  iVar1 = 0;
  do {
    memset(list_hdr,0,0x1c);
    *(undefined2 *)(&list_hdr->channel + 1) = 0xff;
    *(undefined *)((int)&list_hdr->nb_res_slots + 3) = 0xff;
    if (iVar1 < 3) {
      co_list_push_back((co_list *)&chan_env,(co_list_hdr *)list_hdr);
    }
    else {
      if (iVar1 == 3) {
        chan_ctxt_pool[3].channel.center2_freq = 0;
        chan_ctxt_pool[3].channel.type = '\0';
      }
    }
    iVar1 = iVar1 + 1;
    list_hdr = list_hdr + 1;
  } while (iVar1 != 5);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  DAT_4201d204 = chan_tbtt_switch_evt;
  DAT_4201d214 = chan_cde_evt;
  DAT_4201d218 = 0;
  DAT_4201d224 = chan_ctxt_op_evt;
  DAT_4201d234 = chan_conn_less_delay_evt;
  return;
}



void chan_scan_req(uint8_t band,uint16_t freq,int8_t pwr,uint32_t duration_us,uint8_t vif_index)

{
  if (chan_ctxt_pool[3].idx != -1) {
    assert_err("p_scan_chan->idx == CHAN_CTXT_UNUSED","module",0x8a1);
  }
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].nb_rem_slots = (uint16_t)(duration_us >> 10);
  if ((DAT_4201d248 & 0x10) == 0) {
    chan_ctxt_pool[3].channel.band = band;
    chan_ctxt_pool[3].channel.prim20_freq = freq;
    chan_ctxt_pool[3].channel.center1_freq = freq;
    chan_ctxt_pool[3].channel.tx_power = pwr;
    chan_ctxt_pool[3].vif_index = vif_index;
    DAT_4201d248 = DAT_4201d248 | 2;
    chan_conn_less_delay_prog();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  chan_ctxt_pool[3].channel.band = band;
  chan_ctxt_pool[3].channel.prim20_freq = freq;
  chan_ctxt_pool[3].channel.center1_freq = freq;
  chan_ctxt_pool[3].channel.tx_power = pwr;
  chan_ctxt_pool[3].taskid = 0xff;
  chan_ctxt_pool[3]._22_2_ = 0x301;
  chan_ctxt_pool[3].vif_index = vif_index;
  DAT_4201d248 = DAT_4201d248 | 2;
  return;
}



uint8_t chan_roc_req(mm_remain_on_channel_req *req,ke_task_id_t taskid)

{
  byte bVar1;
  byte bVar2;
  undefined2 in_register_0000202e;
  byte bVar3;
  
  if (req->op_code == '\0') {
    if (chan_ctxt_pool[4].idx == -1) {
      chan_ctxt_pool[4].idx = '\x04';
      chan_ctxt_pool[4].channel.band = req->band;
      chan_ctxt_pool[4].channel.type = req->type;
      chan_ctxt_pool[4].channel.prim20_freq = req->prim20_freq;
      chan_ctxt_pool[4].channel.center1_freq = req->center1_freq;
      chan_ctxt_pool[4].channel.center2_freq = req->center2_freq;
      chan_ctxt_pool[4].status = '\x01';
      chan_ctxt_pool[4].nb_rem_slots = (uint16_t)(req->duration_ms * 1000 >> 10);
      chan_ctxt_pool[4].vif_index = req->vif_index;
      chan_ctxt_pool[4].channel.tx_power = req->tx_power;
      chan_ctxt_pool[4].taskid = taskid;
      if (CONCAT22(in_register_0000202e,taskid) == 0) {
        DAT_4201d248 = DAT_4201d248 | 4;
        if (DAT_4201d1fc == 0) {
          chan_switch_start(chan_ctxt_pool + 4);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
      }
      else {
        bVar3 = DAT_4201d248 | 1;
        bVar1 = DAT_4201d248 & 0x10;
        bVar2 = DAT_4201d248 & 0x10;
        DAT_4201d248 = bVar3;
        if (bVar1 == 0) {
          chan_conn_less_delay_prog();
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return bVar2;
        }
      }
      goto LAB_23019e82;
    }
  }
  else {
    if (req->op_code == '\x01') {
      if (chan_ctxt_pool[4].idx != -1) {
        if (chan_ctxt_pool[4].status < 4) {
          if (chan_ctxt_pool[4].status < 2) {
            if (chan_ctxt_pool[4].status == '\x01') {
              DAT_4201d248 = DAT_4201d248 & 0xfe;
            }
          }
          else {
            DAT_4201d1fc = 0;
            DAT_4201d248 = DAT_4201d248 & 0xfb;
          }
        }
        else {
          if (chan_ctxt_pool[4].status == '\x04') {
            mm_timer_clear((mm_timer_tag *)&DAT_4201d220);
            chan_ctxt_op_evt(chan_ctxt_pool + 4);
          }
        }
        chan_ctxt_pool[4].idx = -1;
        if ((DAT_4201d248 & 0x12) == 0x10) {
          DAT_4201d248 = DAT_4201d248 & 0xef;
          mm_timer_clear((mm_timer_tag *)&DAT_4201d230);
          DAT_4201d248 = DAT_4201d248 & 0xef;
        }
      }
LAB_23019e82:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)1;
}



uint8_t chan_ctxt_add(mm_chan_ctxt_add_req *p_add_req,uint8_t *idx)

{
  uint8_t uVar1;
  int iVar2;
  co_list_hdr *pcVar3;
  int iVar4;
  chan_ctxt_tag *pcVar5;
  
  pcVar5 = chan_ctxt_pool;
  iVar4 = 0;
  while ((pcVar5->idx == -1 || (iVar2 = memcmp(p_add_req,&pcVar5->channel,8), iVar2 != 0))) {
    iVar4 = iVar4 + 1;
    pcVar5 = pcVar5 + 1;
    if (iVar4 == 3) {
      pcVar3 = co_list_pop_front((co_list *)&chan_env);
      iVar2 = 1;
      if (pcVar3 != (co_list_hdr *)0x0) {
        uVar1 = (char)((int)(pcVar3 + -0x10807453) >> 2) * -0x49;
        iVar2 = 0;
        *(uint8_t *)((int)&pcVar3[5].next + 3) = uVar1;
        *idx = uVar1;
        *(uint8_t *)&pcVar3[1].next = p_add_req->band;
        *(uint8_t *)((int)&pcVar3[1].next + 1) = p_add_req->type;
        *(uint16_t *)&pcVar3[2].next = p_add_req->center1_freq;
        *(uint16_t *)((int)&pcVar3[2].next + 2) = p_add_req->center2_freq;
        *(uint16_t *)((int)&pcVar3[1].next + 2) = p_add_req->prim20_freq;
        *(int8_t *)&pcVar3[3].next = p_add_req->tx_power;
      }
LAB_23019f9a:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (uint8_t)iVar2;
    }
  }
  *idx = (uint8_t)iVar4;
  goto LAB_23019f9a;
}



void chan_ctxt_del(uint8_t chan_idx)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,chan_idx);
  if (chan_ctxt_pool[iVar1].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x989);
  }
  if (chan_ctxt_pool[iVar1].nb_linked_vif != '\0') {
    assert_err("p_chan_entry->nb_linked_vif == 0","module",0x98b);
  }
  co_list_push_back((co_list *)&chan_env,(co_list_hdr *)(chan_ctxt_pool + iVar1));
  memset(chan_ctxt_pool + iVar1,0,0x1c);
  chan_ctxt_pool[iVar1].taskid = 0xff;
  chan_ctxt_pool[iVar1].idx = -1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_ctxt_update(mm_chan_ctxt_update_req *p_upd_req)

{
  chan_ctxt_tag *pcVar1;
  uint uVar2;
  
  uVar2 = (uint)p_upd_req->chan_index;
  chan_ctxt_pool[uVar2].channel.band = p_upd_req->band;
  chan_ctxt_pool[uVar2].channel.type = p_upd_req->type;
  chan_ctxt_pool[uVar2].channel.center1_freq = p_upd_req->center1_freq;
  chan_ctxt_pool[uVar2].channel.center2_freq = p_upd_req->center2_freq;
  chan_ctxt_pool[uVar2].channel.prim20_freq = p_upd_req->prim20_freq;
  chan_ctxt_pool[uVar2].channel.tx_power = p_upd_req->tx_power;
  pcVar1 = DAT_4201d1f8;
  if (DAT_4201d1f8 != chan_ctxt_pool + uVar2) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  rxl_timer_int_handler();
  rxl_cntrl_evt(0);
  phy_set_channel(p_upd_req->band,p_upd_req->type,p_upd_req->prim20_freq,p_upd_req->center1_freq,
                  p_upd_req->center2_freq,'\0');
  tpc_update_tx_power((pcVar1->channel).tx_power);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_tbtt_switch_update(vif_info_tag *p_vif_entry,uint32_t tbtt_time)

{
  if ((((p_vif_entry->chan_ctxt != (chan_ctxt_tag *)0x0) && (p_vif_entry->chan_ctxt->status != '\0')
       ) && ((p_vif_entry->tbtt_switch).time != tbtt_time - 0x9c4)) &&
     (((p_vif_entry->tbtt_switch).time = tbtt_time - 0x9c4, 1 < DAT_4201d24a &&
      ((p_vif_entry->tbtt_switch).status != '\x02')))) {
    (p_vif_entry->tbtt_switch).status = '\0';
    co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    chan_tbtt_schedule(&p_vif_entry->tbtt_switch);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void chan_bcn_to_evt(vif_info_tag *p_vif_entry)

{
  ushort uVar1;
  int iVar2;
  chan_ctxt_tag *pcVar3;
  ushort uVar4;
  uint uVar5;
  
  iVar2 = _DAT_44b00120;
  if ((p_vif_entry->tbtt_switch).status == '\x02') {
    (p_vif_entry->tbtt_switch).status = '\0';
    pcVar3 = DAT_4201d1f8;
    co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&p_vif_entry->tbtt_switch);
    if (((1 < DAT_4201d24a) &&
        (chan_tbtt_schedule(&p_vif_entry->tbtt_switch), (DAT_4201d248 & 0xc) == 0)) &&
       (DAT_4201d1fc == 0)) {
      chan_upd_nb_rem_slots((uint32_t)&pcVar3->nb_rem_slots);
      uVar1 = pcVar3->nb_res_slots;
      if (uVar1 != 0) {
        uVar5 = (uint)(iVar2 - DAT_4201d244) >> 10 & 0xffff;
        uVar4 = (ushort)uVar5;
        if (uVar1 < uVar5) {
          uVar4 = uVar1;
        }
        pcVar3->nb_res_slots = uVar1 - uVar4;
      }
      DAT_4201d244 = iVar2;
      pcVar3 = chan_get_next_chan();
      if (DAT_4201d1f8 != pcVar3) {
        chan_switch_start(pcVar3);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_bcn_detect_start(vif_info_tag *p_vif_entry)

{
  byte bVar1;
  chan_ctxt_tag *pcVar2;
  undefined *puVar3;
  
  pcVar2 = p_vif_entry->chan_ctxt;
  if (pcVar2 == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry","module",0xb19);
  }
  if (((DAT_4201d248 & 0x40) == 0) && (1 < DAT_4201d24a)) {
    bVar1 = *(byte *)&(p_vif_entry->u).field_0x4;
    puVar3 = (undefined *)ke_msg_alloc(0x46,0,0,0x14);
    *puVar3 = 0;
    puVar3[1] = p_vif_entry->index;
    puVar3[2] = (pcVar2->channel).band;
    puVar3[3] = (pcVar2->channel).type;
    *(uint16_t *)(puVar3 + 4) = (pcVar2->channel).prim20_freq;
    *(uint16_t *)(puVar3 + 6) = (pcVar2->channel).center1_freq;
    *(uint16_t *)(puVar3 + 8) = (pcVar2->channel).center2_freq;
    *(uint *)(puVar3 + 0xc) = (sta_info_tab[bVar1].bcn_int - 5000) / 1000;
    puVar3[0x10] = (pcVar2->channel).tx_power;
    ke_msg_send(puVar3);
    DAT_4201d248 = DAT_4201d248 | 0x40;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool chan_is_on_channel(vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  
  if (DAT_4201d1f8 != 0) {
    if (*(byte *)(DAT_4201d1f8 + 0x17) < 3) {
      pcVar1 = (chan_ctxt_tag *)((int)p_vif_entry->chan_ctxt - DAT_4201d1f8);
    }
    else {
      pcVar1 = (chan_ctxt_tag *)((uint)*(byte *)(DAT_4201d1f8 + 0x19) - (uint)p_vif_entry->index);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)(pcVar1 == (chan_ctxt_tag *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool chan_is_tx_allowed(vif_info_tag *p_vif_entry)

{
  _Bool _Var1;
  undefined3 extraout_var;
  uint uVar2;
  
  _Var1 = chan_is_on_channel(p_vif_entry);
  uVar2 = CONCAT31(extraout_var,_Var1);
  if ((uVar2 != 0) && (DAT_4201d1fc != 0)) {
    uVar2 = (uint)(*(char *)(DAT_4201d1f8 + 0x16) == '\x06');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUB41(uVar2,0);
}



_Bool chan_is_on_operational_channel(vif_info_tag *p_vif_entry)

{
  bool bVar1;
  
  bVar1 = false;
  if ((DAT_4201d1f8 != (chan_ctxt_tag *)0x0) && (bVar1 = false, DAT_4201d1f8->idx < 3)) {
    bVar1 = p_vif_entry->chan_ctxt == DAT_4201d1f8;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)bVar1;
}



void chan_update_tx_power(chan_ctxt_tag *p_chan_entry)

{
  uint uVar1;
  uint uVar2;
  int8_t iVar3;
  uint uVar4;
  
  if (p_chan_entry->nb_linked_vif == '\0') goto LAB_2301a43e;
  uVar4 = 0x7f;
  if (p_chan_entry == vif_info_tab[0].chan_ctxt) {
    iVar3 = vif_info_tab[0].user_tx_power;
    if (vif_info_tab[0].tx_power < vif_info_tab[0].user_tx_power) {
      iVar3 = vif_info_tab[0].tx_power;
    }
    uVar4 = SEXT14(iVar3);
  }
  if (p_chan_entry == vif_info_tab[1].chan_ctxt) {
    uVar1 = (uint)(byte)vif_info_tab[1].user_tx_power;
    if ((int)uVar4 < (int)vif_info_tab[1].user_tx_power) {
      uVar1 = uVar4;
    }
    uVar2 = SEXT14(vif_info_tab[1].tx_power);
    uVar4 = (int)(char)uVar1;
    if ((int)(char)uVar1 <= (int)uVar2) goto LAB_2301a42e;
  }
  else {
LAB_2301a42e:
    uVar2 = uVar4;
    if (uVar2 == 0x7f) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  (p_chan_entry->channel).tx_power = (int8_t)uVar2;
LAB_2301a43e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_ctxt_link(uint8_t vif_idx,uint8_t chan_idx)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar2;
  chan_ctxt_tag *p_chan_entry;
  
  iVar2 = CONCAT31(in_register_0000202d,chan_idx);
  p_chan_entry = chan_ctxt_pool + iVar2;
  if (vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt != (chan_ctxt_tag *)0x0) {
    assert_err("p_vif_entry->chan_ctxt == NULL","module",0x99c);
  }
  if (chan_ctxt_pool[iVar2].idx == -1) {
    assert_err("p_chan_entry->idx != CHAN_CTXT_UNUSED","module",0x99d);
  }
  uVar1 = chan_ctxt_pool[iVar2].nb_linked_vif + '\x01';
  DAT_4201d240 = DAT_4201d240 + 0xc800;
  vif_info_tab[CONCAT31(in_register_00002029,vif_idx)].chan_ctxt = p_chan_entry;
  chan_ctxt_pool[iVar2].nb_linked_vif = uVar1;
  if (uVar1 == '\x01') {
    chan_ctxt_pool[iVar2].status = '\x01';
    DAT_4201d24a = DAT_4201d24a + '\x01';
    co_list_push_back((co_list *)&chan_ctxt_op_evt::p_chan_entry,(co_list_hdr *)p_chan_entry);
    if (DAT_4201d1fc == 0) {
      if ((DAT_4201d248 & 0xc) == 0) {
        if (DAT_4201d24a == '\x01') {
          chan_switch_start(p_chan_entry);
        }
        else {
          chan_cde_evt((void *)0x0);
        }
      }
    }
    else {
      *(undefined *)(DAT_4201d1fc + 0x16) = 1;
      DAT_4201d1fc = 0;
    }
  }
  chan_update_tx_power(p_chan_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void chan_ctxt_unlink(uint8_t vif_idx)

{
  chan_ctxt_tag *pcVar1;
  chan_ctxt_tag *p_chan_entry;
  undefined3 in_register_00002029;
  int iVar2;
  
  iVar2 = CONCAT31(in_register_00002029,vif_idx);
  p_chan_entry = vif_info_tab[iVar2].chan_ctxt;
  if (p_chan_entry == (chan_ctxt_tag *)0x0) {
    assert_err("p_chan_entry != NULL","module",0x9e4);
  }
  co_list_extract((co_list *)&DAT_4201d1e8,(co_list_hdr *)&vif_info_tab[iVar2].tbtt_switch);
  vif_info_tab[iVar2].tbtt_switch.status = '\0';
  vif_info_tab[iVar2].chan_ctxt = (chan_ctxt_tag *)0x0;
  p_chan_entry->nb_linked_vif = p_chan_entry->nb_linked_vif + -1;
  pcVar1 = DAT_4201d1fc;
  if (p_chan_entry->status != '\0') {
    DAT_4201d240 = DAT_4201d240 + -0xc800;
    if (p_chan_entry->nb_linked_vif != '\0') goto LAB_2301a656;
    co_list_extract((co_list *)&chan_ctxt_op_evt::p_chan_entry,(co_list_hdr *)p_chan_entry);
    p_chan_entry->status = '\0';
    DAT_4201d24a = DAT_4201d24a - 1;
    if (DAT_4201d1f8 == p_chan_entry) {
      DAT_4201d1f8 = (chan_ctxt_tag *)0x0;
LAB_2301a622:
      if (pcVar1 == (chan_ctxt_tag *)0x0) {
        if (DAT_4201d24a < 2) {
          if (DAT_4201d24a == 1) {
            chan_switch_start(chan_ctxt_op_evt::p_chan_entry);
          }
        }
        else {
          chan_cde_evt((void *)0x0);
        }
        goto LAB_2301a648;
      }
    }
    else {
      if (pcVar1 != p_chan_entry) goto LAB_2301a622;
      DAT_4201d1fc = (chan_ctxt_tag *)0x0;
    }
    DAT_4201d248 = DAT_4201d248 | 0x20;
  }
LAB_2301a648:
  if (p_chan_entry->nb_linked_vif == '\0') {
    chan_ctxt_del(p_chan_entry->idx);
  }
LAB_2301a656:
  chan_tbtt_schedule((chan_tbtt_tag *)0x0);
  chan_update_tx_power(p_chan_entry);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_dma_init(void)

{
  co_list_init((co_list *)&hal_dma_env);
  hal_dma_env.lli_cnt[0] = (uint16_t)_DAT_44a000a4;
  co_list_init(hal_dma_env.prog + 1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  hal_dma_env.lli_cnt[1] = (uint16_t)_DAT_44a000ac;
  return;
}



void hal_dma_push(hal_dma_desc_tag *desc,int type)

{
  dma_desc *pdVar1;
  evt_field_t event;
  
  pdVar1 = desc->dma_desc;
  if (desc->cb == (cb_dma_func_ptr *)0x0) {
    pdVar1->ctrl = 0;
  }
  else {
    pdVar1->ctrl = (ushort)"\t\v"[type] << 8 | "\t\v"[type] | 0x10 | 0x1000;
    co_list_push_back(hal_dma_env.prog + type,(co_list_hdr *)desc);
  }
  memcpy((void *)pdVar1->dest,(void *)pdVar1->src,(uint)pdVar1->length);
  if (type == 0) {
    event = 0x40;
  }
  else {
    if (type != 1) {
      do {
        vTaskDelay(1000);
        puts("[FW] Dead loop when using dma push\r\n");
      } while( true );
    }
    event = 0x10000000;
  }
  ke_evt_set(event);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void hal_dma_evt(int dma_queue)

{
  evt_field_t event;
  co_list_hdr *pcVar1;
  
  if (dma_queue == 0) {
    event = 0x40;
  }
  else {
    event = 0x10000000;
  }
  ke_evt_clear(event);
  while (pcVar1 = co_list_pop_front(hal_dma_env.prog + dma_queue), pcVar1 != (co_list_hdr *)0x0) {
    if (pcVar1[2].next != (co_list_hdr *)0x0) {
      (*(code *)pcVar1[2].next)(pcVar1[3].next,dma_queue);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t blmac_soft_reset_getf(void)

{
  uint uVar1;
  
  uVar1 = _DAT_44b08050;
  if ((_DAT_44b08050 & 0xfffffffe) != 0) {
    assert_err("(localVal & ~((uint32_t)0x00000001)) == 0","module",0x11d);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_wt_2_crypt_clk_ratio_setf(uint8_t wt2cryptclkratio)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b000f0 = CONCAT31(in_register_00002029,wt2cryptclkratio) | _DAT_44b000f0 & 0xfffffffc;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_rx_flow_cntrl_en_setf(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b00054 = _DAT_44b00054 & 0xfffeffff | 0x10000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void blmac_key_sto_ram_reset_setf(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = _DAT_44b0004c & 0xffffdfff | 0x2000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_idle_req(void)

{
  if ((_DAT_44b00038 & 0xf) != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    ps_env.prevent_sleep = ps_env.prevent_sleep | 4;
    _DAT_44b00038 = 0;
    _DAT_44b0013c = _DAT_44b00120 + 50000;
    _DAT_44b08088 = 0x20;
    _DAT_44b0808c = _DAT_44b0808c | 0x20;
    return;
  }
  assert_rec("blmac_current_state_getf() != HW_IDLE","module",0xe1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_stop(void)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  _DAT_44b08050 = 1;
  do {
    uVar1 = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,uVar1) != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_init(void)

{
  uint uVar1;
  uint8_t uVar2;
  byte bVar3;
  undefined3 extraout_var;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  undefined3 extraout_var_00;
  
  _DAT_44b08050 = 1;
  do {
    uVar2 = blmac_soft_reset_getf();
  } while (CONCAT31(extraout_var,uVar2) != 0);
  _DAT_44b00404 = 0x24f637;
  _DAT_44b00400 = 0x49;
  _DAT_44920004 = 0x5010001f;
  uVar2 = phy_get_mac_freq();
  uVar4 = CONCAT31(extraout_var_00,uVar2);
  uVar1 = _DAT_44b000e4 & 0xff;
  uVar5 = _DAT_44b000e4 & 0xffffff00 | 0x28;
  uVar6 = (((_DAT_44b000e4 & 0x3ff00) >> 8) * uVar4) / uVar1 << 8;
  _DAT_44b000e4 = uVar5;
  if ((uVar6 & 0xfc0000) != 0) {
    assert_err("(((uint32_t)txrfdelayinmacclk << 8) & ~((uint32_t)0x0003FF00)) == 0","module",0x1d59
              );
  }
  _DAT_44b000e4 = (_DAT_44b000e4 & 0xfffc00ff | uVar6 & 0xffff00) & 0xf003ffff | 0x2200000;
  _DAT_44b000e8 =
       (((_DAT_44b000e8 >> 8 & 0xffff) * uVar4) / uVar1 & 0xffff) << 8 | _DAT_44b000e8 & 0xff0000ff;
  uVar5 = _DAT_44b000ec & 0xc00fffff | 0x2700000;
  uVar6 = (((_DAT_44b000ec & 0xffc00) >> 10) * uVar4) / uVar1 << 10;
  _DAT_44b000ec = uVar5;
  if ((uVar6 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)txdelayrfoninmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",
               0x1ea2);
  }
  uVar2 = '\x03';
  _DAT_44b000ec = _DAT_44b000ec & 0xfff00000 | uVar6 & 0x3fffc00 | 0xb4;
  if ((0x1d < uVar4) && (uVar2 = '\x02', 0x3b < uVar4)) {
    uVar2 = '\x01';
  }
  blmac_wt_2_crypt_clk_ratio_setf(uVar2);
  _DAT_44b000f4 =
       (((_DAT_44b000f4 >> 8 & 0xffff) * uVar4) / uVar1 & 0xffff) << 8 | _DAT_44b000f4 & 0xff0000ff;
  _DAT_44b000f8 =
       (((_DAT_44b000f8 >> 8 & 0xffff) * uVar4) / uVar1 & 0xffff) << 8 | _DAT_44b000f8 & 0xff0000ff;
  uVar5 = ((_DAT_44b00104 >> 0x14 & 0x3ff) * uVar4) / uVar1 << 0x14;
  if ((uVar5 & 0xc0000000) != 0) {
    assert_err("(((uint32_t)rifstoinmacclk << 20) & ~((uint32_t)0x3FF00000)) == 0","module",0x228a);
  }
  uVar5 = _DAT_44b00104 & 0xc00fffff | uVar5;
  uVar6 = (((_DAT_44b00104 & 0xffc00) >> 10) * uVar4) / uVar1 << 10;
  _DAT_44b00104 = uVar5;
  if ((uVar6 & 0x3f00000) != 0) {
    assert_err("(((uint32_t)rifsinmacclk << 10) & ~((uint32_t)0x000FFC00)) == 0","module",0x22a4);
  }
  uVar5 = _DAT_44b00104 & 0xfff003ff | uVar6 & 0x3fffc00;
  uVar1 = ((_DAT_44b00104 & 0x3ff) * uVar4) / uVar1;
  _DAT_44b00104 = uVar5;
  if ((uVar1 & 0xfc00) != 0) {
    assert_err("(((uint32_t)txdmaprocdlyinmacclk << 0) & ~((uint32_t)0x000003FF)) == 0","module",
               0x22be);
  }
  _DAT_44b00104 = _DAT_44b00104 & 0xfffffc00 | uVar1 & 0xffff;
  _DAT_44b08074 = 0x8373f14c;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffff7ff;
  if (_DAT_44b000d8 >> 0x18 < 0x11) {
    assert_err("MM_STA_TO_KEY(NX_REMOTE_STA_MAX - 1) <= blmac_sta_key_max_index_getf()","module",
               0x124);
  }
  printf("[WF] [KEY] [CFG] nVAP is %d, endidx %d, startidx %d\r\n",2,0x11,8);
  _DAT_44b000d8 = 0x21108;
  _DAT_44b08080 = 0x800a07c0;
  _DAT_44b0004c = _DAT_44b0004c | 0x4000780;
  blmac_rx_flow_cntrl_en_setf();
  _DAT_44b00060 = 0x7fffffde;
  _DAT_44b00114 = 0x3010a;
  _DAT_44b00064 = 0xff900064;
  _DAT_44b00150 = 0x1000;
  _DAT_44b00224 = 0;
  _DAT_44b000a0 = 0x2020;
  _DAT_44b0004c = _DAT_44b0004c & 0xffffefff | 0x1000;
  blmac_key_sto_ram_reset_setf();
  _DAT_44b00510 = 0x1c25;
  _DAT_44b00310 = _DAT_44b00310 | 0x80;
  bVar3 = phy_get_ntx();
  uVar1 = (bVar3 + 1) * 0x4000000;
  if ((uVar1 & 0xe0000000) != 0) {
    assert_err("(((uint32_t)maxphyntx << 26) & ~((uint32_t)0x1C000000)) == 0","module",0x1539);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = _DAT_44b0004c & 0xfdffffff | 0x2000000;
  _DAT_44b0009c = _DAT_44b0009c & 0xe3ffffff | uVar1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_disable_int(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_reset(void)

{
  if ((_DAT_44b00038 & 0xf) != 0) {
    helper_record_all_states("hal_machw_reset");
  }
  _DAT_44b0004c = _DAT_44b0004c & 0xffffff7f;
  _DAT_44b00038 = 0;
  _DAT_44b00054 = 0x7c;
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
  blmac_rx_flow_cntrl_en_setf();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44b0004c = _DAT_44b0004c | 0x80;
  _DAT_44b08070 = 0x37ff187;
  _DAT_44b08074 = _DAT_44b08074 & 0x7fffffff | 0x80000000;
  _DAT_44b0807c = 0xffffffff;
  _DAT_44b08080 = _DAT_44b08080 & 0x7fffffff | 0x80000000;
  _DAT_44b0808c = _DAT_44b0808c & 0xffffffc0;
  return;
}



// WARNING: Removing unreachable block (ram,0x2301adcc)
// WARNING: Removing unreachable block (ram,0x2301add8)
// WARNING: Removing unreachable block (ram,0x2301ade2)

uint8_t hal_machw_search_addr(mac_addr *addr)

{
                    // WARNING: Do nothing block with infinite loop
  do {
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_monitor_mode(void)

{
  _DAT_44b08074 = _DAT_44b08074 & 0xfffffffc;
  mm_env.rx_filter_umac = 0x7fffffde;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | 0x7fffffde;
  _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | 0xc700;
  blmac_key_sto_ram_reset_setf();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

_Bool hal_machw_sleep_check(void)

{
  uint uVar1;
  
  uVar1 = 0;
  while (((1 << (uVar1 & 0x1f) & _DAT_44b0808c) == 0 ||
         (-1 < (-2000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)))) {
    uVar1 = uVar1 + 1;
    if (uVar1 == 9) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return true;
    }
  }
  if (-1 < (5000 - _DAT_44b00120) + *(int *)(&DAT_44b00128 + uVar1 * 4)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  assert_err("!hal_machw_time_past(blmac_abs_timer_get(i) + 5000)","module",0x208);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_machw_gen_handler(void)

{
  uint uVar1;
  uint uVar2;
  char *pcVar3;
  int iVar4;
  
  uVar2 = _DAT_44b08074 & _DAT_44b0806c;
  _DAT_44b08070 = uVar2;
  if ((uVar2 & 0x40001) != 0) {
    ke_evt_set(0x400000);
  }
  if ((uVar2 & 0x80002) != 0) {
    ke_evt_set(0x200000);
  }
  if ((uVar2 & 4) != 0) {
    if ((_DAT_44b00038 & 0xf) == 0) {
      _DAT_44b0808c = _DAT_44b0808c & 0xffffffdf;
      ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffb;
      ke_evt_set(0x800000);
    }
    else {
      assert_rec("blmac_current_state_getf() == HW_IDLE","module",0x8c);
    }
  }
  uVar1 = _DAT_44b08084;
  if ((uVar2 & 8) != 0) {
    _DAT_44b08088 = _DAT_44b08084;
    if ((_DAT_44b08084 & 0x100) != 0) {
      ke_evt_set(0x4000000);
    }
    if ((uVar1 & 0x40) != 0) {
      rxl_timeout_int_handler();
    }
    if ((uVar1 & 0x80) != 0) {
      ke_evt_set(0x8000000);
    }
    if ((uVar1 & 1) != 0) {
      assert_rec("HAL_AC0_TIMER_BIT timeout ","module",0x22f);
    }
    if ((uVar1 & 2) == 0) {
      if ((uVar1 & 4) == 0) {
        if ((uVar1 & 8) == 0) {
          if ((uVar1 & 0x10) == 0) {
            if ((uVar1 & 0x20) == 0) goto LAB_2301af80;
            iVar4 = 0x236;
            pcVar3 = "!(timer_pending & HAL_IDLE_TIMER_BIT)";
          }
          else {
            iVar4 = 0x235;
            pcVar3 = "!(timer_pending & HAL_BCN_TIMER_BIT)";
          }
        }
        else {
          iVar4 = 0x234;
          pcVar3 = "!(timer_pending & HAL_AC3_TIMER_BIT)";
        }
      }
      else {
        iVar4 = 0x233;
        pcVar3 = "!(timer_pending & HAL_AC2_TIMER_BIT)";
      }
    }
    else {
      iVar4 = 0x232;
      pcVar3 = "!(timer_pending & HAL_AC1_TIMER_BIT)";
    }
    assert_rec(pcVar3,"module",iVar4);
  }
LAB_2301af80:
  if ((uVar2 & 0x80) == 0) {
    if ((uVar2 & 0x100) == 0) {
      if ((int)(uVar2 << 0x13) < 0) {
        iVar4 = 0x27a;
        pcVar3 = "!(genirq_pending & NXMAC_PT_ERROR_BIT)";
      }
      else {
        if ((int)(uVar2 << 0x12) < 0) {
          iVar4 = 0x27b;
          pcVar3 = "!(genirq_pending & NXMAC_AC_0_TX_DMA_DEAD_BIT)";
        }
        else {
          if ((int)(uVar2 << 0x11) < 0) {
            iVar4 = 0x27c;
            pcVar3 = "!(genirq_pending & NXMAC_AC_1_TX_DMA_DEAD_BIT)";
          }
          else {
            if ((int)(uVar2 << 0x10) < 0) {
              iVar4 = 0x27d;
              pcVar3 = "!(genirq_pending & NXMAC_AC_2_TX_DMA_DEAD_BIT)";
            }
            else {
              if ((int)(uVar2 << 0xf) < 0) {
                iVar4 = 0x27e;
                pcVar3 = "!(genirq_pending & NXMAC_AC_3_TX_DMA_DEAD_BIT)";
              }
              else {
                if ((int)(uVar2 << 0xe) < 0) {
                  iVar4 = 0x27f;
                  pcVar3 = "!(genirq_pending & NXMAC_BCN_TX_DMA_DEAD_BIT)";
                }
                else {
                  if ((int)(uVar2 << 10) < 0) {
                    iVar4 = 0x280;
                    pcVar3 = "!(genirq_pending & NXMAC_MAC_PHYIF_UNDER_RUN_BIT)";
                  }
                  else {
                    if ((int)(uVar2 << 9) < 0) {
                      iVar4 = 0x281;
                      pcVar3 = "!(genirq_pending & NXMAC_PHY_ERR_BIT)";
                    }
                    else {
                      if ((int)(uVar2 << 7) < 0) {
                        iVar4 = 0x282;
                        pcVar3 = "!(genirq_pending & NXMAC_RX_HEADER_DMA_DEAD_BIT)";
                      }
                      else {
                        if ((int)(uVar2 << 6) < 0) {
                          iVar4 = 0x283;
                          pcVar3 = "!(genirq_pending & NXMAC_RX_PAYLOAD_DMA_DEAD_BIT)";
                        }
                        else {
                          if (-1 < (int)(uVar2 << 0xb)) {
                            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                            return;
                          }
                          iVar4 = 0x284;
                          pcVar3 = "!(genirq_pending & NXMAC_HW_ERR_BIT)";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      iVar4 = 0x279;
      pcVar3 = "!(genirq_pending & NXMAC_RX_FIFO_OVER_FLOW_BIT)";
    }
  }
  else {
    iVar4 = 0x278;
    pcVar3 = "!(genirq_pending & NXMAC_RX_DMA_EMPTY_BIT)";
  }
  assert_rec(pcVar3,"module",iVar4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void hal_mib_dump(void)

{
  puts("---------- hal_mib_dump ----------\r\n");
  printf("machw_mib nx_rd_fifo_overflow_count is %u\r\n");
  puts("\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mm_monitor_channel_req_handler
              (ke_msg_id_t msgid,mm_monitor_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint16_t prim20_freq;
  undefined4 *puVar1;
  uint32_t uVar2;
  uint16_t center1_freq;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5f,src_id,dest_id,0x28);
  center1_freq = (uint16_t)param->freq;
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  uVar2 = param->freq;
  puVar1[1] = uVar2;
  prim20_freq = (uint16_t)uVar2;
  if ((param->use_40Mhz != 0) && (center1_freq = prim20_freq + 10, param->higher_band == 0)) {
    center1_freq = prim20_freq - 10;
  }
  phy_set_channel('\0',param->use_40Mhz != 0,prim20_freq,center1_freq,0,'\0');
  *puVar1 = 0;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_monitor_enable_req_handler
              (ke_msg_id_t msgid,mm_monitor_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  undefined local_50 [4];
  phy_cfg_tag config;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x5d,src_id,dest_id,0x28);
  *puVar1 = 1;
  puVar1[3] = 0x11111111;
  puVar1[4] = 0x22222222;
  puVar1[5] = 0x33333333;
  puVar1[6] = 0x44444444;
  puVar1[7] = 0x55555555;
  puVar1[8] = 0x66666666;
  puVar1[2] = 0;
  puVar1[9] = 0x77777777;
  puVar1[1] = param->enable;
  memset(local_50,0,0x40);
  local_50 = 0;
  phy_init((phy_cfg_tag *)local_50);
  phy_set_channel('\0','\0',0x985,0x985,0,'\0');
  mm_active();
  *puVar1 = 0;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_cfg_rssi_req_handler
              (ke_msg_id_t msgid,mm_cfg_rssi_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint uVar2;
  
  uVar2 = (uint)param->vif_index;
  if (vif_info_tab[uVar2].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x8fe);
  }
  *(int8_t *)&vif_info_tab[uVar2].u.field_0x1a = param->rssi_thold;
  uVar1 = param->rssi_hyst;
  *(undefined *)&vif_info_tab[uVar2].u.field_0x1c = 0;
  *(uint8_t *)&vif_info_tab[uVar2].u.field_0x1b = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_set_ps_options_req_handler
              (ke_msg_id_t msgid,mm_set_ps_options_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint uVar1;
  
  uVar1 = (uint)param->vif_index;
  if (vif_info_tab[uVar1].type != '\0') {
    assert_err("vif_entry->type == VIF_STA","module",0x815);
  }
  *(uint16_t *)&vif_info_tab[uVar1].u = param->listen_interval;
  *(_Bool *)&vif_info_tab[uVar1].u.field_0x2 = param->dont_listen_bc_mc;
  ke_msg_send_basic(0x4c,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_tim_update_req_handler
              (ke_msg_id_t msgid,mm_tim_update_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_tim_update(param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



int mm_bcn_change_req_handler
              (ke_msg_id_t msgid,mm_bcn_change_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_bcn_change(param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



int mm_remain_on_channel_req_handler
              (ke_msg_id_t msgid,mm_remain_on_channel_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t uVar2;
  uint8_t *puVar3;
  undefined2 in_register_00002036;
  
  uVar2 = chan_roc_req(param,src_id);
  if (CONCAT22(in_register_00002036,src_id) != 0) {
    puVar3 = (uint8_t *)ke_msg_alloc(0x47,src_id,dest_id,3);
    uVar1 = param->op_code;
    puVar3[1] = uVar2;
    *puVar3 = uVar1;
    puVar3[2] = '\x04';
    ke_msg_send(puVar3);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_sta_del_req_handler
              (ke_msg_id_t msgid,mm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  mm_sta_del(param->sta_idx);
  ke_msg_send_basic(0xd,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_sta_add_req_handler
              (ke_msg_id_t msgid,mm_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  
  puVar2 = (uint8_t *)ke_msg_alloc(0xb,src_id,dest_id,3);
  uVar1 = mm_sta_add(param,puVar2 + 1,puVar2 + 2);
  *puVar2 = uVar1;
  ke_msg_send(puVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_key_del_req_handler
              (ke_msg_id_t msgid,mm_key_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if ((_DAT_44b000d8 >> 0x18) + 1 < (uint)param->hw_key_idx) {
    assert_err("param->hw_key_idx <= MM_SEC_MAX_KEY_NBR","module",0x56e);
  }
  mm_sec_machwkey_del(param->hw_key_idx);
  ke_msg_send_basic(0x27,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_key_add_req_handler
              (ke_msg_id_t msgid,mm_key_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  
  puVar2 = (undefined *)ke_msg_alloc(0x25,src_id,dest_id,2);
  if (3 < param->key_idx) {
    assert_err("param->key_idx < MAC_DEFAULT_KEY_COUNT","module",0x53d);
  }
  if (0x20 < (param->key).length) {
    assert_err("param->key.length <= MAC_SEC_KEY_LEN","module",0x541);
  }
  if (5 < param->cipher_suite) {
    assert_err("param->cipher_suite <= MAC_RSNIE_CIPHER_AES_CMAC","module",0x544);
  }
  uVar1 = mm_sec_machwkey_wr(param);
  puVar2[1] = uVar1;
  *puVar2 = 0;
  ke_msg_send(puVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_set_power_req_handler
              (ke_msg_id_t msgid,mm_set_power_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint8_t *idx;
  
  uVar1 = (uint)param->inst_nbr;
  idx = (uint8_t *)ke_msg_alloc(0x2f,src_id,dest_id,2);
  vif_info_tab[uVar1].user_tx_power = param->power;
  idx[1] = vif_info_tab[uVar1].tx_power;
  vif_info_tab[uVar1].tx_power = '\x7f';
  tpc_update_vif_tx_power(vif_info_tab + uVar1,(int8_t *)(idx + 1),idx);
  ke_msg_send(idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_set_idle_req_handler
              (ke_msg_id_t msgid,mm_set_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar2) == 3) {
LAB_2301b686:
    iVar1 = 2;
  }
  else {
    mm_env.host_idle = param->hw_idle;
    if (mm_env.host_idle == '\0') {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT22(extraout_var_01,kVar2) == 2) goto LAB_2301b686;
      mm_active();
    }
    else {
      kVar2 = ke_state_get(dest_id);
      if (CONCAT22(extraout_var_00,kVar2) != 0) {
        if (CONCAT22(extraout_var_00,kVar2) == 2) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 2;
        }
        hal_machw_idle_req();
        ke_state_set(dest_id,2);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 2;
      }
      if ((_DAT_44b00038 & 0xf) != 0) {
        assert_err("blmac_current_state_getf() == HW_IDLE","module",0x47d);
      }
      mm_env._18_2_ = 0;
    }
    ke_msg_send_basic(0x23,src_id,dest_id);
    iVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mm_reset_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  hal_machw_stop();
  phy_stop();
  me_init();
  mm_init();
  ke_msg_send_basic(1,src_id,dest_id);
  ke_state_set(0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_version_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(5,src_id,dest_id,0x18);
  *puVar1 = 0x5040000;
  puVar1[1] = _DAT_44b00004;
  puVar1[2] = _DAT_44b00008;
  phy_get_version(puVar1 + 3,puVar1 + 4);
  puVar1[5] = 0x89df;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_start_req_handler
              (ke_msg_id_t msgid,mm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 0) {
    assert_err("ke_state_get(dest_id) == MM_IDLE","module",0x135);
  }
  phy_init((phy_cfg_tag *)param);
  phy_set_channel('\0','\0',0x96c,0x96c,0,'\0');
  tpc_update_tx_power('\x10');
  ps_env.uapsd_timeout = param->uapsd_timeout * 1000;
  mm_env.lp_clk_accuracy = param->lp_clk_accuracy;
  ke_msg_send_basic(3,src_id,dest_id);
  mm_active();
  hal_machw_idle_req();
  ke_state_set(dest_id,2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int mm_set_ps_mode_req_handler
              (ke_msg_id_t msgid,mm_set_ps_mode_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tag *vif_entry;
  
  vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first;
  if (param->new_state == '\x03') {
    while (vif_entry != (vif_info_tag *)0x0) {
      if ((vif_entry->type == '\0') && (vif_entry->active != false)) {
        ps_polling_frame(vif_entry);
      }
      vif_entry = *(vif_info_tag **)&vif_entry->list_hdr;
    }
    ke_msg_send_basic(0x32,ps_env.taskid,0);
  }
  else {
    ps_set_mode(param->new_state,src_id);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_force_idle_req_handler
              (ke_msg_id_t msgid,mm_force_idle_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  
  kVar2 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar2) == 0) {
    if ((_DAT_44b00038 & 0xf) != 0) {
      assert_err("blmac_current_state_getf() == HW_IDLE","module",0x4c0);
    }
    ke_state_set(dest_id,3);
    iVar1 = 0;
    (*param->cb)(param->cb);
  }
  else {
    iVar1 = 2;
    if (CONCAT22(extraout_var,kVar2) != 2) {
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_hw_config_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  char cVar1;
  byte bVar2;
  _Bool _Var3;
  uint8_t uVar4;
  uint16_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  int iVar8;
  uint8_t uVar9;
  ke_state_t kVar10;
  ke_msg_id_t id;
  undefined2 in_register_0000202a;
  undefined2 extraout_var;
  uint8_t *puVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  uVar16 = CONCAT22(in_register_0000202a,msgid);
  kVar10 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar10) != 0) {
    if (1 < (CONCAT22(extraout_var,kVar10) - 2U & 0xffff)) {
      mm_env.prev_hw_state = (byte)_DAT_44b00038 & 0xf;
      kVar10 = ke_state_get(dest_id);
      mm_env.prev_mm_state = (uint8_t)kVar10;
      hal_machw_idle_req();
      ke_state_set(dest_id,2);
    }
    iVar8 = 2;
    goto LAB_2301bae2;
  }
  if ((_DAT_44b00038 & 0xf) != 0) {
    assert_err("blmac_current_state_getf() == HW_IDLE","module",0x77b);
  }
  iVar8 = DAT_4201d1f8;
  if (uVar16 == 0x16) {
                    // WARNING: Load size is inaccurate
    mm_env.basic_rates[*(byte *)((int)param + 5)] = *param;
    if ((iVar8 != 0) && (*(char *)(iVar8 + 4) == *(char *)((int)param + 5))) {
      _DAT_44b000dc = 0x10;
    }
    id = 0x17;
LAB_2301baa6:
    ke_msg_send_basic(id,src_id,dest_id);
LAB_2301baaa:
    iVar8 = 0;
  }
  else {
    if (0x16 < uVar16) {
      if (uVar16 == 0x1e) {
        uVar16 = (uint)*(byte *)((int)param + 3);
        if (vif_info_tab[uVar16].type == '\0') {
          if (*(char *)((int)param + 2) == '\0') {
            mm_timer_clear(&vif_info_tab[uVar16].tbtt_timer);
          }
          else {
            uVar14 = (uint)*(byte *)&vif_info_tab[uVar16].u.field_0x4;
            mm_timer_set(&vif_info_tab[uVar16].tbtt_timer,
                         _DAT_44b00120 + sta_info_tab[uVar14].bcn_int);
                    // WARNING: Load size is inaccurate
            uVar5 = *param;
            uVar12 = sta_info_tab[uVar14].bcn_int;
            *(undefined2 *)&vif_info_tab[uVar16].u = 0;
            sta_info_tab[uVar14].aid = uVar5;
            uVar15 = (uint)mm_env.lp_clk_accuracy;
            *(undefined *)&vif_info_tab[uVar16].u.field_0x2 = 0;
            sta_info_tab[uVar14].drift = (uint16_t)(((uVar15 + 0x14) * uVar12) / 1000000);
            iVar8 = _DAT_44b00120;
            *(undefined *)&vif_info_tab[uVar16].u.field_0x18 = 0;
            *(undefined4 *)&vif_info_tab[uVar16].u.field_0x14 = 0;
            *(int *)&vif_info_tab[uVar16].u.field_0x8 = iVar8;
            vif_info_tab[uVar16].prevent_sleep = vif_info_tab[uVar16].prevent_sleep | 1;
            *(int *)&vif_info_tab[uVar16].u.field_0x10 = _DAT_44b00120;
            chan_bcn_detect_start(vif_info_tab + uVar16);
          }
        }
        _Var3 = *(_Bool *)((int)param + 2);
        vif_info_tab[uVar16].active = _Var3;
        if (_Var3 != false) {
          _DAT_44b00200 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00204 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b00208 = vif_info_tab[uVar16].txq_params[3];
          _DAT_44b0020c = vif_info_tab[uVar16].txq_params[3];
          mm_env_max_ampdu_duration_set();
        }
        id = 0x1f;
      }
      else {
        if (uVar16 < 0x1f) {
          if (uVar16 == 0x1a) {
            uVar16 = (uint)*(byte *)((int)param + 6);
                    // WARNING: Load size is inaccurate
            vif_info_tab[uVar16].txq_params[*(byte *)((int)param + 5)] = *param;
            if (vif_info_tab[uVar16].active != false) {
              cVar1 = *(char *)((int)param + 5);
                    // WARNING: Load size is inaccurate
              uVar13 = *param;
              uVar12 = _DAT_44b00200;
              uVar6 = uVar13;
              uVar7 = _DAT_44b00208;
              if (((cVar1 != '\x01') && (uVar12 = uVar13, uVar6 = _DAT_44b00204, cVar1 != '\0')) &&
                 (uVar12 = _DAT_44b00200, uVar7 = uVar13, cVar1 != '\x02')) {
                uVar7 = _DAT_44b00208;
                _DAT_44b0020c = uVar13;
              }
              _DAT_44b00208 = uVar7;
              _DAT_44b00204 = uVar6;
              _DAT_44b00200 = uVar12;
              mm_env_max_ampdu_duration_set();
            }
            if (vif_info_tab[uVar16].type == '\0') {
              ps_uapsd_set(vif_info_tab + uVar16,*(uint8_t *)((int)param + 5),
                           *(_Bool *)((int)param + 4));
            }
            id = 0x1b;
          }
          else {
            if (uVar16 == 0x1c) {
                    // WARNING: Load size is inaccurate
              bVar2 = *param;
              if (((uint)bVar2 << 0xe & 0x3e0000) != 0) {
                assert_err("(((uint32_t)abgnmode << 14) & ~((uint32_t)0x0001C000)) == 0","module",
                           0x834);
              }
              _DAT_44b0004c = _DAT_44b0004c & 0xfffe3fff | (uint)bVar2 << 0xe;
              id = 0x1d;
            }
            else {
              if (uVar16 != 0x18) goto LAB_2301b960;
              memcpy(&vif_info_tab[*(byte *)((int)param + 6)].bssid,param,6);
              if ((uint)vif_mgmt_env.vif_sta_cnt + (uint)vif_mgmt_env.vif_ap_cnt == 1) {
                    // WARNING: Load size is inaccurate
                _DAT_44b00020 = *param;
                _DAT_44b00024 = (uint)*(ushort *)((int)param + 4);
              }
              id = 0x19;
            }
          }
        }
        else {
          if (uVar16 == 0x28) {
                    // WARNING: Load size is inaccurate
            uVar9 = '\x05';
            if (*param != '\0') {
              uVar9 = '\0';
              _DAT_44b00054 = _DAT_44b00054 | 0x80;
            }
            puVar11 = (uint8_t *)ke_msg_alloc(0x29,src_id,dest_id,3);
            *puVar11 = *(uint8_t *)((int)param + 1);
            uVar4 = *(uint8_t *)((int)param + 2);
            puVar11[2] = uVar9;
            puVar11[1] = uVar4;
            goto LAB_2301b9bc;
          }
          if (uVar16 == 0x3b) {
            chan_ctxt_update((mm_chan_ctxt_update_req *)param);
            id = 0x3c;
          }
          else {
            if (uVar16 != 0x20) goto LAB_2301b960;
                    // WARNING: Load size is inaccurate
            id = 0x21;
            _DAT_44b000e8 = (uint)*param * (_DAT_44b000e4 & 0xff) * 0x100 | (uint)*param;
          }
        }
      }
      goto LAB_2301baa6;
    }
    if (uVar16 == 0xe) {
                    // WARNING: Load size is inaccurate
      mm_env.rx_filter_umac = *param;
      _DAT_44b00060 = mm_env.rx_filter_umac | mm_env.rx_filter_lmac_enable;
      id = 0xf;
      goto LAB_2301baa6;
    }
    if (0xe < uVar16) {
      if (uVar16 == 0x12) {
                    // WARNING: Load size is inaccurate
        _DAT_44b00090 = (uint)*param | _DAT_44b00090 & 0xffffff00 | 0x80000000;
        id = 0x13;
      }
      else {
        if (uVar16 != 0x14) {
          if (uVar16 != 0x10) goto LAB_2301b960;
          puVar11 = (uint8_t *)ke_msg_alloc(0x11,src_id,dest_id,2);
          if (*(uint8_t *)((int)param + 8) != '\0') {
                    // WARNING: Load size is inaccurate
            phy_set_channel(*param,*(uint8_t *)((int)param + 1),*(uint16_t *)((int)param + 2),
                            *(uint16_t *)((int)param + 4),*(uint16_t *)((int)param + 6),
                            *(uint8_t *)((int)param + 8));
          }
          goto LAB_2301b9bc;
        }
        uVar16 = (uint)*(byte *)((int)param + 2);
                    // WARNING: Load size is inaccurate
        if (vif_info_tab[uVar16].type == '\0') {
          sta_info_tab[*(byte *)&vif_info_tab[uVar16].u.field_0x4].bcn_int = (uint)*param << 10;
        }
        else {
          vif_mgmt_set_ap_bcn_int(vif_info_tab + uVar16,*param);
        }
        id = 0x15;
      }
      goto LAB_2301baa6;
    }
    if (uVar16 == 6) {
      puVar11 = (uint8_t *)ke_msg_alloc(7,src_id,dest_id,2);
                    // WARNING: Load size is inaccurate
      uVar9 = vif_mgmt_register((mac_addr *)((int)param + 1),*param,*(_Bool *)((int)param + 7),
                                puVar11 + 1);
      *puVar11 = uVar9;
LAB_2301b9bc:
      ke_msg_send(puVar11);
      goto LAB_2301baaa;
    }
    if (uVar16 == 8) {
                    // WARNING: Load size is inaccurate
      if (*param < 2) {
        vif_mgmt_unregister(*param);
      }
      if (vif_mgmt_env.used_list.first == (co_list_hdr *)0x0) {
        hal_machw_monitor_mode();
      }
      id = 9;
      goto LAB_2301baa6;
    }
LAB_2301b960:
    assert_err("0","module",0x7ae);
    iVar8 = 2;
  }
  uVar16 = (uint)mm_env.prev_hw_state;
  if ((uVar16 << 4 & 0xffffff0f) != 0) {
    assert_err("(((uint32_t)nextstate << 4) & ~((uint32_t)0x000000F0)) == 0","module",0x5b9);
  }
  _DAT_44b00038 = uVar16 << 4;
  ke_state_set(dest_id,(ushort)mm_env.prev_mm_state);
LAB_2301bae2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl60x_edca_get(int ac,uint8_t *aifs,uint8_t *cwmin,uint8_t *cwmax,uint16_t *txop)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = _DAT_44b00200;
  uVar2 = _DAT_44b00204;
  if (ac != 1) {
    if (ac < 2) {
      if (ac == 0) {
        *txop = (uint16_t)(_DAT_44b00200 >> 0xc);
        *cwmax = (byte)(uVar1 >> 8) & 0xf;
        *cwmin = (byte)(uVar1 >> 4) & 0xf;
        *aifs = (byte)uVar1 & 0xf;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    else {
      uVar2 = _DAT_44b00208;
      if ((ac == 2) || (uVar2 = _DAT_44b0020c, ac == 3)) goto LAB_2301be88;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
LAB_2301be88:
  *txop = (uint16_t)(uVar2 >> 0xc);
  *cwmax = (byte)(uVar2 >> 8) & 0xf;
  *cwmin = (byte)(uVar2 >> 4) & 0xf;
  *aifs = (byte)uVar2 & 0xf;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_init(void)

{
  fw_nap_chain_ptr = &fw_nap_chain;
  bl_env.hw_in_doze = 0;
  dbg_init();
  me_init();
  mm_init();
  ke_init();
  memset(&sta_conn_info,0,0xec);
  sta_conn_info._4_2_ = 0xffff;
  sta_conn_info.conType = '\0';
  sta_conn_info.gtkHwKeyId = -1;
  supplicantFuncInit();
  allocSupplicantData(&sta_conn_info);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_reset_evt(int dummy)

{
  ke_evt_clear(0x80000000);
  hal_machw_reset();
  rxl_reset();
  txl_reset();
  mm_reset();
  vif_mgmt_reset();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

int bl_sleep(void)

{
  vif_info_tag *p_vif_entry;
  _Bool _Var1;
  ke_state_t kVar2;
  int iVar3;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  if (ke_env.evt_field != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  kVar2 = ke_state_get(4);
  if (((CONCAT22(extraout_var_01,kVar2) == 0) && (ps_env.ps_on != false)) &&
     (p_vif_entry = (vif_info_tag *)vif_mgmt_env.used_list.first, ps_env.prevent_sleep == 0)) {
    while (p_vif_entry != (vif_info_tag *)0x0) {
      _Var1 = chan_is_on_channel(p_vif_entry);
      if ((CONCAT31(extraout_var_00,_Var1) != 0) && (p_vif_entry->prevent_sleep != 0))
      goto LAB_2301bf58;
      p_vif_entry = *(vif_info_tag **)&p_vif_entry->list_hdr;
    }
    if (txl_cntrl_env.pck_cnt == 0) {
      _Var1 = hal_machw_sleep_check();
      iVar3 = CONCAT31(extraout_var,_Var1);
      goto LAB_2301bf5a;
    }
  }
LAB_2301bf58:
  iVar3 = 0;
LAB_2301bf5a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_nap_calculate(void)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar2 = 0;
  uVar1 = 0xffffffff;
  do {
    if ((1 << (uVar2 & 0x1f) & _DAT_44b0808c) != 0) {
      uVar3 = *(uint *)(&DAT_44b00128 + uVar2 * 4);
      if (_DAT_44b00120 < uVar3) {
        uVar3 = uVar3 - _DAT_44b00120;
      }
      else {
        uVar3 = (_DAT_44b00120 - 1) - uVar3;
      }
      if (uVar3 < uVar1) {
        uVar1 = uVar3;
      }
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 9);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void rx_swdesc_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  rx_swdesc_tab[0].dma_hdrdesc = rx_dma_hdrdesc;
  rx_swdesc_tab[1].dma_hdrdesc = &DAT_42043064;
  rx_swdesc_tab[2].dma_hdrdesc = &DAT_420430c8;
  rx_swdesc_tab[3].dma_hdrdesc = &DAT_4204312c;
  rx_swdesc_tab[4].dma_hdrdesc = &DAT_42043190;
  rx_swdesc_tab[5].dma_hdrdesc = &DAT_420431f4;
  rx_swdesc_tab[6].dma_hdrdesc = &DAT_42043258;
  rx_swdesc_tab[7].dma_hdrdesc = &DAT_420432bc;
  rx_swdesc_tab[8].dma_hdrdesc = &DAT_42043320;
  rx_swdesc_tab[9].dma_hdrdesc = &DAT_42043384;
  rx_swdesc_tab[10].dma_hdrdesc = &DAT_420433e8;
  rx_swdesc_tab[11].dma_hdrdesc = &DAT_4204344c;
  rx_swdesc_tab[12].dma_hdrdesc = &DAT_420434b0;
  return;
}



int scan_cancel_req_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar1) == 0) {
    scan_send_cancel_cfm('\x01',src_id);
  }
  else {
    DAT_42018f13 = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int scan_start_req_handler
              (ke_msg_id_t msgid,scan_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined *puVar3;
  undefined2 extraout_var;
  
  puVar3 = (undefined *)ke_msg_alloc(0x801,src_id,dest_id,1);
  kVar2 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar2) == 0) {
    if (param->chan_cnt == '\0') {
      assert_err("param->chan_cnt > 0","module",0x46);
    }
    *puVar3 = 0;
    DAT_42018f12 = 0;
    iVar1 = 1;
    scan_search_ds::param = param;
    DAT_42018f10 = src_id;
    scan_ie_download(param);
  }
  else {
    *puVar3 = 8;
    iVar1 = 0;
  }
  ke_msg_send(puVar3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_scan_channel_end_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar1) != 3) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_BEACON_PROBE_RSP","module",0xc4);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable & 0xffffddff;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  DAT_42018f12 = DAT_42018f12 + 1;
  if ((DAT_42018f12 < scan_search_ds::param->chan_cnt) && (DAT_42018f13 == '\0')) {
    scan_set_channel_request();
  }
  else {
    ke_msg_free(&scan_search_ds::param[-1].add_ies);
    if (DAT_42018f13 == '\0') {
      ke_msg_send_basic(0x802,DAT_42018f10,2);
    }
    else {
      scan_send_cancel_cfm('\0',DAT_42018f10);
      DAT_42018f13 = '\0';
    }
    ke_state_set(2,0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mm_scan_channel_start_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  scan_start_req *psVar1;
  uint uVar2;
  ke_state_t kVar3;
  undefined2 extraout_var;
  
  psVar1 = scan_search_ds::param;
  uVar2 = (uint)DAT_42018f12;
  kVar3 = ke_state_get(2);
  if (CONCAT22(extraout_var,kVar3) != 2) {
    assert_err("ke_state_get(TASK_SCAN) == SCAN_WAIT_CHANNEL","module",0x9d);
  }
  mm_env.rx_filter_lmac_enable = mm_env.rx_filter_lmac_enable | 0x2200;
  _DAT_44b00060 = mm_env.rx_filter_lmac_enable | mm_env.rx_filter_umac;
  if ((psVar1->chan[uVar2].flags & 1) == 0) {
    scan_probe_req_tx();
  }
  ke_state_set(2,3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void txl_buffer_reinit(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_buffer_init(void)

{
  uint uVar1;
  txl_buffer_control *ptVar2;
  txl_buffer_control *ptVar3;
  uint8_t uVar4;
  byte bVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  txl_buffer_reinit();
  ptVar3 = txl_buffer_control_desc;
  do {
    *(undefined4 *)&ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)&(ptVar3->field_0).field_0x4 = CONCAT31(extraout_var,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)&(ptVar3->field_0).field_0x8 = (1 << (bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)&(ptVar3->field_0).field_0xc = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x10 = 0xffff0704;
    *(undefined4 *)&(ptVar3->field_0).field_0x14 = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x18 = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x1c = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x20 = 0;
    ptVar2 = ptVar3 + 1;
    *(uint *)&(ptVar3->field_0).field_0x24 = _DAT_44b000a0 & 0xff;
    *(uint *)&(ptVar3->field_0).field_0x28 = _DAT_44b000a0 & 0xff;
    *(uint *)&(ptVar3->field_0).field_0x2c = _DAT_44b000a0 & 0xff;
    uVar1 = _DAT_44b000a0;
    ptVar3->mac_control_info = 0x2200;
    ptVar3->phy_control_info = 0x3f0000;
    *(uint *)&(ptVar3->field_0).field_0x30 = uVar1 & 0xff;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_frame_buf_ctrl);
  ptVar3 = txl_buffer_control_desc_bcmc;
  do {
    *(undefined4 *)&ptVar3->field_0 = 0xbadcab1e;
    uVar4 = phy_get_ntx();
    *(int *)&(ptVar3->field_0).field_0x4 = CONCAT31(extraout_var_00,uVar4) << 0xe;
    bVar5 = phy_get_ntx();
    *(int *)&(ptVar3->field_0).field_0x8 = (1 << (bVar5 + 1 & 0x1f)) + -1;
    *(undefined4 *)&(ptVar3->field_0).field_0xc = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x10 = 0xffff0704;
    *(undefined4 *)&(ptVar3->field_0).field_0x14 = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x18 = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x1c = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x20 = 0;
    uVar1 = _DAT_44b000a0;
    ptVar2 = ptVar3 + 1;
    *(undefined4 *)&(ptVar3->field_0).field_0x28 = 0;
    *(uint *)&(ptVar3->field_0).field_0x24 = uVar1 & 0xff;
    *(undefined4 *)&(ptVar3->field_0).field_0x2c = 0;
    *(undefined4 *)&(ptVar3->field_0).field_0x30 = 0;
    ptVar3->mac_control_info = 0;
    ptVar3->phy_control_info = 0x3f0000;
    ptVar3 = ptVar2;
  } while (ptVar2 != txl_buffer_control_desc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_buffer_reset(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  txl_buffer_env.list[0].first = (txl_buffer_tag *)0x0;
  txl_buffer_env.list[0].last = (txl_buffer_tag *)0x0;
  return;
}



txl_buffer_tag * txl_buffer_alloc(txdesc *txdesc,uint8_t access_category,uint8_t user_idx)

{
  ushort uVar1;
  txl_buffer_tag *ptVar2;
  txl_buffer_tag *ptVar3;
  txl_buffer_control *ptVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  
  uVar5 = (uint)(txdesc->umac).head_len;
  *(uint8_t *)(txdesc->buf + 0x3b) = user_idx;
  txdesc->buf[2] = (uVar5 + 0xf & 0xfffffff0) - uVar5;
  txdesc->buf[0xe] = 0xcafefade;
  uVar1 = (txdesc->host).flags;
  txdesc->buf[1] = uVar5;
  ptVar3 = (txl_buffer_tag *)txdesc->buf;
  if ((uVar1 & 8) == 0) {
    txu_cntrl_frame_build(txdesc,(int)txdesc->buf + uVar5 + 0x14c);
  }
  ptVar4 = (txdesc->umac).buf_control;
  iVar6 = 0;
  do {
    iVar7 = iVar6 + 4;
    *(undefined4 *)((int)txdesc->buf + iVar6 + 0xf0) =
         *(undefined4 *)(&(ptVar4->field_0).field_0x0 + iVar6);
    iVar6 = iVar7;
  } while (iVar7 != 0x3c);
  ptVar2 = ptVar3;
  if (txl_buffer_env.list[0].first != (txl_buffer_tag *)0x0) {
    (txl_buffer_env.list[0].last)->next = ptVar3;
    ptVar2 = txl_buffer_env.list[0].first;
  }
  txl_buffer_env.list[0].first = ptVar2;
  txl_buffer_env.list[0].last = ptVar3;
  txdesc->buf[4] = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar3;
}



void txl_buffer_update_thd(txdesc *txdesc)

{
  uint32_t *puVar1;
  int iVar2;
  tx_pbd *in_a2;
  tx_pbd *ptVar3;
  uint32_t uVar4;
  txl_buffer_tag *ptVar5;
  tx_hw_desc *ptVar6;
  uint32_t uVar7;
  
  ptVar5 = (txdesc->lmac).buffer;
  ptVar6 = (txdesc->lmac).hw_desc;
  puVar1 = (txdesc->host).pbuf_chained_ptr;
  iVar2 = 0;
  ptVar3 = ptVar5->tbd_body;
  while (*puVar1 != 0) {
    ptVar3->upatterntx = 0xcafefade;
    uVar4 = *puVar1;
    ptVar3->datastartptr = uVar4;
    uVar7 = puVar1[4];
    ptVar3->bufctrlinfo = 0;
    iVar2 = iVar2 + 1;
    ptVar3->dataendptr = (uVar4 + uVar7) - 1;
    ptVar3->next = (uint32_t)(ptVar3 + 1);
    puVar1 = puVar1 + 1;
    in_a2 = ptVar3;
    ptVar3 = ptVar3 + 1;
  }
  if (iVar2 == 0) {
    printf("%s: assert when set add_pbd chain\r\n","txl_buffer_update_thd");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  uVar4 = ptVar5->lenheader;
  (ptVar5->tbd).upatterntx = 0xcafefade;
  (ptVar5->tbd).datastartptr = (uint32_t)(ptVar5 + 1);
  (ptVar5->tbd).dataendptr = (uint32_t)(ptVar5->tkip_mic_icv + uVar4 + 0xb);
  (ptVar5->tbd).next = (uint32_t)ptVar5->tbd_body;
  (ptVar5->tbd).bufctrlinfo = 0;
  (ptVar6->thd).field_3 = &ptVar5->tbd;
  in_a2->bufctrlinfo = 0;
  (ptVar6->thd).macctrlinfo2 = 0x100;
  in_a2->next = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cfm_init(void)

{
  memset(&txl_cfm_env,0,0x28);
  co_list_init((co_list *)&txl_cfm_env);
  co_list_init(txl_cfm_env.cfmlist + 1);
  co_list_init(txl_cfm_env.cfmlist + 2);
  co_list_init(txl_cfm_env.cfmlist + 3);
  co_list_init(txl_cfm_env.cfmlist + 4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cfm_push(txdesc *txdesc,uint32_t status,uint8_t access_category)

{
  undefined3 in_register_00002031;
  
  ((txdesc->lmac).hw_desc)->cfm_ptr->status = status;
  co_list_push_back(txl_cfm_env.cfmlist + CONCAT31(in_register_00002031,access_category),
                    (co_list_hdr *)txdesc);
  ke_evt_set(txl_cfm_evt_bit[CONCAT31(in_register_00002031,access_category)]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cfm_evt(int access_category)

{
  uint event;
  txdesc *txdesc;
  
  event = txl_cfm_evt_bit[access_category];
  if ((ke_env.evt_field & event) == 0) {
    assert_err("ke_evt_get() & evt_bit","module",0x168);
  }
  ke_evt_clear(event);
  while (txdesc = (txdesc *)txl_cfm_env.cfmlist[access_category].first, txdesc != (txdesc *)0x0) {
    co_list_pop_front(txl_cfm_env.cfmlist + access_category);
    me_tx_cfm_singleton(txdesc);
    txu_cntrl_cfm(txdesc);
    txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt - 1;
    ipc_emb_txcfm_ind(1 << (access_category & 0x1fU));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void txl_cfm_flush(uint8_t access_category,co_list *list,uint32_t status)

{
  txdesc *txdesc;
  tx_cfm_tag *ptVar1;
  
  while (txdesc = (txdesc *)co_list_pop_front(list), txdesc != (txdesc *)0x0) {
    ptVar1 = ((txdesc->lmac).hw_desc)->cfm_ptr;
    if ((txdesc->lmac).agg_desc == (tx_agg_desc *)0x0) {
      if (-1 < (int)ptVar1->status) {
        ptVar1->status = status;
      }
    }
    else {
      ptVar1->status = status | 0x3c000000;
    }
    if ((txdesc->host).packet_addr == 0) {
      txl_frame_cfm(txdesc);
    }
    else {
      txu_cntrl_cfm(txdesc);
      txl_cntrl_env.pck_cnt = txl_cntrl_env.pck_cnt - 1;
      if ((txdesc->lmac).buffer != (txl_buffer_tag *)0x0) {
        (txdesc->lmac).buffer = (txl_buffer_tag *)0x0;
      }
    }
  }
  txl_frame_evt(0);
  ipc_emb_txcfm_ind(1 << (access_category & 0x1f));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void txl_cfm_dma_int_handler(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  ps_env.prevent_sleep = ps_env.prevent_sleep & 0xfffffffe;
  _DAT_44a00020 = _DAT_44a00024 & 0x100;
  return;
}



void txl_cfm_dump(void)

{
  txl_cfm_env_tag *list;
  uint32_t uVar1;
  uint32_t **ppuVar2;
  
  list = &txl_cfm_env;
  do {
    uVar1 = co_list_cnt((co_list *)list);
    if (uVar1 != 0) {
      ppuVar2 = (uint32_t **)((bam_env_tag *)list)->pkt_cnt;
      while (ppuVar2 != (uint32_t **)0x0) {
        ppuVar2 = (uint32_t **)*ppuVar2;
      }
    }
    list = (txl_cfm_env_tag *)&((bam_env_tag *)list)->ssn;
  } while ((bam_env_tag *)list != bam_env);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bam_init(void)

{
  bam_env[0].sta_idx = -1;
  ke_state_set(8,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bam_send_air_action_frame
               (uint8_t sta_idx,bam_env_tag *bam_env,uint8_t action,uint8_t dialog_token,
               uint16_t param,uint16_t status_code,anon_subr_void_void_ptr_uint32_t *cfm_func)

{
  byte bVar1;
  uint8_t ac;
  uint16_t uVar2;
  undefined3 in_register_00002029;
  txl_frame_desc_tag *frame;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  txl_buffer_tag *ptVar3;
  undefined3 in_register_00002031;
  int iVar4;
  undefined2 in_register_0000203a;
  tx_hw_desc *ptVar5;
  int iVar6;
  uint uVar7;
  char cStack72;
  phy_channel_info phy_info;
  
  iVar4 = CONCAT31(in_register_00002031,action);
  iVar6 = CONCAT31(in_register_00002029,sta_idx);
  bVar1 = sta_info_tab[iVar6].inst_nbr;
  uVar7 = (uint)bVar1;
  phy_get_channel((phy_channel_info *)&cStack72,'\0');
  frame = txl_frame_get((uint)(cStack72 != '\0'),0x100);
  if (frame == (txl_frame_desc_tag *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  tpc_update_frame_tx_power(vif_info_tab + uVar7,frame);
  ptVar3 = (frame->txdesc).lmac.buffer;
  *(undefined *)&ptVar3[1].length = 0xd0;
  *(undefined *)((int)&ptVar3[1].length + 1) = 0;
  *(undefined *)((int)&ptVar3[1].length + 2) = 0;
  *(undefined *)((int)&ptVar3[1].length + 3) = 0;
  *(uint16_t *)&ptVar3[1].lenheader = sta_info_tab[iVar6].mac_addr.array[0];
  *(uint16_t *)((int)&ptVar3[1].lenheader + 2) = sta_info_tab[iVar6].mac_addr.array[1];
  *(uint16_t *)&ptVar3[1].lenpad = sta_info_tab[iVar6].mac_addr.array[2];
  *(uint16_t *)((int)&ptVar3[1].lenpad + 2) = vif_info_tab[uVar7].mac_addr.array[0];
  *(uint16_t *)&ptVar3[1].flags = vif_info_tab[uVar7].mac_addr.array[1];
  *(uint16_t *)((int)&ptVar3[1].flags + 2) = vif_info_tab[uVar7].mac_addr.array[2];
  if (vif_info_tab[uVar7].type == '\x02') {
    *(uint16_t *)&ptVar3[1].next = vif_info_tab[uVar7].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = vif_info_tab[uVar7].mac_addr.array[1];
    uVar2 = vif_info_tab[uVar7].mac_addr.array[2];
  }
  else {
    *(uint16_t *)&ptVar3[1].next = sta_info_tab[iVar6].mac_addr.array[0];
    *(uint16_t *)((int)&ptVar3[1].next + 2) = sta_info_tab[iVar6].mac_addr.array[1];
    uVar2 = sta_info_tab[iVar6].mac_addr.array[2];
  }
  *(uint16_t *)&ptVar3[1].txdesc = uVar2;
  uVar7 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar7 + 1) * 0x10000 >> 0x10);
  iVar6 = (uVar7 + 1) * 0x100000;
  *(char *)((int)&ptVar3[1].txdesc + 2) = (char)((uint)iVar6 >> 0x10);
  *(char *)((int)&ptVar3[1].txdesc + 3) = (char)((uint)iVar6 >> 0x18);
  (frame->txdesc).host.vif_idx = bVar1;
  (frame->txdesc).host.staid = sta_idx;
  if (iVar4 == 1) {
    uVar2 = me_build_add_ba_rsp((uint32_t)ptVar3[1].dma_desc,bam_env,param,dialog_token,status_code)
    ;
    iVar6 = CONCAT22(extraout_var_00,uVar2);
LAB_2301c8fc:
    iVar6 = iVar6 + 0x18;
  }
  else {
    if (iVar4 == 0) {
      ac = "\x01"[CONCAT22(in_register_0000203a,param) >> 2 & 0xf];
      uVar2 = me_build_add_ba_req((uint32_t)ptVar3[1].dma_desc,bam_env);
      iVar6 = CONCAT22(extraout_var,uVar2) + 0x18;
      goto LAB_2301c8ae;
    }
    if (iVar4 == 2) {
      uVar2 = me_build_del_ba((uint32_t)ptVar3[1].dma_desc,bam_env,status_code);
      iVar6 = CONCAT22(extraout_var_01,uVar2);
      goto LAB_2301c8fc;
    }
    assert_warn("0","module",0x25d);
    iVar6 = 0x18;
  }
  ac = '\x03';
LAB_2301c8ae:
  ptVar5 = (frame->txdesc).lmac.hw_desc;
  (ptVar5->thd).field_5 = (ptVar5->thd).field_4 + -1 + iVar6;
  (ptVar5->thd).frmlen = iVar6 + 4;
  if (cfm_func != (anon_subr_void_void_ptr_uint32_t *)0x0) {
    (frame->cfm).cfm_func = (cfm_func_ptr *)cfm_func;
    (frame->cfm).env = bam_env;
  }
  txl_frame_push(frame,ac);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  int iVar1;
  int iVar2;
  uint8_t sta_idx;
  uint8_t dialog_token;
  ushort uVar3;
  uint uVar4;
  
  if (*(char *)((int)&param[1].length + 1) == '\0') {
    uVar3 = *(ushort *)((int)&param[1].framectrl + 1);
    sta_idx = param->sta_idx;
    dialog_token = *(uint8_t *)&param[1].framectrl;
    iVar1 = 0x408;
    if ((uVar3 & 1) != 0) {
      iVar1 = 0x40c;
    }
    iVar2 = 0x418;
    if ((uVar3 & 2) == 0) {
      iVar2 = 0x42c;
    }
    uVar4 = (uint)(uVar3 >> 6);
    printf(
           "-----------------> AABA Request:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,"!hal_machw_time_past(blmac_abs_timer_get(i) + 5000)" + iVar1 + 0x20,
           "!hal_machw_time_past(blmac_abs_timer_get(i) + 5000)" + iVar2 + 0x20,
           (int)(uint)uVar3 >> 2 & 0xf,uVar4);
    if (8 < uVar4) {
      uVar4 = 8;
    }
    uVar3 = (ushort)(uVar4 << 6) | uVar3 & 0x3e | 2;
    printf(
           "-----------------> AABA Response:\r\n    A-MSDU: %s\r\n    Block Ack Policy: %s\r\n    TID: %u\r\n    Number of Buffers: %u\r\n"
           ,"Not Permitted","Immediate Block Ack",(int)(short)uVar3 >> 2 & 0xf,
           ((int)(short)uVar3 & 0xffffU) >> 6);
    bam_send_air_action_frame
              (sta_idx,(bam_env_tag *)0x0,'\x01',dialog_token,uVar3,0,
               (anon_subr_void_void_ptr_uint32_t *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void co_pack8p(uint32_t dst,uint8_t *src,uint32_t len)

{
  uint8_t *puVar1;
  uint8_t *puVar2;
  uint32_t uVar3;
  
  uVar3 = 0;
  while (len != uVar3) {
    puVar1 = src + uVar3;
    puVar2 = (uint8_t *)(dst + uVar3);
    uVar3 = uVar3 + 1;
    *puVar2 = *puVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int phy_freq_to_channel(uint8_t band,uint16_t freq)

{
  undefined3 in_register_00002029;
  undefined2 in_register_0000202e;
  int iVar1;
  int iVar2;
  
  iVar1 = CONCAT22(in_register_0000202e,freq);
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0x48 < (iVar1 - 0x96cU & 0xffff)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (iVar1 == 0x9b4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0xe;
    }
    iVar2 = -0x967;
  }
  else {
    if (CONCAT31(in_register_00002029,band) != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (0x334 < (iVar1 - 0x138dU & 0xffff)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar2 = -5000;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (iVar1 + iVar2) / 5;
}



uint16_t phy_channel_to_freq(uint8_t band,int channel)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  if (CONCAT31(in_register_00002029,band) == 0) {
    if (0xd < channel - 1U) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0xffff;
    }
    if (channel == 0xe) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0x9b4;
    }
    iVar1 = 0x967;
  }
  else {
    if (0xa4 < channel - 1U) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0xffff;
    }
    iVar1 = 5000;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint16_t)((uint)((channel * 5 + iVar1) * 0x10000) >> 0x10);
}



uint32_t me_add_ie_ssid(uint32_t *frame_addr,uint8_t ssid_len,uint8_t *p_ssid)

{
  undefined3 in_register_0000202d;
  uint32_t len;
  
  len = CONCAT31(in_register_0000202d,ssid_len);
  *(undefined *)*frame_addr = 0;
  *(uint8_t *)(*frame_addr + 1) = ssid_len;
  if (len != 0) {
    co_pack8p(*frame_addr + 2,p_ssid,len);
  }
  *frame_addr = *frame_addr + len + 2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return len + 2;
}



uint32_t me_add_ie_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  uint32_t len;
  byte bVar1;
  uint uVar2;
  
  bVar1 = p_rateset->length;
  uVar2 = (uint)bVar1;
  len = 8;
  if (uVar2 < 9) {
    len = uVar2;
  }
  *(undefined *)*frame_addr = 1;
  if (8 < uVar2) {
    bVar1 = 8;
  }
  *(byte *)(*frame_addr + 1) = bVar1;
  co_pack8p(*frame_addr + 2,p_rateset->array,len);
  *frame_addr = *frame_addr + len + 2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return len + 2;
}



uint32_t me_add_ie_ext_supp_rates(uint32_t *frame_addr,mac_rateset *p_rateset)

{
  byte bVar1;
  uint32_t uVar2;
  uint32_t len;
  
  bVar1 = p_rateset->length;
  *(undefined *)*frame_addr = 0x32;
  uVar2 = bVar1 - 6;
  len = bVar1 - 8;
  *(char *)(*frame_addr + 1) = (char)len;
  co_pack8p(*frame_addr + 2,p_rateset->array + 8,len);
  *frame_addr = *frame_addr + uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



uint32_t me_add_ie_ds(uint32_t *frame_addr,uint8_t channel)

{
  *(undefined *)*frame_addr = 3;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = channel;
  *frame_addr = *frame_addr + 3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 3;
}



uint32_t me_add_ie_erp(uint32_t *frame_addr,uint8_t erp_info)

{
  *(undefined *)*frame_addr = 0x2a;
  *(undefined *)(*frame_addr + 1) = 1;
  *(uint8_t *)(*frame_addr + 2) = erp_info;
  *frame_addr = *frame_addr + 3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 3;
}



uint32_t me_add_ie_rsn(uint32_t *frame_addr,uint8_t enc_type)

{
  undefined3 in_register_0000202d;
  uint32_t uVar1;
  uint32_t uVar2;
  
  if (CONCAT31(in_register_0000202d,enc_type) == 1) {
    *(undefined *)*frame_addr = 0x30;
    *(undefined *)(*frame_addr + 1) = 0x14;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 2) = enc_type;
    *(undefined *)(uVar1 + 3) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 0xac;
    *(undefined *)(uVar1 + 7) = 4;
    *(undefined *)(uVar1 + 4) = 0;
    *(undefined *)(uVar1 + 5) = 0xf;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 8) = enc_type;
    *(undefined *)(uVar1 + 9) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xc) = 0xac;
    *(undefined *)(uVar1 + 0xd) = 4;
    *(undefined *)(uVar1 + 10) = 0;
    *(undefined *)(uVar1 + 0xb) = 0xf;
    uVar2 = *frame_addr;
    uVar1 = 0x16;
    *(uint8_t *)(uVar2 + 0xe) = enc_type;
    *(undefined *)(uVar2 + 0xf) = 0;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x12) = 0xac;
    *(undefined *)(uVar2 + 0x10) = 0;
    *(undefined *)(uVar2 + 0x11) = 0xf;
    *(undefined *)(uVar2 + 0x13) = 2;
    uVar2 = *frame_addr;
    *(undefined *)(uVar2 + 0x14) = 0;
    *(undefined *)(uVar2 + 0x15) = 0;
  }
  else {
    uVar1 = 0;
    if (CONCAT31(in_register_0000202d,enc_type) == 2) {
      *(undefined *)*frame_addr = 0x30;
      *(undefined *)(*frame_addr + 1) = 0x18;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 2) = 1;
      *(undefined *)(uVar1 + 3) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 4) = 0;
      *(undefined *)(uVar1 + 5) = 0xf;
      *(undefined *)(uVar1 + 6) = 0xac;
      *(uint8_t *)(uVar1 + 7) = enc_type;
      uVar1 = *frame_addr;
      *(uint8_t *)(uVar1 + 8) = enc_type;
      *(undefined *)(uVar1 + 9) = 0;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 10) = 0;
      *(undefined *)(uVar1 + 0xb) = 0xf;
      *(undefined *)(uVar1 + 0xc) = 0xac;
      *(uint8_t *)(uVar1 + 0xd) = enc_type;
      uVar1 = *frame_addr;
      *(undefined *)(uVar1 + 0x11) = 4;
      *(undefined *)(uVar1 + 0xe) = 0;
      *(undefined *)(uVar1 + 0xf) = 0xf;
      *(undefined *)(uVar1 + 0x10) = 0xac;
      uVar2 = *frame_addr;
      uVar1 = 0x1a;
      *(undefined *)(uVar2 + 0x12) = 1;
      *(undefined *)(uVar2 + 0x13) = 0;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x14) = 0;
      *(undefined *)(uVar2 + 0x15) = 0xf;
      *(undefined *)(uVar2 + 0x16) = 0xac;
      *(uint8_t *)(uVar2 + 0x17) = enc_type;
      uVar2 = *frame_addr;
      *(undefined *)(uVar2 + 0x18) = 0;
      *(undefined *)(uVar2 + 0x19) = 0;
    }
  }
  *frame_addr = *frame_addr + uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint32_t me_add_ie_wpa(uint32_t *frame_addr,uint8_t enc_type)

{
  uint32_t uVar1;
  undefined3 in_register_0000202d;
  uint32_t uVar2;
  
  uVar1 = 0;
  if (CONCAT31(in_register_0000202d,enc_type) == 2) {
    *(undefined *)*frame_addr = 0xdd;
    *(undefined *)(*frame_addr + 1) = 0x1c;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 5) = 1;
    *(undefined *)(uVar1 + 2) = 0;
    *(undefined *)(uVar1 + 3) = 0x50;
    *(undefined *)(uVar1 + 4) = 0xf2;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 6) = 1;
    *(undefined *)(uVar1 + 7) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 8) = 0;
    *(undefined *)(uVar1 + 9) = 0x50;
    *(undefined *)(uVar1 + 10) = 0xf2;
    *(uint8_t *)(uVar1 + 0xb) = enc_type;
    uVar1 = *frame_addr;
    *(uint8_t *)(uVar1 + 0xc) = enc_type;
    *(undefined *)(uVar1 + 0xd) = 0;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0xe) = 0;
    *(undefined *)(uVar1 + 0xf) = 0x50;
    *(undefined *)(uVar1 + 0x10) = 0xf2;
    *(uint8_t *)(uVar1 + 0x11) = enc_type;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x12) = 0;
    *(undefined *)(uVar1 + 0x13) = 0x50;
    *(undefined *)(uVar1 + 0x14) = 0xf2;
    *(undefined *)(uVar1 + 0x15) = 4;
    uVar1 = *frame_addr;
    *(undefined *)(uVar1 + 0x16) = 1;
    *(undefined *)(uVar1 + 0x17) = 0;
    uVar2 = *frame_addr;
    uVar1 = 0x1e;
    *(undefined *)(uVar2 + 0x18) = 0;
    *(undefined *)(uVar2 + 0x19) = 0x50;
    *(undefined *)(uVar2 + 0x1a) = 0xf2;
    *(uint8_t *)(uVar2 + 0x1b) = enc_type;
  }
  *frame_addr = *frame_addr + uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint32_t me_add_ie_tim(uint32_t *frame_addr,uint8_t dtim_period)

{
  *(undefined *)*frame_addr = 5;
  *(undefined *)(*frame_addr + 1) = 4;
  *(uint8_t *)(*frame_addr + 3) = dtim_period;
  *frame_addr = *frame_addr + 6;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 6;
}



uint32_t me_add_ie_ht_capa(uint32_t *frame_addr)

{
  uint16_t uVar1;
  uint32_t uVar2;
  uint uVar3;
  
  uVar3 = (uint)me_env.ht_cap.ht_capa_info;
  *(undefined *)*frame_addr = 0x2d;
  *(undefined *)(*frame_addr + 1) = 0x1a;
  uVar2 = *frame_addr;
  *(byte *)(uVar2 + 2) = (byte)(uVar3 & 0xfffffff3) | 0xc;
  *(char *)(uVar2 + 3) = (char)((uVar3 & 0xfffffff3) >> 8);
  *(uint8_t *)(*frame_addr + 4) = me_env.ht_cap.a_mpdu_param;
  co_pack8p(*frame_addr + 5,me_env.ht_cap.mcs_rate,0x10);
  uVar1 = me_env.ht_cap.ht_extended_capa;
  uVar2 = *frame_addr;
  *(char *)(uVar2 + 0x15) = (char)me_env.ht_cap.ht_extended_capa;
  *(char *)(uVar2 + 0x16) = (char)(uVar1 >> 8);
  co_pack8p(*frame_addr + 0x17,(uint8_t *)&me_env.ht_cap.tx_beamforming_capa,4);
  *(uint8_t *)(*frame_addr + 0x1b) = me_env.ht_cap.asel_capa;
  *frame_addr = *frame_addr + 0x1c;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0x1c;
}



uint32_t me_add_ie_ht_oper(uint32_t *frame_addr,vif_info_tag *p_vif_entry)

{
  chan_ctxt_tag *pcVar1;
  int iVar2;
  uint8_t uVar3;
  uint32_t uVar4;
  
  pcVar1 = p_vif_entry->chan_ctxt;
  *(undefined *)*frame_addr = 0x3d;
  *(undefined *)(*frame_addr + 1) = 0x16;
  iVar2 = phy_freq_to_channel((pcVar1->channel).band,(pcVar1->channel).prim20_freq);
  *(char *)(*frame_addr + 2) = (char)iVar2;
  uVar3 = (pcVar1->channel).type;
  if ((uVar3 != '\0') &&
     (uVar3 = '\a', (pcVar1->channel).prim20_freq <= (pcVar1->channel).center1_freq)) {
    uVar3 = '\x05';
  }
  *(uint8_t *)(*frame_addr + 3) = uVar3;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 4) = 3;
  *(undefined *)(uVar4 + 5) = 0;
  uVar4 = *frame_addr;
  *(undefined *)(uVar4 + 6) = 0;
  *(undefined *)(uVar4 + 7) = 0;
  *(undefined *)(*frame_addr + 8) = 0xff;
  *frame_addr = *frame_addr + 0x18;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0x18;
}



uint16_t me_build_authenticate
                   (uint32_t frame,uint16_t algo_type,uint16_t seq_nbr,uint16_t status_code,
                   uint32_t *challenge_array_ptr)

{
  undefined *puVar1;
  undefined *puVar2;
  int iVar3;
  
  *(char *)frame = (char)algo_type;
  *(char *)(frame + 2) = (char)seq_nbr;
  *(char *)(frame + 4) = (char)status_code;
  *(char *)(frame + 1) = (char)(algo_type >> 8);
  *(char *)(frame + 3) = (char)(seq_nbr >> 8);
  *(char *)(frame + 5) = (char)(status_code >> 8);
  if (challenge_array_ptr != (uint32_t *)0x0) {
    *(undefined *)(frame + 6) = 0x10;
    *(undefined *)(frame + 7) = 0x80;
    iVar3 = 0;
    do {
      puVar1 = (undefined *)((int)challenge_array_ptr + iVar3);
      puVar2 = (undefined *)(frame + 8 + iVar3);
      iVar3 = iVar3 + 1;
      *puVar2 = *puVar1;
    } while (iVar3 != 0x80);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0x88;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 6;
}



uint16_t me_build_deauthenticate(uint32_t frame,uint16_t reason_code)

{
  *(char *)frame = (char)reason_code;
  *(char *)(frame + 1) = (char)(reason_code >> 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_req
                   (uint32_t frame,mac_bss_info *bss,mac_addr *old_ap_addr_ptr,uint8_t vif_idx,
                   uint32_t *ie_addr,uint16_t *ie_len,sm_connect_req *con_par)

{
  byte bVar1;
  u32_l *puVar2;
  u8_l uVar3;
  uint8_t uVar4;
  ushort uVar5;
  mac_ssid *pmVar6;
  int8_t *piVar7;
  uint uVar8;
  u16_l uVar9;
  short sVar10;
  int iVar11;
  uint16_t uVar12;
  uint32_t uVar13;
  uint32_t uVar14;
  uint uVar15;
  char *pcVar16;
  int8_t *piVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  ushort uVar21;
  me_chan_config_req *pmVar22;
  char cVar23;
  char cVar24;
  ushort uVar25;
  uint8_t uVar26;
  int8_t *apiStack100 [4];
  int8_t iStack81;
  undefined2 uStack80;
  undefined uStack78;
  int8_t min;
  int8_t max;
  undefined uStack73;
  u8_l uStack72;
  
  uVar9 = con_par->listen_interval;
  uVar5 = con_par->ie_len;
  uVar3 = con_par->uapsd_queues;
  if (uVar9 == 0) {
    uVar9 = 5;
  }
  apiStack100[0] = (int8_t *)frame;
  uVar12 = me_build_capability(vif_idx);
  *apiStack100[0] = (int8_t)uVar12;
  apiStack100[0][1] = (int8_t)(uVar12 >> 8);
  apiStack100[0][2] = (int8_t)uVar9;
  apiStack100[0][3] = (int8_t)(uVar9 >> 8);
  iVar11 = 4;
  if (old_ap_addr_ptr != (mac_addr *)0x0) {
    iVar11 = 10;
    *(uint16_t *)(apiStack100[0] + 4) = old_ap_addr_ptr->array[0];
    *(uint16_t *)(apiStack100[0] + 6) = old_ap_addr_ptr->array[1];
    *(uint16_t *)(apiStack100[0] + 8) = old_ap_addr_ptr->array[2];
  }
  apiStack100[0] = apiStack100[0] + iVar11;
  *ie_addr = (uint32_t)apiStack100[0];
  uVar13 = me_add_ie_ssid((uint32_t *)apiStack100,(bss->ssid).length,(bss->ssid).array);
  uVar14 = me_add_ie_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
  sVar10 = (short)iVar11 + (short)uVar14 + (short)uVar13;
  if (8 < (bss->rate_set).length) {
    uVar13 = me_add_ie_ext_supp_rates((uint32_t *)apiStack100,&bss->rate_set);
    sVar10 = sVar10 + (short)uVar13;
  }
  if ((uVar12 & 0x100) != 0) {
    piVar17 = apiStack100[0] + 1;
    *apiStack100[0] = '!';
    apiStack100[0] = apiStack100[0] + 2;
    *piVar17 = '\x02';
    phy_get_rf_gain_capab((int8_t *)&uStack80,&iStack81);
    bVar1 = bss->chan->tx_power;
    if ((char)bVar1 < (char)uStack80) {
      uStack80 = uStack80 & 0xff00 | (ushort)bVar1;
    }
    *apiStack100[0] = iStack81;
    apiStack100[0][1] = (char)uStack80;
    piVar17 = apiStack100[0] + 3;
    apiStack100[0][2] = '$';
    apiStack100[0] = apiStack100[0] + 4;
    if (bss->chan->band == '\0') {
      pmVar22 = &me_env.chan;
      iVar11 = 1;
      uVar4 = me_env.chan.chan2G4_cnt;
    }
    else {
      pmVar22 = (me_chan_config_req *)me_env.chan.chan5G;
      iVar11 = 4;
      uVar4 = me_env.chan.chan5G_cnt;
    }
    uVar21 = 0;
    cVar23 = '\0';
    uVar26 = '\0';
    uVar8 = 0;
    uVar19 = 0;
    while( true ) {
      piVar7 = apiStack100[0];
      uVar25 = uVar21 + 2 & 0xff;
      pcVar16 = apiStack100[0] + 1;
      if (uVar26 == uVar4) break;
      uVar18 = uVar8;
      uVar20 = uVar19;
      if ((pmVar22->chan2G4[0].flags & 2) == 0) {
        uVar15 = phy_freq_to_channel(pmVar22->chan2G4[0].band,pmVar22->chan2G4[0].freq);
        uVar18 = uVar15 & 0xff;
        uVar20 = uVar18;
        cVar24 = cVar23;
        if ((cVar23 != '\0') && (uVar20 = uVar19, (uVar15 & 0xff) - uVar8 != iVar11)) {
          cVar24 = cVar23 + '\x01';
          *piVar7 = (int8_t)uVar19;
          apiStack100[0] = piVar7 + 2;
          *pcVar16 = cVar23;
          uVar21 = uVar25;
        }
        cVar23 = cVar24 + '\x01';
        pmVar22 = (me_chan_config_req *)(pmVar22->chan2G4 + 1);
      }
      uVar26 = uVar26 + '\x01';
      uVar8 = uVar18;
      uVar19 = uVar20;
    }
    *apiStack100[0] = (int8_t)uVar19;
    sVar10 = sVar10 + 6 + uVar25;
    apiStack100[0] = apiStack100[0] + 2;
    *pcVar16 = cVar23;
    *piVar17 = (int8_t)uVar25;
  }
  pmVar6 = &con_par->ssid;
  iVar11 = -(int)con_par;
  while ((sm_connect_req *)(pmVar6->array + (uVar5 - 1)) != con_par) {
    puVar2 = con_par->ie_buf;
    piVar17 = apiStack100[0] + iVar11 + (int)con_par;
    con_par = (sm_connect_req *)(con_par->ssid).array;
    *piVar17 = *(int8_t *)puVar2;
  }
  uVar12 = sVar10 + uVar5;
  piVar17 = apiStack100[0] + uVar5;
  apiStack100[0] = piVar17;
  if ((bss->valid_flags & 1) != 0) {
    memset(&uStack78,0,0xe);
    uStack80 = 0x7dd;
    min = 'P';
    _max = 0x2f2;
    uStack73 = 1;
    if ((ps_env.uapsd_timeout != 0) && ((char)(bss->edca_param).qos_info < '\0')) {
      uStack72 = uVar3;
    }
    co_pack8p((uint32_t)piVar17,(uint8_t *)&uStack80,9);
    uVar12 = uVar12 + uStack80._1_1_ + 2;
    apiStack100[0] = apiStack100[0] + uStack80._1_1_ + 2;
  }
  if (((bss->valid_flags & 2) != 0) && (me_env.ht_supported != false)) {
    uVar13 = me_add_ie_ht_capa((uint32_t *)apiStack100);
    uVar12 = uVar12 + (short)uVar13;
  }
  *ie_len = (short)apiStack100[0] - (short)*ie_addr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar12;
}



uint16_t me_build_add_ba_req(uint32_t frame,bam_env_tag *bam_env)

{
  uint16_t uVar1;
  uint uVar2;
  int iVar3;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 0;
  *(uint8_t *)(frame + 2) = bam_env->dialog_token;
  uVar2 = (uint)bam_env->ba_policy << 1 | (uint)bam_env->tid << 2 | (uint)bam_env->buffer_size << 6;
  *(char *)(frame + 3) = (char)uVar2;
  *(char *)(frame + 4) = (char)(uVar2 >> 8);
  uVar1 = bam_env->ba_timeout;
  *(char *)(frame + 5) = (char)uVar1;
  *(char *)(frame + 6) = (char)(uVar1 >> 8);
  iVar3 = (uint)bam_env->ssn << 0x14;
  *(char *)(frame + 7) = (char)((uint)iVar3 >> 0x10);
  *(char *)(frame + 8) = (char)((uint)iVar3 >> 0x18);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 9;
}



uint16_t me_build_add_ba_rsp(uint32_t frame,bam_env_tag *bam_env,uint16_t param,uint8_t dialog_token
                            ,uint16_t status_code)

{
  undefined2 in_register_0000203a;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 1;
  *(char *)(frame + 5) = (char)param;
  *(char *)(frame + 4) = (char)(status_code >> 8);
  *(uint8_t *)(frame + 2) = dialog_token;
  *(char *)(frame + 3) = (char)status_code;
  *(char *)(frame + 6) = (char)(param >> 8);
  if (CONCAT22(in_register_0000203a,status_code) == 0) {
    *(undefined *)(frame + 7) = 0xd0;
    *(undefined *)(frame + 8) = 7;
  }
  else {
    *(undefined *)(frame + 7) = 0;
    *(undefined *)(frame + 8) = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 9;
}



uint16_t me_build_del_ba(uint32_t frame,bam_env_tag *bam_env,uint16_t reason_code)

{
  byte bVar1;
  
  *(undefined *)frame = 3;
  *(undefined *)(frame + 1) = 2;
  bVar1 = (byte)(((uint)bam_env->tid << 0x1c) >> 0x18);
  if (bam_env->dev_type == '\x01') {
    bVar1 = bVar1 | 8;
  }
  *(undefined *)(frame + 2) = 0;
  *(byte *)(frame + 3) = bVar1;
  *(char *)(frame + 4) = (char)reason_code;
  *(char *)(frame + 5) = (char)(reason_code >> 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 6;
}



void me_extract_rate_set(uint32_t buffer,uint16_t buflen,mac_rateset *mac_rate_set_ptr)

{
  byte bVar1;
  byte bVar2;
  uint32_t uVar3;
  uint uVar4;
  uint8_t *puVar5;
  uint uVar6;
  
  mac_rate_set_ptr->length = '\0';
  uVar3 = mac_ie_find(buffer,buflen,'\x01');
  if (uVar3 != 0) {
    bVar1 = *(byte *)(uVar3 + 1);
    uVar4 = (uint)bVar1;
    if (uVar4 < 0xd) {
      puVar5 = mac_rate_set_ptr->array;
      while (uVar4 = uVar4 - 1, uVar4 != 0xffffffff) {
        *puVar5 = (puVar5 + 1)[uVar3 - (int)mac_rate_set_ptr];
        puVar5 = puVar5 + 1;
      }
      mac_rate_set_ptr->length = bVar1;
      uVar3 = mac_ie_find(buffer,buflen,'2');
      if (uVar3 != 0) {
        bVar1 = *(byte *)(uVar3 + 1);
        uVar4 = (uint)bVar1;
        if (0xc < mac_rate_set_ptr->length + uVar4) {
          assert_err("mac_rate_set_ptr->length + elmt_length <= MAC_RATESET_LEN","module",0x396);
        }
        bVar2 = mac_rate_set_ptr->length;
        if (bVar2 + uVar4 < 0xd) {
          uVar6 = 0;
          while (uVar4 != uVar6) {
            mac_rate_set_ptr->array[bVar2 + uVar6] = *(uint8_t *)(uVar3 + 2 + uVar6);
            uVar6 = uVar6 + 1;
          }
          mac_rate_set_ptr->length = bVar1 + mac_rate_set_ptr->length;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_extract_power_constraint(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  uint32_t uVar1;
  uint8_t uVar2;
  
  uVar1 = mac_ie_find(buffer,buflen,' ');
  uVar2 = '\0';
  if (uVar1 != 0) {
    uVar2 = *(uint8_t *)(uVar1 + 2);
  }
  bss->power_constraint = uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_extract_country_reg(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  scan_chan_tag *psVar1;
  uint32_t uVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  int iVar8;
  
  uVar2 = mac_ie_find(buffer,buflen,'\a');
  if (uVar2 != 0) {
    psVar1 = bss->chan;
    iVar8 = 1;
    if (psVar1->band != '\0') {
      iVar8 = 4;
    }
    uVar3 = phy_freq_to_channel(psVar1->band,psVar1->freq);
    uVar7 = 5;
    while (uVar7 <= *(byte *)(uVar2 + 1) + 1) {
      pbVar4 = (byte *)(uVar7 + uVar2);
      uVar5 = (uint)*pbVar4;
      bVar6 = 0;
      while (bVar6 != pbVar4[1]) {
        if (uVar5 == (uVar3 & 0xff)) {
          psVar1->tx_power = pbVar4[2];
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        bVar6 = bVar6 + 1;
        uVar5 = uVar5 + iVar8 & 0xff;
      }
      uVar7 = uVar7 + 3 & 0xff;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void me_extract_mobility_domain(uint32_t buffer,uint16_t buflen,mac_bss_info *bss)

{
  uint32_t uVar1;
  
  uVar1 = mac_ie_find(buffer,buflen,'6');
  if (uVar1 == 0) {
    (bss->mde).mdid = 0;
    (bss->mde).ft_capability_policy = '\0';
  }
  else {
    (bss->mde).mdid = *(uint16_t *)(uVar1 + 2);
    (bss->mde).ft_capability_policy = *(uint8_t *)(uVar1 + 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int me_extract_csa(uint32_t buffer,uint16_t buflen,uint8_t *mode,mm_chan_ctxt_add_req *chan_desc)

{
  byte bVar1;
  byte bVar2;
  bool band;
  uint uVar3;
  uint16_t uVar4;
  uint16_t uVar5;
  uint16_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  uint32_t uVar10;
  uint uVar11;
  uint8_t uVar12;
  
  uVar7 = mac_ie_find(buffer,buflen,'%');
  uVar8 = mac_ie_find(buffer,buflen,'<');
  if ((uVar7 | uVar8) == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uVar9 = mac_ie_find(buffer,buflen,'>');
  uVar10 = mac_ie_find(buffer,buflen,-0x3c);
  if (uVar10 != 0) {
    uVar10 = mac_ie_find(uVar10 + 2,(ushort)*(byte *)(uVar10 + 1),-0x3e);
  }
  if (uVar7 == 0) {
    bVar1 = *(byte *)(uVar8 + 5);
    *mode = *(uint8_t *)(uVar8 + 2);
    bVar2 = *(byte *)(uVar8 + 4);
  }
  else {
    bVar1 = *(byte *)(uVar7 + 4);
    *mode = *(uint8_t *)(uVar7 + 2);
    bVar2 = *(byte *)(uVar7 + 3);
  }
  uVar3 = (uint)bVar1;
  if (uVar3 == 0) {
    uVar3 = 2;
  }
  band = 0xe < bVar2;
  uVar4 = phy_channel_to_freq(band,(uint)bVar2);
  if (uVar10 != 0) {
    uVar11 = *(byte *)(uVar10 + 2) - 1 & 0xff;
    bVar1 = *(byte *)(uVar10 + 4);
    uVar12 = '\x01';
    if (uVar11 < 3) {
      uVar12 = *(uint8_t *)((int)&CSWTCH_115 + uVar11);
    }
    uVar5 = phy_channel_to_freq(band,(uint)*(byte *)(uVar10 + 3));
    uVar6 = 0;
    if (bVar1 != 0) {
      uVar6 = phy_channel_to_freq(band,(uint)bVar1);
    }
    goto LAB_2301d564;
  }
  if (uVar9 == 0) {
LAB_2301d5c6:
    uVar6 = 0;
    uVar12 = '\0';
    uVar5 = uVar4;
  }
  else {
    uVar5 = uVar4 + 10;
    if (*(char *)(uVar9 + 2) != '\x01') {
      if (*(char *)(uVar9 + 2) != '\x03') goto LAB_2301d5c6;
      uVar5 = uVar4 - 10;
    }
    uVar6 = 0;
    uVar12 = '\x01';
  }
LAB_2301d564:
  chan_desc->center2_freq = uVar6;
  chan_desc->band = band;
  chan_desc->type = uVar12;
  chan_desc->prim20_freq = uVar4;
  chan_desc->center1_freq = uVar5;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_beacon(uint32_t frame,uint8_t vif_idx,uint16_t *tim_oft,uint8_t *tim_len,
                        uint8_t hidden_ssid)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint8_t ssid_len;
  undefined3 in_register_0000202d;
  int iVar7;
  uint8_t *p_ssid;
  undefined3 in_register_00002039;
  uint uVar8;
  int iVar9;
  undefined *puVar10;
  mac_rateset *p_rateset;
  uint32_t uStack68;
  undefined2 uStack64;
  undefined uStack62;
  undefined uStack61;
  uint8_t wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  *(undefined *)frame = 0x80;
  *(undefined *)(frame + 1) = 0;
  *(undefined *)(frame + 2) = 0;
  *(undefined *)(frame + 3) = 0;
  uStack68 = frame;
  memcpy((void *)(frame + 4),&mac_addr_bcst,6);
  memcpy((void *)(frame + 10),&vif_info_tab[iVar7].mac_addr,6);
  memcpy((void *)(frame + 0x10),&vif_info_tab[iVar7].mac_addr,6);
  uVar8 = (uint)txl_cntrl_env.seqnbr;
  txl_cntrl_env.seqnbr = (uint16_t)((uVar8 + 1) * 0x10000 >> 0x10);
  iVar9 = (uVar8 + 1) * 0x100000;
  *(char *)(frame + 0x16) = (char)((uint)iVar9 >> 0x10);
  *(char *)(frame + 0x17) = (char)((uint)iVar9 >> 0x18);
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(char *)(uStack68 + 0x20) = (char)uVar2;
  *(char *)(uStack68 + 0x21) = (char)(uVar2 >> 8);
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  p_ssid = vif_info_tab[iVar7].bss_info.ssid.array;
  *(char *)(uStack68 + 0x22) = (char)uVar2;
  *(char *)(uStack68 + 0x23) = (char)(uVar2 >> 8);
  uStack68 = uStack68 + 0x24;
  if (CONCAT31(in_register_00002039,hidden_ssid) == 0) {
    ssid_len = vif_info_tab[iVar7].bss_info.ssid.length;
  }
  else {
    printf("Using Hidden SSID [%s]\r\n",p_ssid);
    p_ssid = (uint8_t *)0x0;
    ssid_len = '\0';
  }
  uVar3 = me_add_ie_ssid(&uStack68,ssid_len,p_ssid);
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar4 = me_add_ie_supp_rates(&uStack68,p_rateset);
  uVar8 = (uVar3 + 0x24 & 0xffff) + uVar4 & 0xffff;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack68,p_rateset);
    uVar8 = uVar8 + uVar3 & 0xffff;
  }
  uVar3 = me_add_ie_ds(&uStack68,
                       (char)((int)((vif_info_tab[iVar7].bss_info.chan)->freq - 0x96c) / 5) + '\x01'
                      );
  *tim_oft = (uint16_t)((uVar8 + uVar3) * 0x10000 >> 0x10);
  uVar4 = me_add_ie_tim(&uStack68,*(uint8_t *)&vif_info_tab[iVar7].bss_info.beacon_period);
  *tim_len = (uint8_t)(uVar4 & 0xff);
  uVar5 = me_add_ie_rsn(&uStack68,enc_type);
  memcpy(int_rsn_ie,(void *)(uStack68 - (uVar5 & 0xff)),uVar5 & 0xff);
  uVar6 = me_add_ie_erp(&uStack68,'\0');
  sVar1 = (short)(uVar8 + uVar3) + (short)(uVar4 & 0xff) + (short)uVar6 + ((ushort)uVar5 & 0xff);
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack68);
    uVar4 = me_add_ie_ht_oper(&uStack68,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack68,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack62,0,0xe);
    uStack64 = 0x7dd;
    uStack61 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack68,(uint8_t *)&uStack64,9);
    *(char *)(uStack68 + 1) = *(char *)(uStack68 + 1) + '\x11';
    puVar10 = (undefined *)(uStack68 + 2 + (uint)uStack64._1_1_);
    *puVar10 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar10[1] = (char)uVar3;
    puVar10[2] = (char)(uVar3 >> 8);
    puVar10[3] = (char)(uVar3 >> 0x10);
    puVar10[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar10[5] = (char)uVar3;
    puVar10[6] = (char)(uVar3 >> 8);
    puVar10[7] = (char)(uVar3 >> 0x10);
    puVar10[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar10[9] = (char)uVar3;
    puVar10[10] = (char)(uVar3 >> 8);
    puVar10[0xb] = (char)(uVar3 >> 0x10);
    puVar10[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar10[0xd] = (char)uVar3;
    puVar10[0xe] = (char)(uVar3 >> 8);
    puVar10[0xf] = (char)(uVar3 >> 0x10);
    puVar10[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + uStack64._1_1_ + 0x13;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



// WARNING: Variable defined which should be unmapped: wme_ie
// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_probe_rsp(uint32_t frame,uint8_t vif_idx)

{
  uint8_t enc_type;
  short sVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  int iVar5;
  uint32_t uVar6;
  undefined3 in_register_0000202d;
  int iVar7;
  scan_chan_tag *psVar8;
  undefined *puVar9;
  mac_rateset *p_rateset;
  uint32_t uStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  uint8_t wme_ie [16];
  
  iVar7 = CONCAT31(in_register_0000202d,vif_idx);
  enc_type = vif_info_tab[iVar7].bss_info.sec_type;
  uVar2 = vif_info_tab[iVar7].bss_info.beacon_interval;
  *(char *)(frame + 8) = (char)uVar2;
  *(char *)(frame + 9) = (char)(uVar2 >> 8);
  uStack52 = frame;
  uVar2 = me_build_capability(vif_idx);
  if (enc_type != '\0') {
    uVar2 = uVar2 | 0x10;
  }
  *(char *)(uStack52 + 10) = (char)uVar2;
  *(char *)(uStack52 + 0xb) = (char)(uVar2 >> 8);
  uStack52 = uStack52 + 0xc;
  p_rateset = &vif_info_tab[iVar7].bss_info.rate_set;
  uVar3 = me_add_ie_ssid(&uStack52,vif_info_tab[iVar7].bss_info.ssid.length,
                         vif_info_tab[iVar7].bss_info.ssid.array);
  uVar4 = me_add_ie_supp_rates(&uStack52,p_rateset);
  sVar1 = (short)uVar3 + (short)uVar4 + 0xc;
  if (8 < vif_info_tab[iVar7].bss_info.rate_set.length) {
    uVar3 = me_add_ie_ext_supp_rates(&uStack52,p_rateset);
    sVar1 = sVar1 + (short)uVar3;
  }
  psVar8 = vif_info_tab[iVar7].bss_info.chan;
  iVar5 = phy_freq_to_channel(psVar8->band,psVar8->freq);
  uVar3 = me_add_ie_ds(&uStack52,(uint8_t)iVar5);
  uVar4 = me_add_ie_rsn(&uStack52,enc_type);
  uVar6 = me_add_ie_erp(&uStack52,'\0');
  sVar1 = sVar1 + (short)uVar4 + (short)uVar3 + (short)uVar6;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 2) != 0) {
    uVar3 = me_add_ie_ht_capa(&uStack52);
    uVar4 = me_add_ie_ht_oper(&uStack52,vif_info_tab + iVar7);
    sVar1 = sVar1 + (short)uVar4 + (short)uVar3;
  }
  uVar3 = me_add_ie_wpa(&uStack52,enc_type);
  uVar2 = sVar1 + (short)uVar3;
  if ((vif_info_tab[iVar7].bss_info.valid_flags & 1) != 0) {
    memset(&uStack46,0,0xe);
    uStack48 = 0x7dd;
    uStack45 = 0x50;
    wme_ie._0_2_ = 0x2f2;
    wme_ie[3] = '\x01';
    wme_ie[4] = vif_info_tab[iVar7].bss_info.edca_param.qos_info;
    co_pack8p(uStack52,(uint8_t *)&uStack48,9);
    *(char *)(uStack52 + 1) = *(char *)(uStack52 + 1) + '\x11';
    puVar9 = (undefined *)(uStack52 + 2 + (uint)uStack48._1_1_);
    *puVar9 = 0;
    uVar3 = vif_info_tab[iVar7].txq_params[1];
    puVar9[1] = (char)uVar3;
    puVar9[2] = (char)(uVar3 >> 8);
    puVar9[3] = (char)(uVar3 >> 0x10);
    puVar9[4] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[0];
    puVar9[5] = (char)uVar3;
    puVar9[6] = (char)(uVar3 >> 8);
    puVar9[7] = (char)(uVar3 >> 0x10);
    puVar9[8] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[2];
    puVar9[9] = (char)uVar3;
    puVar9[10] = (char)(uVar3 >> 8);
    puVar9[0xb] = (char)(uVar3 >> 0x10);
    puVar9[0xc] = (char)(uVar3 >> 0x18);
    uVar3 = vif_info_tab[iVar7].txq_params[3];
    puVar9[0xd] = (char)uVar3;
    puVar9[0xe] = (char)(uVar3 >> 8);
    puVar9[0xf] = (char)(uVar3 >> 0x10);
    puVar9[0x10] = (char)(uVar3 >> 0x18);
    uVar2 = uVar2 + uStack48._1_1_ + 0x13;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

uint16_t me_build_associate_rsp
                   (uint32_t frame,uint8_t vif_idx,uint16_t status_code,me_sta_add_req *req)

{
  uint8_t uVar1;
  ushort uVar2;
  uint16_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  undefined2 in_register_00002032;
  undefined *puStack52;
  undefined2 uStack48;
  undefined uStack46;
  undefined uStack45;
  uint8_t wme_ie [16];
  
  iVar6 = CONCAT31(in_register_0000202d,vif_idx);
  uVar1 = vif_info_tab[iVar6].bss_info.sec_type;
  puStack52 = (undefined *)frame;
  uVar3 = me_build_capability(vif_idx);
  if (uVar1 != '\0') {
    uVar3 = uVar3 | 0x10;
  }
  *puStack52 = (char)uVar3;
  puStack52[1] = (char)(uVar3 >> 8);
  uVar3 = 6;
  puStack52[2] = (char)status_code;
  puStack52[3] = (char)(status_code >> 8);
  uVar2 = req->aid;
  puStack52[4] = (char)uVar2;
  puStack52[5] = (byte)((uint)uVar2 >> 8) | 0xc0;
  puStack52 = puStack52 + 6;
  if (CONCAT22(in_register_00002032,status_code) == 0) {
    uVar4 = me_add_ie_supp_rates((uint32_t *)&puStack52,&req->rate_set);
    uVar3 = (short)uVar4 + 6;
    if (8 < (req->rate_set).length) {
      uVar4 = me_add_ie_ext_supp_rates((uint32_t *)&puStack52,&req->rate_set);
      uVar3 = uVar3 + (short)uVar4;
    }
    if ((req->flags & 2) != 0) {
      uVar4 = me_add_ie_ht_capa((uint32_t *)&puStack52);
      uVar5 = me_add_ie_ht_oper((uint32_t *)&puStack52,vif_info_tab + iVar6);
      uVar3 = uVar3 + (short)uVar5 + (short)uVar4;
    }
    if ((req->flags & 1) != 0) {
      memset(&uStack46,0,0xe);
      uStack48 = 0x7dd;
      uStack45 = 0x50;
      wme_ie._0_2_ = 0x2f2;
      wme_ie[3] = '\x01';
      wme_ie[4] = vif_info_tab[iVar6].bss_info.edca_param.qos_info;
      co_pack8p((uint32_t)puStack52,(uint8_t *)&uStack48,9);
      puStack52[1] = puStack52[1] + '\x11';
      puStack52 = puStack52 + uStack48._1_1_ + 2;
      *puStack52 = 0;
      uVar4 = vif_info_tab[iVar6].txq_params[1];
      puStack52[1] = (char)uVar4;
      puStack52[2] = (char)(uVar4 >> 8);
      puStack52[3] = (char)(uVar4 >> 0x10);
      puStack52[4] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[0];
      puStack52[5] = (char)uVar4;
      puStack52[6] = (char)(uVar4 >> 8);
      puStack52[7] = (char)(uVar4 >> 0x10);
      puStack52[8] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[2];
      puStack52[9] = (char)uVar4;
      puStack52[10] = (char)(uVar4 >> 8);
      puStack52[0xb] = (char)(uVar4 >> 0x10);
      puStack52[0xc] = (char)(uVar4 >> 0x18);
      uVar4 = vif_info_tab[iVar6].txq_params[3];
      puStack52[0xd] = (char)uVar4;
      puStack52[0xe] = (char)(uVar4 >> 8);
      puStack52[0xf] = (char)(uVar4 >> 0x10);
      puStack52[0x10] = (char)(uVar4 >> 0x18);
      uVar3 = uVar3 + uStack48._1_1_ + 0x13;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



int me_rc_set_rate_req_handler
              (ke_msg_id_t msgid,me_rc_set_rate_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  byte bVar1;
  uint16_t fixed_rate_config;
  rc_sta_stats *rc_ss;
  _Bool _Var2;
  undefined3 extraout_var;
  
  bVar1 = param->sta_idx;
  rc_ss = sta_info_tab[bVar1].pol_tbl.sta_stats;
  if (rc_ss == (rc_sta_stats *)0x0) {
    assert_err("rc_ss != NULL","module",0x31d);
  }
  fixed_rate_config = param->fixed_rate_cfg;
  if (fixed_rate_config == 0xffff) {
    rc_ss->fixed_rate_cfg = 0xffff;
    rc_ss->info = rc_ss->info & 0x9f;
    rc_update_bw_nss_max(sta_info_tab[bVar1].staid,rc_ss->bw_max,rc_ss->no_ss);
  }
  else {
    _Var2 = rc_check_fixed_rate_config(rc_ss,fixed_rate_config);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      rc_ss->fixed_rate_cfg = fixed_rate_config;
      rc_ss->info = rc_ss->info & 0x9f | 0x20;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_rc_stats_req_handler
              (ke_msg_id_t msgid,me_rc_stats_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  rc_sta_stats *rc_ss;
  byte *pbVar1;
  uint32_t uVar2;
  uint uVar3;
  
  pbVar1 = (byte *)ke_msg_alloc(0x140f,src_id,dest_id,0xd0);
  rc_ss = sta_info_tab[param->sta_idx].pol_tbl.sta_stats;
  *pbVar1 = param->sta_idx;
  if (rc_ss == (rc_sta_stats *)0x0) {
    *(undefined2 *)(pbVar1 + 2) = 0;
  }
  else {
    *(uint16_t *)(pbVar1 + 2) = rc_ss->no_samples;
    uVar3 = 0;
    *(uint16_t *)(pbVar1 + 4) = rc_ss->ampdu_len;
    *(uint16_t *)(pbVar1 + 6) = rc_ss->ampdu_packets;
    *(uint32_t *)(pbVar1 + 8) = rc_ss->avg_ampdu_len;
    pbVar1[0xc] = rc_ss->sw_retry_step;
    pbVar1[0xd] = rc_ss->sample_wait;
    memcpy(pbVar1 + 0x10,rc_ss->retry,0x20);
    memcpy(pbVar1 + 0x30,rc_ss->rate_stats,0x78);
    while (uVar3 < rc_ss->no_samples) {
      uVar2 = rc_calc_tp(rc_ss,(uint8_t)uVar3);
      *(uint32_t *)(pbVar1 + (uVar3 + 0x28) * 4 + 8) = uVar2;
      uVar3 = uVar3 + 1 & 0xffff;
    }
  }
  ke_msg_send(pbVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_traffic_ind_req_handler
              (ke_msg_id_t msgid,me_traffic_ind_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  uint16_t *puVar2;
  sta_ps_traffic sVar3;
  sta_ps_traffic sVar4;
  
  uVar1 = (uint)param->sta_idx;
  sVar4 = sta_info_tab[uVar1].traffic_avail;
  if (param->uapsd == false) {
    if (param->tx_avail == '\0') {
      sVar4 = sVar4 & ~PS_TRAFFIC_HOST;
    }
    else {
      sVar4 = sVar4 | PS_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar4;
  }
  else {
    sVar3 = sVar4 & ~UAPSD_TRAFFIC_HOST;
    if (param->tx_avail != '\0') {
      sVar3 = sVar4 | UAPSD_TRAFFIC_HOST;
    }
    sta_info_tab[uVar1].traffic_avail = sVar3;
    if (sta_info_tab[uVar1].info.uapsd_queues != '\x0f') goto LAB_2301df24;
  }
  puVar2 = (uint16_t *)ke_msg_alloc(0x41,0,5,4);
  *puVar2 = sta_info_tab[uVar1].aid;
  *(uint8_t *)((int)puVar2 + 3) = sta_info_tab[uVar1].inst_nbr;
  *(uint8_t *)(puVar2 + 1) = param->tx_avail;
  ke_msg_send(puVar2);
LAB_2301df24:
  ke_msg_send_basic(0x140d,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_sta_del_req_handler
              (ke_msg_id_t msgid,me_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t *puVar1;
  undefined *puVar2;
  
  puVar1 = (uint8_t *)ke_msg_alloc(0xc,0,5,1);
  *puVar1 = param->sta_idx;
  ke_msg_send(puVar1);
  if (param->tdls_sta != false) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[param->sta_idx].inst_nbr;
    ke_msg_send(puVar2);
  }
  ke_msg_send_basic(0x140a,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_control_port_req_handler
              (ke_msg_id_t msgid,me_set_control_port_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  byte bVar1;
  undefined *puVar2;
  uint8_t uVar3;
  uint uVar4;
  
  uVar4 = (uint)param->sta_idx;
  bVar1 = sta_info_tab[uVar4].inst_nbr;
  uVar3 = (param->control_port_open != false) + '\x01';
  sta_info_tab[uVar4].ctrl_port_state = uVar3;
  if ((vif_info_tab[bVar1].type == '\0') && (uVar3 == '\x02')) {
    puVar2 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
    *puVar2 = 0;
    puVar2[1] = sta_info_tab[uVar4].inst_nbr;
    ke_msg_send(puVar2);
  }
  ke_msg_send_basic(0x1405,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_chan_config_req_handler
              (ke_msg_id_t msgid,me_chan_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  memcpy(&me_env.chan,param,0xfe);
  ke_msg_send_basic(0x1403,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_set_ps_mode_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",699);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1414,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_set_idle_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(dest_id);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(dest_id) == ME_BUSY","module",0x252);
  }
  if (me_env.requester_id != 0xff) {
    ke_msg_send_basic(0x1412,me_env.requester_id,dest_id);
  }
  ke_state_set(dest_id,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_config_req_handler
              (ke_msg_id_t msgid,me_config_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t uVar1;
  undefined *puVar2;
  undefined3 extraout_var;
  
  puVar2 = (undefined *)ke_msg_alloc(0x31,0,5,1);
  me_env.ht_supported = param->ht_supp;
  memcpy(&me_env.ht_cap,param,0x20);
  ke_msg_send_basic(0x1401,src_id,dest_id);
  if (me_env.ht_supported == false) {
    me_env._302_2_ = 0;
  }
  else {
    uVar1 = phy_get_nss();
    me_env._302_2_ =
         CONCAT11((char)(me_env.ht_cap.ht_capa_info >> 1),
                  (char)(CONCAT31(extraout_var,uVar1) + 1 >> 1)) & 0x1ff;
  }
  me_env.tx_lft = param->tx_lft;
  me_env.ps_on = param->ps_on;
  if (me_env.ps_on != false) {
    me_env.requester_id = 0xff;
    *puVar2 = 2;
    ke_msg_send(puVar2);
    ke_state_set(5,1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_ps_disable_req_handler
              (ke_msg_id_t msgid,me_set_ps_disable_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  char *pcVar2;
  int iVar3;
  
  if (me_env.ps_on == false) goto LAB_2301e228;
  kVar1 = ke_state_get(5);
  iVar3 = 2;
  if (CONCAT22(extraout_var,kVar1) == 1) goto LAB_2301e238;
  if (me_env.ps_disable_vifs == 0) {
    if (param->ps_disable == false) goto LAB_2301e228;
LAB_2301e26a:
    pcVar2 = (char *)ke_msg_alloc(0x31,0,dest_id,1);
    if (param->ps_disable == false) {
      me_env.ps_disable_vifs = ~(1 << (param->vif_idx & 0x1f)) & me_env.ps_disable_vifs;
    }
    else {
      me_env.ps_disable_vifs = 1 << (param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
    }
    me_env.requester_id = src_id;
    *pcVar2 = (me_env.ps_disable_vifs == 0) << 1;
    ke_msg_send(pcVar2);
    ke_state_set(dest_id,1);
  }
  else {
    if (param->ps_disable == false) goto LAB_2301e26a;
    me_env.ps_disable_vifs = 1 << (param->vif_idx & 0x1f) | me_env.ps_disable_vifs;
LAB_2301e228:
    ke_msg_send_basic(0x1414,src_id,dest_id);
  }
  iVar3 = 0;
LAB_2301e238:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int me_set_active_req_handler
              (ke_msg_id_t msgid,me_set_active_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  void *pvVar2;
  
  kVar1 = ke_state_get(5);
  if (CONCAT22(extraout_var,kVar1) == 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 2;
  }
  if (me_env.active_vifs == 0) {
    if (param->active != false) goto LAB_2301e304;
  }
  else {
    if (param->active == false) {
LAB_2301e304:
      pvVar2 = ke_msg_alloc(0x22,0,dest_id,1);
      if (param->active == false) {
        me_env.active_vifs = ~(1 << (param->vif_idx & 0x1f)) & me_env.active_vifs;
      }
      else {
        me_env.active_vifs = 1 << (param->vif_idx & 0x1f) | me_env.active_vifs;
      }
      me_env.requester_id = src_id;
      *(bool *)pvVar2 = me_env.active_vifs == 0;
      ke_msg_send(pvVar2);
      ke_state_set(dest_id,1);
      goto LAB_2301e352;
    }
    me_env.active_vifs = 1 << (param->vif_idx & 0x1f) | me_env.active_vifs;
  }
  ke_msg_send_basic(0x1412,src_id,dest_id);
LAB_2301e352:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int me_sta_add_req_handler
              (ke_msg_id_t msgid,me_sta_add_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ushort uVar1;
  byte bVar2;
  byte bVar3;
  _Bool _Var4;
  byte *sta_idx;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined *puVar5;
  undefined3 extraout_var_01;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint8_t uStack81;
  undefined auStack80 [3];
  uint8_t hw_sta_idx;
  mm_sta_add_req sta_add_req;
  
  sta_idx = (byte *)ke_msg_alloc(0x1408,src_id,dest_id,3);
  bVar2 = rxu_cntrl_get_pm();
  sta_add_req.mac_addr.array[1]._1_1_ = param->vif_idx;
  uVar8 = (uint)sta_add_req.mac_addr.array[1]._1_1_;
  if ((param->flags & 2) == 0) {
    sta_add_req.mac_addr.array[1]._0_1_ = '\0';
    sta_add_req.paid_gid._0_2_ = 0;
  }
  else {
    uVar6 = (uint)(param->ht_cap).a_mpdu_param;
    sta_add_req.mac_addr.array[1]._0_1_ = '\x01';
    uVar7 = (int)uVar6 >> 2 & 7;
    if (2 < uVar7) {
      sta_add_req.mac_addr.array[1]._0_1_ = (uint8_t)(1 << (uVar7 - 3 & 0x1f));
    }
    sta_add_req.paid_gid._0_2_ = (short)(1 << (uVar6 & 3) + 0xd) - 1;
  }
  sta_add_req.ampdu_size_max_vht = 0;
  memcpy((void *)((int)&sta_add_req.paid_gid + 2),param,6);
  sta_add_req.mac_addr.array[2]._1_1_ = param->rssi;
  sta_add_req._16_4_ = param->tsflo;
  sta_add_req.tsflo = param->tsfhi;
  _auStack80 = 0;
  sta_add_req.tsfhi._0_1_ = param->data_rate;
  bVar3 = mm_sta_add((mm_sta_add_req *)auStack80,sta_idx,&uStack81);
  sta_idx[1] = bVar3;
  if (CONCAT31(extraout_var_00,bVar3) != 0) goto LAB_2301e56a;
  uVar6 = (uint)*sta_idx;
  memcpy(&sta_info_tab[uVar6].info,&param->rate_set,0xd);
  if ((param->flags & 1) == 0) {
LAB_2301e46c:
    iVar9 = 0;
  }
  else {
    uVar7 = sta_info_tab[uVar6].info.capa_flags;
    sta_info_tab[uVar6].info.capa_flags = uVar7 | 1;
    if (((param->flags & 2) == 0) || (me_env.ht_supported == false)) goto LAB_2301e46c;
    sta_info_tab[uVar6].info.capa_flags = uVar7 | 3;
    memcpy(&sta_info_tab[uVar6].info.ht_cap,&param->ht_cap,0x20);
    _Var4 = me_set_sta_ht_vht_param(sta_info_tab + uVar6,&vif_info_tab[uVar8].bss_info);
    iVar9 = CONCAT31(extraout_var_01,_Var4);
  }
  sta_info_tab[uVar6].info.uapsd_queues = param->uapsd_queues;
  sta_info_tab[uVar6].info.max_sp_len = param->max_sp_len;
  sta_info_tab[uVar6].aid = param->aid;
  me_init_rate(sta_info_tab + uVar6);
  if (((param->flags & 0x10) != 0) && (bVar3 = param->opmode, -1 < (char)bVar3)) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar6].staid,bVar3 & 3,bVar3 >> 4);
  }
  if (iVar9 != 0) {
    me_sta_bw_nss_max_upd(sta_info_tab[uVar6].staid,-1,'\0');
  }
  sta_info_tab[uVar6].pol_tbl.upd_field = sta_info_tab[uVar6].pol_tbl.upd_field | 0x10;
  sta_info_tab[uVar6].ctrl_port_state = ((vif_info_tab[uVar8].flags & 1) == 0) + '\x01';
  uVar1 = *(ushort *)&vif_info_tab[uVar8].u.field_0x2f0;
  sta_info_tab[uVar6].ctrl_port_ethertype = uVar1 >> 8 | uVar1 << 8;
  sta_idx[2] = bVar2;
  if (CONCAT31(extraout_var,bVar2) != 0) {
    sta_info_tab[uVar6].ps_state = bVar2;
    if (*(char *)&vif_info_tab[uVar8].u.field_0x2ee == '\0') {
      uVar6 = vif_info_tab[uVar8].index + 10 & 0xff;
      puVar5 = (undefined *)ke_msg_alloc(0x49,0xd,0,2);
      sta_info_tab[uVar6].ps_state = '\x01';
      *puVar5 = (char)uVar6;
      puVar5[1] = 1;
      ke_msg_send(puVar5);
    }
    *(char *)&vif_info_tab[uVar8].u.field_0x2ee =
         *(char *)&vif_info_tab[uVar8].u.field_0x2ee + '\x01';
  }
LAB_2301e56a:
  ke_msg_send(sta_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cfm_raw_send(void *env,uint32_t status)

{
  printf("send complete, status is %08lX\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int scanu_raw_send_req_handler
              (ke_msg_id_t msgid,scanu_raw_send_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  size_t __n;
  txl_frame_desc_tag *frame;
  tx_hw_desc *ptVar1;
  void *__src;
  
  printf("[FW] pkt address is %p, len is %lu\r\n",param->pkt,param->len);
  scanu_raw_send_cfm('\0',src_id);
  __src = param->pkt;
  __n = param->len;
  frame = txl_frame_get(0,0x100);
  if (frame != (txl_frame_desc_tag *)0x0) {
    memcpy((frame->txdesc).lmac.buffer + 1,__src,__n);
    (frame->txdesc).host.staid = -1;
    (frame->cfm).cfm_func = cfm_raw_send;
    ptVar1 = (frame->txdesc).lmac.hw_desc;
    (frame->txdesc).host.vif_idx = '\0';
    (frame->txdesc).umac.head_len = '\0';
    (frame->txdesc).umac.tail_len = '\0';
    (frame->cfm).env = frame;
    (ptVar1->thd).field_5 = (ptVar1->thd).field_4 + (__n - 1);
    (ptVar1->thd).frmlen = __n + 4;
    txl_frame_push_force(frame,'\x03');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int scanu_join_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  vif_info_tab[param->vif_idx].bss_info.valid_flags = 0;
  scanu_env._362_2_ = 1;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = *(uint16_t *)((param->bssid).array + 4);
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  if (((param->bssid).array[0] & 1) != 0) {
    assert_err("!MAC_ADDR_GROUP(&param->bssid)","module",0xb6);
  }
  scanu_start();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



int scanu_start_req_handler
              (ke_msg_id_t msgid,scanu_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  scanu_env._362_2_ = 0;
  scanu_env.bssid.array._0_4_ = *(undefined4 *)(param->bssid).array;
  scanu_env.bssid.array[2] = *(uint16_t *)((param->bssid).array + 4);
  scanu_env.param = param;
  scanu_env.src_id = src_id;
  scanu_start();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  int iVar1;
  
  iVar1 = scanu_frame_handler(param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int scan_done_ind_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  scanu_env.band = scanu_env.band + '\x01';
  scanu_scan_next();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int scan_start_cfm_handler
              (ke_msg_id_t msgid,scan_start_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (param->status != '\0') {
    scanu_confirm(param->status);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  
  kVar1 = ke_state_get(6);
  if (((CONCAT22(extraout_var,kVar1) != 4) &&
      (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) != 0)) &&
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_01,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_IDLE) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x1db);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var_02,kVar1) == 4) {
    sm_send_next_bss_param();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar1) != 4) {
    assert_err("ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING","module",0x1fa);
  }
  sm_send_next_bss_param();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int sm_rsp_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT22(extraout_var,kVar1) == 5) ||
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) == 6)) {
    sm_connect_ind(0xb);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int scanu_start_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  mac_addr *pmStack24;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  pmStack24 = (mac_addr *)0x0;
  bssid = (mac_addr *)0x0;
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_SM) == SM_SCANNING","module",0x10a);
  }
  sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
  if ((pmStack24 == (mac_addr *)0x0) || ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0)) {
    sm_connect_ind(0xc);
  }
  else {
    sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_connection_loss_ind_handler
              (ke_msg_id_t msgid,mm_connection_loss_ind *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  uint uVar3;
  
  uVar3 = (uint)param->inst_nbr;
  kVar2 = ke_state_get(6);
  iVar1 = 2;
  if (CONCAT22(extraout_var,kVar2) == 0) {
    iVar1 = 0;
    if ((vif_info_tab[uVar3].type == '\0') && (vif_info_tab[uVar3].active != false)) {
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + uVar3,0x10);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int scanu_join_cfm_handler(ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  sm_connect_req *psVar1;
  uint8_t uVar2;
  ke_state_t kVar3;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  void *pvVar4;
  undefined uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint8_t auStack33 [4];
  uint8_t chan_idx;
  
  psVar1 = sm_env.connect_param;
  kVar3 = ke_state_get(6);
  if (CONCAT22(extraout_var_00,kVar3) != 2) {
    assert_err("ke_state_get(TASK_SM) == SM_JOINING","module",0x134);
  }
  uVar8 = (uint)psVar1->vif_idx;
  if ((int)vif_info_tab[uVar8].bss_info.valid_flags < 0) {
    uVar2 = sm_add_chan_ctx(auStack33);
    if (CONCAT31(extraout_var,uVar2) == 0) {
      pvVar4 = ke_msg_alloc(10,0,6,0x20);
      chan_ctxt_link(psVar1->vif_idx,auStack33[0]);
      *(u8_l *)((int)pvVar4 + 0x11) = psVar1->vif_idx;
      memcpy((void *)((int)pvVar4 + 10),&vif_info_tab[uVar8].bss_info.bssid,6);
      *(undefined *)((int)pvVar4 + 0x12) = 0;
      if ((vif_info_tab[uVar8].bss_info.valid_flags & 2) != 0) {
        uVar6 = (uint)vif_info_tab[uVar8].bss_info.ht_cap.a_mpdu_param;
        uVar5 = 1;
        uVar7 = (int)uVar6 >> 2 & 7;
        if (2 < uVar7) {
          uVar5 = (undefined)(1 << (uVar7 - 3 & 0x1f));
        }
        *(undefined *)((int)pvVar4 + 0x10) = uVar5;
        *(short *)((int)pvVar4 + 8) = (short)(1 << (uVar6 & 3) + 0xd) + -1;
      }
      *(undefined4 *)((int)pvVar4 + 4) = 0;
      ke_msg_send(pvVar4);
      ke_state_set(6,3);
    }
    else {
      sm_connect_ind(0xd);
    }
    vif_info_tab[uVar8].flags = psVar1->flags;
    if ((psVar1->flags & 4) != 0) {
      vif_info_tab[uVar8].bss_info.valid_flags =
           vif_info_tab[uVar8].bss_info.valid_flags & 0xfffffff9;
    }
  }
  else {
    if (sm_env.join_passive == false) {
      sm_connect_ind(0xe);
    }
    else {
      sm_join_bss(&vif_info_tab[uVar8].bss_info.bssid,vif_info_tab[uVar8].bss_info.chan,true);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Variable defined which should be unmapped: chan

int sm_connect_req_handler
              (ke_msg_id_t msgid,sm_connect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  undefined *puVar3;
  undefined2 extraout_var_00;
  undefined uVar4;
  uint uVar5;
  mac_addr *pmStack40;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  pmStack40 = (mac_addr *)0x0;
  bssid = (mac_addr *)0x0;
  uVar5 = (uint)param->vif_idx;
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar2) == 8) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 2;
  }
  puVar3 = (undefined *)ke_msg_alloc(0x1801,src_id,dest_id,1);
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var_00,kVar2) == 0) {
    if ((vif_info_tab[uVar5].type == '\0') && (vif_info_tab[uVar5].active == false)) {
      if (param->auth_type != '\x02') {
        if (*(char *)&vif_info_tab[uVar5].u.field_0x4 != -1) {
          assert_err("vif->u.sta.ap_id == INVALID_STA_IDX","module",0x59);
        }
        if (vif_info_tab[uVar5].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x5a);
        }
      }
    }
    else {
      if (param->auth_type != '\x02') {
        iVar1 = 0;
        uVar4 = 9;
        goto LAB_2301eb3e;
      }
    }
    if (sm_env.connect_param != (sm_connect_req *)0x0) {
      assert_err("NULL == sm_env.connect_param","module",0x5d);
    }
    sm_env.connect_param = param;
    if (sm_env.connect_ind != (sm_connect_ind *)0x0) {
      assert_err("NULL == sm_env.connect_ind","module",0x61);
    }
    sm_env.connect_ind = (sm_connect_ind *)ke_msg_alloc(0x1802,src_id,dest_id,0x354);
    sm_env.exist_ssid_idx = -1;
    sm_env.ft_over_ds = false;
    printf("connecting using vif_idx %u\r\n",(uint)param->vif_idx);
    if (param->auth_type == '\x02') {
      sm_env.ft_over_ds = true;
      memcpy(&sm_env.ft_old_bssid,&vif_info_tab[param->vif_idx].bssid,6);
      ke_state_set(6,8);
      sm_disconnect_process(vif_info_tab + param->vif_idx,0);
    }
    else {
      if ((param->chan).freq == 0xffff) {
        sm_get_bss_params(&pmStack40,(scan_chan_tag **)&bssid);
      }
      else {
        pmStack40 = (mac_addr *)&param->bssid;
        bssid = (mac_addr *)&param->chan;
      }
      if ((pmStack40 == (mac_addr *)0x0) || ((scan_chan_tag *)bssid == (scan_chan_tag *)0x0)) {
        sm_scan_bss(pmStack40,(scan_chan_tag *)bssid);
      }
      else {
        sm_join_bss(pmStack40,(scan_chan_tag *)bssid,false);
      }
    }
    iVar1 = 1;
    uVar4 = 0;
  }
  else {
    iVar1 = 0;
    uVar4 = 8;
  }
LAB_2301eb3e:
  *puVar3 = uVar4;
  ke_msg_send(puVar3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  int iVar2;
  ushort uVar3;
  
  uVar3 = param->framectrl & 0xfc;
  if (uVar3 == 0xb0) {
    kVar1 = ke_state_get(6);
    if (CONCAT22(extraout_var,kVar1) == 5) {
      sm_auth_handler(param);
    }
  }
  else {
    if ((uVar3 == 0x10) || (uVar3 == 0x30)) {
      kVar1 = ke_state_get(6);
      if (CONCAT22(extraout_var_00,kVar1) == 6) {
        sm_assoc_rsp_handler(param);
      }
    }
    else {
      if (((uVar3 == 0xc0) || (uVar3 == 0xa0)) &&
         (kVar1 = ke_state_get(6), CONCAT22(extraout_var_01,kVar1) == 0)) {
        iVar2 = sm_deauth_handler(param);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_set_vif_state_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  sm_connect_req *psVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  u8_l *puVar3;
  undefined *puVar4;
  uint8_t uVar5;
  uint uVar6;
  uint uVar7;
  
  kVar2 = ke_state_get(6);
  psVar1 = sm_env.connect_param;
  if (CONCAT22(extraout_var,kVar2) == 7) {
    uVar6 = (uint)(sm_env.connect_param)->vif_idx;
    uVar7 = (uint)*(byte *)&vif_info_tab[uVar6].u.field_0x4;
    puVar3 = (u8_l *)ke_msg_alloc(0x4b,0,6,6);
    puVar3[4] = psVar1->dont_wait_bcmc;
    *(u16_l *)(puVar3 + 2) = psVar1->listen_interval;
    *puVar3 = psVar1->vif_idx;
    ke_msg_send(puVar3);
    uVar5 = ((vif_info_tab[uVar6].flags & 1) == 0) + '\x01';
    sta_info_tab[uVar7].ctrl_port_state = uVar5;
    sta_info_tab[uVar7].ctrl_port_ethertype =
         psVar1->ctrl_port_ethertype >> 8 | psVar1->ctrl_port_ethertype << 8;
    if (uVar5 == '\x02') {
      puVar4 = (undefined *)ke_msg_alloc(0x1413,5,6,2);
      *puVar4 = 0;
      puVar4[1] = psVar1->vif_idx;
      ke_msg_send(puVar4);
    }
    if ((*(uint *)&vif_info_tab[uVar6].bss_info.is_supplicant_enabled & 0x12800) == 0) {
      sm_connect_ind(0);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  mac_addr *pmStack24;
  mac_addr *bssid;
  scan_chan_tag *chan;
  
  kVar1 = ke_state_get(6);
  if ((CONCAT22(extraout_var,kVar1) != 4) &&
     (kVar1 = ke_state_get(6), CONCAT22(extraout_var_00,kVar1) != 8)) {
    assert_err(
               "(ke_state_get(TASK_SM) == SM_BSS_PARAM_SETTING) || (ke_state_get(TASK_SM) == SM_DISCONNECTING)"
               ,"module",0x216);
  }
  kVar1 = ke_state_get(6);
  if (CONCAT22(extraout_var_01,kVar1) == 8) {
    if (sm_env.ft_over_ds == false) {
      ke_state_set(6,0);
    }
    else {
      pmStack24 = (mac_addr *)0x0;
      bssid = (mac_addr *)0x0;
      sm_get_bss_params(&pmStack24,(scan_chan_tag **)&bssid);
      sm_join_bss(pmStack24,(scan_chan_tag *)bssid,false);
    }
  }
  else {
    if (sm_env.ft_over_ds == false) {
      sm_auth_send(1,(uint32_t *)0x0);
    }
    else {
      sm_assoc_req_send();
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_sta_add_cfm_handler
              (ke_msg_id_t msgid,mm_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  uint uVar3;
  uint uVar4;
  
  kVar2 = ke_state_get(6);
  if (CONCAT22(extraout_var,kVar2) != 3) {
    assert_err("ke_state_get(TASK_SM) == SM_STA_ADDING","module",0x19c);
  }
  if (param->status == '\0') {
    uVar4 = (uint)param->sta_idx;
    uVar1 = (uint)sta_info_tab[uVar4].inst_nbr;
    memcpy(&sta_info_tab[uVar4].info,&vif_info_tab[uVar1].bss_info.rate_set,0xd);
    uVar3 = vif_info_tab[uVar1].bss_info.valid_flags;
    if ((uVar3 & 1) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 1;
    }
    if ((uVar3 & 2) != 0) {
      sta_info_tab[uVar4].info.capa_flags = sta_info_tab[uVar4].info.capa_flags | 2;
      memcpy(&sta_info_tab[uVar4].info.ht_cap,&vif_info_tab[uVar1].bss_info,0x20);
      me_set_sta_ht_vht_param(sta_info_tab + uVar4,&vif_info_tab[uVar1].bss_info);
    }
    sm_set_bss_param();
  }
  else {
    sm_connect_ind(0xf);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int sm_disconnect_req_handler
              (ke_msg_id_t msgid,sm_disconnect_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  int iVar2;
  
  kVar1 = ke_state_get(6);
  iVar2 = 2;
  if (CONCAT22(extraout_var,kVar1) == 0) {
    sm_disconnect(param->vif_idx,param->reason_code);
    ke_msg_send_basic(0x1804,0xd,6);
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int apm_sta_connect_timeout_ind_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint8_t sta_idx;
  sta_info_tag *psVar1;
  TickType_t TVar2;
  
  TVar2 = xTaskGetTickCount();
  psVar1 = sta_info_tab;
  sta_idx = '\0';
  do {
    if ((psVar1->time_last_seen != 0) && (30000 < (int)(TVar2 - psVar1->time_last_seen))) {
      apm_sta_fw_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    psVar1 = psVar1 + 1;
  } while (sta_idx != '\f');
  ke_timer_set(0x1c0a,7,5000000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int rxu_mgt_ind_handler(ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,
                       ke_task_id_t src_id)

{
  _Bool is_reassoc;
  ushort uVar1;
  
  uVar1 = param->framectrl & 0xfc;
  if (uVar1 == 0x40) {
    apm_probe_req_handler(param);
  }
  else {
    if (uVar1 == 0xb0) {
      apm_auth_handler(param);
    }
    else {
      is_reassoc = false;
      if ((param->framectrl & 0xfc) != 0) {
        if (uVar1 != 0x20) {
          if (uVar1 == 0xc0) {
            apm_deauth_handler(param);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          if (uVar1 == 0xa0) {
            apm_disassoc_handler(param);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          if (uVar1 != 0x80) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          apm_beacon_handler(param);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        is_reassoc = true;
      }
      apm_assoc_req_handler(param,is_reassoc);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int apm_sta_add_cfm_handler
              (ke_msg_id_t msgid,me_sta_add_cfm *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  if (uap_conn_info == (cm_ConnectionInfo_t *)0x0) {
    apm_sta_add(param->sta_idx);
  }
  else {
    uap_conn_info->staId = param->sta_idx;
    SendEAPOLMsgUsingBufDesc(uap_conn_info,(BufferDesc_t *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int apm_sta_del_req_handler
              (ke_msg_id_t msgid,apm_sta_del_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)ke_msg_alloc(0x1c0c,src_id,dest_id,3);
  if ((vif_info_tab[param->vif_idx].type == '\x02') && (param->sta_idx < 0xd)) {
    apm_sta_remove(param->vif_idx,param->sta_idx);
    *puVar1 = 0;
  }
  else {
    *puVar1 = 0xff;
  }
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int apm_stop_cac_req_handler
              (ke_msg_id_t msgid,apm_stop_cac_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  if (((vif_info_tab[param->vif_idx].type == '\x02') &&
      (vif_info_tab[param->vif_idx].active == false)) &&
     (kVar1 = ke_state_get(7), CONCAT22(extraout_var,kVar1) == 0)) {
    chan_ctxt_unlink(param->vif_idx);
    ps_env.prevent_sleep = ps_env.prevent_sleep & 0xffffffef;
  }
  ke_msg_send_basic(0x1c07,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int apm_conf_max_sta_req_handler
              (ke_msg_id_t msgid,apm_conf_max_sta_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  apm_env.max_sta_supported = param->max_sta_supported;
  if (0xc < apm_env.max_sta_supported) {
    apm_env.max_sta_supported = 0xc;
  }
  ke_msg_send_basic(0x1c0e,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int apm_start_cac_req_handler
              (ke_msg_id_t msgid,apm_start_cac_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  int iVar1;
  uint8_t uVar2;
  ke_state_t kVar3;
  undefined *puVar4;
  undefined2 extraout_var_00;
  undefined3 extraout_var;
  uint8_t local_2d;
  undefined auStack44 [3];
  uint8_t chan_idx;
  mm_chan_ctxt_add_req req;
  
  local_2d = '\0';
  iVar1 = 4;
  if (vif_info_tab[param->vif_idx].type == '\x02') {
    if ((vif_info_tab[param->vif_idx].active == false) &&
       (kVar3 = ke_state_get(7), CONCAT22(extraout_var_00,kVar3) == 0)) {
      auStack44[0] = (param->chan).band;
      auStack44[1] = param->ch_width;
      unique0x00000590 = (param->chan).freq;
      req._0_2_ = (uint16_t)param->center_freq1;
      req.prim20_freq = (uint16_t)param->center_freq2;
      uVar2 = chan_ctxt_add((mm_chan_ctxt_add_req *)auStack44,&local_2d);
      iVar1 = CONCAT31(extraout_var,uVar2);
      if (iVar1 == 0) {
        chan_ctxt_link(param->vif_idx,local_2d);
        ps_env.prevent_sleep = ps_env.prevent_sleep | 0x10;
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      iVar1 = 8;
    }
  }
  puVar4 = (undefined *)ke_msg_alloc(0x1c05,src_id,dest_id,2);
  *puVar4 = (char)iVar1;
  puVar4[1] = local_2d;
  ke_msg_send(puVar4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_ps_disable_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT22(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT22(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0xee);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var_01,kVar1) == 1) {
    apm_send_next_bss_param();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_bss_param_setting_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var,kVar1) != 1) {
    assert_err("ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING","module",0x110);
  }
  apm_send_next_bss_param();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mm_bcn_change_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var,kVar1) != 2) {
    assert_err("ke_state_get(TASK_APM) == APM_BCN_SETTING","module",0x156);
  }
  apm_start_cfm('\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int apm_stop_req_handler
              (ke_msg_id_t msgid,apm_stop_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint uVar1;
  ke_state_t kVar2;
  undefined2 extraout_var;
  
  uVar1 = (uint)param->vif_idx;
  if ((vif_info_tab[uVar1].type == '\x02') && (vif_info_tab[uVar1].active != false)) {
    kVar2 = ke_state_get(7);
    if (CONCAT22(extraout_var,kVar2) != 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 2;
    }
    if (apm_env.apm_emb_enabled != false) {
      apm_env.apm_emb_enabled = false;
    }
    apm_stop(vif_info_tab + uVar1);
    if (uap_conn_info != (cm_ConnectionInfo_t *)0x0) {
      RemoveAPKeyInfo(uap_conn_info);
      cm_DeleteConnection(uap_conn_info);
      uap_conn_info = (cm_ConnectionInfo_t *)0x0;
    }
  }
  ke_msg_send_basic(0x1c03,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int apm_start_req_handler
              (ke_msg_id_t msgid,apm_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t uVar1;
  uint8_t uVar2;
  _Bool _Var3;
  ke_state_t kVar4;
  uint16_t uVar5;
  undefined2 extraout_var_01;
  undefined3 extraout_var;
  scan_chan_tag *psVar6;
  undefined3 extraout_var_00;
  int iVar7;
  undefined *puVar8;
  uint uVar9;
  undefined uVar10;
  uint8_t *ssid;
  uint8_t uStack51;
  int8_t iStack50;
  uint8_t auStack49 [2];
  uint8_t chan_idx;
  int8_t pwr;
  uint8_t idx;
  
  printf("[WF] received APM Start %s:%d\r\n","apm_start_req_handler",0x4c);
  uVar9 = (uint)param->vif_idx;
  uVar10 = 4;
  if (vif_info_tab[uVar9].type == '\x02') {
    kVar4 = ke_state_get(7);
    if (CONCAT22(extraout_var_01,kVar4) == 0) {
      if (vif_info_tab[uVar9].active == false) {
        if (vif_info_tab[uVar9].chan_ctxt != (chan_ctxt_tag *)0x0) {
          assert_err("vif->chan_ctxt == NULL","module",0x67);
        }
        apm_env.param = param;
        uVar2 = me_add_chan_ctx(&uStack51,&param->chan,param->center_freq1,param->center_freq2,
                                param->ch_width);
        uVar10 = 1;
        if (CONCAT31(extraout_var,uVar2) == 0) {
          psVar6 = me_freq_to_chan_ptr((param->chan).band,(param->chan).freq);
          vif_info_tab[uVar9].bss_info.chan = psVar6;
          psVar6->tx_power = (param->chan).tx_power;
          vif_info_tab[uVar9].bss_info.center_freq1 = (uint16_t)param->center_freq1;
          vif_info_tab[uVar9].bss_info.center_freq2 = (uint16_t)param->center_freq2;
          uVar2 = param->ch_width;
          if (uVar2 == '\x04') {
            uVar2 = '\x03';
          }
          vif_info_tab[uVar9].bss_info.bw = uVar2;
          uVar2 = param->ch_width;
          vif_info_tab[uVar9].bss_info.power_constraint = '\0';
          vif_info_tab[uVar9].bss_info.phy_bw = uVar2;
          chan_ctxt_link(param->vif_idx,uStack51);
          apm_env.apm_emb_enabled = param->apm_emb_enabled;
          apm_env.hidden_ssid = param->hidden_ssid;
          _Var3 = apm_embedded_enabled(vif_info_tab + uVar9);
          if (CONCAT31(extraout_var_00,_Var3) != 0) {
            me_get_basic_rates(&param->rate_set,(mac_rateset *)param);
            if (param->qos_supported != '\0') {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 1;
            }
            if (me_env.ht_supported != false) {
              vif_info_tab[uVar9].bss_info.valid_flags =
                   vif_info_tab[uVar9].bss_info.valid_flags | 2;
            }
            vif_info_tab[uVar9].bss_info.beacon_interval = param->bcn_int;
            vif_info_tab[uVar9].bss_info.beacon_period = (ushort)param->beacon_period;
            vif_info_tab[uVar9].bss_info.sec_type = param->ap_sec_type;
            memcpy(&vif_info_tab[uVar9].bss_info.ssid,&param->ssid,0x22);
            vif_info_tab[uVar9].bss_info.ssid.array[vif_info_tab[uVar9].bss_info.ssid.length] = '\0'
            ;
            *(undefined4 *)vif_info_tab[uVar9].bss_info.bssid.array =
                 *(undefined4 *)vif_info_tab[uVar9].mac_addr.array;
            vif_info_tab[uVar9].bss_info.bssid.array[2] = vif_info_tab[uVar9].mac_addr.array[2];
            memcpy(&vif_info_tab[uVar9].bss_info.rate_set,&param->rate_set,0xd);
            vif_info_tab[uVar9].txq_params[0] = _DAT_44b00200;
            vif_info_tab[uVar9].txq_params[1] = _DAT_44b00204;
            vif_info_tab[uVar9].txq_params[2] = _DAT_44b00208;
            uVar1 = _DAT_44b0020c;
            vif_info_tab[uVar9].bss_info.edca_param.qos_info = '\0';
            vif_info_tab[uVar9].txq_params[3] = uVar1;
            *(undefined4 *)&vif_info_tab[uVar9].bss_info.aid_bitmap = 0xffff0000;
            apm_env.bcn_buf = (uint8_t *)ke_malloc(0x14d);
            uVar5 = me_build_beacon((uint32_t)apm_env.bcn_buf,vif_info_tab[uVar9].index,
                                    &param->tim_oft,&param->tim_len,apm_env.hidden_ssid);
            param->bcn_len = uVar5;
            if (param->ap_sec_type == '\0') {
              uap_conn_info = (cm_ConnectionInfo_t *)0x0;
            }
            else {
              uap_conn_info =
                   cm_InitConnection('\x02','\0','\0',
                                     (IEEEtypes_MacAddr_t *)&vif_info_tab[uVar9].bss_info.bssid,
                                     (IEEEtypes_MacAddr_t *)0x0,'\0',(mdev_t *)0x0);
              ssid = vif_info_tab[uVar9].bss_info.ssid.array;
              ap_setpsk(uap_conn_info,(CHAR *)ssid,(CHAR *)param->phrase);
              cm_SetComData(uap_conn_info,(char *)ssid);
              uap_conn_info->instNbr = param->vif_idx;
              printf("%s:uap_conn_info->instNbr = %d\r\n","apm_start_req_handler",
                     (uint)uap_conn_info->instNbr);
              InitGroupKey(uap_conn_info);
            }
          }
          if ((param->chan).band == '\0') {
            uVar5 = me_legacy_rate_bitfield_build(&vif_info_tab[uVar9].bss_info.rate_set,true);
            if ((uVar5 & 0xf) == 0) {
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x01';
            }
            else {
              iVar7 = __clzsi2(uVar5 & 0xf);
              vif_info_tab[uVar9].bss_info.high_11b_rate = '\x1f' - (char)iVar7;
            }
          }
          apm_set_bss_param();
          iStack50 = (vif_info_tab[uVar9].bss_info.chan)->tx_power;
          tpc_update_vif_tx_power(vif_info_tab + uVar9,&iStack50,auStack49);
          printf("[WF] return with other handler\r\n");
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 1;
        }
      }
      else {
        uVar10 = 9;
      }
    }
    else {
      uVar10 = 8;
    }
  }
  printf("[WF] Sending APM CFM %s:%d\r\n","apm_start_req_handler",0xcc);
  puVar8 = (undefined *)ke_msg_alloc(0x1c01,src_id,dest_id,4);
  *puVar8 = uVar10;
  puVar8[1] = param->vif_idx;
  ke_msg_send(puVar8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int me_set_active_cfm_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ke_state_t kVar1;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  
  kVar1 = ke_state_get(7);
  if ((CONCAT22(extraout_var,kVar1) != 1) &&
     (kVar1 = ke_state_get(7), CONCAT22(extraout_var_00,kVar1) != 0)) {
    assert_err(
               "(ke_state_get(TASK_APM) == APM_BSS_PARAM_SETTING) || (ke_state_get(TASK_APM) == APM_IDLE)"
               ,"module",0x12f);
  }
  kVar1 = ke_state_get(7);
  if (CONCAT22(extraout_var_01,kVar1) == 1) {
    if (apm_env.bss_config.first != (co_list_hdr *)0x0) {
      assert_err("co_list_is_empty(&apm_env.bss_config)","module",0x135);
    }
    apm_bcn_set();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int hostapd_mgt_ind_handler
              (ke_msg_id_t msgid,rxu_mgt_ind *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  ushort uVar1;
  
  uVar1 = param->framectrl & 0xfc;
  if ((uVar1 != 0x40) && (uVar1 != 0xb0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  ke_state_get(10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void dump_cfg_entries(void)

{
  cfg_element_entry *pcVar1;
  char *pcVar2;
  char acStack64 [4];
  char strs [16];
  
  puts("================= CFG TASK =================\r\n");
  pcVar1 = cfg_entrys_mm;
  while (pcVar1 < &_fsymc_info_bloop) {
    printf("entry %p\r\n",pcVar1);
    printf("    task    : %lu\r\n",(blog_level_t *)pcVar1->task);
    printf("    element : %u\r\n",(uint)pcVar1->element);
    printf("    type    : %u\r\n",(uint)pcVar1->type);
    printf("    name    : %s\r\n",pcVar1->name);
    pcVar2 = cfg_api_element_dump(pcVar1->val,*(CFG_ELEMENT_TYPE *)&pcVar1->type,acStack64);
    printf("    type    : %s\r\n",pcVar2);
    printf("    val     : %s\r\n");
    puts("------------------------\r\n");
    pcVar1 = pcVar1 + 1;
  }
  puts("---------------------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: val

int cfg_start_req_handler
              (ke_msg_id_t msgid,cfg_start_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined *puVar1;
  int iVar2;
  undefined4 uStack20;
  uint32_t val [1];
  
  if (param->ops == 0) {
    iVar2 = utils_tlv_bl_unpack_auto
                      ((uint32_t *)(param + 5),param[4].ops,*(uint16_t *)&param[3].ops,&uStack20);
    printf("unpack ret is %d, result is %lu\r\n",iVar2,uStack20);
    cfg_api_element_set(param[1].ops,param[2].ops,param[3].ops,&uStack20,(void *)0x0);
  }
  else {
    if (2 < param->ops) {
      dump_cfg_entries();
    }
  }
  puVar1 = (undefined *)ke_msg_alloc(0x3001,src_id,dest_id,1);
  *puVar1 = 0;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void dbg_init(void)

{
  memset(&dbg_env,0,8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  dbg_env.filter_module = 0xffffffff;
  dbg_env.filter_severity = 2;
  return;
}



void dbg_test_print(char *fmt,...)

{
  uint uVar1;
  byte *pbVar2;
  va_list args;
  
  if (dbg_env.filter_severity != 0) {
    pbVar2 = (byte *)(fmt + 2);
    do {
      uVar1 = (uint)(byte)*fmt;
      if (-1 < *fmt) break;
      if (uVar1 < 0x88) {
        if ((~dbg_env.filter_module >> (uVar1 - 0x80 & 0x1f) & 1) != 0) break;
      }
      else {
        if (5 < (uVar1 + 0x66 & 0xff)) {
          assert_err("DBG_SEV_MIN <= prefix && prefix < DBG_SEV_MAX","module",0x297);
        }
        if (dbg_env.filter_severity <= uVar1 - 0x9a) break;
      }
      fmt = (char *)((byte *)fmt + 1);
    } while (pbVar2 != (byte *)fmt);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int dbg_get_sys_stat_req_handler
              (ke_msg_id_t msgid,void *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  undefined4 *puVar1;
  
  puVar1 = (undefined4 *)ke_msg_alloc(0x40a,src_id,dest_id,0xc);
  *puVar1 = 0;
  puVar1[1] = 0;
  puVar1[2] = 0;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int dbg_mem_write_req_handler
              (ke_msg_id_t msgid,dbg_mem_write_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t **ppuVar1;
  uint32_t **ppuVar2;
  
  ppuVar1 = (uint32_t **)ke_msg_alloc(0x403,src_id,dest_id,8);
  *(uint32_t *)param->memaddr = param->memdata;
  ppuVar2 = (uint32_t **)param->memaddr;
  *ppuVar1 = (uint32_t *)ppuVar2;
  ppuVar1[1] = *ppuVar2;
  ke_msg_send(ppuVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int dbg_mem_read_req_handler
              (ke_msg_id_t msgid,dbg_mem_read_req *param,ke_task_id_t dest_id,ke_task_id_t src_id)

{
  uint32_t *puVar1;
  
  puVar1 = (uint32_t *)ke_msg_alloc(0x401,src_id,dest_id,8);
  puVar1[1] = *(uint32_t *)param->memaddr;
  *puVar1 = param->memaddr;
  ke_msg_send(puVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int dbg_set_sev_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_sev_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_severity = param->sev_filter;
  ke_msg_send_basic(0x407,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int dbg_set_mod_filter_req_handler
              (ke_msg_id_t msgid,dbg_set_mod_filter_req *param,ke_task_id_t dest_id,
              ke_task_id_t src_id)

{
  dbg_env.filter_module = param->mod_filter;
  ke_msg_send_basic(0x405,src_id,dest_id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling

co_list_hdr *
ke_queue_extract(co_list *queue,anon_subr__Bool_co_list_hdr_ptr_uint32_t *func,uint32_t arg)

{
  co_list_hdr cVar1;
  co_list_hdr cVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  co_list_hdr cVar4;
  
  cVar4 = (co_list_hdr)queue->first;
  cVar1 = (co_list_hdr)0x0;
  do {
    cVar2 = cVar1;
    cVar1 = cVar4;
    if (cVar1 == (co_list_hdr)0x0) goto LAB_2301fa68;
    _Var3 = (*func)((co_list_hdr *)cVar1,arg);
    cVar4 = *(co_list_hdr *)cVar1;
  } while (CONCAT31(extraout_var,_Var3) == 0);
  if (cVar2 == (co_list_hdr)0x0) {
    queue->first = (co_list_hdr *)cVar4;
  }
  else {
    *(co_list_hdr *)cVar2 = cVar4;
  }
  if (*(int *)cVar1 == 0) {
    queue->last = (co_list_hdr *)cVar2;
  }
  else {
    *(undefined4 *)cVar1 = 0;
  }
LAB_2301fa68:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (co_list_hdr *)cVar1;
}



void bl_aes_128(UINT8 *key,UINT8 *input,UINT8 *output)

{
  BL_AesEncrypt(key,'\x02',input,output);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void xor_128(UINT8 *a,UINT8 *b,UINT8 *out)

{
  byte *pbVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  
  iVar2 = 0;
  do {
    pbVar1 = a + iVar2;
    pbVar4 = b + iVar2;
    pbVar3 = out + iVar2;
    iVar2 = iVar2 + 1;
    *pbVar3 = *pbVar1 ^ *pbVar4;
  } while (iVar2 != 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void leftshift_onebit(UINT8 *input,UINT8 *output)

{
  byte *pbVar1;
  int iVar2;
  byte bVar3;
  byte *pbVar4;
  
  bVar3 = 0;
  iVar2 = 0xf;
  do {
    pbVar1 = input + iVar2;
    pbVar4 = output + iVar2;
    iVar2 = iVar2 + -1;
    *pbVar4 = bVar3 | *pbVar1 << 1;
    bVar3 = *pbVar1 >> 7;
  } while (iVar2 != -1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: tmp

void generate_subkey(UINT8 *key,UINT8 *K1,UINT8 *K2)

{
  UINT8 local_40 [4];
  UINT8 L [16];
  UINT8 Z [16];
  UINT8 tmp [16];
  
  memset(L + 0xc,0,0x10);
  bl_aes_128(key,L + 0xc,local_40);
  if ((char)local_40[0] < '\0') {
    leftshift_onebit(local_40,Z + 0xc);
    xor_128(Z + 0xc,"",K1);
  }
  else {
    leftshift_onebit(local_40,K1);
  }
  if ((char)*K1 < '\0') {
    leftshift_onebit(K1,Z + 0xc);
    xor_128(Z + 0xc,"",K2);
  }
  else {
    leftshift_onebit(K1,K2);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void padding(UINT8 *lastb,UINT8 *pad,int length)

{
  int iVar1;
  
  iVar1 = 0;
  do {
    if (iVar1 < length) {
      pad[iVar1] = lastb[iVar1];
    }
    else {
      if (length == iVar1) {
        pad[length] = -0x80;
      }
      else {
        pad[iVar1] = '\0';
      }
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_aes_cmac(UINT8 *key,UINT8 *input,int length,UINT8 *mac)

{
  int iVar1;
  int iVar2;
  UINT8 *pUVar3;
  UINT8 *pUVar4;
  UINT8 local_80 [4];
  UINT8 X [16];
  UINT8 Y [16];
  UINT8 M_last [16];
  UINT8 padded [16];
  UINT8 K1 [16];
  UINT8 K2 [16];
  
  generate_subkey(key,padded + 0xc,K1 + 0xc);
  iVar1 = (length + 0xf) / 0x10;
  if (iVar1 == 0) {
    iVar1 = 1;
  }
  else {
    if ((length & 0xfU) == 0) {
      pUVar4 = padded;
      pUVar3 = input + (iVar1 + -1) * 0x10;
      goto LAB_2301fbde;
    }
  }
  padding(input + (iVar1 + -1) * 0x10,M_last + 0xc,length % 0x10);
  pUVar4 = K1;
  pUVar3 = M_last + 0xc;
LAB_2301fbde:
  xor_128(pUVar3,pUVar4 + 0xc,Y + 0xc);
  memset(local_80,0,0x10);
  iVar2 = 0;
  while (iVar2 < iVar1 + -1) {
    xor_128(local_80,input + iVar2 * 0x10,X + 0xc);
    bl_aes_128(key,X + 0xc,local_80);
    iVar2 = iVar2 + 1;
  }
  xor_128(local_80,Y + 0xc,X + 0xc);
  bl_aes_128(key,X + 0xc,local_80);
  iVar1 = 0;
  do {
    pUVar4 = local_80 + iVar1;
    pUVar3 = mac + iVar1;
    iVar1 = iVar1 + 1;
    *pUVar3 = *pUVar4;
  } while (iVar1 != 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int BL_AES_MEMCMP(UINT8 *dst,UINT8 *src,int len)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  iVar1 = len;
  while (len != iVar2) {
    if (dst[iVar2] == src[iVar2]) {
      iVar1 = iVar1 + -1;
    }
    iVar2 = iVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(iVar1 != 0);
}



void BL_AES_MEMSET(UINT8 *dst,UINT8 val,int size)

{
  UINT8 *pUVar1;
  
  pUVar1 = dst;
  while (pUVar1 != dst + size) {
    *pUVar1 = val;
    pUVar1 = pUVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void BL_AES_MEMCPY(UINT8 *dst,UINT8 *src,int size)

{
  UINT8 *pUVar1;
  UINT8 *pUVar2;
  int iVar3;
  
  if (dst < src) {
    iVar3 = 0;
    while (iVar3 != size) {
      pUVar1 = src + iVar3;
      pUVar2 = dst + iVar3;
      iVar3 = iVar3 + 1;
      *pUVar2 = *pUVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  while (size = size + -1, size != -1) {
    dst[size] = src[size];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int BL_AesEncrypt(UINT8 *kek,UINT8 kekLen,UINT8 *data,UINT8 *ret)

{
  undefined3 in_register_0000202d;
  undefined auStack416 [4];
  UINT8 pBuf [400];
  
  rijndael_set_key((rijndael_ctx *)auStack416,kek,CONCAT31(in_register_0000202d,kekLen) << 6,1);
  rijndael_encrypt((rijndael_ctx *)auStack416,data,ret);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int BL_AesWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *plain,UINT8 *keyIv,UINT8 *cipher)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  UINT8 aUStack72 [4];
  UINT8 a [8];
  UINT8 b [16];
  
  if (n != 0) {
    BL_AES_MEMSET(a + 4,'\0',0x10);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    BL_AES_MEMCPY(aUStack72,keyIv,8);
    BL_AES_MEMCPY(cipher + 8,plain,n << 3);
    uVar2 = 0;
    iVar4 = 6;
    do {
      iVar1 = 1;
      while (iVar3 = iVar1 * 8, iVar1 != n + 1) {
        BL_AES_MEMCPY(a + 4,aUStack72,8);
        BL_AES_MEMCPY(b + 4,cipher + iVar3,8);
        BL_AesEncrypt(kek,kekLen,a + 4,a + 4);
        BL_AES_MEMCPY(aUStack72,a + 4,8);
        a[3] = (char)uVar2 + (char)iVar1 ^ a[3];
        iVar1 = iVar1 + 1;
        BL_AES_MEMCPY(cipher + iVar3,b + 4,8);
      }
      iVar4 = iVar4 + -1;
      uVar2 = uVar2 + (n & 0xff) & 0xff;
    } while (iVar4 != 0);
    BL_AES_MEMCPY(cipher,aUStack72,8);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int BL_AesUnWrap(UINT8 *kek,UINT8 kekLen,UINT32 n,UINT8 *cipher,UINT8 *keyIv,UINT8 *plain)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  UINT32 UVar2;
  UINT8 *src;
  int iVar3;
  UINT8 aUStack472 [4];
  UINT8 a [8];
  UINT8 b [16];
  UINT8 pBuf [400];
  
  if (n != 0) {
    BL_AES_MEMSET(aUStack472,'\0',8);
    BL_AES_MEMSET(a + 4,'\0',0x10);
    BL_AES_MEMCPY(aUStack472,cipher,8);
    uVar1 = (n & 0xff) * 5;
    BL_AES_MEMCPY(plain,cipher + 8,n * 8);
    rijndael_set_key((rijndael_ctx *)(b + 0xc),kek,CONCAT31(in_register_0000202d,kekLen) << 6,0);
    iVar3 = 6;
    do {
      UVar2 = n;
      src = plain + n * 8 + -8;
      while (0 < (int)UVar2) {
        BL_AES_MEMCPY(a + 4,aUStack472,8);
        b[3] = (char)(uVar1 & 0xff) + (char)UVar2 ^ b[3];
        BL_AES_MEMCPY(b + 4,src,8);
        rijndael_decrypt((rijndael_ctx *)(b + 0xc),a + 4,a + 4);
        BL_AES_MEMCPY(aUStack472,a + 4,8);
        BL_AES_MEMCPY(src,b + 4,8);
        src = src + -8;
        UVar2 = UVar2 - 1;
      }
      uVar1 = (uVar1 & 0xff) - (n & 0xff);
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    if (keyIv == (UINT8 *)0x0) {
      keyIv = BL_DEFAULT_IV;
    }
    iVar3 = BL_AES_MEMCMP(keyIv,aUStack472,8);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -(uint)(iVar3 != 0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Variable defined which should be unmapped: pBuf

void Bl_hmac_md5(UINT8 *text_data,int text_len,UINT8 *key,int key_len,void *digest)

{
  ulong *puVar1;
  Bl_MD5_CTX *pBVar2;
  Bl_MD5_CTX *context;
  Bl_MD5_CTX *context_00;
  undefined auStack584 [4];
  Bl_MD5_CTX tctx;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    wpa_MD5Init((Bl_MD5_CTX *)auStack584);
    wpa_MD5Update((Bl_MD5_CTX *)auStack584,key,key_len);
    wpa_MD5Final(pBuf + 0x94,(Bl_MD5_CTX *)auStack584);
    key_len = 0x10;
    key = pBuf + 0x94;
  }
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  context_00 = (Bl_MD5_CTX *)(pBuf + 0x3c);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    puVar1 = pBVar2->state;
    pBVar2->state[0] = pBVar2->state[0] ^ 0x36363636;
    pBVar2 = (Bl_MD5_CTX *)(puVar1 + 1);
  } while ((Bl_MD5_CTX *)(puVar1 + 1) != context_00);
  wpa_MD5Init(context_00);
  wpa_MD5Update(context_00,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context_00,text_data,text_len);
  wpa_MD5Final((uchar *)digest,context_00);
  memset(tctx.buffer + 0x3c,0,0x40);
  memcpy(tctx.buffer + 0x3c,key,key_len);
  pBVar2 = (Bl_MD5_CTX *)(tctx.buffer + 0x3c);
  do {
    context = (Bl_MD5_CTX *)(pBVar2->state + 1);
    pBVar2->state[0] = pBVar2->state[0] ^ 0x5c5c5c5c;
    pBVar2 = context;
  } while (context != context_00);
  wpa_MD5Init(context);
  wpa_MD5Update(context,tctx.buffer + 0x3c,0x40);
  wpa_MD5Update(context,(UINT8 *)digest,0x10);
  wpa_MD5Final((uchar *)digest,context);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void Bl_hmac_sha1(uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
                 int outputLen)

{
  uint *puVar1;
  uint *puVar2;
  uchar **ppuVar3;
  int iVar4;
  uint *Message_Digest;
  uint local_1c0;
  uchar pBuf [400];
  
  if (0x40 < key_len) {
    Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),key,key_len);
    Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),key);
    key_len = 0x14;
  }
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  Message_Digest = (uint *)(pBuf + 0x3c);
  puVar1 = &local_1c0;
  do {
    puVar2 = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = puVar2;
  } while (puVar2 != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  iVar4 = 0;
  while (iVar4 < textNum) {
    puVar1 = (uint *)(pTextLen + iVar4);
    ppuVar3 = ppText + iVar4;
    iVar4 = iVar4 + 1;
    Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),*ppuVar3,*puVar1);
  }
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)Message_Digest);
  memset(&local_1c0,0,0x40);
  memcpy(&local_1c0,key,key_len);
  puVar1 = &local_1c0;
  do {
    puVar2 = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = puVar2;
  } while (puVar2 != Message_Digest);
  Bl_SHA1Init((Bl_SHA1_CTX *)(pBuf + 0x50));
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)&local_1c0,0x40);
  Bl_SHA1Update((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)puVar2,0x14);
  Bl_SHA1Final((Bl_SHA1_CTX *)(pBuf + 0x50),(UINT8 *)puVar2);
  memcpy(output,puVar2,outputLen);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void Bl_PRF(uchar *key,int key_len,uchar *prefix,int prefix_len,uchar *data,int data_len,
           uchar *output,int len)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int local_b0;
  int total_len;
  uchar *pText;
  UINT8 prf_input [120];
  
  total_len = (int)&pText;
  memset(&pText,0,0x78);
  if (prefix == (uchar *)0x0) {
    memcpy(&pText,data,data_len);
    local_b0 = data_len;
  }
  else {
    memcpy(&pText,prefix,prefix_len);
    local_b0 = prefix_len + 1 + data_len;
    prf_input[prefix_len + -4] = '\0';
    memcpy((void *)((int)&pText + prefix_len + 1),data,data_len);
  }
  prf_input[local_b0 + -4] = '\0';
  iVar3 = 0;
  iVar2 = 0;
  local_b0 = local_b0 + 1;
  while (iVar1 = (iVar2 * -0x14 + len) * 0x1000000 >> 0x18, iVar2 < (len + 0x13) / 0x14) {
    if (0x14 < iVar1) {
      iVar1 = 0x14;
    }
    Bl_hmac_sha1((uchar **)&total_len,&local_b0,1,key,key_len,output + iVar3,(int)(char)iVar1);
    iVar3 = iVar3 + (char)iVar1;
    iVar2 = iVar2 + 1;
    *(char *)((int)&total_len + local_b0 + 3) = *(char *)((int)&total_len + local_b0 + 3) + '\x01';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wpa_MD5Transform(UINT32 *state,ulong *block)

{
  ulong uVar1;
  ulong uVar2;
  ulong uVar3;
  ulong uVar4;
  ulong uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  ulong uVar16;
  ulong uVar17;
  ulong uVar18;
  ulong uVar19;
  uint uVar20;
  uint uVar21;
  ulong uVar22;
  ulong uVar23;
  ulong uVar24;
  ulong uVar25;
  
  uVar19 = *block;
  uVar20 = state[2];
  uVar21 = state[3];
  uVar12 = state[1];
  uVar5 = block[1];
  uVar8 = ((uVar20 ^ uVar21) & uVar12 ^ uVar21) + *state + uVar19 + 0xd76aa478;
  uVar9 = (uVar8 >> 0x19 | uVar8 * 0x80) + uVar12;
  uVar22 = block[2];
  uVar8 = ((uVar12 ^ uVar20) & uVar9 ^ uVar20) + uVar5 + 0xe8c7b756 + uVar21;
  uVar6 = (uVar8 >> 0x14 | uVar8 * 0x1000) + uVar9;
  uVar8 = ((uVar12 ^ uVar9) & uVar6 ^ uVar12) + uVar22 + 0x242070db + uVar20;
  uVar14 = block[3];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar14 + 0xc1bdceee + uVar12;
  uVar24 = block[4];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar24 + 0xf57c0faf + uVar9;
  uVar16 = block[5];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar16 + 0x4787c62a + uVar6;
  uVar1 = block[6];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar1 + 0xa8304613 + uVar8;
  uVar18 = block[7];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar18 + 0xfd469501 + uVar7;
  uVar4 = block[8];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar4 + 0x698098d8 + uVar9;
  uVar2 = block[9];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar2 + 0x8b44f7af + uVar6;
  uVar13 = block[10];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + (uVar13 - 0xa44f) + uVar8;
  uVar23 = block[0xb];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar23 + 0x895cd7be + uVar7;
  uVar15 = block[0xc];
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar6 ^ uVar8) & uVar7 ^ uVar6) + uVar15 + 0x6b901122 + uVar9;
  uVar25 = block[0xd];
  uVar9 = (uVar9 >> 0x19 | uVar9 * 0x80) + uVar7;
  uVar6 = ((uVar8 ^ uVar7) & uVar9 ^ uVar8) + uVar25 + 0xfd987193 + uVar6;
  uVar17 = block[0xe];
  uVar6 = (uVar6 >> 0x14 | uVar6 * 0x1000) + uVar9;
  uVar8 = ((uVar7 ^ uVar9) & uVar6 ^ uVar7) + uVar17 + 0xa679438e + uVar8;
  uVar3 = block[0xf];
  uVar8 = (uVar8 * 0x20000 | uVar8 >> 0xf) + uVar6;
  uVar7 = ((uVar9 ^ uVar6) & uVar8 ^ uVar9) + uVar3 + 0x49b40821 + uVar7;
  uVar7 = (uVar7 * 0x400000 | uVar7 >> 10) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar5 + 0xf61e2562 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar1 + 0xc040b340 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar23 + 0x265e5a51 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar19 + 0xe9b6c7aa + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar16 + 0xd62f105d + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar13 + 0x2441453 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar3 + 0xd8a1e681 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar24 + 0xe7d3fbc8 + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar2 + 0x21e1cde6 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar17 + 0xc33707d6 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar14 + 0xf4d50d87 + uVar8;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = ((uVar6 ^ uVar8) & uVar9 ^ uVar6) + uVar4 + 0x455a14ed + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = ((uVar8 ^ uVar7) & uVar6 ^ uVar8) + uVar25 + 0xa9e3e905 + uVar9;
  uVar9 = (uVar9 >> 0x1b | uVar9 * 0x20) + uVar7;
  uVar6 = ((uVar7 ^ uVar9) & uVar8 ^ uVar7) + uVar22 + 0xfcefa3f8 + uVar6;
  uVar6 = (uVar6 >> 0x17 | uVar6 * 0x200) + uVar9;
  uVar8 = ((uVar9 ^ uVar6) & uVar7 ^ uVar9) + uVar8 + uVar18 + 0x676f02d9;
  uVar8 = (uVar8 >> 0x12 | uVar8 * 0x4000) + uVar6;
  uVar7 = (uVar9 & (uVar6 ^ uVar8) ^ uVar6) + uVar15 + 0x8d2a4c8a + uVar7;
  uVar7 = (uVar7 * 0x100000 | uVar7 >> 0xc) + uVar8;
  uVar9 = uVar9 + (uVar16 - 0x5c6be) + (uVar6 ^ uVar8 ^ uVar7);
  uVar10 = (uVar9 >> 0x1c | uVar9 * 0x10) + uVar7;
  uVar6 = (uVar8 ^ uVar7 ^ uVar10) + uVar4 + 0x8771f681 + uVar6;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar7 ^ uVar10 ^ uVar6) + uVar23 + 0x6d9d6122 + uVar8;
  uVar8 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar7 = (uVar10 ^ uVar6 ^ uVar8) + uVar17 + 0xfde5380c + uVar7;
  uVar9 = (uVar7 * 0x800000 | uVar7 >> 9) + uVar8;
  uVar7 = (uVar6 ^ uVar8 ^ uVar9) + uVar5 + 0xa4beea44 + uVar10;
  uVar10 = (uVar7 >> 0x1c | uVar7 * 0x10) + uVar9;
  uVar6 = (uVar8 ^ uVar9 ^ uVar10) + uVar6 + uVar24 + 0x4bdecfa9;
  uVar6 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar10;
  uVar8 = (uVar9 ^ uVar10 ^ uVar6) + uVar8 + uVar18 + 0xf6bb4b60;
  uVar7 = (uVar8 >> 0x10 | uVar8 * 0x10000) + uVar6;
  uVar8 = (uVar10 ^ uVar6 ^ uVar7) + uVar13 + 0xbebfbc70 + uVar9;
  uVar9 = (uVar8 * 0x800000 | uVar8 >> 9) + uVar7;
  uVar8 = (uVar6 ^ uVar7 ^ uVar9) + uVar10 + uVar25 + 0x289b7ec6;
  uVar8 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar9;
  uVar6 = (uVar7 ^ uVar9 ^ uVar8) + uVar6 + uVar19 + 0xeaa127fa;
  uVar10 = (uVar6 >> 0x15 | uVar6 * 0x800) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar10) + uVar14 + 0xd4ef3085 + uVar7;
  uVar7 = (uVar6 >> 0x10 | uVar6 * 0x10000) + uVar10;
  uVar6 = (uVar8 ^ uVar10 ^ uVar7) + uVar9 + uVar1 + 0x4881d05;
  uVar6 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar8 = (uVar10 ^ uVar7 ^ uVar6) + uVar8 + uVar2 + 0xd9d4d039;
  uVar9 = (uVar8 >> 0x1c | uVar8 * 0x10) + uVar6;
  uVar8 = (uVar7 ^ uVar6 ^ uVar9) + uVar10 + uVar15 + 0xe6db99e5;
  uVar8 = (uVar8 >> 0x15 | uVar8 * 0x800) + uVar9;
  uVar7 = (uVar6 ^ uVar9 ^ uVar8) + uVar3 + 0x1fa27cf8 + uVar7;
  uVar7 = (uVar7 >> 0x10 | uVar7 * 0x10000) + uVar8;
  uVar6 = (uVar9 ^ uVar8 ^ uVar7) + uVar6 + uVar22 + 0xc4ac5665;
  uVar10 = (uVar6 * 0x800000 | uVar6 >> 9) + uVar7;
  uVar6 = ((~uVar8 | uVar10) ^ uVar7) + uVar19 + 0xf4292244 + uVar9;
  uVar9 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar10;
  uVar8 = ((~uVar7 | uVar9) ^ uVar10) + uVar18 + 0x432aff97 + uVar8;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar9;
  uVar6 = ((~uVar10 | uVar8) ^ uVar9) + uVar17 + 0xab9423a7 + uVar7;
  uVar7 = (uVar6 >> 0x11 | uVar6 * 0x8000) + uVar8;
  uVar6 = ((~uVar9 | uVar7) ^ uVar8) + uVar10 + uVar16 + 0xfc93a039;
  uVar6 = (uVar6 * 0x200000 | uVar6 >> 0xb) + uVar7;
  uVar9 = ((~uVar8 | uVar6) ^ uVar7) + uVar9 + uVar15 + 0x655b59c3;
  uVar11 = (uVar9 >> 0x1a | uVar9 * 0x40) + uVar6;
  uVar8 = ((~uVar7 | uVar11) ^ uVar6) + uVar8 + uVar14 + 0x8f0ccc92;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar6 | uVar10) ^ uVar11) + (uVar13 - 0x100b83) + uVar7;
  uVar7 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar7) ^ uVar10) + uVar5 + 0x85845dd1 + uVar6;
  uVar9 = (uVar8 * 0x200000 | uVar8 >> 0xb) + uVar7;
  uVar8 = ((~uVar10 | uVar9) ^ uVar7) + uVar11 + uVar4 + 0x6fa87e4f;
  uVar6 = (uVar8 >> 0x1a | uVar8 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar6) ^ uVar9) + uVar10 + uVar3 + 0xfe2ce6e0;
  uVar8 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar6;
  uVar7 = ((~uVar9 | uVar8) ^ uVar6) + uVar7 + uVar1 + 0xa3014314;
  uVar7 = (uVar7 >> 0x11 | uVar7 * 0x8000) + uVar8;
  uVar9 = ((~uVar6 | uVar7) ^ uVar8) + uVar25 + 0x4e0811a1 + uVar9;
  uVar9 = (uVar9 * 0x200000 | uVar9 >> 0xb) + uVar7;
  uVar6 = ((~uVar8 | uVar9) ^ uVar7) + uVar6 + uVar24 + 0xf7537e82;
  uVar11 = (uVar6 >> 0x1a | uVar6 * 0x40) + uVar9;
  uVar8 = ((~uVar7 | uVar11) ^ uVar9) + uVar8 + uVar23 + 0xbd3af235;
  uVar10 = (uVar8 >> 0x16 | uVar8 * 0x400) + uVar11;
  uVar8 = ((~uVar9 | uVar10) ^ uVar11) + uVar7 + uVar22 + 0x2ad7d2bb;
  uVar6 = (uVar8 >> 0x11 | uVar8 * 0x8000) + uVar10;
  uVar8 = ((~uVar11 | uVar6) ^ uVar10) + uVar2 + 0xeb86d391 + uVar9;
  *state = uVar11 + *state;
  state[2] = uVar20 + uVar6;
  state[3] = uVar21 + uVar10;
  state[1] = uVar12 + uVar6 + (uVar8 * 0x200000 | uVar8 >> 0xb);
  memset(block,0,0x40);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wpa_MD5Init(Bl_MD5_CTX *context)

{
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->count[1] = 0;
  context->count[0] = 0;
  context->state[3] = 0x10325476;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wpa_MD5Update(Bl_MD5_CTX *context,UINT8 *input,UINT32 inputLen)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = context->count[0];
  uVar2 = uVar1 + inputLen * 8;
  context->count[0] = uVar2;
  uVar1 = uVar1 >> 3 & 0x3f;
  if (uVar2 < inputLen * 8) {
    context->count[1] = context->count[1] + 1;
  }
  context->count[1] = (inputLen >> 0x1d) + context->count[1];
  uVar2 = 0x40 - uVar1;
  if (inputLen < uVar2) {
    uVar2 = 0;
  }
  else {
    memcpy(context->buffer + uVar1,input,uVar2);
    wpa_MD5Transform((UINT32 *)context,(ulong *)context->buffer);
    while (uVar2 + 0x3f < inputLen) {
      memcpy(context->scratch,input + uVar2,0x40);
      wpa_MD5Transform((UINT32 *)context,context->scratch);
      uVar2 = uVar2 + 0x40;
    }
    uVar1 = 0;
  }
  memcpy(context->buffer + uVar1,input + uVar2,inputLen - uVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wpa_MD5Final(uchar *digest,Bl_MD5_CTX *context)

{
  uint uVar1;
  int iVar2;
  UINT8 aUStack24 [4];
  uchar bits [8];
  
  memcpy(aUStack24,context->count,8);
  uVar1 = context->count[0] >> 3 & 0x3f;
  if (uVar1 < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  wpa_MD5Update(context,PADDING,iVar2 - uVar1);
  wpa_MD5Update(context,aUStack24,8);
  memcpy(digest,context,0x10);
  memset(context,0,0x98);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int rijndaelKeySetupEnc(u32 *rk,u8 *cipherKey,int keyBits)

{
  uint uVar1;
  uint uVar2;
  u32 *puVar3;
  u32 *puVar4;
  
  *rk = (uint)*cipherKey << 0x18 ^ (uint)cipherKey[1] << 0x10 ^ (uint)cipherKey[3] ^
        (uint)cipherKey[2] << 8;
  rk[1] = (uint)cipherKey[4] << 0x18 ^ (uint)cipherKey[5] << 0x10 ^ (uint)cipherKey[7] ^
          (uint)cipherKey[6] << 8;
  rk[2] = (uint)cipherKey[8] << 0x18 ^ (uint)cipherKey[9] << 0x10 ^ (uint)cipherKey[0xb] ^
          (uint)cipherKey[10] << 8;
  rk[3] = (uint)cipherKey[0xc] << 0x18 ^ (uint)cipherKey[0xd] << 0x10 ^ (uint)cipherKey[0xf] ^
          (uint)cipherKey[0xe] << 8;
  if (keyBits == 0x80) {
    puVar3 = rcon;
    puVar4 = rk + 0x24;
    while( true ) {
      uVar1 = *puVar3;
      uVar2 = rk[3];
      puVar3 = puVar3 + 1;
      uVar1 = *rk ^ uVar1 ^ (uint)Te4[uVar2 >> 0x18] ^ (uint)Te4[uVar2 & 0xff] << 8 ^
              (uint)Te4[uVar2 >> 0x10 & 0xff] << 0x18 ^ (uint)Te4[uVar2 >> 8 & 0xff] << 0x10;
      rk[4] = uVar1;
      uVar1 = uVar1 ^ rk[1];
      rk[5] = uVar1;
      uVar1 = uVar1 ^ rk[2];
      rk[6] = uVar1;
      rk[7] = uVar1 ^ uVar2;
      if (rk == puVar4) break;
      rk = rk + 4;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 10;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void rijndael_set_key(rijndael_ctx *ctx,u8 *key,int bits,int encrypt)

{
  int iVar1;
  u32 *rk;
  int iVar2;
  u32 uVar3;
  u32 *puVar4;
  uint uVar5;
  u32 *puVar6;
  
  rk = ctx->key;
  iVar2 = rijndaelKeySetupEnc(rk,key,bits);
  ctx->Nr = iVar2;
  if (encrypt == 0) {
    ctx->decrypt = 1;
    if (iVar2 == 0) {
      iVar2 = rijndaelKeySetupEnc(rk,key,bits);
    }
    puVar4 = rk;
    puVar6 = ctx->key + iVar2 * 4 + -2;
    while (encrypt < iVar2 * 4 - encrypt) {
      uVar3 = *puVar4;
      encrypt = encrypt + 4;
      *puVar4 = puVar6[2];
      puVar6[2] = uVar3;
      uVar3 = puVar4[1];
      puVar4[1] = puVar6[3];
      puVar6[3] = uVar3;
      uVar3 = puVar4[2];
      puVar4[2] = puVar6[4];
      puVar6[4] = uVar3;
      uVar3 = puVar4[3];
      puVar4[3] = puVar6[5];
      puVar6[5] = uVar3;
      puVar4 = puVar4 + 4;
      puVar6 = puVar6 + -4;
    }
    iVar1 = 1;
    while (iVar1 < iVar2) {
      puVar4 = rk + 4;
      uVar5 = *puVar4;
      iVar1 = iVar1 + 1;
      *puVar4 = Td2[Te4[uVar5 >> 8 & 0xff]] ^
                Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[5];
      rk[5] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[6];
      rk[6] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      uVar5 = rk[7];
      rk[7] = Td2[Te4[uVar5 >> 8 & 0xff]] ^
              Td0[Te4[uVar5 >> 0x18]] ^ Td3[Te4[uVar5 & 0xff]] ^ Td1[Te4[uVar5 >> 0x10 & 0xff]];
      rk = puVar4;
    }
  }
  else {
    ctx->decrypt = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rijndael_decrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar5 = Td0[uVar10 >> 0x18] ^ Td3[uVar16 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Td1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar6 = Td0[uVar16 >> 0x18] ^ Td3[uVar14 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Td1 + (uVar10 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar11 >> 6 & 0x3fc));
    uVar8 = Td0[uVar14 >> 0x18] ^ Td3[uVar11 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Td1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Td2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Td0[uVar11 >> 0x18] ^ Td3[uVar10 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Td1 + (uVar14 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Td2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar12 >> 0x10 & 0xff;
    uVar18 = uVar8 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar6 >> 0x10 & 0xff;
    uVar14 = uVar5 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Td0[uVar5 >> 0x18] ^ Td3[uVar6 & 0xff] ^ uVar10 ^ Td1[uVar19] ^ Td2[uVar18];
    uVar16 = Td0[uVar6 >> 0x18] ^ Td3[uVar8 & 0xff] ^ puVar4[9] ^ Td1[uVar17] ^ Td2[uVar16];
    uVar14 = Td0[uVar8 >> 0x18] ^ Td3[uVar12 & 0xff] ^ puVar4[10] ^ Td1[uVar11] ^ Td2[uVar14];
    uVar11 = Td0[uVar12 >> 0x18] ^ Td3[uVar5 & 0xff] ^ puVar4[0xb] ^ Td1[uVar9] ^ Td2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Td4[uVar5 >> 0x18] << 0x18 ^ (uint)Td4[uVar19] << 0x10 ^ (uint)Td4[uVar6 & 0xff] ^
           (uint)Td4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Td4[uVar17];
  bVar2 = Td4[uVar6 >> 0x18];
  bVar3 = Td4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Td4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Td4[uVar12 >> 0x18];
  uVar10 = (uint)Td4[uVar8 >> 0x18] << 0x18 ^ (uint)Td4[uVar11] << 0x10 ^ (uint)Td4[uVar12 & 0xff] ^
           (uint)Td4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Td4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Td4[uVar5 & 0xff] ^
           (uint)Td4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void rijndael_encrypt(rijndael_ctx *ctx,u8 *src,u8 *dst)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  u32 *puVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  
  uVar10 = (uint)*src << 0x18 ^ (uint)src[1] << 0x10 ^ (uint)src[3] ^ (uint)src[2] << 8 ^
           ctx->key[0];
  uVar16 = (uint)src[4] << 0x18 ^ (uint)src[5] << 0x10 ^ (uint)src[7] ^ (uint)src[6] << 8 ^
           ctx->key[1];
  uVar14 = (uint)src[8] << 0x18 ^ (uint)src[9] << 0x10 ^ (uint)src[0xb] ^ (uint)src[10] << 8 ^
           ctx->key[2];
  uVar11 = (uint)src[0xc] << 0x18 ^ (uint)src[0xd] << 0x10 ^ (uint)src[0xf] ^ (uint)src[0xe] << 8 ^
           ctx->key[3];
  iVar13 = ctx->Nr >> 1;
  puVar4 = ctx->key;
  iVar15 = iVar13;
  while( true ) {
    uVar8 = Te0[uVar10 >> 0x18] ^ Te3[uVar11 & 0xff] ^ puVar4[4] ^
            *(uint *)((int)Te1 + (uVar16 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar14 >> 6 & 0x3fc));
    iVar15 = iVar15 + -1;
    uVar6 = Te0[uVar16 >> 0x18] ^ Te3[uVar10 & 0xff] ^ puVar4[5] ^
            *(uint *)((int)Te1 + (uVar14 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar11 >> 6 & 0x3fc));
    uVar5 = Te0[uVar14 >> 0x18] ^ Te3[uVar16 & 0xff] ^ puVar4[6] ^
            *(uint *)((int)Te1 + (uVar11 >> 0xe & 0x3fc)) ^
            *(uint *)((int)Te2 + (uVar10 >> 6 & 0x3fc));
    uVar12 = Te0[uVar11 >> 0x18] ^ Te3[uVar14 & 0xff] ^ puVar4[7] ^
             *(uint *)((int)Te1 + (uVar10 >> 0xe & 0x3fc)) ^
             *(uint *)((int)Te2 + (uVar16 >> 6 & 0x3fc));
    uVar19 = uVar6 >> 0x10 & 0xff;
    uVar18 = uVar5 >> 8 & 0xff;
    uVar10 = puVar4[8];
    uVar17 = uVar5 >> 0x10 & 0xff;
    uVar16 = uVar12 >> 8 & 0xff;
    uVar11 = uVar12 >> 0x10 & 0xff;
    uVar14 = uVar8 >> 8 & 0xff;
    uVar9 = uVar8 >> 0x10 & 0xff;
    uVar7 = uVar6 >> 8 & 0xff;
    if (iVar15 == 0) break;
    uVar10 = Te0[uVar8 >> 0x18] ^ Te3[uVar12 & 0xff] ^ uVar10 ^ Te1[uVar19] ^ Te2[uVar18];
    uVar16 = Te0[uVar6 >> 0x18] ^ Te3[uVar8 & 0xff] ^ puVar4[9] ^ Te1[uVar17] ^ Te2[uVar16];
    uVar14 = Te0[uVar5 >> 0x18] ^ Te3[uVar6 & 0xff] ^ puVar4[10] ^ Te1[uVar11] ^ Te2[uVar14];
    uVar11 = Te0[uVar12 >> 0x18] ^ Te3[uVar5 & 0xff] ^ puVar4[0xb] ^ Te1[uVar9] ^ Te2[uVar7];
    puVar4 = puVar4 + 8;
  }
  puVar4 = ctx->key + iVar13 * 8;
  uVar10 = (uint)Te4[uVar8 >> 0x18] << 0x18 ^ (uint)Te4[uVar19] << 0x10 ^ (uint)Te4[uVar12 & 0xff] ^
           (uint)Te4[uVar18] << 8 ^ uVar10;
  *dst = (u8)(uVar10 >> 0x18);
  dst[1] = (u8)(uVar10 >> 0x10);
  dst[2] = (u8)(uVar10 >> 8);
  bVar1 = Te4[uVar17];
  bVar2 = Te4[uVar6 >> 0x18];
  bVar3 = Te4[uVar8 & 0xff];
  dst[3] = (u8)uVar10;
  uVar10 = (uint)bVar2 << 0x18 ^ (uint)bVar1 << 0x10 ^ (uint)bVar3 ^ (uint)Te4[uVar16] << 8 ^
           puVar4[1];
  dst[4] = (u8)(uVar10 >> 0x18);
  dst[5] = (u8)(uVar10 >> 0x10);
  dst[6] = (u8)(uVar10 >> 8);
  dst[7] = (u8)uVar10;
  bVar1 = Te4[uVar12 >> 0x18];
  uVar10 = (uint)Te4[uVar5 >> 0x18] << 0x18 ^ (uint)Te4[uVar11] << 0x10 ^ (uint)Te4[uVar6 & 0xff] ^
           (uint)Te4[uVar14] << 8 ^ puVar4[2];
  dst[8] = (u8)(uVar10 >> 0x18);
  dst[9] = (u8)(uVar10 >> 0x10);
  dst[0xb] = (u8)uVar10;
  bVar2 = Te4[uVar9];
  dst[10] = (u8)(uVar10 >> 8);
  uVar10 = (uint)bVar1 << 0x18 ^ (uint)bVar2 << 0x10 ^ (uint)Te4[uVar5 & 0xff] ^
           (uint)Te4[uVar7] << 8 ^ puVar4[3];
  dst[0xc] = (u8)(uVar10 >> 0x18);
  dst[0xd] = (u8)(uVar10 >> 0x10);
  dst[0xe] = (u8)(uVar10 >> 8);
  dst[0xf] = (u8)uVar10;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void Bl_SHA1ProcessMessageBlock(Bl_SHA1_CTX *context)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  UINT32 *pUVar4;
  uint uVar5;
  UINT32 *pUVar6;
  UINT32 *pUVar7;
  uint uVar8;
  UINT32 UVar9;
  uint uVar10;
  uint uVar11;
  UINT32 UVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  UINT32 UVar16;
  
  pUVar4 = context->Scratch;
  pUVar6 = pUVar4;
  do {
    pUVar7 = pUVar6 + 1;
    *pUVar6 = (uint)*(byte *)(pUVar6 + 0x10) << 0x18 | (uint)*(byte *)((int)pUVar6 + 0x41) << 0x10 |
              (uint)*(byte *)((int)pUVar6 + 0x42) << 8 | (uint)*(byte *)((int)pUVar6 + 0x43);
    pUVar6 = pUVar7;
  } while ((UINT32 *)context->Message_Block != pUVar7);
  uVar11 = 0;
  uVar8 = context->Intermediate_Hash[2];
  uVar10 = context->Intermediate_Hash[0];
  UVar12 = context->Intermediate_Hash[1];
  uVar2 = context->Intermediate_Hash[3];
  UVar16 = context->Intermediate_Hash[4];
  do {
    uVar13 = uVar2;
    uVar3 = uVar10;
    uVar2 = uVar8;
    if ((uVar11 & 0x30) == 0) {
      UVar9 = context->Scratch[uVar11];
    }
    else {
      uVar8 = pUVar4[uVar11 + 0xd & 0xf] ^ pUVar4[uVar11 + 8 & 0xf] ^ pUVar4[uVar11 & 0xf] ^
              pUVar4[uVar11 + 2 & 0xf];
      UVar9 = uVar8 >> 0x1f | uVar8 << 1;
      pUVar4[uVar11 & 0xf] = UVar9;
    }
    uVar11 = uVar11 + 1;
    uVar10 = UVar9 + ((uVar2 ^ uVar13) & UVar12 ^ uVar13) +
                     (uVar3 << 5 | uVar3 >> 0x1b) + 0x5a827999 + UVar16;
    uVar8 = UVar12 << 0x1e | UVar12 >> 2;
    UVar12 = uVar3;
    UVar16 = uVar13;
  } while (uVar11 != 0x14);
  do {
    uVar14 = uVar10;
    uVar1 = uVar2;
    uVar2 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar5 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar2 = pUVar4[uVar2 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar5 & 0xf];
    uVar2 = uVar2 >> 0x1f | uVar2 << 1;
    pUVar4[uVar15] = uVar2;
    uVar10 = (uVar3 ^ uVar8 ^ uVar1) + (uVar14 << 5 | uVar14 >> 0x1b) + 0x6ed9eba1 + uVar2 + uVar13;
    uVar5 = uVar3 << 0x1e | uVar3 >> 2;
    uVar2 = uVar8;
    uVar3 = uVar14;
    uVar8 = uVar5;
    uVar13 = uVar1;
  } while (uVar11 != 0x28);
  do {
    uVar8 = uVar10;
    uVar13 = uVar11 + 0xd;
    uVar10 = uVar11 + 8;
    uVar15 = uVar11 & 0xf;
    uVar3 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar13 & 0xf] ^ pUVar4[uVar10 & 0xf] ^ pUVar4[uVar15] ^ pUVar4[uVar3 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar15] = uVar10;
    uVar10 = ((uVar5 | uVar2) & uVar14 | uVar5 & uVar2) + (uVar8 << 5 | uVar8 >> 0x1b) + 0x8f1bbcdc
             + uVar10 + uVar1;
    uVar13 = uVar14 << 0x1e | uVar14 >> 2;
    uVar1 = uVar2;
    uVar14 = uVar8;
    uVar3 = uVar2;
    uVar2 = uVar5;
    uVar5 = uVar13;
  } while (uVar11 != 0x3c);
  do {
    uVar15 = uVar13;
    uVar5 = uVar2;
    uVar1 = uVar10;
    uVar10 = uVar11 + 0xd;
    uVar13 = uVar11 + 8;
    uVar2 = uVar11 & 0xf;
    uVar14 = uVar11 + 2;
    uVar11 = uVar11 + 1;
    uVar10 = pUVar4[uVar10 & 0xf] ^ pUVar4[uVar13 & 0xf] ^ pUVar4[uVar2] ^ pUVar4[uVar14 & 0xf];
    uVar10 = uVar10 >> 0x1f | uVar10 << 1;
    pUVar4[uVar2] = uVar10;
    uVar10 = uVar10 + (uVar8 ^ uVar15 ^ uVar5) + (uVar1 << 5 | uVar1 >> 0x1b) + 0xca62c1d6 + uVar3;
    uVar13 = uVar8 << 0x1e | uVar8 >> 2;
    uVar8 = uVar1;
    uVar3 = uVar5;
    uVar2 = uVar15;
  } while (uVar11 != 0x50);
  context->Message_Block_Index = 0;
  UVar12 = context->Intermediate_Hash[1];
  context->Intermediate_Hash[0] = uVar10 + context->Intermediate_Hash[0];
  context->Intermediate_Hash[1] = uVar1 + UVar12;
  context->Intermediate_Hash[2] = uVar13 + context->Intermediate_Hash[2];
  context->Intermediate_Hash[3] = uVar15 + context->Intermediate_Hash[3];
  context->Intermediate_Hash[4] = uVar5 + context->Intermediate_Hash[4];
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int Bl_SHA1Init(Bl_SHA1_CTX *context)

{
  if (context != (Bl_SHA1_CTX *)0x0) {
    context->Intermediate_Hash[0] = 0x67452301;
    context->Intermediate_Hash[1] = 0xefcdab89;
    context->Intermediate_Hash[2] = 0x98badcfe;
    context->Intermediate_Hash[3] = 0x10325476;
    context->Length_Low = 0;
    context->Length_High = 0;
    context->Intermediate_Hash[4] = 0xc3d2e1f0;
    *(undefined4 *)&context->Message_Block_Index = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



int Bl_SHA1Final(Bl_SHA1_CTX *context,UINT8 *Message_Digest)

{
  short sVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  UINT32 UVar5;
  SINT16 *pSVar6;
  
  uVar4 = 1;
  if (((context != (Bl_SHA1_CTX *)0x0) && (Message_Digest != (UINT8 *)0x0)) &&
     (uVar4 = (uint)context->Corrupted, uVar4 == 0)) {
    if (context->Computed == '\0') {
      iVar3 = (int)context->Message_Block_Index;
      context->Message_Block_Index = (SINT16)((uint)((iVar3 + 1) * 0x10000) >> 0x10);
      context->Message_Block[iVar3] = -0x80;
      if (iVar3 < 0x38) {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[sVar1] = '\0';
        }
      }
      else {
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x3f < sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[sVar1] = '\0';
        }
        Bl_SHA1ProcessMessageBlock(context);
        while( true ) {
          sVar1 = context->Message_Block_Index;
          if (0x37 < sVar1) break;
          context->Message_Block_Index = sVar1 + 1;
          context->Message_Block[sVar1] = '\0';
        }
      }
      UVar5 = context->Length_High;
      *(ushort *)(context->Message_Block + 0x3a) =
           *(ushort *)&context->Length_High << 8 | *(ushort *)&context->Length_High >> 8;
      context->Message_Block[0x39] = (UINT8)(UVar5 >> 0x10);
      uVar2 = *(ushort *)&context->Length_Low;
      context->Message_Block[0x38] = (UINT8)(UVar5 >> 0x18);
      UVar5 = context->Length_Low;
      *(ushort *)(context->Message_Block + 0x3e) = uVar2 << 8 | uVar2 >> 8;
      context->Message_Block[0x3d] = (UINT8)(UVar5 >> 0x10);
      context->Message_Block[0x3c] = (UINT8)(UVar5 >> 0x18);
      Bl_SHA1ProcessMessageBlock(context);
      pSVar6 = (SINT16 *)context->Message_Block;
      do {
        *(UINT8 *)pSVar6 = '\0';
        pSVar6 = (SINT16 *)((int)pSVar6 + 1);
      } while (&context->Message_Block_Index != pSVar6);
      context->Length_Low = 0;
      context->Length_High = 0;
      context->Computed = '\x01';
    }
    uVar4 = 0;
    do {
      Message_Digest[uVar4] =
           (UINT8)(*(uint *)((int)context->Intermediate_Hash + (uVar4 & 0xfffffffc)) >>
                  ((~uVar4 & 3) << 3));
      uVar4 = uVar4 + 1;
    } while (uVar4 != 0x14);
    memset(context,0,0xa0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar4;
}



int Bl_SHA1Update(Bl_SHA1_CTX *context,UINT8 *message_array,uint length)

{
  short sVar1;
  UINT8 *pUVar2;
  uint uVar3;
  UINT32 UVar4;
  int iVar5;
  
  if (length == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uVar3 = 1;
  if ((context != (Bl_SHA1_CTX *)0x0) && (message_array != (UINT8 *)0x0)) {
    if (context->Computed == '\0') {
      uVar3 = (uint)context->Corrupted;
      if (uVar3 == 0) {
        pUVar2 = message_array + length;
        while ((message_array != pUVar2 && (context->Corrupted == '\0'))) {
          sVar1 = context->Message_Block_Index;
          iVar5 = (sVar1 + 1) * 0x10000;
          context->Message_Block_Index = (SINT16)((uint)iVar5 >> 0x10);
          context->Message_Block[sVar1] = *message_array;
          UVar4 = context->Length_Low + 8;
          context->Length_Low = UVar4;
          if ((UVar4 == 0) &&
             (UVar4 = context->Length_High + 1, context->Length_High = UVar4, UVar4 == 0)) {
            context->Corrupted = '\x01';
          }
          if (iVar5 >> 0x10 == 0x40) {
            Bl_SHA1ProcessMessageBlock(context);
          }
          message_array = message_array + 1;
        }
        uVar3 = 0;
      }
    }
    else {
      context->Corrupted = '\x03';
      uVar3 = 3;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

Status_e supplicantRestoreDefaults(void)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantRestoreDefaults");
  pmkCacheInit();
  pmkCacheRomInit();
  dbg_test_print("%dms : Leave: %s\n",_DAT_44b00120 / 1000,"supplicantRestoreDefaults");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return FW_SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void supplicantFuncInit(void)

{
  dbg_test_print("%dms : Enter: %s\n",_DAT_44b00120 / 1000,"supplicantFuncInit");
  supplicantRestoreDefaults();
  dbg_test_print("%dms : Leave: %s\n","supplicantFuncInit");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ap_setpsk(cm_ConnectionInfo_t *connPtr,CHAR *ssid,CHAR *passphrase)

{
  apInfo_t *paVar1;
  size_t sVar2;
  
  paVar1 = cm_GetApInfo(connPtr);
  if (paVar1 != (apInfo_t *)0x0) {
    sVar2 = strlen(ssid);
    (paVar1->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar2;
    memcpy(&(paVar1->bssConfig).comData,ssid,0x20);
    sVar2 = strlen(passphrase);
    (paVar1->bssConfig).RsnConfig.PSKPassPhraseLen = (UINT8)sVar2;
    memcpy((paVar1->bssConfig).RsnConfig.PSKPassPhrase,passphrase,0x40);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ap_resetConfiguration(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void InitializeAp(cm_ConnectionInfo_t *connPtr)

{
  ushort uVar1;
  apInfo_t *paVar2;
  apSpecificData_t *paVar3;
  size_t sVar4;
  
  paVar2 = cm_GetApInfo(connPtr);
  paVar3 = cm_GetApData(connPtr);
  if ((paVar2 != (apInfo_t *)0x0) && (paVar3 != (apSpecificData_t *)0x0)) {
    sVar4 = strlen("Marvell Micro AP");
    (paVar2->bssConfig).comData.SsIdLen = (IEEEtypes_Len_t)sVar4;
    memcpy(&(paVar2->bssConfig).comData,"Marvell Micro AP",0x20);
    (paVar2->bssData).updatePassPhrase = 1;
    memset(&(paVar2->bssConfig).RsnConfig,0,0x7c);
    uVar1 = *(ushort *)&(paVar2->bssConfig).RsnConfig;
    (paVar2->bssConfig).RsnConfig.AuthKeyCount = 1;
    *(ushort *)&(paVar2->bssConfig).RsnConfig = uVar1 & 0xf7 | 0x108;
    *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher =
         *(ushort *)&(paVar2->bssConfig).RsnConfig.wpa2UcstCipher & 0xf7 | 0x108;
    (paVar2->bssConfig).RsnConfig.MaxPwsHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.MaxGrpHskRetries = '\x03';
    (paVar2->bssConfig).RsnConfig.PwsHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpHskTimeOut = 100;
    (paVar2->bssConfig).RsnConfig.GrpReKeyTime = 0x15180;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl60x_check_mac_status(int *is_ok)

{
  int iVar1;
  dump_data_t *pdVar2;
  
  iVar1 = 0;
  pdVar2 = dump_data_poll;
  while( true ) {
    if ((int)(uint)dump_data_ptr <= iVar1) {
      *is_ok = 0;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (pdVar2->mac_debugRegHWSM2 != 0x8801e000) break;
    iVar1 = iVar1 + 1;
    pdVar2 = pdVar2 + 1;
  }
  *is_ok = 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void helper_record_dump(void)

{
  uint32_t *puVar1;
  dump_data_t *pdVar2;
  int iVar3;
  
  pdVar2 = dump_data_poll;
  puts("========= helper_record_dump\r\n");
  iVar3 = 0;
  while (iVar3 < (int)(uint)dump_data_ptr) {
    printf("[%d] time %ld, func %s\r\n",iVar3,pdVar2->time,pdVar2->func_name);
    printf("MAC: %08lx: rxControlCs %d,txControlCs %d,macControlCs %d\r\n",pdVar2->mac_debugRegHWSM2
           ,pdVar2->mac_debugRegHWSM2 & 0x3f,pdVar2->mac_debugRegHWSM2 >> 8 & 0x1ff,
           (uint)*(byte *)((int)&pdVar2->mac_debugRegHWSM2 + 3));
    iVar3 = iVar3 + 1;
    printf("MAC: Coex %04x,Backoff %04x,MPIF %04x,MPIF2 %04x\r\n",(uint)pdVar2->mac_debugPortCoex,
           (uint)pdVar2->mac_debugPortBackoff,(uint)pdVar2->mac_debugPortMacPhyIf,
           (uint)pdVar2->mac_debugPortMacPhyIf2);
    printf("PHY: MainFSM %04x,TDTX %04x,DSSSCCK1 %04x,DSSSCCKTx %04x\r\n",
           (uint)pdVar2->phy_debugPortMainFSM,(uint)pdVar2->phy_debugPortTDTX,
           (uint)pdVar2->phy_debugPortDSSSCCK1,(uint)pdVar2->phy_debugPortDSSSCCKTx);
    puVar1 = &pdVar2->rf_state;
    pdVar2 = pdVar2 + 1;
    printf("RFC: RC %s, RF %s\r\n",rf_state_str[*puVar1]);
  }
  printf("\r\n\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_rc_rf_states(uint *param_1,uint *param_2)

{
  uint uVar1;
  
  _DAT_40001220 = _DAT_40001220 & 0xfffffff | 0x20000000;
  uVar1 = _DAT_40001224 >> 0x19;
  *param_1 = _DAT_40001224 >> 0x1c & 7;
  *param_2 = uVar1 & 7;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void helper_record_all_states(char *func_name)

{
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar1 = _DAT_44b00120;
  uVar4 = (uint)dump_data_ptr;
  dump_data_poll[uVar4].func_name = func_name;
  dump_data_poll[uVar4].time = uVar1;
  helper_record_rc_rf_states(&dump_data_poll[uVar4].rc_state,&dump_data_poll[uVar4].rf_state);
  dump_data_poll[uVar4].mac_debugRegHWSM1 = _DAT_44b00500;
  dump_data_poll[uVar4].mac_debugRegHWSM2 = _DAT_44b00504;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortCoex = _DAT_44b0050c;
  _DAT_44b00510 = _DAT_44b00510 & 0xffff0000 | 0x2f0b;
  *(undefined4 *)&dump_data_poll[uVar4].mac_debugPortMacPhyIf = _DAT_44b0050c;
  _DAT_44900068 = _DAT_44900068 & 0xffff0000 | 0x14;
  _DAT_400000d0 = 4;
  _DAT_400000d4 = 0x40000004;
  _DAT_400000d8 = 0x80000004;
  _DAT_400000dc = 0xc0000004;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortTDTX = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortMainFSM = (ushort)(uVar2 >> 0x11);
  _DAT_44900074 = 0xb09;
  uVar2 = _DAT_400000e0 & 0xfffffffe;
  uVar3 = _DAT_400000e0 >> 1;
  _DAT_400000e0 = uVar2;
  dump_data_poll[uVar4].phy_debugPortDSSSCCK1 = (uint16_t)uVar3;
  dump_data_poll[uVar4].phy_debugPortDSSSCCKTx = (ushort)(uVar2 >> 0x11);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  dump_data_ptr = dump_data_ptr + 1 & 0xf;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u32_conflict ipc_emb2app_rawstatus_get(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _DAT_44800004;
}



void ipc_host_init(ipc_host_env_tag *env,ipc_host_cb_tag *cb,ipc_shared_env_tag *shared_env_ptr,
                  void *pthis)

{
  printf("[IPC] [TX] Low level size %d, driver size %d, total size %d\r\n",internel_cal_size_tx_desc
         ,internel_cal_size_tx_hdr,internel_cal_size_tx_desc + internel_cal_size_tx_hdr);
  utils_list_init(&tx_list_bl);
  memset(env,0,0xe4);
  env->shared = shared_env_ptr;
  memcpy(env,cb,0x20);
  env->rx_bufnb = 2;
  env->rxdesc_nb = '\x02';
  env->ipc_e2amsg_bufnb = 8;
  env->ipc_e2amsg_bufsz = 0x3e0;
  env->pthis = pthis;
  env->rx_bufsz = 0x800;
  env->tx_host_id = env->tx_host_id0;
  env->txdesc = shared_env_ptr->txdesc0;
  memset(shared_env_ptr->txdesc0,0,0xcc0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int ipc_host_msg_push(ipc_host_env_tag *env,void *msg_buf,uint16_t len)

{
  undefined2 in_register_00002032;
  int iVar1;
  ipc_shared_env_tag *piVar2;
  int iVar3;
  
  iVar1 = *(int *)((int)msg_buf + 0xc);
  piVar2 = env->shared;
  iVar3 = 0;
  while (iVar3 < CONCAT22(in_register_00002032,len)) {
    *(undefined4 *)((int)(piVar2->msg_a2e_buf).msg + iVar3) = *(undefined4 *)(iVar1 + iVar3);
    iVar3 = iVar3 + 4;
  }
  env->msga2e_hostid = msg_buf;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44800000 = 2;
  return 0;
}



uint32_t ipc_host_get_rawstatus(ipc_host_env_tag *env)

{
  u32_conflict uVar1;
  
  uVar1 = ipc_emb2app_rawstatus_get();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



txdesc_host * ipc_host_txdesc_get(ipc_host_env_tag *env)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = env->txdesc_used_idx;
  uVar2 = env->txdesc_free_idx;
  if (uVar2 < uVar1) {
    used_issue = used_issue + 1;
  }
  if (uVar1 + 4 != uVar2) {
    if (uVar2 - uVar1 < 5) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return env->txdesc + (uVar2 & 3);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (txdesc_host *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_txdesc_push(ipc_host_env_tag *env,void *host_id)

{
  uint uVar1;
  
  uVar1 = env->txdesc_free_idx & 3;
  env->txdesc[uVar1].ready = 0xffffffff;
  env->tx_host_id[uVar1] = host_id;
  env->txdesc_free_idx = env->txdesc_free_idx + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44800000 = 0x100;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_irq(ipc_host_env_tag *env,uint32_t status)

{
  uint uVar1;
  uint8_t uVar2;
  int iVar3;
  undefined3 extraout_var;
  void *pvVar4;
  anon_subr_uint8_t_void_ptr_void_ptr_for_recv_msgack_ind *paVar5;
  uint uVar6;
  int *piVar7;
  uint uVar8;
  
  uVar1 = _DAT_4480001c | status;
  _DAT_44800008 = status;
  if ((uVar1 & 0x780) != 0) {
    piVar7 = nx_txdesc_cnt_msk;
    uVar8 = 7;
    do {
      if ((1 << (uVar8 & 0x1f) & uVar1) != 0) {
        while( true ) {
          uVar6 = env->txdesc_used_idx & *piVar7;
          if ((env->tx_host_id[uVar6] == (void *)0x0) ||
             (iVar3 = (*(env->cb).send_data_cfm)(env->pthis,env->tx_host_id[uVar6]), iVar3 != 0))
          break;
          env->tx_host_id[uVar6] = (void *)0x0;
          env->txdesc_used_idx = env->txdesc_used_idx + 1;
          bl_tx_notify();
        }
      }
      uVar8 = uVar8 + 1;
      piVar7 = (int *)((uint *)piVar7 + 1);
    } while (uVar8 != 0xb);
  }
  bl_tx_resend();
  if ((uVar1 & 4) != 0) {
    pvVar4 = env->msga2e_hostid;
    env->msga2e_cnt = env->msga2e_cnt + '\x01';
    paVar5 = (env->cb).recv_msgack_ind;
    env->msga2e_hostid = (void *)0x0;
    (*paVar5)(env->pthis,pvVar4);
  }
  if ((uVar1 & 1) != 0) {
    do {
      uVar2 = (*(env->cb).recv_dbg_ind)
                        (env->pthis,env->ipc_host_dbgbuf_array[env->ipc_host_dbg_idx].hostid);
    } while (CONCAT31(extraout_var,uVar2) == 0);
  }
  if ((uVar1 & 0x10) != 0) {
    (*(env->cb).prim_tbtt_ind)(env->pthis);
  }
  if ((uVar1 & 0x20) != 0) {
                    // WARNING: Could not recover jumptable at 0x230223be. Too many branches
                    // WARNING: Treating indirect jump as call
    (*(env->cb).sec_tbtt_ind)(env->pthis);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_enable_irq(ipc_host_env_tag *env,uint32_t value)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4480000c = value;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ipc_host_disable_irq_e2a(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_44800010 = 0x7ff;
  return;
}



int bl_main_disconnect(void)

{
  bl_send_sm_disconnect_req(&wifi_hw,0x34);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_powersaving(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_powersaving_req(&wifi_hw,mode);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_denoise(int mode)

{
  int iVar1;
  
  iVar1 = bl_send_mm_denoise_req(&wifi_hw,mode);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_monitor(void)

{
  undefined auStack56 [4];
  mm_monitor_cfm cfm;
  
  memset(auStack56,0,0x28);
  bl_send_monitor_enable(&wifi_hw,(mm_monitor_cfm *)auStack56);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_phy_up(void)

{
  int iVar1;
  
  iVar1 = bl_send_start(&wifi_hw);
  if (iVar1 == 0) {
    wifi_hw.drv_flags = wifi_hw.drv_flags | 4;
  }
  else {
    iVar1 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_monitor_channel_set(int channel,int use_40MHZ)

{
  undefined auStack56 [4];
  mm_monitor_channel_cfm cfm;
  
  bl_send_monitor_channel_set(&wifi_hw,(mm_monitor_channel_cfm *)auStack56,channel,use_40MHZ);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_if_remove(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  
  printf("[WF] MM_REMOVE_IF_REQ Sending with vif_index %u...\r\n",
         CONCAT31(in_register_00002029,vif_index));
  bl_send_remove_if(&wifi_hw,vif_index);
  printf("[WF] MM_REMOVE_IF_REQ Done\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_raw_send(uint8_t *pkt,int len)

{
  int iVar1;
  
  iVar1 = bl_send_scanu_raw_send(&wifi_hw,pkt,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_rate_config(uint8_t sta_idx,uint16_t fixed_rate_cfg)

{
  int iVar1;
  
  iVar1 = bl_send_me_rate_config_req(&wifi_hw,sta_idx,fixed_rate_cfg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_set_country_code(char *country_code)

{
  bl_msg_update_channel_cfg(country_code);
  bl_send_me_chan_config_req(&wifi_hw);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_get_channel_nums(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return channel_num_default;
}



int bl_main_if_add(int is_sta,netif *netif,uint8_t *vif_index)

{
  uint uVar1;
  int iVar2;
  undefined *puVar3;
  mm_add_if_cfm amStack36 [2];
  mm_add_if_cfm add_if_cfm;
  
  if (is_sta == 0) {
    puVar3 = &UNK_2307b2d0;
  }
  else {
    puVar3 = &UNK_2307b2cc;
  }
  printf("[WF] MM_ADD_IF_REQ Sending: %s\r\n",puVar3);
  iVar2 = bl_send_add_if(&wifi_hw,netif->hwaddr,(is_sta == 0) + NL80211_IFTYPE_STATION,false,
                         amStack36);
  printf("[WF] MM_ADD_IF_REQ Done\r\n");
  if (iVar2 == 0) {
    if (amStack36[0].status == '\0') {
      uVar1 = (uint)amStack36[0].inst_nbr;
      if (is_sta != 0) {
        wifi_hw.vif_index_sta = (uint)amStack36[0].inst_nbr;
        uVar1 = wifi_hw.vif_index_ap;
      }
      wifi_hw.vif_index_ap = uVar1;
      *vif_index = amStack36[0].inst_nbr;
      printf("[WF] vif_index from LAMC is %d\r\n");
      wifi_hw.vif_table[amStack36[0].inst_nbr].dev = netif;
      wifi_hw.vif_table[amStack36[0].inst_nbr].up = true;
    }
    else {
      printf("%s: Status Error(%d)\n",&UNK_2307b314);
      iVar2 = -5;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_main_apm_start(char *ssid,char *password,int channel,uint8_t vif_index,uint8_t hidden_ssid)

{
  int iVar1;
  undefined3 in_register_00002035;
  apm_start_cfm local_24;
  apm_start_cfm start_ap_cfm;
  
  memset(&local_24,0,4);
  printf("[WF] APM_START_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002035,vif_index)
        );
  iVar1 = bl_send_apm_start_req(&wifi_hw,&local_24,ssid,password,channel,vif_index,hidden_ssid);
  printf("[WF] APM_START_REQ Done\r\n");
  printf("[WF] status is %02X\r\n",(uint)local_24.status);
  printf("[WF] vif_idx is %02X\r\n",(uint)local_24.vif_idx);
  printf("[WF] ch_idx is %02X\r\n",(uint)local_24.ch_idx);
  printf("[WF] bcmc_idx is %02X\r\n",(uint)local_24.bcmc_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifi_hw.ap_bcmc_idx = (uint)local_24.bcmc_idx;
  return iVar1;
}



int bl_main_apm_stop(uint8_t vif_index)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  printf("[WF] APM_STOP_REQ Sending with vif_index %u\r\n",CONCAT31(in_register_00002029,vif_index))
  ;
  iVar1 = bl_send_apm_stop_req(&wifi_hw,vif_index);
  printf("[WF] APM_STOP_REQ Done\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_apm_sta_cnt_get(uint8_t *sta_cnt)

{
  *sta_cnt = '\f';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_apm_sta_info_get(wifi_apm_sta_info *apm_sta_info,uint8_t idx)

{
  undefined3 in_register_0000202d;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_0000202d,idx);
  if (wifi_hw.sta_table[iVar1].is_used != '\0') {
    apm_sta_info->sta_idx = wifi_hw.sta_table[iVar1].sta_idx;
    apm_sta_info->is_used = wifi_hw.sta_table[iVar1].is_used;
    apm_sta_info->rssi = (int)wifi_hw.sta_table[iVar1].rssi;
    apm_sta_info->tsflo = wifi_hw.sta_table[iVar1].tsflo;
    apm_sta_info->tsfhi = wifi_hw.sta_table[iVar1].tsfhi;
    apm_sta_info->data_rate = wifi_hw.sta_table[iVar1].data_rate;
    memcpy(apm_sta_info->sta_mac,wifi_hw.sta_table + iVar1,6);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_apm_sta_delete(uint8_t sta_idx)

{
  byte vif_idx;
  undefined3 in_register_00002029;
  int iVar1;
  int iVar2;
  apm_sta_del_cfm aStack36;
  apm_sta_del_cfm sta_del_cfm;
  
  iVar1 = CONCAT31(in_register_00002029,sta_idx);
  memset(&aStack36,0,3);
  vif_idx = wifi_hw.sta_table[iVar1].vif_idx;
  printf("[WF] APM_STA_DEL_REQ: sta_idx = %u, vif_idx = %u\r\n",iVar1,(uint)vif_idx);
  bl_send_apm_sta_del_req(&wifi_hw,&aStack36,sta_idx,vif_idx);
  iVar2 = -1;
  if (aStack36.status == '\0') {
    memset(wifi_hw.sta_table + iVar1,0,0x1c);
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_main_apm_remove_all_sta(void)

{
  uint8_t sta_idx;
  u8 *puVar1;
  
  puVar1 = &wifi_hw.sta_table[0].is_used;
  sta_idx = '\0';
  do {
    if (*puVar1 == '\x01') {
      bl_main_apm_sta_delete(sta_idx);
    }
    sta_idx = sta_idx + '\x01';
    puVar1 = puVar1 + 0x1c;
  } while (sta_idx != '\f');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_main_conf_max_sta(uint8_t max_sta_supported)

{
  int iVar1;
  
  iVar1 = bl_send_apm_conf_max_sta_req(&wifi_hw,max_sta_supported);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_cfg_task_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,void *arg2)

{
  int iVar1;
  
  iVar1 = bl_send_cfg_task_req(&wifi_hw,ops,task,element,type,arg1,arg2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_scan(void)

{
  bl_send_scanu_req(&wifi_hw);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_cfg80211_connect(bl_hw *bl_hw,cfg80211_connect_params *sme)

{
  int iVar1;
  sm_connect_cfm asStack20 [4];
  sm_connect_cfm sm_connect_cfm;
  
  iVar1 = bl_send_sm_connect_req(bl_hw,sme,asStack20);
  if (iVar1 == 0) {
    iVar1 = -5;
    if (asStack20[0] < 10) {
      iVar1 = (int)(char)CSWTCH_6[asStack20[0]];
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_main_connect(uint8_t *ssid,int ssid_len,uint8_t *psk,int psk_len,uint8_t *pmk,int pmk_len,
                   uint8_t *mac,uint8_t band,uint16_t freq)

{
  short in_stack_00000000;
  undefined auStack272 [4];
  cfg80211_connect_params sme;
  
  memset(auStack272,0,0xf0);
  sme.crypto.cipher_group = 0;
  sme.ssid_len._0_1_ = NL80211_AUTHTYPE_AUTOMATIC;
  sme.pmk._0_1_ = (u8)psk_len;
  sme.pmk._1_1_ = (u8)pmk_len;
  if (mac != (uint8_t *)0x0) {
    sme.channel_hint = (ieee80211_channel *)mac;
  }
  if (in_stack_00000000 != 0) {
    sme.channel._4_4_ = 0;
    auStack272[0] = band;
  }
  sme.bssid_hint = ssid;
  sme.ssid = (u8 *)ssid_len;
  sme.crypto.wep_tx_key = (int)psk;
  sme.key = pmk;
  bl_cfg80211_connect(&wifi_hw,(cfg80211_connect_params *)auStack272);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_main_event_handle(void)

{
  bl_irq_bottomhalf(&wifi_hw);
  bl_tx_try_flush();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_main_lowlevel_init(void)

{
  bl_irqs_init(&wifi_hw);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_main_rtthread_start(bl_hw **bl_hw)

{
  int iVar1;
  char *fmt;
  
  bl_main_lowlevel_init();
  *bl_hw = &wifi_hw;
  wifi_hw.vifs.next = &wifi_hw.vifs;
  wifi_hw.vifs.prev = &wifi_hw.vifs;
  wifi_hw.mod_params = &bl_mod_params;
  iVar1 = bl_platform_on(&wifi_hw);
  if (iVar1 == 0) {
    ipc_host_enable_irq(wifi_hw.ipc_env,0x7ff);
    bl_wifi_enable_irq();
    iVar1 = bl_send_reset(&wifi_hw);
    if (iVar1 == 0) {
      vTaskDelay(5);
      iVar1 = bl_send_version_req(&wifi_hw,&wifi_hw.version_cfm);
      if (iVar1 != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      printf("[version] lmac %u.%u.%u.%u\r\n",wifi_hw.version_cfm.version_lmac >> 0x18,
             wifi_hw.version_cfm.version_lmac >> 0x10 & 0xff,
             wifi_hw.version_cfm.version_lmac >> 8 & 0xff,wifi_hw.version_cfm.version_lmac & 0xff);
      printf("[version] version_machw_1 %08X\r\n",wifi_hw.version_cfm.version_machw_1);
      printf("[version] version_machw_2 %08X\r\n",wifi_hw.version_cfm.version_machw_2);
      printf("[version] version_phy_1 %08X\r\n",wifi_hw.version_cfm.version_phy_1);
      printf("[version] version_phy_2 %08X\r\n",wifi_hw.version_cfm.version_phy_2);
      printf("[version] features %08X\r\n",wifi_hw.version_cfm.features);
      iVar1 = bl_handle_dynparams(&wifi_hw);
      if (iVar1 == 0) {
        bl_send_me_config_req(&wifi_hw);
        bl_send_me_chan_config_req(&wifi_hw);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        wifi_hw.status = RWNX_INTERFACE_STATUS_UP;
        return 0;
      }
      fmt = "bl_handle_dynparams Error\r\n";
    }
    else {
      fmt = "bl_send_reset Error\r\n";
    }
  }
  else {
    fmt = "bl_platform_on Error\r\n";
  }
  printf(fmt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_handle_dynparams(bl_hw *bl_hw)

{
  ushort uVar1;
  short sVar2;
  int iVar3;
  short sVar4;
  uint uVar5;
  bl_mod_params *pbVar6;
  
  uVar5 = bl_hw->flags;
  bl_hw->flags = uVar5 | 0x40000;
  pbVar6 = bl_hw->mod_params;
  if (pbVar6->tdls != false) {
    bl_hw->flags = uVar5 | 0x58000;
  }
  if (pbVar6->ap_uapsd_on != false) {
    bl_hw->flags = bl_hw->flags | 0x4000;
  }
  if (5 < (uint)pbVar6->phy_cfg) {
    pbVar6->phy_cfg = 2;
  }
  if (2 < (uint)bl_hw->mod_params->mcs_map) {
    bl_hw->mod_params->mcs_map = 0;
  }
  uVar1 = (bl_hw->ht_cap).cap;
  pbVar6 = bl_hw->mod_params;
  iVar3 = pbVar6->nss;
  (bl_hw->ht_cap).cap = uVar1 | 0x100;
  if (pbVar6->ldpc_on != false) {
    (bl_hw->ht_cap).cap = uVar1 | 0x101;
  }
  sVar2 = (short)iVar3;
  if (pbVar6->use_2040 == false) {
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x41;
    (bl_hw->ht_cap).mcs.rx_mask[0] = -1;
  }
  else {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).mcs.rx_mask[4] = '\x01';
    (bl_hw->ht_cap).cap = uVar1 | 2;
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * 0x87;
  }
  if (1 < iVar3) {
    (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0x80;
  }
  if (pbVar6->sgi != false) {
    uVar1 = (bl_hw->ht_cap).cap;
    (bl_hw->ht_cap).cap = uVar1 | 0x20;
    if (pbVar6->use_2040 == false) {
      sVar4 = 0x48;
    }
    else {
      (bl_hw->ht_cap).cap = uVar1 | 0x60;
      sVar4 = 0x96;
    }
    (bl_hw->ht_cap).mcs.rx_highest = sVar2 * sVar4;
  }
  (bl_hw->ht_cap).cap = (bl_hw->ht_cap).cap | 0xc;
  if (pbVar6->ht_on == false) {
    (bl_hw->ht_cap).ht_supported = false;
  }
  if (pbVar6->custregd != false) {
    printf("\n\n%s: CAUTION: USING PERMISSIVE CUSTOM REGULATORY RULES\n\n","bl_handle_dynparams");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_send_msg(bl_hw *bl_hw,void *msg_params,int reqcfm,lmac_msg_id_t reqid,void *cfm)

{
  ushort uVar1;
  lmac_msg_id_t lVar2;
  bool bVar3;
  bl_cmd *__s;
  u32_conflict uVar4;
  undefined2 in_register_00002036;
  int iVar5;
  lmac_msg *pv;
  
  iVar5 = CONCAT22(in_register_00002036,reqid);
  pv = (lmac_msg *)((int)msg_params + -8);
  if ((((((bl_hw->drv_flags >> 2 & 1) == 0) && ((reqid & 0xfffd) != 1)) && (iVar5 != 5)) &&
      ((iVar5 != 0x23 && ((reqid & 0xfffd) != 0x1401)))) && (iVar5 != 0x32)) {
    printf("%s: bypassing (RWNX_DEV_RESTARTING set) 0x%02x\n","bl_send_msg",iVar5);
  }
  else {
    if (bl_hw->ipc_env != (ipc_host_env_tag *)0x0) {
      uVar1 = *(ushort *)((int)msg_params + -8);
      bVar3 = true;
      if (((uVar1 != 0x41) && (uVar1 != 0x50)) && ((uVar1 + 0xebf4 & 0xfffb) != 0)) {
        bVar3 = (uVar1 & 0xfffb) == 0x2408;
      }
      __s = (bl_cmd *)pvPortMalloc(0x40);
      if (__s == (bl_cmd *)0x0) {
        vPortFree(pv);
        printf("%s: failed to allocate mem for cmd, size is %d\r\n","bl_send_msg",0x40);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0xfffffff4;
      }
      memset(__s,0,0x40);
      __s->result = 4;
      lVar2 = *(lmac_msg_id_t *)((int)msg_params + -8);
      __s->reqid = reqid;
      __s->a2e_msg = pv;
      __s->id = lVar2;
      __s->e2a_msg = (char *)cfm;
      if (bVar3) {
        __s->flags = 1;
      }
      if (reqcfm != 0) {
        __s->flags = __s->flags | 2;
      }
      uVar4 = (*(bl_hw->cmd_mgr).queue)(&bl_hw->cmd_mgr,__s);
      if (!bVar3) {
        vPortFree(__s);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar4;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __s->result;
    }
    printf("%s: bypassing (restart must have failed)\r\n","bl_send_msg");
  }
  vPortFree(pv);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xfffffff0;
}



void * bl_msg_zalloc(lmac_msg_id_t id,lmac_task_id_t dest_id,uint16_t param_len)

{
  lmac_msg_id_t *__s;
  undefined2 in_register_00002032;
  size_t xWantedSize;
  
  xWantedSize = CONCAT22(in_register_00002032,param_len) + 8;
  __s = (lmac_msg_id_t *)pvPortMalloc(xWantedSize);
  if (__s == (lmac_msg_id_t *)0x0) {
    printf("%s: msg allocation failed\n","bl_msg_zalloc");
  }
  else {
    memset(__s,0,xWantedSize);
    *__s = id;
    __s[1] = dest_id;
    __s[2] = 100;
    __s[3] = param_len;
    __s = __s + 4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



void bl_msg_update_channel_cfg(char *code)

{
  int iVar1;
  int iVar2;
  char *fmt;
  ieee80211_dot_d *piVar3;
  
  piVar3 = country_list;
  iVar1 = 0;
  do {
    iVar2 = strcmp(piVar3->code,code);
    if (iVar2 == 0) {
      fmt = "[WF] country code %s used, num of channel %d\r\n";
      channel_num_default = country_list[iVar1].channel_num;
      channels_default = country_list[iVar1].channels;
      goto LAB_23022de2;
    }
    iVar1 = iVar1 + 1;
    piVar3 = piVar3 + 1;
  } while (iVar1 != 4);
  channel_num_default = 0xe;
  fmt = "[WF] %s NOT found, using JP instead, num of channel %d\r\n";
  channels_default = bl_channels_24_JP;
LAB_23022de2:
  printf(fmt,code,channel_num_default);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_msg_get_channel_nums(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return channel_num_default;
}



int bl_send_reset(bl_hw *bl_hw)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(0,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,1,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_monitor_enable(bl_hw *bl_hw,mm_monitor_cfm *cfm)

{
  undefined4 *msg_params;
  int iVar1;
  
  msg_params = (undefined4 *)bl_msg_zalloc(0x5c,0,4);
  if (msg_params != (undefined4 *)0x0) {
    *msg_params = 1;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x5d,cfm);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_monitor_channel_set(bl_hw *bl_hw,mm_monitor_channel_cfm *cfm,int channel,int use_40Mhz)

{
  uint uVar1;
  uint *msg_params;
  int iVar2;
  
  msg_params = (uint *)bl_msg_zalloc(0x5e,0,0xc);
  if (msg_params == (uint *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0xc;
  }
  if (channel - 1U < 0xe) {
    if (channel == 0xe) {
      uVar1 = 0x9b4;
    }
    else {
      uVar1 = channel * 5 + 0x967U & 0xffff;
    }
  }
  else {
    uVar1 = 0xffff;
  }
  *msg_params = uVar1;
  if (use_40Mhz == 0) {
    msg_params[1] = 0;
  }
  else {
    msg_params[1] = 1;
    if (use_40Mhz != 1) {
      msg_params[2] = 1;
      goto LAB_23022f04;
    }
  }
  msg_params[2] = 0;
LAB_23022f04:
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x5f,cfm);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_send_version_req(bl_hw *bl_hw,mm_version_cfm *cfm)

{
  void *msg_params;
  int iVar1;
  
  msg_params = bl_msg_zalloc(4,0,0);
  if (msg_params != (void *)0x0) {
    iVar1 = bl_send_msg(bl_hw,msg_params,1,5,cfm);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_me_config_req(bl_hw *bl_hw)

{
  u8 *puVar1;
  u16 *msg_params;
  int iVar2;
  u8 *puVar3;
  ieee80211_mcs_info *piVar4;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1400,5,0x34);
  if (msg_params != (u16 *)0x0) {
    printf("[ME] HT supp %d, VHT supp %d\r\n",1,0);
    msg_params[0x17] = 1;
    *msg_params = (bl_hw->ht_cap).cap;
    *(u8 *)(msg_params + 1) = (bl_hw->ht_cap).ampdu_density << 2 | (bl_hw->ht_cap).ampdu_factor;
    piVar4 = &(bl_hw->ht_cap).mcs;
    puVar3 = (u8 *)((int)msg_params + 3);
    while (piVar4 != (ieee80211_mcs_info *)&bl_hw->vif_started) {
      puVar1 = piVar4->rx_mask;
      piVar4 = (ieee80211_mcs_info *)(piVar4->rx_mask + 1);
      *puVar3 = *puVar1;
      puVar3 = puVar3 + 1;
    }
    msg_params[10] = 0;
    *(undefined4 *)(msg_params + 0xc) = 0;
    *(undefined *)(msg_params + 0xe) = 0;
    *(_Bool *)(msg_params + 0x18) = bl_hw->mod_params->ps_on;
    msg_params[0x16] = (u16)bl_hw->mod_params->tx_lft;
    iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1401,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_me_chan_config_req(bl_hw *bl_hw)

{
  byte bVar1;
  void *msg_params;
  int iVar2;
  uint uVar3;
  u16 *puVar4;
  
  msg_params = bl_msg_zalloc(0x1402,5,0xfe);
  if (msg_params == (void *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0xc;
  }
  *(undefined *)((int)msg_params + 0xfc) = 0;
  iVar2 = 0;
  while (iVar2 < channel_num_default) {
    bVar1 = *(byte *)((int)msg_params + 0xfc);
    puVar4 = (u16 *)((uint)bVar1 * 6 + (int)msg_params);
    *(undefined *)((int)puVar4 + 3) = 0;
    if ((channels_default[iVar2].flags & 1) != 0) {
      *(undefined *)((int)puVar4 + 3) = 2;
    }
    uVar3 = channels_default[iVar2].flags;
    *(undefined *)(puVar4 + 1) = 0;
    *(byte *)((int)puVar4 + 3) = (uVar3 & 10) != 0 | *(byte *)((int)puVar4 + 3);
    *puVar4 = channels_default[iVar2].center_freq;
    *(char *)(puVar4 + 2) = (char)channels_default[iVar2].max_power;
    uVar3 = bVar1 + 1 & 0xff;
    *(char *)((int)msg_params + 0xfc) = (char)uVar3;
    if (uVar3 == 0xe) break;
    iVar2 = iVar2 + 1;
  }
  *(undefined *)((int)msg_params + 0xfd) = 0;
  iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1403,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_send_me_rate_config_req(bl_hw *bl_hw,uchar sta_idx,uint16_t fixed_rate_cfg)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1410,5,4);
  if (msg_params != (uchar *)0x0) {
    *msg_params = sta_idx;
    *(uint16_t *)(msg_params + 2) = fixed_rate_cfg;
    iVar1 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_start(bl_hw *bl_hw)

{
  void *__dest;
  int iVar1;
  
  __dest = bl_msg_zalloc(2,0,0x48);
  if (__dest != (void *)0x0) {
    (bl_hw->phy_config).parameters[0] = 1;
    memcpy(__dest,&bl_hw->phy_config,0x40);
    *(int *)((int)__dest + 0x40) = bl_hw->mod_params->uapsd_timeout;
    *(short *)((int)__dest + 0x44) = (short)bl_hw->mod_params->lp_clk_ppm;
    iVar1 = bl_send_msg(bl_hw,__dest,1,3,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_add_if(bl_hw *bl_hw,uchar *mac,nl80211_iftype iftype,_Bool p2p,mm_add_if_cfm *cfm)

{
  undefined *msg_params;
  int iVar1;
  undefined uVar2;
  
  msg_params = (undefined *)bl_msg_zalloc(6,0,8);
  if (msg_params == (undefined *)0x0) {
    iVar1 = -0xc;
LAB_23023236:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  memcpy(msg_params + 1,mac,6);
  switch(iftype + ~NL80211_IFTYPE_UNSPECIFIED) {
  case NL80211_IFTYPE_UNSPECIFIED:
    uVar2 = 1;
    break;
  case NL80211_IFTYPE_AP:
    iVar1 = -1;
    goto LAB_23023236;
  case NL80211_IFTYPE_MONITOR:
    uVar2 = 3;
    break;
  case NL80211_IFTYPE_MESH_POINT:
    msg_params[7] = 1;
  default:
    *msg_params = 0;
    goto LAB_2302320e;
  case NL80211_IFTYPE_P2P_CLIENT:
    msg_params[7] = 1;
  case NL80211_IFTYPE_STATION:
    uVar2 = 2;
  }
  *msg_params = uVar2;
LAB_2302320e:
  iVar1 = bl_send_msg(bl_hw,msg_params,1,7,cfm);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_send_remove_if(bl_hw *bl_hw,uchar inst_nbr)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(8,0,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = inst_nbr;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,9,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_scanu_req(bl_hw *bl_hw)

{
  u16 uVar1;
  u16 *msg_params;
  int iVar2;
  ieee80211_channel *piVar3;
  int iVar4;
  u16 *puVar5;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1000,4,0x154);
  if (msg_params != (u16 *)0x0) {
    iVar4 = bl_hw->vif_index_sta;
    msg_params[0xa6] = 0;
    *(char *)(msg_params + 0xa7) = (char)iVar4;
    iVar4 = channel_num_default;
    *(char *)((int)msg_params + 0x14f) = (char)channel_num_default;
    *(undefined4 *)(msg_params + 0xa0) = 0xffffffff;
    msg_params[0xa2] = 0xffff;
    msg_params[0xa8] = 0x100;
    *(undefined4 *)(msg_params + 0xa4) = 0;
    iVar2 = 0;
    puVar5 = msg_params;
    while (iVar2 < (int)(iVar4 & 0xffU)) {
      piVar3 = channels_default + iVar2;
      *(nl80211_band *)(puVar5 + 1) = piVar3->band;
      uVar1 = piVar3->center_freq;
      *(undefined *)((int)puVar5 + 3) = 1;
      *puVar5 = uVar1;
      *(char *)(puVar5 + 2) = (char)piVar3->max_reg_power;
      iVar2 = iVar2 + 1;
      puVar5 = puVar5 + 3;
    }
    iVar4 = bl_send_msg(bl_hw,msg_params,0,0,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_scanu_raw_send(bl_hw *bl_hw,uint8_t *pkt,int len)

{
  uint8_t **msg_params;
  int iVar1;
  undefined auStack36 [4];
  scanu_raw_send_cfm cfm;
  
  msg_params = (uint8_t **)bl_msg_zalloc(0x1005,4,8);
  if (msg_params == (uint8_t **)0x0) {
    iVar1 = -0xc;
  }
  else {
    *msg_params = pkt;
    msg_params[1] = (uint8_t *)len;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1006,auStack36);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_send_sm_connect_req(bl_hw *bl_hw,cfg80211_connect_params *sme,sm_connect_cfm *cfm)

{
  _Bool _Var1;
  undefined *msg_params;
  int iVar2;
  nl80211_auth_type nVar3;
  u32_conflict uVar4;
  uint uVar5;
  uint uVar6;
  __be16 _Var7;
  u8 *puVar8;
  uint uVar9;
  
  msg_params = (undefined *)bl_msg_zalloc(0x1800,6,0x1c4);
  if (msg_params == (undefined *)0x0) {
    iVar2 = -0xc;
    goto LAB_23023526;
  }
  uVar9 = 0;
  if ((sme->crypto).n_ciphers_pairwise != 0) {
    uVar4 = (sme->crypto).ciphers_pairwise[0];
    uVar9 = 4;
    if ((1 < uVar4 - 0xfac01) && (uVar9 = 0, uVar4 == 0xfac05)) {
      uVar9 = 4;
    }
  }
  if ((sme->crypto).control_port != false) {
    uVar9 = uVar9 | 1;
  }
  if ((sme->crypto).control_port_no_encrypt != false) {
    uVar9 = uVar9 | 2;
  }
  if (((sme->crypto).cipher_group & 0xfffffffb) != 0xfac01) {
    uVar9 = uVar9 | 8;
  }
  if (sme->mfp == NL80211_MFP_REQUIRED) {
    uVar9 = uVar9 | 0x10;
  }
  _Var7 = (sme->crypto).control_port_ethertype;
  if (_Var7 == 0) {
    _Var7 = 0x888e;
  }
  *(__be16 *)(msg_params + 0x34) = _Var7;
  puVar8 = sme->bssid;
  if (puVar8 == (u8 *)0x0) {
LAB_23023458:
    memcpy(msg_params + 0x22,&mac_addr_bcst,6);
  }
  else {
    if (*puVar8 == -1) {
      uVar5 = 0;
      if (((puVar8[1] == -1) && (puVar8[2] == -1)) &&
         ((puVar8[3] == -1 && ((puVar8[4] == -1 && (puVar8[5] == -1)))))) goto LAB_23023458;
    }
    else {
      if ((((*puVar8 == '\0') && (puVar8[1] == '\0')) && (puVar8[2] == '\0')) &&
         ((puVar8[3] == '\0' && (uVar5 = (uint)puVar8[4], uVar5 == 0)))) {
        if (puVar8[5] == '\0') goto LAB_23023458;
      }
      else {
        uVar5 = 0;
      }
    }
    do {
      uVar6 = uVar5 + 1;
      msg_params[uVar5 + 0x22] = sme->bssid[uVar5];
      uVar5 = uVar6;
    } while (uVar6 != 6);
  }
  msg_params[0x3d] = (char)bl_hw->vif_index_sta;
  if ((sme->channel).center_freq == 0) {
    *(undefined2 *)(msg_params + 0x28) = 0xffff;
  }
  else {
    msg_params[0x2a] = (sme->channel).band;
    *(u16 *)(msg_params + 0x28) = (sme->channel).center_freq;
    msg_params[0x2b] = ((sme->channel).flags & 10) != 0;
  }
  uVar5 = 0;
  while (uVar5 < sme->ssid_len) {
    msg_params[uVar5 + 1] = sme->ssid[uVar5];
    uVar5 = uVar5 + 1;
  }
  *msg_params = (char)sme->ssid_len;
  *(uint *)(msg_params + 0x30) = uVar9;
  uVar9 = sme->ie_len;
  if (uVar9 < 0x101) {
    if (uVar9 != 0) {
      memcpy(msg_params + 0x40,sme->ie,uVar9);
    }
    *(short *)(msg_params + 0x36) = (short)sme->ie_len;
    _Var1 = bl_mod_params.listen_bcmc;
    *(short *)(msg_params + 0x38) = (short)bl_mod_params.listen_itv;
    msg_params[0x3a] = _Var1 ^ 1;
    nVar3 = sme->auth_type;
    if (nVar3 == NL80211_AUTHTYPE_AUTOMATIC) {
      nVar3 = NL80211_AUTHTYPE_OPEN_SYSTEM;
    }
    msg_params[0x3b] = nVar3;
    msg_params[0x3c] = (char)bl_mod_params.uapsd_queues;
    msg_params[0x140] = 1;
    if (sme->key_len != 0) {
      memcpy(msg_params + 0x141,sme->key,(uint)sme->key_len);
    }
    if (sme->pmk_len != 0) {
      memcpy(msg_params + 0x181,sme->pmk,(uint)sme->pmk_len);
    }
    iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1801,cfm);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  printf("%s:%d\r\n","bl_send_sm_connect_req",0x30a);
  iVar2 = -0x16;
LAB_23023526:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_send_sm_disconnect_req(bl_hw *bl_hw,u16 reason)

{
  u16 *msg_params;
  int iVar1;
  
  msg_params = (u16 *)bl_msg_zalloc(0x1803,6,4);
  if (msg_params != (u16 *)0x0) {
    *msg_params = reason;
    *(char *)(msg_params + 1) = (char)bl_hw->vif_index_sta;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1804,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_mm_powersaving_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x31,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_mm_denoise_req(bl_hw *bl_hw,int mode)

{
  undefined *msg_params;
  int iVar1;
  
  msg_params = (undefined *)bl_msg_zalloc(0x30,0,1);
  if (msg_params != (undefined *)0x0) {
    *msg_params = (char)mode;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x32,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_apm_start_req
              (bl_hw *bl_hw,apm_start_cfm *cfm,char *ssid,char *password,int channel,uchar vif_index
              ,uchar hidden_ssid)

{
  void *msg_params;
  size_t sVar1;
  int iVar2;
  uint uVar3;
  undefined auStack44 [4];
  uint8_t rate [12];
  
  memcpy(auStack44,&DAT_2307b534,0xc);
  msg_params = bl_msg_zalloc(0x1c00,7,0xa8);
  if (msg_params == (void *)0x0) {
    iVar2 = -0xc;
  }
  else {
    *(undefined *)((int)msg_params + 0x10) = 0;
    if (channel - 1U < 0xe) {
      if (channel == 0xe) {
        uVar3 = 0x9b4;
      }
      else {
        uVar3 = channel * 5 + 0x967U & 0xffff;
      }
    }
    else {
      uVar3 = 0xffff;
    }
    *(short *)((int)msg_params + 0xe) = (short)uVar3;
    *(uint *)((int)msg_params + 0x14) = uVar3;
    *(undefined2 *)((int)msg_params + 0x28) = 100;
    *(undefined4 *)((int)msg_params + 0x2c) = 8;
    *(undefined2 *)((int)msg_params + 0x30) = 0x8e88;
    *(undefined *)((int)msg_params + 0x32) = 6;
    *(uchar *)((int)msg_params + 0x1d) = hidden_ssid;
    *(uchar *)((int)msg_params + 0x33) = vif_index;
    *(undefined *)((int)msg_params + 0x11) = 0;
    *(undefined *)((int)msg_params + 0x12) = 0;
    *(undefined4 *)((int)msg_params + 0x18) = 0;
    *(undefined *)((int)msg_params + 0x1c) = 0;
    *(undefined4 *)((int)msg_params + 0x20) = 0;
    *(undefined4 *)((int)msg_params + 0x24) = 0;
    sVar1 = strlen(password);
    *(undefined *)((int)msg_params + 0x34) = 1;
    *(bool *)((int)msg_params + 0x66) = sVar1 != 0;
    sVar1 = strlen(ssid);
    memcpy((void *)((int)msg_params + 0x45),ssid,sVar1);
    sVar1 = strlen(password);
    memcpy((void *)((int)msg_params + 0x67),password,sVar1);
    sVar1 = strlen(ssid);
    *(char *)((int)msg_params + 0x44) = (char)sVar1;
    *(undefined *)((int)msg_params + 0x35) = 0xc;
    memcpy((void *)((int)msg_params + 0x36),auStack44,0xc);
    *(undefined2 *)((int)msg_params + 0x42) = 0x101;
    iVar2 = bl_send_msg(bl_hw,msg_params,1,0x1c01,cfm);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_send_apm_stop_req(bl_hw *bl_hw,uchar vif_idx)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c02,7,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c03,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_apm_sta_del_req(bl_hw *bl_hw,apm_sta_del_cfm *cfm,uchar sta_idx,uchar vif_idx)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c0b,7,2);
  if (msg_params != (uchar *)0x0) {
    msg_params[1] = sta_idx;
    *msg_params = vif_idx;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0c,cfm);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_apm_conf_max_sta_req(bl_hw *bl_hw,uchar max_sta_supported)

{
  uchar *msg_params;
  int iVar1;
  
  msg_params = (uchar *)bl_msg_zalloc(0x1c0d,7,1);
  if (msg_params != (uchar *)0x0) {
    *msg_params = max_sta_supported;
    iVar1 = bl_send_msg(bl_hw,msg_params,1,0x1c0e,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



int bl_send_cfg_task_req
              (bl_hw *bl_hw,uint32_t ops,uint32_t task,uint32_t element,uint32_t type,void *arg1,
              void *arg2)

{
  uint32_t *msg_params;
  int iVar1;
  TickType_t TVar2;
  uint32_t uVar3;
  
  msg_params = (uint32_t *)bl_msg_zalloc(0x3000,0xc,0x24);
  if (msg_params == (uint32_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0xc;
  }
  *msg_params = ops;
  if (ops < 3) {
    if (ops == 0) {
      msg_params[1] = task;
      msg_params[2] = element;
      msg_params[3] = type;
      uVar3 = utils_tlv_bl_pack_auto(msg_params + 5,8,(uint16_t)type,arg1);
      msg_params[4] = uVar3;
    }
  }
  else {
    if (ops != 3) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307c064,&UNK_2307c058,0x40f,
                &UNK_2307c058,0x40f);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    msg_params[1] = task;
    msg_params[2] = element;
    msg_params[4] = 0;
  }
  iVar1 = bl_send_msg(bl_hw,msg_params,1,0x3001,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_platform_on(bl_hw *bl_hw)

{
  int iVar1;
  
  ipc_shenv = &ipc_shared_env;
  iVar1 = bl_ipc_init(bl_hw,&ipc_shared_env);
  if (iVar1 == 0) {
    _DAT_44800008 = 0xffffffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_rx_chan_pre_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_rx_rssi_status_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  if (cb_rssi != (wifi_event_rssi_cb_t *)0x0) {
    (*cb_rssi)(cb_rssi_env,*(int8_t *)((int)msg->param + 2));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_rx_apm_sta_del_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  printf("[WF] APM_STA_DEL_IND\r\n");
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)msg->param);
  if (*(byte *)msg->param < 0xc) {
    bl_hw->sta_table[*(byte *)msg->param].is_used = '\0';
  }
  else {
    printf("[WF]    --------- Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x16,(uint)*(byte *)msg->param);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_rx_apm_sta_add_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  int *piVar1;
  uint uVar2;
  
  printf("[WF] APM_STA_ADD_IND\r\n");
  printf("[WF]    flags %08X\r\n",msg->param[0]);
  printf("[WF]    MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7),(uint)*(byte *)(msg->param + 2),
         (uint)*(byte *)((int)msg->param + 9));
  printf("[WF]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[WF]    sta_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  uVar2 = (uint)*(byte *)((int)msg->param + 0xb);
  if (uVar2 < 0xc) {
    memcpy(bl_hw->sta_table + uVar2,msg->param + 1,6);
    piVar1 = (bl_hw->stats).ampdus_tx + uVar2 * 7 + -0x11;
    *(undefined *)((int)piVar1 + 0xc99) = *(undefined *)((int)msg->param + 0xb);
    *(undefined *)((int)piVar1 + 0xc9a) = *(undefined *)((int)msg->param + 10);
    *(undefined *)(piVar1 + 0x326) = 1;
    *(undefined *)(piVar1 + 0x327) = *(undefined *)(msg->param + 3);
    piVar1[0x328] = msg->param[4];
    piVar1[0x329] = msg->param[5];
    *(undefined *)(piVar1 + 0x32a) = *(undefined *)(msg->param + 6);
  }
  else {
    printf("[WF]    ------ Potential illegal sta_idx\r\n");
  }
  aos_post_event(2,0x15,(uint)*(byte *)((int)msg->param + 0xb));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void notify_event_scan_done(int join_scan)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  buffer._0_4_ = 0xec;
  wStack24 = (join_scan != 0) + 1;
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_rx_scanu_join_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_rx_scanu_start_cfm(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  notify_event_scan_done(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_chan_switch_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  wifi_event wStack24;
  uint8_t buffer [8];
  
  buffer._0_4_ = (uint)*(byte *)msg->param;
  memset(&wStack24,0,4);
  memset(buffer,0,4);
  wStack24 = 0;
  if (cb_event != (wifi_event_cb_t *)0x0) {
    (*cb_event)(cb_event_env,&wStack24);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_connect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  int *piVar1;
  netif *netif;
  sm_reason_code *psVar2;
  uint uVar3;
  int iVar4;
  undefined local_40 [4];
  wifi_event_sm_connect_ind ind_new;
  
  psVar2 = reason_list;
  iVar4 = 0;
  do {
    if (psVar2->reason_code == *(uint16_t *)msg->param) goto LAB_23023c3e;
    iVar4 = iVar4 + 1;
    psVar2 = psVar2 + 1;
  } while (iVar4 != 0x10);
  iVar4 = 0;
LAB_23023c3e:
  printf("[RX] Connection Status\r\n");
  printf("[RX]   status_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]   connect result: %s\r\n",reason_list[iVar4].action);
  printf("[RX]   MAC %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)msg->param + 2),
         (uint)*(byte *)((int)msg->param + 3),(uint)*(byte *)(msg->param + 1),
         (uint)*(byte *)((int)msg->param + 5),(uint)*(byte *)((int)msg->param + 6),
         (uint)*(byte *)((int)msg->param + 7));
  printf("[RX]   vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 9));
  printf("[RX]   ap_idx %u\r\n",(uint)*(byte *)((int)msg->param + 10));
  printf("[RX]   ch_idx %u\r\n",(uint)*(byte *)((int)msg->param + 0xb));
  printf("[RX]   qos %u\r\n",(uint)*(byte *)(msg->param + 3));
  printf("[RX]   acm %u\r\n",(uint)*(byte *)((int)msg->param + 0xd));
  printf("[RX]   assoc_req_ie_len %u\r\n",(uint)*(ushort *)((int)msg->param + 0xe));
  printf("[RX]   assoc_rsp_ie_len %u\r\n",(uint)*(ushort *)(msg->param + 4));
  printf("[RX]   aid %u\r\n",(uint)*(ushort *)(msg->param + 0xcd));
  printf("[RX]   band %u\r\n",(uint)*(byte *)((int)msg->param + 0x336));
  printf("[RX]   center_freq %u\r\n",(uint)*(ushort *)(msg->param + 0xce));
  printf("[RX]   width %u\r\n",(uint)*(byte *)((int)msg->param + 0x33a));
  printf("[RX]   center_freq1 %u\r\n",msg->param[0xcf]);
  printf("[RX]   center_freq2 %u\r\n",msg->param[0xd0]);
  if (*(short *)msg->param == 0) {
    bl_hw->sta_idx = (uint)*(byte *)((int)msg->param + 10);
    bl_hw->is_up = 1;
  }
  else {
    bl_hw->is_up = 0;
  }
  memset(local_40,0,0x20);
  local_40 = msg->param[0];
  ind_new._0_4_ = msg->param[1];
  ind_new.bssid[2] = *(uint8_t *)((int)msg->param + 9);
  ind_new.bssid[3] = *(uint8_t *)((int)msg->param + 10);
  ind_new.bssid[4] = *(uint8_t *)((int)msg->param + 0xb);
  ind_new._8_4_ = (uint)*(byte *)(msg->param + 3);
  ind_new.qos._0_2_ = *(uint16_t *)(msg->param + 0xcd);
  ind_new.qos._2_1_ = *(uint8_t *)((int)msg->param + 0x336);
  ind_new.aid = *(uint16_t *)(msg->param + 0xce);
  ind_new.band = *(uint8_t *)((int)msg->param + 0x33a);
  ind_new._20_4_ = msg->param[0xcf];
  ind_new.center_freq1 = msg->param[0xd0];
  if (cb_sm_connect_ind != (wifi_event_sm_connect_ind_cb_t *)0x0) {
    (*cb_sm_connect_ind)(cb_sm_connect_ind_env,(wifi_event_sm_connect_ind *)local_40);
  }
  if (*(short *)msg->param == 0) {
    uVar3 = (uint)*(byte *)((int)msg->param + 9);
    if (bl_hw->vif_table + uVar3 != (bl_vif *)0x0) {
      piVar1 = (bl_hw->stats).ampdus_tx + uVar3 * 0x31 + -0x11;
      netif = (netif *)piVar1[0xda];
      if (netif != (netif *)0x0) {
        netifapi_netif_common(netif,netif_set_link_up,(netifapi_errt_fn)0x0);
        netifapi_netif_common((netif *)piVar1[0xda],netif_set_default,(netifapi_errt_fn)0x0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    printf("[RX]  -------- CRITICAL when check netif. ptr is %p:%p\r\n");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Variable defined which should be unmapped: ind_new
// WARNING: Could not reconcile some variable overlaps

int bl_rx_sm_disconnect_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  int *piVar1;
  netif *netif;
  uint uVar2;
  ip4_addr_t iStack28;
  ip4_addr_t addr_any;
  wifi_event_sm_disconnect_ind ind_new;
  
  iStack28 = ipaddr_addr("0.0.0.0");
  printf("[RX] sm_disconnect_ind\r\n       reason_code %u\r\n",(uint)*(ushort *)msg->param);
  printf("[RX]    vif_idx %u\r\n",(uint)*(byte *)((int)msg->param + 2));
  printf("[RX]     ft_over_ds %u\r\n",(uint)*(byte *)((int)msg->param + 3));
  if (cb_sm_disconnect_ind != (wifi_event_sm_disconnect_ind_cb_t *)0x0) {
    memset(&addr_any,0,8);
    addr_any.addr._0_2_ = *(uint16_t *)msg->param;
    addr_any.addr._2_1_ = *(uint8_t *)((int)msg->param + 2);
    (*cb_sm_disconnect_ind)(cb_sm_disconnect_ind_env,(wifi_event_sm_disconnect_ind *)&addr_any);
  }
  uVar2 = (uint)*(byte *)((int)msg->param + 2);
  if (bl_hw->vif_table + uVar2 != (bl_vif *)0x0) {
    piVar1 = (bl_hw->stats).ampdus_tx + uVar2 * 0x31 + -0x11;
    netif = (netif *)piVar1[0xda];
    if (netif != (netif *)0x0) {
      netifapi_netif_common(netif,netif_set_link_down,(netifapi_errt_fn)0x0);
      netifapi_netif_set_addr((netif *)piVar1[0xda],&iStack28,&iStack28,&iStack28);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int bl_rx_scanu_result_ind(bl_hw *bl_hw,bl_cmd *cmd,ipc_e2a_msg *msg)

{
  uchar uVar1;
  void *pvVar2;
  undefined3 extraout_var;
  uint16_t buflen;
  uint uVar3;
  int *security_mode;
  byte bVar4;
  ushort uVar5;
  int iVar6;
  u32_l *puVar7;
  u32_l *addr;
  longlong in_fa1;
  _Bool _Stack121;
  uint8_t auStack120 [3];
  uint8_t is_pmf_required;
  uint8_t rsn_wpa_ie [32];
  wifi_event_beacon_ind ind_new;
  
  _Stack121 = false;
  memset(auStack120,0,0x20);
  security_mode = (int *)0x80;
  uVar5 = *(ushort *)(msg->param + 7) & 0xfc;
  if (uVar5 != 0x80) {
    if (uVar5 == 0x50) {
      printf("Probe Response\r\n");
      if (cb_probe_resp_ind != (wifi_event_probe_resp_ind_cb_t *)0x0) {
        (*cb_probe_resp_ind)((void *)0x0,in_fa1);
      }
    }
    else {
      printf("Bug Scan IND?\r\n");
    }
    goto LAB_230240e6;
  }
  if (cb_beacon_ind == (wifi_event_beacon_ind_cb_t *)0x0) goto LAB_230240e6;
  memset(rsn_wpa_ie + 0x1c,0,0x38);
  uVar5 = *(ushort *)msg->param;
  addr = msg->param + 0x10;
  iVar6 = 0;
  puVar7 = addr;
  while (iVar6 < (int)(uint)uVar5) {
    security_mode = (int *)(uint)*(byte *)puVar7;
    uVar3 = (uint)*(byte *)((int)puVar7 + 1);
    if (security_mode == (int *)0x0) {
      if (uVar3 < 0x21) {
        ind_new._48_4_ = uVar3;
        memcpy(ind_new.bssid + 2,(byte *)((int)puVar7 + 2),uVar3);
        security_mode = &ind_new.ssid_len;
        ind_new.bssid[*(byte *)((int)puVar7 + 1) + 2] = '\0';
      }
      break;
    }
    iVar6 = iVar6 + uVar3 + 2;
    puVar7 = (u32_l *)((int)puVar7 + uVar3 + 2);
  }
  iVar6 = 0;
  puVar7 = addr;
  while (iVar6 < (int)(uint)*(ushort *)msg->param) {
    security_mode = (int *)(uint)*(byte *)((int)puVar7 + 1);
    if (*(byte *)puVar7 == 3) {
      if (security_mode < (int *)0x21) {
        ind_new.ssid[32] = *(byte *)((int)puVar7 + 2);
      }
      break;
    }
    security_mode = (int *)((int)security_mode + 2);
    iVar6 = (int)security_mode + iVar6;
    puVar7 = (u32_l *)((int)puVar7 + (int)security_mode);
  }
  if ((*(ushort *)((int)msg->param + 0x3e) & 0x10) == 0) {
    ind_new.rssi = '\0';
  }
  else {
    buflen = (uint16_t)((uVar5 - 0x24) * 0x10000 >> 0x10);
    pvVar2 = (void *)mac_ie_find((uint32_t)addr,buflen,'0');
    iVar6 = 0;
    if (pvVar2 != (void *)0x0) {
      bVar4 = (byte)ind_new.wpa_mcstCipher | 0x20;
      ind_new._44_4_ = ind_new._44_4_ | 0x2000;
      memcpy(auStack120,pvVar2,*(byte *)((int)pvVar2 + 1) + 2 & 0xff);
      uVar1 = process_rsn_ie(auStack120,(Cipher_t *)&ind_new.auth,(Cipher_t *)&ind_new.cipher,
                             &_Stack121,(SecurityMode_t *)security_mode,(_Bool)bVar4);
      iVar6 = CONCAT31(extraout_var,uVar1);
    }
    pvVar2 = (void *)mac_vsie_find((uint32_t)addr,buflen,"",'\x04');
    if ((pvVar2 != (void *)0x0) && (ind_new._44_4_ = ind_new._44_4_ | 0x800, iVar6 == 0)) {
      memcpy(auStack120,pvVar2,*(byte *)((int)pvVar2 + 1) + 2 & 0xff);
      process_wpa_ie(auStack120,(Cipher_t *)&ind_new.ppm_rel,(Cipher_t *)&ind_new.channel);
    }
    if ((ind_new._44_4_ & 0x2800) == 0x2800) {
      bVar4 = ind_new.cipher | ind_new.channel;
      uVar3 = bVar4 & 8;
      if ((bVar4 & 4) == 0) {
        if ((bVar4 & 8) != 0) {
          if (((ind_new._40_4_ & 0x8000800) == 0) && ((ind_new._40_4_ & 0x4000400) != 0))
          goto LAB_23024090;
LAB_23024118:
          bVar4 = 2;
          goto next;
        }
      }
      else {
LAB_2302408c:
        bVar4 = 3;
        if (uVar3 != 0) {
LAB_23024090:
          bVar4 = 4;
        }
next:
        ind_new._40_4_ = ind_new._40_4_ & 0xffffff00 | (uint)bVar4;
        if ((ind_new._44_4_ & 0x2800) != 0x2800) goto LAB_23024172;
      }
      ind_new.rssi = '\x04';
    }
    else {
      if ((ind_new._44_4_ & 0x800) == 0) {
        if ((ind_new._44_4_ & 0x2000) == 0) {
          ind_new._40_4_ = CONCAT31(ind_new._41_3_,1);
        }
        else {
          uVar3 = ind_new._44_4_ & 8;
          if ((ind_new._44_4_ & 4) != 0) goto LAB_2302408c;
          if ((ind_new._44_4_ & 8) != 0) {
            ind_new.ppm_rel = ind_new.auth;
            goto LAB_23024146;
          }
        }
      }
      else {
        uVar3 = ind_new.channel & 8;
        if ((ind_new._40_4_ & 0x40000) != 0) goto LAB_2302408c;
        if ((ind_new._40_4_ & 0x80000) != 0) {
LAB_23024146:
          if (((ind_new.ppm_rel & 8U) != 0) || ((ind_new.ppm_rel & 4U) == 0)) goto LAB_23024118;
          goto LAB_23024090;
        }
      }
LAB_23024172:
      if ((ind_new._44_4_ & 0x2000) == 0) {
        if ((ind_new._44_4_ & 0x800) == 0) {
          ind_new.rssi = '\x01';
        }
        else {
          ind_new.rssi = '\x02';
        }
      }
      else {
        ind_new.rssi = '\x03';
      }
    }
  }
  ind_new.ssid[29] = *(uint8_t *)(msg->param + 6);
  ind_new.ssid[30] = *(uint8_t *)((int)msg->param + 0x19);
  ind_new.ssid[31] = *(uint8_t *)((int)msg->param + 0x1a);
  rsn_wpa_ie._28_2_ = *(undefined2 *)(msg->param + 0xb);
  rsn_wpa_ie._30_2_ = *(undefined2 *)((int)msg->param + 0x2e);
  ind_new.bssid._0_2_ = *(undefined2 *)(msg->param + 0xc);
  (*cb_beacon_ind)(cb_beacon_ind_env,(wifi_event_beacon_ind *)(rsn_wpa_ie + 0x1c));
LAB_230240e6:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_mesh_path_update_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_mesh_proxy_update_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_remain_on_channel_exp_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_ps_change_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_traffic_req_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_csa_counter_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_csa_finish_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_csa_traffic_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_channel_survey_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_dbg_error_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_cfm(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_tdls_chan_switch_base_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_tdls_peer_ps_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_me_tkip_mic_failure_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_me_tx_credits_update_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_mesh_path_create_cfm(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 bl_rx_mesh_peer_update_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_rx_sm_connect_ind_cb_register(void *env,wifi_event_sm_connect_ind_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_sm_connect_ind = cb;
  cb_sm_connect_ind_env = env;
  return 0;
}



int bl_rx_sm_disconnect_ind_cb_register(void *env,wifi_event_sm_disconnect_ind_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_sm_disconnect_ind = cb;
  cb_sm_disconnect_ind_env = env;
  return 0;
}



int bl_rx_beacon_ind_cb_register(void *env,wifi_event_beacon_ind_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_beacon_ind = cb;
  cb_beacon_ind_env = env;
  return 0;
}



int bl_rx_probe_resp_ind_cb_register(void *env,wifi_event_probe_resp_ind_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_probe_resp_ind = cb;
  return 0;
}



int bl_rx_pkt_cb_register(void *env,wifi_event_pkt_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_pkt = cb;
  cb_pkt_env = env;
  return 0;
}



int bl_rx_pkt_cb_unregister(void *env)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_pkt = (wifi_event_pkt_cb_t *)0x0;
  cb_pkt_env = (void *)0x0;
  return 0;
}



int bl_rx_rssi_cb_register(void *env,wifi_event_rssi_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_rssi = cb;
  cb_rssi_env = env;
  return 0;
}



int bl_rx_event_register(void *env,wifi_event_cb_t *cb)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cb_event = cb;
  cb_event_env = env;
  return 0;
}



void bl_rx_e2a_handler(void *arg)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Could not recover jumptable at 0x230242f0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*wifi_hw.cmd_mgr.msgind)
            ((bl_cmd_mgr *)0x4201d5b0,(ipc_e2a_msg *)arg,msg_hdlrs[*arg >> 10][*arg & 0x3ff]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_rx_pkt_cb(uint8_t *pkt,int len)

{
  if (cb_pkt != (wifi_event_pkt_cb_t *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2302430a. Too many branches
                    // WARNING: Treating indirect jump as call
    (*cb_pkt)(cb_pkt_env,pkt,len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tx_push(bl_hw *bl_hw,bl_txhdr *txhdr)

{
  hostdesc *phVar1;
  hostdesc *phVar2;
  txdesc_host *ptVar3;
  hostdesc *phVar4;
  uint32_t *host_id;
  
  host_id = txhdr->p;
  ptVar3 = ipc_host_txdesc_get(bl_hw->ipc_env);
  if (&ptVar3->host == (hostdesc *)0x0) {
    printf("%d:ASSERT_ERR(host)\n",0x37);
  }
  phVar1 = &ptVar3->host;
  phVar4 = &txhdr->host;
  do {
    phVar2 = (hostdesc *)((int)&phVar1->pbuf_addr + 1);
    *(undefined *)&phVar1->pbuf_addr = *(undefined *)&phVar4->pbuf_addr;
    phVar1 = phVar2;
    phVar4 = (hostdesc *)((int)&phVar4->pbuf_addr + 1);
  } while ((hostdesc *)ptVar3->pad_txdesc != phVar2);
  ipc_host_txdesc_push(bl_hw->ipc_env,host_id);
  (bl_hw->stats).cfm_balance = (bl_hw->stats).cfm_balance + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tx_resend(void)

{
  bl_hw *bl_hw;
  txdesc_host *ptVar1;
  uint uVar2;
  
  vTaskEnterCritical();
  while ((txhdr_pos_r != txhdr_pos_w &&
         (ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), bl_hw = bl_hw_static,
         ptVar1 != (txdesc_host *)0x0))) {
    uVar2 = txhdr_pos_r & 7;
    txhdr_hodler[uVar2]->status = 0;
    bl_tx_push(bl_hw,txhdr_hodler[uVar2]);
    txhdr_pos_r = txhdr_pos_r + 1;
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_tx_try_flush(void)

{
  txdesc_host *ptVar1;
  bl_txhdr *txhdr;
  
  vTaskEnterCritical();
  while ((ptVar1 = ipc_host_txdesc_get(bl_hw_static->ipc_env), ptVar1 != (txdesc_host *)0x0 &&
         (txhdr = (bl_txhdr *)utils_list_pop_front(&tx_list_bl), txhdr != (bl_txhdr *)0x0))) {
    bl_tx_push(bl_hw_static,txhdr);
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_txdatacfm(void *pthis,void *host_id)

{
  bl_txhdr *pbVar1;
  uint uVar2;
  int iVar3;
  
  pbVar1 = (bl_txhdr *)((-*(int *)((int)host_id + 4) & 3U) + *(int *)((int)host_id + 4));
  iVar3 = pbVar1->status;
  if (iVar3 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  if (iVar3 << 0xf < 0) {
    if (((txhdr_pos_w + 1 ^ txhdr_pos_r) & 7) != 0) {
      puts(" push back\r\n");
      uVar2 = txhdr_pos_w & 7;
      txhdr_pos_w = txhdr_pos_w + 1;
      txhdr_hodler[uVar2] = pbVar1;
      goto LAB_230244a6;
    }
    puts(" NOT push back when no mem\r\n");
  }
  pbuf_free((pbuf *)host_id);
LAB_230244a6:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_tx_notify(void)

{
  if (taskHandle_output != (TaskHandle_t)0x0) {
    xTaskGenericNotify(taskHandle_output,0,eIncrement,(uint32_t *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t bl_output(bl_hw *bl_hw,netif *netif,pbuf *p,int is_sta)

{
  u16_t uVar1;
  undefined2 uVar2;
  utils_list_hdr *list_hdr;
  err_t eVar3;
  u8_t uVar4;
  undefined3 extraout_var;
  undefined uVar5;
  pbuf *ppVar6;
  uint8_t *mac;
  int iVar7;
  utils_list_hdr *puVar8;
  
  if ((bl_hw == (bl_hw *)0x0) || ((netif->flags & 4) == 0)) {
    printf("[TX] wifi is down, return now\r\n");
    eVar3 = -0xb;
  }
  else {
    if (taskHandle_output == (TaskHandle_t)0x0) {
      taskHandle_output = xTaskGetCurrentTaskHandle();
    }
    mac = (uint8_t *)p->payload;
    uVar1 = p->tot_len;
    bl_hw_static = bl_hw;
    uVar4 = pbuf_header(p,0x80);
    if (CONCAT31(extraout_var,uVar4) == 0) {
      list_hdr = (utils_list_hdr *)((-(int)p->payload & 3U) + (int)p->payload);
      memset(list_hdr,0,0x5c);
      list_hdr[2].next = (utils_list_hdr *)p;
      memcpy(list_hdr + 7,mac,6);
      memcpy((void *)((int)&list_hdr[8].next + 2),mac + 6,6);
      list_hdr[3].next = (utils_list_hdr *)p;
      uVar2 = *(undefined2 *)(mac + 0xc);
      *(undefined *)((int)&list_hdr[0xd].next + 2) = 0;
      *(undefined2 *)&list_hdr[10].next = uVar2;
      if (is_sta == 0) {
        uVar5 = *(undefined *)&bl_hw->vif_index_ap;
      }
      else {
        uVar5 = *(undefined *)&bl_hw->vif_index_sta;
      }
      *(undefined *)((int)&list_hdr[0xd].next + 3) = uVar5;
      *(undefined2 *)((int)&list_hdr[0xe].next + 2) = 0;
      *(u16_t *)&list_hdr[5].next = uVar1 - 0xe;
      if (is_sta == 0) {
        iVar7 = bl_utils_idx_lookup(bl_hw,mac);
        *(char *)&list_hdr[0xe].next = (char)iVar7;
      }
      else {
        *(char *)&list_hdr[0xe].next = (char)bl_hw->sta_idx;
      }
      puVar8 = list_hdr + 0xf;
      iVar7 = 0;
      ppVar6 = p;
      do {
        if (iVar7 == 0) {
          list_hdr[0xf].next = (utils_list_hdr *)((int)ppVar6->payload + 0x8e);
          list_hdr[0x13].next = (utils_list_hdr *)(ppVar6->len - 0x8e);
        }
        else {
          if (iVar7 == 4) {
            printf("[TX] [PBUF] Please fix for bigger chained pbuf, total_len %d\r\n",
                   (uint)p->tot_len);
          }
          puVar8->next = (utils_list_hdr *)ppVar6->payload;
          puVar8[4].next = (utils_list_hdr *)(uint)ppVar6->len;
        }
        ppVar6 = ppVar6->next;
        iVar7 = iVar7 + 1;
        puVar8 = puVar8 + 1;
      } while (ppVar6 != (pbuf *)0x0);
      if (2 < iVar7) {
        printf("[TX] [LOOP] Chain Used %d\r\n",iVar7);
      }
      list_hdr[4].next = (utils_list_hdr *)0x11111111;
      list_hdr[6].next = list_hdr + 1;
      list_hdr[1].next = (utils_list_hdr *)0x0;
      pbuf_ref(p);
      vTaskEnterCritical();
      utils_list_push_back(&tx_list_bl,list_hdr);
      vTaskExitCritical();
      bl_irq_handler();
      eVar3 = '\0';
    }
    else {
      printf("[TX] Reserve room failed for header\r\n");
      eVar3 = -0xc;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar3;
}



u8 bl_radarind(void *pthis,void *hostid)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



u8 bl_msgackind(void *pthis,void *hostid)

{
  (**(code **)((int)pthis + 0x24))((int)pthis + 4,*(code **)((int)pthis + 0x24));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void bl_prim_tbtt_ind(void *pthis)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void my_pbuf_free_custom(pbuf *p)

{
  bl60x_firmwre_mpdu_free(p[1].payload);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



undefined4 bl_dbgind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_sec_tbtt_ind(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void my_pbuf_free_custom_fake(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

int tcpip_stack_input(void *swdesc,uchar status,void *hwhdr,uint msdu_offset,wifi_pkt *pkt)

{
  char cVar1;
  char cVar2;
  ushort uVar3;
  uint uVar4;
  uint32_t *puVar5;
  int iVar6;
  wifi_pkt *pwVar7;
  ushort *pkt_00;
  void **ppvVar8;
  int iVar9;
  TickType_t TVar10;
  char *fmt;
  pbuf *h;
  SFtype a;
  pbuf *t;
  u16_t length;
  pbuf_custom *ppVar11;
  uint uVar12;
  ushort uVar13;
  uint uVar14;
  list_head *plVar15;
  bl_vif *pbVar16;
  uint uVar17;
  undefined4 uVar18;
  DFtype DVar19;
  
  if ((status & 1) == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  uVar14 = (uint)*(byte *)((int)hwhdr + 0x31);
  pbVar16 = (bl_vif *)wifi_hw.vifs.next;
  if (uVar14 == 0xff) {
    while (pbVar16 != (bl_vif *)&wifi_hw.vifs) {
      if (*(char *)((int)&(&pbVar16->net_stats)[1].rx_packets + 3) != '\0') goto LAB_23024722;
      pbVar16 = (bl_vif *)(pbVar16->list).next;
    }
LAB_230246ec:
    pbVar16 = (bl_vif *)0x0;
  }
  else {
    pbVar16 = (bl_vif *)0x0;
    if ((uVar14 < 2) &&
       (pbVar16 = wifi_hw.vif_table + uVar14, wifi_hw.vif_table[uVar14].up == false))
    goto LAB_230246ec;
  }
LAB_23024722:
  if ((*(uint *)((int)hwhdr + 0x30) & 2) == 0) {
    if (((*(char *)((int)hwhdr + 0x32) != -1) && ((*(uint *)((int)hwhdr + 0x30) & 4) != 0)) &&
       (pbVar16->use_4addr == false)) {
      printf("[RX] Trigger 4addr unexpected frame\r\n");
    }
    iVar9 = wifi_mgmr_ext_dump_needed();
    if (iVar9 != 0) {
      cVar1 = *(char *)((int)hwhdr + 0x1a);
      cVar2 = *(char *)((int)hwhdr + 0x19);
      TVar10 = xTaskGetTickCount();
      uVar14 = (((int)cVar1 & 0xffffU) << 8 | (int)cVar2) & 0xffff;
      if (4000 < (int)(TVar10 - (int)packets_lasttime_7032)) {
        packets_num_7031 = 0;
        freq_offset_all_7029 = 0;
      }
      uVar4 = (int)cVar2 & 0xf;
      packets_num_7031 = packets_num_7031 + 1;
      packets_lasttime_7032 = (SFtype)xTaskGetTickCount();
      iVar6 = packets_num_7031;
      iVar9 = freq_offset_all_7029;
      uVar17 = uVar14 >> 4 & 0x1f;
                    // WARNING: Load size is inaccurate
      uVar3 = *hwhdr;
      cVar1 = *(char *)((int)hwhdr + 0x17);
      if ((*(ushort *)((int)hwhdr + 0x12) & 7) < 2) {
        if ((*(uint *)((int)hwhdr + 0xc) >> 0xc & 0xf) < 4) {
          __floatsidf(*(char *)((int)hwhdr + 0x1f) * -0x10000 >> 0x10);
          __muldf3();
          a = (SFtype)__fixdfsi();
          freq_offset_all_7029 = iVar9 + (int)a;
          uVar12 = *(uint *)((int)hwhdr + 0x24);
          DVar19 = __extendsfdf2(a);
          printf(
                 "[11b] %04d bytes[%03lu], fcs_err %d, rssi %d, %04x, lna %02u, rbb %02u, dg %02d; evm3 %04u:%03d, freq_offset %d, ppm %f\r\n"
                 ,(uint)uVar3,iVar6,uVar12 >> 8 & 1,(int)cVar1,uVar14,uVar4,uVar17,SUB84(DVar19,0));
          goto LAB_230248ca;
        }
        freq_offset_all_7029 =
             freq_offset_all_7029 +
             (int)CONCAT11(*(undefined *)((int)hwhdr + 0x20),*(char *)((int)hwhdr + 0x1f)) / 0x7a;
        DVar19 = __extendsfdf2(packets_lasttime_7032);
        uVar18 = SUB84(DVar19,0);
        fmt = 
        "[11g] %04d bytes[%03lu], rssi %d, %04x, lna %02u, rbb %02u, dg %02d; evm3_4 %03d, freq_offset %d, ppm %f\r\n"
        ;
      }
      else {
        freq_offset_all_7029 = freq_offset_all_7029 + (int)*(short *)((int)hwhdr + 0x1f) / 0x7a;
        DVar19 = __extendsfdf2(packets_lasttime_7032);
        uVar18 = SUB84(DVar19,0);
        fmt = 
        "[11n] %04d bytes[%03lu], rssi %d, %04x, lna %02u, rbb %02u, dg %02d; evm3_4 %03d, freq_offset %d, ppm %f\r\n"
        ;
      }
      printf(fmt,(uint)uVar3,iVar6,(int)cVar1,uVar14,uVar4,uVar17,uVar14 >> 9,uVar18);
    }
LAB_230248ca:
    if (pbVar16 == (bl_vif *)0x0) {
      printf("------ Frame received but no active vif (%d)\r\n",(uint)*(byte *)((int)hwhdr + 0x31));
    }
    else {
      ppVar11 = (pbuf_custom *)pkt->pbuf[0];
      memset(ppVar11,0,0x18);
      ppVar11->custom_free_function = my_pbuf_free_custom;
      ppVar11[1].pbuf.next = (pbuf *)swdesc;
      length = (u16_t)((pkt->len[0] - msdu_offset) * 0x10000 >> 0x10);
      h = pbuf_alloced_custom(PBUF_RAW,length,PBUF_REF,ppVar11,(void *)(pkt->pkt[0] + msdu_offset),
                              length);
      pwVar7 = (wifi_pkt *)(pkt->len + 1);
      ppvVar8 = (void **)pkt->pkt;
      do {
        ppvVar8 = ppvVar8 + 1;
        if (*(short *)pwVar7->pkt == 0) break;
        ppVar11 = (pbuf_custom *)ppvVar8[4];
        memset(ppVar11,0,0x18);
        ppVar11->custom_free_function = my_pbuf_free_custom_fake;
        puVar5 = pwVar7->pkt;
        pwVar7 = (wifi_pkt *)((int)pwVar7->pkt + 2);
        t = pbuf_alloced_custom(PBUF_RAW,*(u16_t *)puVar5,PBUF_REF,ppVar11,*ppvVar8,*(u16_t *)puVar5
                               );
        pbuf_cat(h,t);
      } while (pwVar7 != pkt + 1);
      if (pbVar16->dev != (netif *)0x0) {
        plVar15 = (list_head *)pbVar16->dev->input;
        iVar9 = (*(code *)plVar15)(h,plVar15);
        iVar9 = -(uint)(iVar9 != 0);
        goto LAB_23024940;
      }
    }
  }
  else {
                    // WARNING: Load size is inaccurate
    pkt_00 = (ushort *)(pkt->pkt[0] + msdu_offset);
    bl_rx_pkt_cb((uint8_t *)pkt_00,(uint)*hwhdr);
    uVar3 = *pkt_00;
    uVar13 = uVar3 & 0xfc;
    if ((((uVar13 != 0x80) && (((uVar13 - 0xa0 & 0xffdf) != 0 || (1 < (ushort)(pkt_00[0xc] - 6)))))
        && ((uVar13 != 0xd0 || (*(char *)(pkt_00 + 0xc) != '\x06')))) &&
       (((uVar3 & 0xc) != 8 && ((uVar3 & 0x8c) == 0x88)))) {
      printf("[RX] %04X QOS DATA %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)(pkt_00 + 2),
             (uint)*(byte *)((int)pkt_00 + 5),(uint)*(byte *)(pkt_00 + 3),
             (uint)*(byte *)((int)pkt_00 + 7),(uint)*(byte *)(pkt_00 + 4),
             (uint)*(byte *)((int)pkt_00 + 9));
    }
  }
  iVar9 = -1;
LAB_23024940:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar9;
}



int bl_utils_idx_lookup(bl_hw *bl_hw,uint8_t *mac)

{
  bl_sta *__s1;
  int iVar1;
  int iVar2;
  int iVar3;
  
  __s1 = bl_hw->sta_table;
  iVar1 = 0;
  do {
    if ((__s1->is_used != '\0') && (iVar3 = memcmp(__s1,mac,6), iVar2 = iVar1, iVar3 == 0)) break;
    iVar1 = iVar1 + 1;
    __s1 = __s1 + 1;
    iVar2 = wifi_hw.ap_bcmc_idx;
  } while (iVar1 != 0xc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_ipc_init(bl_hw *bl_hw,ipc_shared_env_tag *ipc_shared_mem)

{
  undefined local_30 [4];
  ipc_host_cb_tag cb;
  
  memset(local_30,0,0x20);
  cb.recv_data_ind = bl_radarind;
  cb.recv_msg_ind = bl_msgackind;
  cb.recv_msgack_ind = bl_dbgind;
  local_30 = bl_txdatacfm;
  cb.recv_dbg_ind = bl_prim_tbtt_ind;
  cb.prim_tbtt_ind = bl_sec_tbtt_ind;
  cb.send_data_cfm = (anon_subr_int_void_ptr_void_ptr_for_send_data_cfm *)0x0;
  cb.recv_radar_ind = (anon_subr_uint8_t_void_ptr_void_ptr_for_recv_radar_ind *)0x0;
  ipc_env = (ipc_host_env_tag *)pvPortMalloc(0xe4);
  bl_hw->ipc_env = ipc_env;
  ipc_host_init(ipc_env,(ipc_host_cb_tag *)local_30,ipc_shared_mem,bl_hw);
  bl_cmd_mgr_init(&bl_hw->cmd_mgr);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_utils_dump(void)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  
  puts("---------- bl_utils_dump -----------\r\n");
  printf("txdesc_free_idx: %lu(%lu)\r\n",ipc_env->txdesc_free_idx,ipc_env->txdesc_free_idx & 3);
  printf("txdesc_used_idx: %lu(%lu)\r\n",ipc_env->txdesc_used_idx,ipc_env->txdesc_used_idx & 3);
  iVar1 = 0;
  printf("tx_host_id0 cnt: %d(used %ld)\r\n",4,ipc_env->txdesc_free_idx - ipc_env->txdesc_used_idx);
  puts("  list:   pbuf    status ptr  status\r\n");
  do {
    uVar2 = ipc_env->txdesc_used_idx + iVar1;
    if (uVar2 == ipc_env->txdesc_free_idx) break;
    iVar1 = iVar1 + 1;
    iVar3 = *(int *)((int)ipc_env->tx_host_id0[uVar2 & 3] + 4);
    iVar3 = (-iVar3 & 3U) + iVar3;
    printf("    [%lu]%p(%p:%08lX)\r\n",*(undefined4 *)(iVar3 + 0x18),*(undefined4 *)(iVar3 + 4));
  } while (iVar1 != 4);
  puts("========== bl_utils_dump End =======\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateSnifferGuard(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(ch == (void *)(uint)*event->data);
}



_Bool stateConnectedIPYesGuard_ip_update(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(ch == (void *)(uint)*event->data);
}



void printErrMsg(void *stateData,event *event)

{
  printf("ENTERED ERROR STATE!");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateSnifferExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateSnifferAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectedIPNoAction_ipgot(void *oldStateData,event *event,void *newStateData)

{
  uint *puVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  puVar1 = (uint *)((int)event->data + 0xd);
  puVar2 = (uint *)((int)event->data + 0x11);
  uVar4 = *puVar1;
  uVar3 = *puVar2;
  printf(
         "[WF][SM] IP GOT IP:%u.%u.%u.%u, MASK: %u.%u.%u.%u, Gateway: %u.%u.%u.%u, dns1: %u.%u.%u.%u, dns2: %u.%u.%u.%u\r\n"
         ,uVar4 & 0xff,uVar4 >> 8 & 0xff,(uint)(*(uint3 *)puVar1 >> 0x10),uVar4 >> 0x18,uVar3 & 0xff
         ,uVar3 >> 8 & 0xff,(uint)(*(uint3 *)puVar2 >> 0x10));
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateGlobalEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateGlobalAction(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] Global Action\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectingEnter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,8,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateSnifferGuard_ChannelSet(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    bl_main_monitor_channel_set(*(int *)(pbVar1 + 1),*(int *)(pbVar1 + 5));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateIdleGuard_sniffer(void *ev,event *event)

{
                    // WARNING: Load size is inaccurate
  if (ev == (void *)(uint)*event->data) {
    bl_main_monitor();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return true;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void stateConnectedIPNoExit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
  xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateDisconnect_action_idle(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM] Removing STA interface...\r\n");
  bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateDisconnect_action_reconnect(void *oldStateData,event *event,void *newStateData)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData);
  printf("[WF][SM]  Action Connect\r\n");
  printf("           ssid %s\r\n",(uint8_t *)((int)oldStateData + 0x4d));
  printf("           ssid len %u\r\n",*(undefined4 *)((int)oldStateData + 0x6e));
  printf("           psk %s\r\n",(uint8_t *)((int)oldStateData + 0x72));
  printf("           psk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf4));
  printf("           pmk %s\r\n",(uint8_t *)((int)oldStateData + 0xb3));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)oldStateData + 0xf8));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",
         (uint)*(byte *)((int)oldStateData + 0x101),(uint)*(byte *)((int)oldStateData + 0x100),
         (uint)*(byte *)((int)oldStateData + 0xff),(uint)*(byte *)((int)oldStateData + 0xfe),
         (uint)*(byte *)((int)oldStateData + 0xfd),(uint)*(byte *)((int)oldStateData + 0xfc));
  bl_main_connect((uint8_t *)((int)oldStateData + 0x4d),*(int *)((int)oldStateData + 0x6e),
                  (uint8_t *)((int)oldStateData + 0x72),*(int *)((int)oldStateData + 0xf4),
                  (uint8_t *)((int)oldStateData + 0xb3),*(int *)((int)oldStateData + 0xf8),
                  (uint8_t *)((int)oldStateData + 0xfc),'\0',_DAT_00000010);
  aos_post_event(2,3,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ip_obtaining_timeout(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  printf("[WF][SM] IP obtaining timeout\r\n");
  wifi_mgmr_api_fw_disconnect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectedIPNoEnter(void *stateData,event *event)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  TickType_t xOptionalValue;
  ip_addr_t iStack44;
  ip4_addr_t addr_ipaddr;
  ip4_addr_t addr_netmask;
  ip4_addr_t addr_gw;
  
  printf("[WF][SM] Entering %s state\r\n",stateData);
  xTimerCreateStatic("wifi IP obtaining",15000,0,stateData,ip_obtaining_timeout,
                     (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff);
  vTaskEnterCritical();
  uVar5 = wifiMgmr.wlan_sta.ipv4.dns2;
  uVar4 = wifiMgmr.wlan_sta.ipv4.dns1;
  uVar3 = wifiMgmr.wlan_sta.ipv4.gw;
  uVar2 = wifiMgmr.wlan_sta.ipv4.mask;
  uVar1 = wifiMgmr.wlan_sta.ipv4.ip;
  vTaskExitCritical();
  if (uVar1 == 0) {
    printf("[WF][SM] DHCP Starting...%p\r\n",0x4201e474);
    wifi_netif_dhcp_start(&wifiMgmr.wlan_sta.netif);
  }
  else {
    printf("[WF][SM] Static IP Starting...%p\r\n",0x4201e474);
    iStack44 = uVar4;
    dns_setserver('\0',&iStack44);
    iStack44 = uVar5;
    dns_setserver('\x01',&iStack44);
    iStack44 = uVar1;
    addr_ipaddr = uVar2;
    addr_netmask = uVar3;
    netifapi_netif_common(&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
    netifapi_netif_set_addr
              (&wifiMgmr.wlan_sta.netif,(ip4_addr_t *)&iStack44,&addr_ipaddr,&addr_netmask);
  }
  aos_post_event(2,4,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateConnectedIPNoGuard_disconnect(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  if (ch == (void *)(uint)*event->data) {
    bl_main_disconnect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateConnectedIPYesGuard_disconnect(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  if (ch == (void *)(uint)*event->data) {
    bl_main_disconnect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateConnectedIPYesGuard_rcconfig(void *ch,event *event)

{
  byte *pbVar1;
  
  pbVar1 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar1) {
    printf("[WF][SM] rate config, use sta_idx 0, rate_config %04X\r\n",*(undefined4 *)(pbVar1 + 1));
    bl_main_rate_config('\0',*(uint16_t *)(pbVar1 + 1));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void stateIdleAction_connect(void *oldStateData,event *event,void *newStateData)

{
  void *pvVar1;
  wifi_mgmr_profile_msg_t *profile_msg;
  char *pcVar2;
  
  pvVar1 = event->data;
  *(undefined *)((int)pvVar1 + 0x2d) = 0;
  *(undefined *)((int)pvVar1 + 0x72) = 0;
  printf("[WF][SM] Action Connect\r\n");
  profile_msg = (wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0xd);
  printf("           ssid %s\r\n",profile_msg);
  printf("           ssid len %u\r\n",*(undefined4 *)((int)pvVar1 + 0x2e));
  printf("           psk %s\r\n",(uint8_t *)((int)pvVar1 + 0x32));
  printf("           psk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb4));
  printf("           pmk %s\r\n",(uint8_t *)((int)pvVar1 + 0x73));
  printf("           pmk len %u\r\n",*(undefined4 *)((int)pvVar1 + 0xb8));
  printf("           channel band %d\r\n",(uint)*(byte *)((int)pvVar1 + 0xc2));
  printf("           channel freq %d\r\n",(uint)*(ushort *)((int)pvVar1 + 0xc3));
  printf("           mac %02X:%02X:%02X:%02X:%02X:%02X\r\n",(uint)*(byte *)((int)pvVar1 + 0xc1),
         (uint)*(byte *)((int)pvVar1 + 0xc0),(uint)*(byte *)((int)pvVar1 + 0xbf),
         (uint)*(byte *)((int)pvVar1 + 0xbe),(uint)*(byte *)((int)pvVar1 + 0xbd),
         (uint)*(byte *)((int)pvVar1 + 0xbc));
  if (*(char *)((int)pvVar1 + 0xc5) == '\0') {
    pcVar2 = "false";
  }
  else {
    pcVar2 = "true";
  }
  printf("           dhcp status: %s\r\n",pcVar2);
  wifi_mgmr_profile_add(&wifiMgmr,profile_msg,-1);
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n",oldStateData,newStateData);
  bl_main_connect((uint8_t *)profile_msg,*(int *)((int)pvVar1 + 0x2e),
                  (uint8_t *)((int)pvVar1 + 0x32),*(int *)((int)pvVar1 + 0xb4),
                  (uint8_t *)((int)pvVar1 + 0x73),*(int *)((int)pvVar1 + 0xb8),
                  (uint8_t *)((int)pvVar1 + 0xbc),*(uint8_t *)((int)pvVar1 + 0xc2),_DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateGlobal_cfg_req(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x16') {
    bl_main_cfg_task_req
              (*(uint32_t *)(pcVar1 + 0xd),*(uint32_t *)(pcVar1 + 0x11),*(uint32_t *)(pcVar1 + 0x15)
               ,*(uint32_t *)(pcVar1 + 0x19),pcVar1 + 0x21,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_fw_powersaving(void *ch,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\x10') {
    printf("------>>>>>> Powersaving CMD, mode: %u\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_powersaving(*(int *)(pcVar1 + 1));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_conf_max_sta(void *ev,event *event)

{
  char *pcVar1;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\n') {
    printf("[WF][SM] Conf max sta supported %lu...\r\n",*(undefined4 *)(pcVar1 + 1));
    bl_main_conf_max_sta(pcVar1[1]);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_AP(void *ev,event *event)

{
  char *pcVar1;
  int iVar2;
  
  pcVar1 = (char *)event->data;
  if (*pcVar1 == '\b') {
    iVar2 = bl_main_if_add(0,&wifiMgmr.wlan_ap.netif,&wifiMgmr.wlan_ap.vif_index);
    if (iVar2 == 0) {
      netifapi_netif_common(&wifiMgmr.wlan_ap.netif,netif_set_link_up,(netifapi_errt_fn)0x0);
      netifapi_netif_common(&wifiMgmr.wlan_ap.netif,dhcpd_start,(netifapi_errt_fn)0x0);
      printf("[WF][SM] start AP with ssid %s;\r\n",pcVar1 + 0x11);
      printf("[WF][SM]               pwd  %s;\r\n",pcVar1 + 0x37);
      printf("[WF][SM]               channel  %ld;\r\n",*(undefined4 *)(pcVar1 + 0xd));
      bl_main_apm_start(pcVar1 + 0x11,pcVar1 + 0x37,*(int *)(pcVar1 + 0xd),
                        wifiMgmr.wlan_ap.vif_index,pcVar1[0x32]);
      wifiMgmr.inf_ap_enabled = 1;
      dns_server_init();
      aos_post_event(2,0xb,0);
    }
    else {
      printf("[WF][SM] %s: add AP iface failed\r\n","stateGlobalGuard_AP");
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_scan_beacon(void *ch,event *event)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  int iVar4;
  int iVar5;
  TickType_t TVar6;
  size_t sVar7;
  int iVar8;
  int iVar9;
  TickType_t TVar10;
  uint32_t uVar11;
  wifi_mgmr_t *pwVar12;
  int iVar13;
  wifi_mgmr_scan_item_t *__dest;
  uint32_t uVar14;
  
  pbVar3 = (byte *)event->data;
  if (ch == (void *)(uint)*pbVar3) {
    pwVar12 = &wifiMgmr;
    if ((((int)(uint)pbVar3[0x3b] <= wifiMgmr.channel_nums) && (pbVar3[0x3b] != 0)) &&
       ((pbVar3[0xd] != 0 || ((wifiMgmr.features & 1) != 0)))) {
      TVar6 = xTaskGetTickCount();
      bVar2 = false;
      uVar14 = 0xffffffff;
      iVar4 = -1;
      iVar13 = 0;
      iVar9 = -1;
      do {
        iVar5 = iVar13;
        if (wifiMgmr.channel_nums < (int)(uint)pwVar12->scan_items[0].channel) {
          memset(pwVar12->scan_items,0,0x3c);
          pwVar12->scan_items[0].is_used = '\0';
        }
        else {
          if (pwVar12->scan_items[0].is_used != '\0') {
            uVar11 = pwVar12->scan_items[0].timestamp_lastseen;
            if ((!bVar2) || ((int)(uVar11 - uVar14) < 0)) {
              iVar4 = iVar13;
              uVar14 = uVar11;
            }
            iVar8 = memcmp(pwVar12->scan_items[0].bssid,pbVar3 + 0x35,6);
            iVar5 = iVar9;
            bVar2 = true;
            if ((iVar8 == 0) &&
               (iVar9 = strcmp((char *)(pbVar3 + 0xd),(char *)pwVar12->scan_items), bVar2 = true,
               iVar9 == 0)) {
              if ((wifiMgmr.scan_items[iVar13].rssi <= (char)pbVar3[0x3c]) ||
                 (TVar10 = xTaskGetTickCount(),
                 2999 < (int)(TVar10 - wifiMgmr.scan_items[iVar13].timestamp_lastseen))) {
                wifiMgmr.scan_items[iVar13].channel = pbVar3[0x3b];
                wifiMgmr.scan_items[iVar13].rssi = pbVar3[0x3c];
                wifiMgmr.scan_items[iVar13].ppm_abs = pbVar3[0x3d];
                bVar1 = pbVar3[0x3e];
                wifiMgmr.scan_items[iVar13].timestamp_lastseen = TVar6;
                wifiMgmr.scan_items[iVar13].ppm_rel = bVar1;
                wifiMgmr.scan_items[iVar13].auth = pbVar3[0x3f];
                wifiMgmr.scan_items[iVar13].cipher = pbVar3[0x40];
              }
              goto LAB_230257f4;
            }
          }
        }
        iVar13 = iVar13 + 1;
        pwVar12 = (wifi_mgmr_t *)&(pwVar12->wlan_sta).netif.input;
        iVar9 = iVar5;
      } while (iVar13 != 0x32);
      if ((iVar5 != -1) || (iVar5 = iVar4, iVar4 != -1)) {
        __dest = wifiMgmr.scan_items + iVar5;
        memset(__dest,0,0x3c);
        strncpy((char *)__dest,(char *)(pbVar3 + 0xd),0x20);
        wifiMgmr.scan_items[iVar5].ssid_tail[0] = '\0';
        sVar7 = strlen((char *)__dest);
        wifiMgmr.scan_items[iVar5].ssid_len = sVar7;
        memcpy(wifiMgmr.scan_items[iVar5].bssid,pbVar3 + 0x35,6);
        wifiMgmr.scan_items[iVar5].channel = pbVar3[0x3b];
        bVar1 = pbVar3[0x3c];
        wifiMgmr.scan_items[iVar5].timestamp_lastseen = TVar6;
        wifiMgmr.scan_items[iVar5].rssi = bVar1;
        wifiMgmr.scan_items[iVar5].auth = pbVar3[0x3f];
        wifiMgmr.scan_items[iVar5].cipher = pbVar3[0x40];
        wifiMgmr.scan_items[iVar5].is_used = '\x01';
      }
    }
  }
LAB_230257f4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void __reload_tsen(timer_cb_arg_t data)

{
  pvTimerGetTimerID((TimerHandle_t)data);
  wifi_mgmr_api_fw_tsen_reload();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void event_cb_wifi_event_mgmr(input_event_t *event,void *private_data)

{
  if (event->code == 0x14) {
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void trigger_auto_denoise(void *arg)

{
  if (auto_repeat != 0) {
    wifi_mgmr_api_denoise_enable();
    aos_post_delayed_action(0x55,trigger_auto_denoise,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateDisconnect_exit(void *stateData,event *event)

{
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  if (*(char *)((int)stateData + 0x4c) != '\0') {
    printf("Delete Timer.\r\n");
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),3,0,(BaseType_t *)0x0,0);
    xTimerGenericCommand((TimerHandle_t)((int)stateData + 0x20),5,0,(BaseType_t *)0x0,0);
    *(undefined *)((int)stateData + 0x4c) = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  printf("Delete Timer Skipped\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void disconnect_retry(timer_cb_arg_t data)

{
  void *pvVar1;
  int iVar2;
  
  pvVar1 = pvTimerGetTimerID((TimerHandle_t)data);
  iVar2 = wifi_mgmr_profile_get(&wifiMgmr,(wifi_mgmr_profile_msg_t *)((int)pvVar1 + 0x4d));
  if (iVar2 != 0) {
    printf("[WF][SM] Retry Again --->>> retry Abort, since profile copy failed\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  printf("[WF][SM] Retry Again --->>> retry connect\r\n");
  wifi_mgmr_api_reconnect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateGlobalGuard_fw_disconnect(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  if (*event->data == '\x0f') {
    printf("Disconnect CMD\r\n");
    bl_main_disconnect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void stateConnectedIPYes_exit(void *stateData,event *event)

{
  ip4_addr_t iStack20;
  ip4_addr_t addr_ipaddr;
  
  iStack20 = 0;
  printf("[WF][SM] Exiting %s state\r\n",stateData);
  netifapi_netif_common(&wifiMgmr.wlan_sta.netif,dhcp_stop,(netifapi_errt_fn)0x0);
  netifapi_netif_set_addr(&wifiMgmr.wlan_sta.netif,&iStack20,&iStack20,&iStack20);
  if (auto_repeat != 0) {
    auto_repeat = 0;
    bl_main_denoise(0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateGlobalGuard_denoise(void *ev,event *event)

{
  int mode;
  
                    // WARNING: Load size is inaccurate
  if (*event->data != '\f') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  if (*(int *)((int)event->data + 1) == 0) {
    auto_repeat = 0;
    mode = 0;
  }
  else {
    if (wifiMgmr.m.currentState != &stateConnectedIPYes) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return false;
    }
    mode = 3;
    if (auto_repeat == 0) {
      auto_repeat = 1;
      bl_main_denoise(1);
      aos_post_event(2,0x14,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return false;
    }
  }
  bl_main_denoise(mode);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateIdleGuard_connect(void *ev,event *event)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if (ev == (void *)(uint)*event->data) {
    iVar1 = bl_main_if_add(1,&wifiMgmr.wlan_sta.netif,&wifiMgmr.wlan_sta.vif_index);
    if (iVar1 != 0) {
      printf("[WF][SM] %s: add STA iface failed\r\n","stateIdleGuard_connect");
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)(iVar1 == 0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateIfaceDownGuard_phyup(void *ev,event *event)

{
  bool bVar1;
  int iVar2;
  
                    // WARNING: Load size is inaccurate
  if (ev == (void *)(uint)*event->data) {
    iVar2 = bl_main_phy_up();
    bVar1 = iVar2 == 0;
  }
  else {
    printf("[WF][SM] state mismatch\r\n");
    bVar1 = false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)bVar1;
}



_Bool stateSnifferGuard_raw_send(void *ch,event *event)

{
  char *pcVar1;
  
  if (((wifiMgmr.m.currentState != &stateIdle) && (wifiMgmr.m.currentState != &stateIfaceDown)) &&
     (pcVar1 = (char *)event->data, *pcVar1 == '\x15')) {
    bl_main_raw_send(*(uint8_t **)(pcVar1 + 1),*(int *)(pcVar1 + 5));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_stop(void *ev,event *event)

{
                    // WARNING: Load size is inaccurate
  if (*event->data == '\t') {
    printf("[WF][SM] Stoping AP interface...\r\n");
    bl_main_apm_stop(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Removing and deauth all sta client...\r\n");
    bl_main_apm_remove_all_sta();
    printf("[WF][SM] Removing AP interface...\r\n");
    bl_main_if_remove(wifiMgmr.wlan_ap.vif_index);
    printf("[WF][SM] Stopping DHCP on AP interface...\r\n");
    netifapi_netif_common(&wifiMgmr.wlan_ap.netif,(netifapi_void_fn)0x0,dhcp_server_stop);
    printf("[WF][SM] Removing ETH interface ...\r\n");
    netifapi_netif_common(&wifiMgmr.wlan_ap.netif,netif_remove,(netifapi_errt_fn)0x0);
    wifiMgmr.inf_ap_enabled = 0;
    aos_post_event(2,0xc,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_enable_autoreconnect(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  if (ch == (void *)(uint)*event->data) {
    printf("Enable Auto Reconnect\r\n");
    wifi_mgmr_profile_autoreconnect_enable(&wifiMgmr,-1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool stateGlobalGuard_disable_autoreconnect(void *ch,event *event)

{
  bool bVar1;
  
                    // WARNING: Load size is inaccurate
  if (ch == (void *)(uint)*event->data) {
    bVar1 = wifiMgmr.m.currentState != &stateDisconnect;
    if (bVar1) {
      printf("Disable Auto Reconnect\r\n");
      wifi_mgmr_profile_autoreconnect_disable(&wifiMgmr,-1);
    }
    else {
      printf("Disable Autoreconnect in Disconnec State\r\n");
      printf("[WF][SM] Removing STA interface...\r\n");
      bl_main_if_remove(wifiMgmr.wlan_sta.vif_index);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)!bVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Variable defined which should be unmapped: is_ok

void stateDisconnect_enter(void *stateData,event *event)

{
  int iVar1;
  TickType_t xOptionalValue;
  uint uVar2;
  uint uStack20;
  int is_ok;
  
  uStack20 = 0;
  printf("[WF][SM] Entering %s state\r\n",stateData);
  iVar1 = wifi_mgmr_profile_autoreconnect_is_enabled(&wifiMgmr,-1);
  if (iVar1 == 0) {
    printf("[WF][SM] Will NOT retry connect\r\n");
  }
  else {
    xTimerCreateStatic("wifi disconnect",2000,0,stateData,disconnect_retry,
                       (StaticTimer_t *)(TimerHandle_t)((int)stateData + 0x20));
    printf("[WF][SM] Will retry in 2000 ticks\r\n");
    xOptionalValue = xTaskGetTickCount();
    xTimerGenericCommand
              ((TimerHandle_t)((int)stateData + 0x20),1,xOptionalValue,(BaseType_t *)0x0,0xffffffff)
    ;
    *(undefined *)((int)stateData + 0x4c) = 1;
  }
  aos_post_event(2,5,(uint)wifiMgmr.wifi_mgmr_stat_info.status_code);
  uVar2 = bl60x_check_mac_status((int *)&uStack20);
  if ((uVar2 | uStack20) == 0) {
    aos_post_event(2,0x17,0);
    helper_record_dump();
  }
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool stateGlobalGuard_fw_scan(void *ch,event *event)

{
                    // WARNING: Load size is inaccurate
  if (*event->data == '\x12') {
    if (((wifiMgmr.m.currentState == &stateConnecting) ||
        (wifiMgmr.m.currentState == &stateConnectedIPNo)) ||
       (wifiMgmr.m.currentState == &stateDisconnect)) {
      printf("------>>>>>> Scan CMD Pending\r\n");
      wifiMgmr.pending_task = wifiMgmr.pending_task | 1;
    }
    else {
      if (((wifiMgmr.m.currentState == &stateIdle) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         (wifiMgmr.m.currentState == &stateSniffer)) {
        printf("------>>>>>> Scan CMD\r\n");
        bl_main_scan();
      }
      else {
        printf("------>>>>>> FW busy\r\n");
        aos_post_event(2,9,1);
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



bool stateDisconnect_guard(uint param_1,int param_2)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1 == **(byte **)(param_2 + 4);
}



void stateGlobalExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateSnifferEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



bool stateConnectingGuard(uint param_1,int param_2)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1 == **(byte **)(param_2 + 4);
}



void stateConnectingAction_connected(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectingAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectingExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIdleAction_sniffer(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIdleEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIdleExit(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIfaceDownAction_phyup(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIfaceDownEnter(void)

{
  printf("[WF][SM] Entering %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateIfaceDownExit(void)

{
  printf("[WF][SM] Exiting %s state\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



bool stateConnectedIPNoGuard(uint param_1,int param_2)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1 == **(byte **)(param_2 + 4);
}



void stateConnectedIPNoAction_disconnect(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



bool stateConnectedIPYesGuard(uint param_1,int param_2)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1 == **(byte **)(param_2 + 4);
}



void stateConnectedIPYes_action(void)

{
  printf("[WF][SM] State Action ###%s### --->>> ###%s###\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateConnectedIPYes_enter(void *stateData,event *event)

{
  printf("[WF][SM] Entering %s state\r\n",stateData);
  aos_post_event(2,7,0);
  if ((wifiMgmr.pending_task & 1) != 0) {
    printf("[WF][SM] Pending Scan Sent\r\n");
    bl_main_scan();
    wifiMgmr.pending_task = wifiMgmr.pending_task & 0xfffffffe;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



char * wifi_mgmr_auth_to_str(uint8_t auth)

{
  undefined3 in_register_00002029;
  
  switch(CONCAT31(in_register_00002029,auth)) {
  case 0:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "Open";
  case 1:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WEP";
  case 2:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WPA-PSK";
  case 3:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WPA2-PSK";
  case 4:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WPA2-PSK/WPA-PSK";
  case 5:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WPA/WPA2-Enterprise";
  default:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "Unknown";
  }
}



char * wifi_mgmr_cipher_to_str(uint8_t cipher)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,cipher);
  if (iVar1 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "NONE";
  }
  if (iVar1 == 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "WEP";
  }
  if (iVar1 == 2) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "AES";
  }
  if (iVar1 != 3) {
    if (iVar1 != 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return "Unknown";
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "TKIP/AES";
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return "TKIP";
}



int wifi_mgmr_event_notify(wifi_mgmr_msg_t *msg)

{
  size_t sVar1;
  int iVar2;
  
  while (wifiMgmr.ready == '\0') {
    printf("Wait Wi-Fi Mgmr Start up...\r\n");
    vTaskDelay(0x14);
  }
  sVar1 = xStreamBufferSend((StreamBufferHandle_t)&wifiMgmr.mq,msg,msg->len,0xffffffff);
  iVar2 = 0;
  if (sVar1 == 0) {
    printf("Failed when send msg 0x%p, len dec:%u\r\n",msg,msg->len);
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_mgmr_start(void)

{
  TickType_t xOptionalValue;
  size_t sVar1;
  void *pvRxData;
  int16_t iStack274;
  undefined auStack272 [2];
  int16_t temp;
  event ev;
  uint8_t buffer [232];
  
  pvRxData = (void *)((int)&ev.data + 1);
  _auStack272 = 1;
  ev.type = (int)pvRxData;
  stateM_init(&wifiMgmr.m,&stateIfaceDown,&stateError);
  wifi_mgmr_event_init();
  aos_register_event_filter(2,event_cb_wifi_event_mgmr,(void *)0x0);
  aos_post_event(2,2,0);
  hal_sys_capcode_update(-1,-1);
  printf("[WF][SM] reload tsen \r\n");
  xTimerCreateStatic("wifi reload tsen",10000,1,&state_tsen_reload_data,__reload_tsen,
                     (StaticTimer_t *)&state_tsen_reload_data.timer);
  xOptionalValue = xTaskGetTickCount();
  xTimerGenericCommand
            ((TimerHandle_t)&state_tsen_reload_data.timer,1,xOptionalValue,(BaseType_t *)0x0,
             0xffffffff);
  do {
    while( true ) {
      do {
        sVar1 = xStreamBufferReceive((StreamBufferHandle_t)&wifiMgmr.mq,pvRxData,0xe0,0xffffffff);
      } while (sVar1 == 0);
      if (ev.data._1_1_ != 0xd) break;
      iStack274 = 0;
      if ((((wifiMgmr.m.currentState == &stateConnecting) ||
           (wifiMgmr.m.currentState == &stateDisconnect)) ||
          (wifiMgmr.m.currentState == &stateConnectedIPYes)) ||
         ((wifiMgmr.m.currentState == &stateSniffer ||
          (wifiMgmr.m.currentState == &stateConnectedIPNo)))) {
        bl_tsen_adc_get(&iStack274,'\0');
        phy_tcal_callback(iStack274);
      }
    }
    _auStack272 = 1;
    if (0xd < ev.data._1_1_) {
      _auStack272 = (uint)(0x16 < ev.data._1_1_) << 1;
    }
    stateM_handleEvent(&wifiMgmr.m,(event *)auStack272);
  } while( true );
}



void _wifi_mgmr_entry(void *pvParameters)

{
  wifi_conf_t *conf;
  TaskHandle_t aptStack36 [4];
  code *pcStack20;
  
  pcStack20 = wifi_mgmr_start_background;
  conf = (wifi_conf_t *)wifi_mgmr_start();
  wifi_mgmr_drv_init(conf);
  aptStack36[0] = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,aptStack36);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_mgmr_start_background(wifi_conf_t *conf)

{
  TaskHandle_t ptStack20;
  TaskHandle_t xHandle;
  
  wifi_mgmr_drv_init(conf);
  ptStack20 = (TaskHandle_t)0x0;
  xTaskCreate(_wifi_mgmr_entry,"wifi_mgmr",0x300,(void *)0x0,0x1c,&ptStack20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_mgmr_init(void)

{
  StreamBufferHandle_t pSVar1;
  
  pSVar1 = xStreamBufferGenericCreateStatic
                     (0x8c0,0,1,wifiMgmr.mq_pool,(StaticStreamBuffer_t *)&wifiMgmr.mq);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifiMgmr.ready = '\x01';
  wifiMgmr.scan_item_timeout = 15000;
  return (uint)(pSVar1 == (StreamBufferHandle_t)0x0);
}



int wifi_mgmr_state_get_internal(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230262ac;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230262ac;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230262ac;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar2 = 9;
  }
LAB_230262ac:
  *state = iVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void wifi_mgmr_set_connect_stat_info(wifi_event_sm_connect_ind *ind,uint8_t type_ind)

{
  uint8_t uVar1;
  uint8_t *puVar2;
  uint8_t *puVar3;
  
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->status_code;
  puVar2 = ind->bssid;
  puVar3 = wifiMgmr.wifi_mgmr_stat_info.bssid;
  do {
    uVar1 = *puVar2;
    puVar2 = puVar2 + 1;
    *puVar3 = uVar1;
    puVar3 = puVar3 + 1;
  } while (puVar2 != &ind->vif_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifiMgmr.wifi_mgmr_stat_info.type_ind = type_ind;
  wifiMgmr.wifi_mgmr_stat_info.chan_freq = ind->center_freq;
  wifiMgmr.wifi_mgmr_stat_info.chan_band = ind->band;
  return;
}



int wifi_mgmr_set_country_code_internal(char *country_code)

{
  bl_main_set_country_code(country_code);
  strncpy(wifiMgmr.country_code,country_code,3);
  wifiMgmr.country_code[2] = '\0';
  wifiMgmr.channel_nums = bl_main_get_channel_nums();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get_internal(uint8_t *sta_cnt)

{
  bl_main_apm_sta_cnt_get(sta_cnt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int wifi_mgmr_ap_sta_info_get_internal(wifi_mgmr_sta_basic_info_t *sta_info_internal,uint8_t idx)

{
  undefined auStack40 [4];
  wifi_apm_sta_info apm_sta_info;
  
  memset(auStack40,0,0x18);
  bl_main_apm_sta_info_get((wifi_apm_sta_info *)auStack40,idx);
  *(undefined2 *)sta_info_internal = auStack40._0_2_;
  sta_info_internal->rssi = apm_sta_info.tsflo;
  sta_info_internal->tsflo = apm_sta_info.tsfhi;
  sta_info_internal->tsfhi = apm_sta_info.sta_mac._2_4_;
  sta_info_internal->data_rate = (uint8_t)apm_sta_info.rssi;
  memcpy(sta_info_internal->sta_mac,(void *)((int)auStack40 + 2),6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_ap_sta_delete_internal(uint8_t sta_idx)

{
  bl_main_apm_sta_delete(sta_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_scan_complete_notify(void)

{
  wifi_mgmr_scan_complete_callback();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_connect(char *ssid,char *psk,char *pmk,uint8_t *mac,uint8_t band,uint16_t freq)

{
  size_t __n;
  int iVar1;
  undefined3 in_register_00002039;
  undefined2 in_register_0000203e;
  undefined auStack232 [2];
  undefined uStack230;
  undefined uStack229;
  uint8_t buffer [198];
  
  memset(auStack232,0,0xc6);
  auStack232[0] = WIFI_MGMR_EVENT_APP_CONNECT;
  auStack232[1] = 0x44;
  uStack230 = 0x33;
  uStack229 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = -0x3a;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  __n = strlen(ssid);
  buffer._42_2_ = (undefined2)__n;
  buffer._44_2_ = (undefined2)(__n >> 0x10);
  memcpy(buffer + 9,ssid,__n);
  buffer[41] = '\0';
  if (psk == (char *)0x0) {
    buffer._176_4_ = 0;
LAB_23026504:
    buffer[110] = '\0';
    if (pmk == (char *)0x0) {
      buffer._180_4_ = 0;
    }
    else {
      buffer._180_4_ = strlen(pmk);
      if (buffer._180_4_ != 0) {
        if (buffer._180_4_ != 0x40) goto LAB_23026562;
        memcpy(buffer + 0x6f,pmk,0x40);
      }
    }
    buffer[175] = '\0';
    if (mac != (uint8_t *)0x0) {
      memcpy(buffer + 0xb8,mac,6);
    }
    if (CONCAT22(in_register_0000203e,freq) != 0) {
      buffer[191] = (uint8_t)freq;
      buffer[192] = (uint8_t)(freq >> 8);
      buffer[190] = band;
      printf("wifi mgmr band:%d freq: %d\r\n",CONCAT31(in_register_00002039,band),
             CONCAT22(in_register_0000203e,freq));
    }
    buffer[193] = '\x01';
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack232);
    iVar1 = 0;
  }
  else {
    buffer._176_4_ = strlen(psk);
    if (buffer._176_4_ < 0x41) {
      if (buffer._176_4_ != 0) {
        memcpy(buffer + 0x2e,psk,buffer._176_4_);
      }
      goto LAB_23026504;
    }
LAB_23026562:
    iVar1 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int wifi_mgmr_api_cfg_req
              (uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
              uint32_t *buf)

{
  int iVar1;
  undefined auStack100 [2];
  undefined uStack98;
  undefined uStack97;
  uint8_t buffer [65];
  
  if (length < 0x21) {
    memset(auStack100,0,0x41);
    auStack100[0] = WIFI_MGMR_EVENT_FW_CFG_REQ;
    auStack100[1] = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    iVar1 = length + 0xc6;
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[6] = (uint8_t)((uint)iVar1 >> 8);
    buffer[7] = (uint8_t)((uint)iVar1 >> 0x10);
    buffer[10] = (uint8_t)(ops >> 8);
    buffer[11] = (uint8_t)(ops >> 0x10);
    buffer[14] = (uint8_t)(task >> 8);
    buffer[15] = (uint8_t)(task >> 0x10);
    buffer[18] = (uint8_t)(element >> 8);
    buffer[19] = (uint8_t)(element >> 0x10);
    buffer[22] = (uint8_t)(type >> 8);
    buffer[23] = (uint8_t)(type >> 0x10);
    buffer[5] = (uint8_t)iVar1;
    buffer[9] = (uint8_t)ops;
    buffer[13] = (uint8_t)task;
    buffer[17] = (uint8_t)element;
    buffer[21] = (uint8_t)type;
    buffer[26] = (uint8_t)(length >> 8);
    buffer[27] = (uint8_t)(length >> 0x10);
    buffer[8] = (uint8_t)((uint)iVar1 >> 0x18);
    buffer[12] = (uint8_t)(ops >> 0x18);
    buffer[16] = (uint8_t)(task >> 0x18);
    buffer[20] = (uint8_t)(element >> 0x18);
    buffer[24] = (uint8_t)(type >> 0x18);
    buffer[25] = (uint8_t)length;
    buffer[28] = (uint8_t)(length >> 0x18);
    if (length != 0) {
      memcpy(buffer + 0x1d,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack100);
    return 0;
  }
  return -1;
}



// WARNING: Variable defined which should be unmapped: buffer

int wifi_mgmr_api_ip_got(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  undefined auStack52 [2];
  undefined uStack50;
  undefined uStack49;
  uint8_t buffer [33];
  
  memset(auStack52,0,0x21);
  auStack52[0] = WIFI_MGMR_EVENT_APP_IP_GOT;
  auStack52[1] = 0x44;
  uStack50 = 0x33;
  uStack49 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '!';
  buffer[10] = (uint8_t)(ip >> 8);
  buffer[11] = (uint8_t)(ip >> 0x10);
  buffer[14] = (uint8_t)(mask >> 8);
  buffer[15] = (uint8_t)(mask >> 0x10);
  buffer[18] = (uint8_t)(gw >> 8);
  buffer[19] = (uint8_t)(gw >> 0x10);
  buffer[9] = (uint8_t)ip;
  buffer[13] = (uint8_t)mask;
  buffer[17] = (uint8_t)gw;
  buffer[21] = (uint8_t)dns1;
  buffer[22] = (uint8_t)(dns1 >> 8);
  buffer[12] = (uint8_t)(ip >> 0x18);
  buffer[16] = (uint8_t)(mask >> 0x18);
  buffer[20] = (uint8_t)(gw >> 0x18);
  buffer[23] = (uint8_t)(dns1 >> 0x10);
  buffer[24] = (uint8_t)(dns1 >> 0x18);
  buffer[25] = (uint8_t)dns2;
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  buffer[26] = (uint8_t)(dns2 >> 8);
  buffer[27] = (uint8_t)(dns2 >> 0x10);
  buffer[28] = (uint8_t)(dns2 >> 0x18);
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack52);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_ip_update(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_GLB_IP_UPDATE;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_reconnect(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_RECONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_disable_autoreconnect(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_enable_autoreconnect(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_disconnect(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_DISCONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_rate_config(uint16_t config)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  local_20[1] = (undefined)config;
  buffer[4] = 'U';
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_conf_max_sta(uint8_t max_sta_supported)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  local_20[1] = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_ifaceup(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_PHY_UP;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_sniffer_enable(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_SNIFFER;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_scan_item_beacon
              (uint8_t channel,int8_t rssi,uint8_t auth,uint8_t *mac,uint8_t *ssid,int len,
              int8_t ppm_abs,int8_t ppm_rel,uint8_t cipher)

{
  undefined auStack108 [2];
  undefined uStack106;
  undefined uStack105;
  uint8_t buffer [73];
  
  memset(auStack108,0,0x49);
  auStack108[0] = WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON;
  auStack108[1] = 0x44;
  uStack106 = 0x33;
  uStack105 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = 'I';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  memcpy(buffer + 9,ssid,len);
  buffer[45] = (uint8_t)len;
  buffer[46] = (uint8_t)((uint)len >> 8);
  buffer[47] = (uint8_t)((uint)len >> 0x10);
  buffer[48] = (uint8_t)((uint)len >> 0x18);
  buffer[41] = '\0';
  memcpy(buffer + 0x31,mac,6);
  buffer[55] = channel;
  buffer[56] = rssi;
  buffer[57] = ppm_abs;
  buffer[58] = ppm_rel;
  buffer[59] = auth;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack108);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_fw_disconnect(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_FW_DISCONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_fw_tsen_reload(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  local_20[0] = WIFI_MGMR_EVENT_APP_RELOAD_TSEN;
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_fw_scan(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_FW_SCAN;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_fw_powersaving(int mode)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_FW_POWERSAVING;
  uStack30 = (undefined)((uint)mode >> 8);
  uStack29 = (undefined)((uint)mode >> 0x10);
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  local_20[1] = (undefined)mode;
  buffer[4] = 'U';
  buffer[0] = (uint8_t)((uint)mode >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int wifi_mgmr_api_ap_start(char *ssid,char *passwd,int channel,uint8_t hidden_ssid)

{
  size_t sVar1;
  int iVar2;
  undefined3 in_register_00002035;
  undefined auStack156 [2];
  undefined uStack154;
  undefined uStack153;
  uint8_t buffer [124];
  
  if (ssid == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  memset(auStack156,0,0x7c);
  sVar1 = strlen(ssid);
  buffer[47] = (uint8_t)sVar1;
  buffer._48_4_ = buffer._48_4_ & 0xff000000 | sVar1 >> 8;
  if (sVar1 < 0x21) {
    if (passwd != (char *)0x0) {
      buffer._116_4_ = strlen(passwd);
      if (0x20 < buffer._116_4_) goto LAB_23026f80;
    }
    auStack156[0] = WIFI_MGMR_EVENT_APP_AP_START;
    auStack156[1] = 0x44;
    uStack154 = 0x33;
    uStack153 = 0x22;
    buffer[0] = '\x11';
    buffer[1] = -0x78;
    buffer[2] = 'w';
    buffer[3] = 'f';
    buffer[4] = 'U';
    buffer[5] = '|';
    buffer[6] = '\0';
    buffer[7] = '\0';
    buffer[8] = '\0';
    memcpy(buffer + 0xd,ssid,(uint)buffer[47] | buffer._48_4_ << 8);
    if (passwd == (char *)0x0) {
      buffer._116_4_ = 0;
    }
    else {
      memcpy(buffer + 0x33,passwd,buffer._116_4_);
    }
    buffer[9] = (uint8_t)channel;
    buffer[10] = (uint8_t)((uint)channel >> 8);
    buffer[46] = CONCAT31(in_register_00002035,hidden_ssid) != 0;
    buffer[11] = (uint8_t)((uint)channel >> 0x10);
    buffer[12] = (uint8_t)((uint)channel >> 0x18);
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack156);
    iVar2 = 0;
  }
  else {
LAB_23026f80:
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int wifi_mgmr_api_ap_stop(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_AP_STOP;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_idle(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  buffer[0] = '\x11';
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  local_20[0] = WIFI_MGMR_EVENT_APP_IDLE;
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_denoise_enable(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_DENOISE;
  local_20[1] = 1;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  return 0;
}



int wifi_mgmr_api_denoise_disable(void)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_APP_DENOISE;
  buffer[1] = -0x78;
  buffer[2] = 'w';
  buffer[3] = 'f';
  buffer[4] = 'U';
  local_20[1] = 0;
  uStack30 = 0;
  uStack29 = 0;
  buffer[0] = '\0';
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  return 0;
}



int wifi_mgmr_api_raw_send(uint8_t *pkt,int len)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  uint8_t buffer [13];
  
  memset(local_20,0,0xd);
  local_20[0] = WIFI_MGMR_EVENT_FW_DATA_RAW_SEND;
  uStack30 = (undefined)((uint)pkt >> 8);
  uStack29 = (undefined)((uint)pkt >> 0x10);
  buffer[2] = (uint8_t)((uint)len >> 8);
  local_20[1] = SUB41(pkt,0);
  buffer[1] = (uint8_t)len;
  buffer[3] = (uint8_t)((uint)len >> 0x10);
  buffer[0] = (uint8_t)((uint)pkt >> 0x18);
  buffer[4] = (uint8_t)((uint)len >> 0x18);
  buffer[5] = '\r';
  buffer[6] = '\0';
  buffer[7] = '\0';
  buffer[8] = '\0';
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_api_set_country_code(char *country_code)

{
  wifi_mgmr_set_country_code_internal(country_code);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cmd_rf_dump(char *buf,int len,int argc,char **argv)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_dump_reset(char *buf,int len,int argc,char **argv)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  pkt_counter = 10;
  return;
}



void cmd_wifi_power_table_update(char *buf,int len,int argc,char **argv)

{
  int8_t aiStack56 [4];
  int8_t power_table_test [38];
  
  memcpy(aiStack56,&DAT_2307d844,0x26);
  bl_tpc_update_power_table(aiStack56);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_state_get(char *buf,int len,int argc,char **argv)

{
  char *fmt;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  switch(iStack20) {
  case 0:
    fmt = "wifi state unknown\r\n";
    break;
  case 1:
    fmt = "wifi state idle\r\n";
    break;
  case 2:
    fmt = "wifi state connecting\r\n";
    break;
  case 3:
    fmt = "wifi state connected ip getting\r\n";
    break;
  case 4:
    fmt = "wifi state connected ip got\r\n";
    break;
  case 5:
    fmt = "wifi state disconnect\r\n";
    break;
  case 6:
    fmt = "wifi state ifdown\r\n";
    break;
  case 7:
    fmt = "wifi state sniffer\r\n";
    break;
  case 8:
    fmt = "wifi state psk error\r\n";
    break;
  case 9:
    fmt = "wifi state no ap found\r\n";
    break;
  default:
    goto switchD_2302724c_caseD_a;
  case 0x11:
    fmt = "wifi state with ap idle\r\n";
    break;
  case 0x12:
    fmt = "wifi state with ap connecting\r\n";
    break;
  case 0x13:
    fmt = "wifi state with ap connected ip getting\r\n";
    break;
  case 0x14:
    fmt = "wifi state with ap connected ip got\r\n";
    break;
  case 0x15:
    fmt = "wifi state with ap disconnect\r\n";
  }
  printf(fmt);
switchD_2302724c_caseD_a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_sta_get_state_cmd(char *buf,int len,int argc,char **argv)

{
  char *fmt;
  int iStack20;
  int state;
  
  iStack20 = 0;
  wifi_mgmr_state_get(&iStack20);
  printf("%s:wifi state = 0x%x\r\n","wifi_sta_get_state_cmd",iStack20);
  if (iStack20 == 0) {
    fmt = "wifi current state: WIFI_STATE_UNKNOWN\r\n";
  }
  else {
    if (iStack20 == 1) {
      fmt = "wifi current state: WIFI_STATE_IDLE\r\n";
    }
    else {
      if (iStack20 == 2) {
        fmt = "wifi current state: WIFI_STATE_CONNECTING\r\n";
      }
      else {
        if (iStack20 == 3) {
          fmt = "wifi current state: WIFI_STATE_CONNECTED_IP_GETTING\r\n";
        }
        else {
          if (iStack20 == 4) {
            fmt = "wifi current state: WIFI_STATE_CONNECTED_IP_GOT\r\n";
          }
          else {
            if (iStack20 == 5) {
              fmt = "wifi current state: WIFI_STATE_DISCONNECT\r\n";
            }
            else {
              if (iStack20 == 0x11) {
                fmt = "wifi current state: WIFI_STATE_WITH_AP_IDLE\r\n";
              }
              else {
                if (iStack20 == 0x12) {
                  fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTING\r\n";
                }
                else {
                  if (iStack20 == 0x13) {
                    fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING\r\n";
                  }
                  else {
                    if (iStack20 == 0x14) {
                      fmt = "wifi current state: WIFI_STATE_WITH_AP_CONNECTED_IP_GOT\r\n";
                    }
                    else {
                      if (iStack20 == 0x15) {
                        fmt = "wifi current state: WIFI_STATE_WITH_AP_DISCONNECT\r\n";
                      }
                      else {
                        if (iStack20 == 6) {
                          fmt = "wifi current state: WIFI_STATE_IFDOWN\r\n";
                        }
                        else {
                          if (iStack20 == 7) {
                            fmt = "wifi current state: WIFI_STATE_SNIFFER\r\n";
                          }
                          else {
                            if (iStack20 == 8) {
                              fmt = "wifi current state: WIFI_STATE_PSK_ERROR\r\n";
                            }
                            else {
                              if (iStack20 == 9) {
                                fmt = "wifi current state: WIFI_STATE_NO_AP_FOUND\r\n";
                              }
                              else {
                                fmt = "wifi current state: invalid\r\n";
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  printf(fmt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_edca_dump_cmd(char *buf,int len,int argc,char **argv)

{
  byte local_15;
  byte local_14;
  byte local_13;
  uint8_t aifs;
  ushort uStack18;
  uint8_t cwmin;
  uint8_t cwmax;
  uint16_t txop;
  
  local_15 = 0;
  local_14 = 0;
  local_13 = 0;
  uStack18 = 0;
  puts("EDCA Statistic:\r\n");
  bl60x_edca_get(0,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BK:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(1,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_BE:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(2,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VI:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  bl60x_edca_get(3,&local_15,&local_14,&local_13,(uint16_t *)&stack0xffffffee);
  puts("  AC_VO:");
  printf("aifs %3u, cwmin %3u, cwmax %3u, txop %4u\r\n",(uint)local_15,(uint)local_14,(uint)local_13
         ,(uint)uStack18);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_list_get_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  uint uVar2;
  char *fmt;
  wifi_ap_data_rate *pwVar3;
  byte bStack77;
  uint8_t sta_cnt;
  uint uStack76;
  int state;
  wifi_sta_basic_info sta_info;
  
  uStack76 = 0;
  bStack77 = 0;
  wifi_mgmr_state_get((int *)&stack0xffffffb4);
  if ((uStack76 & 0x10) == 0) {
    fmt = "wifi AP is not enabled, state = %d\r\n";
    uVar2 = uStack76;
  }
  else {
    wifi_mgmr_ap_sta_cnt_get(&bStack77);
    if (bStack77 != 0) {
      memset(&state,0,0x18);
      printf("sta list:\r\n");
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      printf(
            "No.      StaIndex      Mac-Address       Signal      DateRate            TimeStamp\r\n"
            );
      printf(
            "-----------------------------------------------------------------------------------\r\n"
            );
      uVar2 = 0;
      while (uVar2 < bStack77) {
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,(uint8_t)uVar2);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          pwVar3 = data_rate_list;
          cVar1 = '\0';
          do {
            if (pwVar3->data_rate == (uint8_t)sta_info.rssi) break;
            cVar1 = cVar1 + '\x01';
            pwVar3 = pwVar3 + 1;
          } while (cVar1 != '\f');
          printf(
                 " %u          %u        %02X:%02X:%02X:%02X:%02X:%02X    %d      %s      0x%llx\r\n"
                 ,uVar2,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
        }
        uVar2 = uVar2 + 1 & 0xff;
      }
      goto LAB_23027550;
    }
    uVar2 = 0;
    fmt = "no sta connect current AP, sta_cnt = %d\r\n";
  }
  printf(fmt,uVar2);
LAB_23027550:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_ap_sta_delete_cmd(char *buf,int len,int argc,char **argv)

{
  char cVar1;
  byte idx;
  char *pcVar2;
  char *pcVar3;
  size_t sVar4;
  char *pcVar5;
  byte bVar6;
  char cVar7;
  byte bStack45;
  uint8_t sta_cnt;
  char *pcStack44;
  int state;
  wifi_sta_basic_info sta_info;
  
  pcStack44 = (char *)0x0;
  bStack45 = 0;
  if (argc == 2) {
    wifi_mgmr_state_get((int *)&stack0xffffffd4);
    if (((uint)pcStack44 & 0x10) == 0) {
      pcVar3 = "wifi AP is not enabled, state = %d\r\n";
      pcVar2 = pcStack44;
    }
    else {
      printf("Delete Sta No.%s \r\n",argv[1]);
      pcVar3 = argv[1];
      idx = 0;
      sVar4 = strlen(pcVar3);
      cVar7 = '\x01';
      pcVar5 = pcVar3 + sVar4;
      *pcVar5 = '\0';
      pcVar2 = pcVar5;
      while ((int)(pcVar5 + -(int)pcVar2) < (int)sVar4) {
        cVar1 = pcVar2[-1];
        bVar6 = cVar1 - 0x30;
        if (9 < bVar6) {
          if ((byte)(cVar1 + 0x9fU) < 6) {
            bVar6 = cVar1 + 0xa9;
          }
          else {
            bVar6 = 0;
            if ((byte)(cVar1 + 0xbfU) < 6) {
              bVar6 = cVar1 - 0x37;
            }
          }
        }
        pcVar2 = pcVar2 + -1;
        idx = idx + bVar6 * cVar7;
        cVar7 = cVar7 * '\n';
      }
      pcVar2 = (char *)(uint)idx;
      printf("sta_str: %s, str_len: %d, sta_num: %d, q: %s\r\n",pcVar3,pcVar2);
      printf("sta num = %d \r\n",pcVar2);
      wifi_mgmr_ap_sta_cnt_get(&bStack45);
      pcVar5 = (char *)(uint)bStack45;
      if ((pcVar5 == (char *)0x0) || (pcVar5 < pcVar2)) {
        pcVar3 = "no valid sta in list or sta idx(%d) is invalid\r\n";
        pcVar2 = pcVar5;
      }
      else {
        memset(&state,0,0x18);
        wifi_mgmr_ap_sta_info_get((wifi_sta_basic_info *)&state,idx);
        if ((state._1_1_ != '\0') && ((uint8_t)state != -0x11)) {
          printf("sta info: No.%u,sta_idx = %u,mac = %02X:%02X:%02X:%02X:%02X:%02X,rssi = %d\r\n",
                 pcVar2,(uint)state._2_1_,(uint)state._3_1_,(uint)sta_info.sta_idx,
                 (uint)sta_info.is_used,(uint)sta_info.sta_mac[0]);
          wifi_mgmr_ap_sta_delete((uint8_t)state);
          goto LAB_23027670;
        }
        pcVar3 = "No.%d sta is invalid\r\n";
      }
    }
  }
  else {
    pcVar3 = "[USAGE]: %s sta_num\r\n";
    pcVar2 = *argv;
  }
  printf(pcVar3,pcVar2);
LAB_23027670:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_pta_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_pta_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pta_forece_enable(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_pti_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_pti_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_pti_forece_enable(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_rf_force_off(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_coex_rf_force_on(char *buf,int len,int argc,char **argv)

{
  coex_wifi_rf_forece_enable(1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_mib(char *buf,int len,int argc,char **argv)

{
  hal_mib_dump();
  utils_hexdump(*argv,0x1e);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_cfg(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint32_t task;
  int iVar2;
  uint32_t ops;
  uint32_t length;
  uint32_t *buf_00;
  uint32_t element;
  uint32_t type;
  uint32_t uStack88;
  uint32_t val [1];
  getopt_env_t getopt_env;
  
  type = 0;
  utils_getopt_init((getopt_env_t *)val,0);
  element = 0;
  task = 0;
  uVar1 = 4;
  while (iVar2 = utils_getopt((getopt_env_t *)val,argc,argv,":c:T:e:t:v:"), iVar2 != -1) {
    if (iVar2 == 99) {
      iVar2 = strcmp("dump",(char *)val);
      if (iVar2 == 0) {
        uVar1 = 3;
      }
      else {
        iVar2 = strcmp("set",(char *)val);
        if (iVar2 == 0) {
          uVar1 = 0;
        }
        else {
          iVar2 = strcmp("get",(char *)val);
          if (iVar2 == 0) {
            uVar1 = 1;
          }
          else {
            iVar2 = strcmp("reset",(char *)val);
            if (iVar2 == 0) {
              uVar1 = 2;
            }
          }
        }
      }
    }
    else {
      if (iVar2 < 100) {
        if (iVar2 == 0x3f) {
          printf("%s: unknown option %c\r\n",*argv,getopt_env.opterr);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        if (iVar2 == 0x54) {
          type = atoi((char *)val);
        }
      }
      else {
        if (iVar2 == 0x74) {
          task = atoi((char *)val);
        }
        else {
          if (iVar2 == 0x76) {
            uStack88 = atoi((char *)val);
          }
          else {
            if (iVar2 == 0x65) {
              element = atoi((char *)val);
            }
          }
        }
      }
    }
  }
  printf("Target CFG Element Info, task: %lu, element %lu, type %lu, val %lu\r\n",task,element,type,
         uStack88);
  if (uVar1 == 2) {
    printf("    OPS: %s\r\n","reset");
    buf_00 = (uint32_t *)0x0;
    length = 0;
    type = 0;
    ops = 2;
  }
  else {
    if (uVar1 < 3) {
      if (uVar1 == 1) {
        printf("    OPS: %s\r\n","get");
        buf_00 = &uStack88;
        length = 4;
        ops = 1;
        goto LAB_230278a4;
      }
    }
    else {
      if (uVar1 == 3) {
        printf("    OPS: %s\r\n","dump");
        buf_00 = (uint32_t *)0x0;
        length = 0;
        type = 0;
        element = 0;
        task = 0;
        ops = 3;
        goto LAB_230278a4;
      }
      if (uVar1 == 4) {
        printf("UNKNOWN OPS\r\n");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    printf("    OPS: %s\r\n","set");
    buf_00 = &uStack88;
    length = 4;
    ops = 0;
  }
LAB_230278a4:
  wifi_mgmr_cfg_req(ops,task,element,type,length,buf_00);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_ap_stop(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_ap_stop((wifi_interface_t *)0x0);
  printf("--->>> cmd_wifi_ap_stop\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: ssid_name

void cmd_wifi_ap_start(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *interface;
  uint hidden_ssid;
  char *passwd;
  int channel;
  uint8_t auStack56 [3];
  byte bStack53;
  uint8_t mac [6];
  char ssid_name [32];
  
  memset(auStack56,0,6);
  bl_wifi_mac_addr_get(auStack56);
  memset(mac + 4,0,0x20);
  snprintf((char *)(mac + 4),0x20,"BL60X_uAP_%02X%02X%02X",(uint)bStack53,(uint)mac[0],(uint)mac[1])
  ;
  interface = (wifi_interface_t *)wifi_mgmr_ap_enable();
  if (argc == 1) {
    channel = 1;
    passwd = (char *)0x0;
    hidden_ssid = 0;
  }
  else {
    channel = atoi(argv[1]);
    if (10 < channel - 1U) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    passwd = "12345678";
    hidden_ssid = (uint)(argc == 3);
  }
  wifi_mgmr_ap_start(interface,(char *)(mac + 4),hidden_ssid,passwd,channel);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_sniffer_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_disable();
  wifi_mgmr_sniffer_unregister((void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_sniffer_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sniffer_enable();
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_denoise_disable_cmd(void)

{
  undefined auStack32 [2];
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(auStack32,0,0xd);
  auStack32[0] = WIFI_MGMR_EVENT_APP_DENOISE;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  auStack32[1] = 0;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack32);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_denoise_enable_cmd(void)

{
  undefined auStack32 [2];
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(auStack32,0,0xd);
  auStack32[0] = WIFI_MGMR_EVENT_APP_DENOISE;
  auStack32[1] = 1;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack32);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void wifi_power_saving_off_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_power_saving_on_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_powersaving(2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_rc_fixed_disable(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_rate_config(0xffff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_disable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_enable_autoreconnect_cmd(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void wifi_disconnect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_sta_disconnect();
  vTaskDelay(1000);
  wifi_mgmr_sta_disable((wifi_interface_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_sta_ip_unset_cmd(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void wifi_sta_ip_info(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  ip4_addr_t iStack80;
  ip4_addr_t ip;
  ip4_addr_t gw;
  ip4_addr_t mask;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  int rssi;
  int8_t power_rate_table [38];
  
  wifi_mgmr_sta_ip_get((uint32_t *)&iStack80,(uint32_t *)&ip,(uint32_t *)&gw);
  wifi_mgmr_sta_dns_get((uint32_t *)&mask,(uint32_t *)&dns1);
  wifi_mgmr_rssi_get((int *)&dns2);
  bl_tpc_power_table_get((int8_t *)&rssi);
  printf("RSSI:   %ddbm\r\n",dns2);
  pcVar1 = ip4addr_ntoa(&iStack80);
  printf("IP  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&gw);
  printf("MASK:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&ip);
  printf("GW  :   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&mask);
  printf("DNS1:   %s \r\n",pcVar1);
  pcVar1 = ip4addr_ntoa(&dns1);
  printf("DNS2:   %s \r\n",pcVar1);
  puts("Power Table (dbm):\r\n");
  puts("--------------------------------\r\n");
  printf("  11b: %u %u %u %u             (1Mbps 2Mbps 5.5Mbps 11Mbps)\r\n",(int)(char)rssi,
         (int)rssi._1_1_,(int)rssi._2_1_,(int)rssi._3_1_);
  printf(
         "  11g: %u %u %u %u %u %u %u %u (6Mbps 9Mbps 12Mbps 18Mbps 24Mbps 36Mbps 48Mbps 54Mbps)\r\n"
         ,(int)power_rate_table[4],(int)power_rate_table[5],(int)power_rate_table[6],
         (int)power_rate_table[7],(int)power_rate_table[8],(int)power_rate_table[9],
         (int)power_rate_table[10]);
  printf("  11n: %u %u %u %u %u %u %u %u (MCS0 ~ MCS7)\r\n",(int)power_rate_table[12],
         (int)power_rate_table[13],(int)power_rate_table[14],(int)power_rate_table[15],
         (int)power_rate_table[16],(int)power_rate_table[17],(int)power_rate_table[18]);
  puts("--------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_raw_send(char *buf,int len,int argc,char **argv)

{
  char *s;
  int iVar1;
  
  iVar1 = cmd_wifi_raw_send::seq << 4;
  packet_raw[22] = (uint8_t)iVar1;
  cmd_wifi_raw_send::seq = cmd_wifi_raw_send::seq + 1;
  packet_raw[23] = (uint8_t)((uint)iVar1 >> 8);
  iVar1 = wifi_mgmr_raw_80211_send(packet_raw,0x18);
  if (iVar1 == 0) {
    s = "Raw send succeed\r\n";
  }
  else {
    s = "Raw send failed\r\n";
  }
  puts(s);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_scan_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_mgmr_scan((void *)0x0,(scan_complete_cb_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sniffer_cb(void *env,uint8_t *pkt,int len)

{
  TickType_t TVar1;
  
  sniffer_counter_5067 = sniffer_counter_5067 + 1;
  TVar1 = xTaskGetTickCount();
  if (10000 < (int)(TVar1 - last_tick_5069)) {
    last_tick_5069 = xTaskGetTickCount();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_dump(char *buf,int len,int argc,char **argv)

{
  if (argc < 2) {
    puts("[CLI] Dump statistic use normal mode\r\n");
    vTaskEnterCritical();
  }
  else {
    puts("[CLI] Dump statistic use forced mode\r\n");
    vTaskEnterCritical();
  }
  bl60x_fw_dump_statistic((uint)(argc >= 2));
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_wifi_ap_conf_max_sta(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  
  if (argc != 2) {
    printf("Usage: wifi_ap_max_sta [num]\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar1 = atoi(argv[1]);
  printf("Conf Max Sta to %d\r\n",iVar1);
  wifi_mgmr_conf_max_sta((uint8_t)iVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_mon_cmd(char *buf,int len,int argc,char **argv)

{
  if (1 < argc) {
    wifi_mgmr_sniffer_enable();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  wifi_mgmr_sniffer_register((void *)0x0,sniffer_cb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_rc_fixed_enable(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  char *pcVar4;
  uint uVar5;
  
  if (argc != 4) {
    printf("rc_fix_en [b/g/n] [MCS] [GI]");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar1 = atoi(argv[1]);
  uVar5 = uVar1 & 0xff;
  uVar2 = atoi(argv[2]);
  uVar3 = atoi(argv[3]);
  if (uVar5 == 1) {
    pcVar4 = "n mode";
  }
  else {
    pcVar4 = "b/g mdoe";
  }
  printf("wifi set mode:%s, mcs:%d, gi:%d\r\n",pcVar4,uVar2 & 0xff,uVar3 & 0xff);
  if (uVar5 == 1) {
    uVar1 = ((uVar1 & 0xff) << 0xc | (uVar3 & 0xff) << 9) & 0xffff | uVar2 & 0xff;
  }
  else {
    uVar1 = 0;
    if (uVar5 == 0) {
      uVar1 = uVar2 & 0xff | 0x600;
    }
  }
  printf("wifi rc:0x%x\r\n",uVar1);
  wifi_mgmr_rate_config((uint16_t)uVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_connect_cmd(char *buf,int len,int argc,char **argv)

{
  wifi_interface_t *wifi_interface;
  
  if (argc != 3) {
    printf("[USAGE]: %s [ssid] [password]\r\n",*argv);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  wifi_interface = (wifi_interface_t *)wifi_mgmr_sta_enable();
  wifi_mgmr_sta_connect(wifi_interface,argv[1],argv[2],(char *)0x0,(uint8_t *)0x0,'\0',0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_sta_ip_set_cmd(char *buf,int len,int argc,char **argv)

{
  ip4_addr_t ip;
  ip4_addr_t mask;
  ip4_addr_t gw;
  ip4_addr_t dns1;
  ip4_addr_t dns2;
  ip4_addr_t iStack56;
  ip4_addr_t addr;
  char addr_str [20];
  
  if (argc == 6) {
    ip = (ip4_addr_t)ipaddr_addr(argv[1]);
    mask = (ip4_addr_t)ipaddr_addr(argv[2]);
    gw = (ip4_addr_t)ipaddr_addr(argv[3]);
    dns1 = (ip4_addr_t)ipaddr_addr(argv[4]);
    dns2 = (ip4_addr_t)ipaddr_addr(argv[5]);
    iStack56 = (u32_t)ip;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("IP  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = (u32_t)mask;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("MASK: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = (u32_t)gw;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("GW  : ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = (u32_t)dns1;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS1: ");
    puts((char *)&addr);
    puts("\r\n");
    iStack56 = (u32_t)dns2;
    ip4addr_ntoa_r(&iStack56,(char *)&addr,0x14);
    puts("DNS2: ");
    puts((char *)&addr);
    puts("\r\n");
    wifi_mgmr_sta_ip_set((uint32_t)ip,(uint32_t)mask,(uint32_t)gw,(uint32_t)dns1,(uint32_t)dns2);
  }
  else {
    puts("Illegal CMD format\r\n");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_scan_filter_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc == 2) {
    wifi_mgmr_scan_filter_hidden_ssid((uint)(*argv[1] == '1'));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_capcode_cmd(char *buf,int len,int argc,char **argv)

{
  uint8_t uVar1;
  char *fmt;
  undefined3 extraout_var;
  int iVar2;
  char *pcVar3;
  
  if (argc - 1U < 2) {
    if (argc != 1) {
      iVar2 = atoi(argv[1]);
      printf("Setting capcode to %d\r\n",iVar2);
      if (0 < iVar2) {
        hal_sys_capcode_update((uint8_t)iVar2,(uint8_t)iVar2);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    uVar1 = hal_sys_capcode_get();
    pcVar3 = (char *)CONCAT31(extraout_var,uVar1);
    fmt = "Capcode %u is being used\r\n";
  }
  else {
    pcVar3 = *argv;
    fmt = "Usage: %s capcode\r\n";
  }
  printf(fmt,pcVar3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_mgmr_cli_scanlist(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  wifi_mgmr_t *pwVar7;
  int iVar8;
  TickType_t TVar9;
  
  printf("cached scan list\r\n");
  pwVar7 = &wifiMgmr;
  printf(
        "****************************************************************************************************\r\n"
        );
  iVar8 = 0;
  do {
    if (pwVar7->scan_items[0].is_used == '\0') {
LAB_2302810e:
      printf("index[%02d]: empty\r\n",iVar8);
    }
    else {
      TVar9 = xTaskGetTickCount();
      if ((uint)wifiMgmr.scan_item_timeout <= TVar9 - pwVar7->scan_items[0].timestamp_lastseen)
      goto LAB_2302810e;
      bVar1 = pwVar7->scan_items[0].channel;
      bVar2 = pwVar7->scan_items[0].bssid[0];
      bVar3 = pwVar7->scan_items[0].bssid[1];
      bVar4 = pwVar7->scan_items[0].bssid[2];
      bVar5 = pwVar7->scan_items[0].bssid[3];
      bVar6 = pwVar7->scan_items[0].bssid[4];
      wifi_mgmr_auth_to_str(pwVar7->scan_items[0].auth);
      wifi_mgmr_cipher_to_str(pwVar7->scan_items[0].cipher);
      printf(
             "index[%02d]: channel %02u, bssid %02X:%02X:%02X:%02X:%02X:%02X, rssi %3d, ppm abs:rel %3d : %3d, auth %20s, cipher:%12s, SSID %s\r\n"
             ,iVar8,(uint)bVar1,(uint)bVar2,(uint)bVar3,(uint)bVar4,(uint)bVar5,(uint)bVar6);
    }
    iVar8 = iVar8 + 1;
    pwVar7 = (wifi_mgmr_t *)&(pwVar7->wlan_sta).netif.input;
    if (iVar8 == 0x32) {
      printf(
            "----------------------------------------------------------------------------------------------------\r\n"
            );
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  } while( true );
}



int wifi_mgmr_ext_dump_needed(void)

{
  bool bVar1;
  
  bVar1 = 0 < pkt_counter;
  if (bVar1) {
    pkt_counter = pkt_counter + -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



int wifi_mgmr_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mac_is_unvalid(uint8_t *mac)

{
  int iVar1;
  
  iVar1 = 1;
  do {
    if (mac[iVar1] != *mac) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (byte)(*mac - 1) < 0xfe ^ 1;
}



int wifi_mgmr_psk_cal(char *password,char *ssid,int ssid_len,char *output)

{
  int iVar1;
  uchar auStack48 [4];
  char psk [32];
  
  iVar1 = bl60x_fw_password_hash(password,(uchar *)ssid,ssid_len,auStack48);
  if (iVar1 == 0) {
    utils_bin2hex(output,auStack48,0x20);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int wifi_mgmr_drv_init(wifi_conf_t *conf)

{
  bl606a0_wifi_init(conf);
  wifi_mgmr_api_set_country_code((char *)conf);
  wifi_mgmr_init();
  wifi_mgmr_api_ifaceup();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_sta_enable(void)

{
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  if (wifi_mgmr_sta_enable::done == 1) {
    printf("----- BUG FIXME? NOT do STA enable again\r\n");
  }
  else {
    wifi_mgmr_sta_enable::done = 1;
    printf("---------STA enable\r\n");
    wifiMgmr.wlan_sta.mode = 0;
    iStack28 = 0;
    ipaddr = 0;
    netmask = 0;
    memcpy(wifiMgmr.wlan_sta.netif.hwaddr,wifiMgmr.wlan_sta.mac,6);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
    if (iVar1 != 0) {
      bl_wifi_mac_addr_get(wifiMgmr.wlan_sta.netif.hwaddr);
      iVar1 = mac_is_unvalid(wifiMgmr.wlan_sta.netif.hwaddr);
      if (iVar1 != 0) {
        wifiMgmr.wlan_sta.netif.hwaddr._0_2_ = 0x50c0;
        wifiMgmr.wlan_sta.netif.hwaddr._2_4_ = 0x100c943;
      }
      memcpy(wifiMgmr.wlan_sta.mac,wifiMgmr.wlan_sta.netif.hwaddr,6);
    }
    netifapi_netif_add(&wifiMgmr.wlan_sta.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                       bl606a0_wifi_netif_init,tcpip_input);
    wifiMgmr.wlan_sta.netif.name = 0x7473;
    wifiMgmr.wlan_sta.netif.flags = wifiMgmr.wlan_sta.netif.flags | 0x24;
    netif_set_default(&wifiMgmr.wlan_sta.netif);
    netif_set_up(&wifiMgmr.wlan_sta.netif);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return &wifiMgmr.wlan_sta;
}



int wifi_mgmr_sta_disable(wifi_interface_t *interface)

{
  wifi_mgmr_api_idle();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sta_ip_get(uint32_t *ip,uint32_t *gw,uint32_t *mask)

{
  *ip = wifiMgmr.wlan_sta.netif.ip_addr;
  *mask = wifiMgmr.wlan_sta.netif.netmask;
  *gw = wifiMgmr.wlan_sta.netif.gw;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sta_dns_get(uint32_t *dns1,uint32_t *dns2)

{
  ip_addr_t *piVar1;
  
  piVar1 = dns_getserver('\0');
  *dns1 = piVar1->addr;
  piVar1 = dns_getserver('\x01');
  *dns2 = piVar1->addr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sta_ip_set(uint32_t ip,uint32_t mask,uint32_t gw,uint32_t dns1,uint32_t dns2)

{
  vTaskEnterCritical();
  wifiMgmr.wlan_sta.ipv4.ip = ip;
  wifiMgmr.wlan_sta.ipv4.mask = mask;
  wifiMgmr.wlan_sta.ipv4.gw = gw;
  wifiMgmr.wlan_sta.ipv4.dns1 = dns1;
  wifiMgmr.wlan_sta.ipv4.dns2 = dns2;
  vTaskExitCritical();
  wifi_mgmr_api_ip_update();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sta_ip_unset(void)

{
  int iVar1;
  
  iVar1 = wifi_mgmr_sta_ip_set(0,0,0,0,0);
  return iVar1;
}



int wifi_mgmr_sta_disconnect(void)

{
  wifi_mgmr_api_disconnect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sta_powersaving(int ps)

{
  if ((ps == 1) || (ps == 2)) {
    wifi_mgmr_api_fw_powersaving(ps);
    ps = 0;
  }
  else {
    if (ps == 0) {
      wifi_mgmr_api_fw_powersaving(0);
    }
    else {
      ps = -1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ps;
}



int wifi_mgmr_sta_autoconnect_enable(void)

{
  wifi_mgmr_api_enable_autoreconnect();
  return 0;
}



int wifi_mgmr_sta_autoconnect_disable(void)

{
  wifi_mgmr_api_disable_autoreconnect();
  return 0;
}



void wifi_mgmr_sta_ssid_set(char *ssid)

{
  size_t sVar1;
  
  sVar1 = strlen(ssid);
  if (sVar1 != 0) {
    sVar1 = strlen(ssid);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.ssid,ssid,sVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void wifi_mgmr_sta_psk_set(char *psk)

{
  size_t sVar1;
  
  sVar1 = strlen(psk);
  if (sVar1 != 0) {
    sVar1 = strlen(psk);
    memcpy(wifiMgmr.wifi_mgmr_stat_info.psk,psk,sVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_mgmr_sta_connect
              (wifi_interface_t *wifi_interface,char *ssid,char *psk,char *pmk,uint8_t *mac,
              uint8_t band,uint16_t freq)

{
  int iVar1;
  
  wifi_mgmr_sta_ssid_set(ssid);
  wifi_mgmr_sta_psk_set(psk);
  iVar1 = wifi_mgmr_api_connect(ssid,psk,pmk,mac,band,freq);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: gw

wifi_interface_t wifi_mgmr_ap_enable(void)

{
  int iVar1;
  ip4_addr_t iStack28;
  ip4_addr_t ipaddr;
  ip4_addr_t netmask;
  ip4_addr_t gw;
  
  wifiMgmr.wlan_ap.mode = 1;
  iStack28 = 0x10ba8c0;
  ipaddr = 0xffffff;
  netmask = 0;
  memcpy(wifiMgmr.wlan_ap.netif.hwaddr,wifiMgmr.wlan_ap.mac,6);
  iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
  if (iVar1 != 0) {
    bl_wifi_mac_addr_get(wifiMgmr.wlan_ap.netif.hwaddr);
    iVar1 = mac_is_unvalid(wifiMgmr.wlan_ap.netif.hwaddr);
    if (iVar1 != 0) {
      wifiMgmr.wlan_ap.netif.hwaddr._0_2_ = 0x50c0;
      wifiMgmr.wlan_ap.netif.hwaddr._2_4_ = 0x100c943;
    }
    memcpy(wifiMgmr.wlan_ap.mac,wifiMgmr.wlan_ap.netif.hwaddr,6);
  }
  netifapi_netif_add(&wifiMgmr.wlan_ap.netif,&iStack28,&ipaddr,&netmask,(void *)0x0,
                     bl606a0_wifi_netif_init,tcpip_input);
  wifiMgmr.wlan_ap.netif.name = 0x7061;
  netif_set_default(&wifiMgmr.wlan_ap.netif);
  netif_set_up(&wifiMgmr.wlan_ap.netif);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return &wifiMgmr.wlan_ap;
}



int wifi_mgmr_ap_start(wifi_interface_t *interface,char *ssid,int hidden_ssid,char *passwd,
                      int channel)

{
  wifi_mgmr_api_ap_start(ssid,passwd,channel,(uint8_t)hidden_ssid);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_ap_stop(wifi_interface_t *interface)

{
  wifi_mgmr_api_ap_stop();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_ap_sta_cnt_get(uint8_t *sta_cnt)

{
  wifi_mgmr_ap_sta_cnt_get_internal(sta_cnt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling

int wifi_mgmr_ap_sta_info_get(wifi_sta_basic_info *sta_info,uint8_t idx)

{
  undefined auStack40 [4];
  wifi_mgmr_sta_basic_info sta_info_internal;
  
  memset(auStack40,0,0x18);
  wifi_mgmr_ap_sta_info_get_internal((wifi_mgmr_sta_basic_info_t *)auStack40,idx);
  *(undefined2 *)sta_info = auStack40._0_2_;
  sta_info->rssi = sta_info_internal.tsflo;
  sta_info->tsflo = sta_info_internal.tsfhi;
  sta_info->tsfhi = sta_info_internal.sta_mac._2_4_;
  sta_info->data_rate = (uint8_t)sta_info_internal.rssi;
  memcpy(sta_info->sta_mac,(void *)((int)auStack40 + 2),6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_ap_sta_delete(uint8_t sta_idx)

{
  wifi_mgmr_ap_sta_delete_internal(sta_idx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sniffer_register(void *env,sniffer_cb_t *cb)

{
  bl_rx_pkt_cb_register(env,(wifi_event_pkt_cb_t *)cb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sniffer_unregister(void *env)

{
  bl_rx_pkt_cb_unregister(env);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sniffer_enable(void)

{
  wifi_mgmr_api_sniffer_enable();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_sniffer_disable(void)

{
  wifi_mgmr_api_idle();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_rate_config(uint16_t config)

{
  undefined auStack32 [2];
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(auStack32,0,0xd);
  auStack32[0] = WIFI_MGMR_EVENT_APP_RC_CONFIG;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  auStack32[1] = (undefined)config;
  uStack24 = 0x55;
  uStack30 = (undefined)(config >> 8);
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack32);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_conf_max_sta(uint8_t max_sta_supported)

{
  undefined auStack32 [2];
  undefined uStack30;
  undefined uStack29;
  undefined uStack28;
  undefined uStack27;
  undefined uStack26;
  undefined uStack25;
  undefined uStack24;
  undefined uStack23;
  undefined uStack22;
  undefined uStack21;
  undefined uStack20;
  
  memset(auStack32,0,0xd);
  auStack32[0] = WIFI_MGMR_EVENT_APP_CONF_MAX_STA;
  uStack27 = 0x88;
  uStack26 = 0x77;
  uStack25 = 0x66;
  uStack24 = 0x55;
  uStack30 = 0;
  uStack29 = 0;
  uStack28 = 0;
  uStack23 = 0xd;
  uStack22 = 0;
  uStack21 = 0;
  uStack20 = 0;
  auStack32[1] = max_sta_supported;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack32);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_state_get(int *state)

{
  uint16_t uVar1;
  int iVar2;
  
  uVar1 = wifiMgmr.wifi_mgmr_stat_info.status_code;
  if (wifiMgmr.m.currentState == &stateIdle) {
    if (wifiMgmr.inf_ap_enabled != 0) {
      iVar2 = 0x11;
      goto LAB_230262ac;
    }
    iVar2 = 1;
  }
  else {
    if (wifiMgmr.m.currentState == &stateConnecting) {
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x12;
        goto LAB_230262ac;
      }
      iVar2 = 2;
    }
    else {
      if (wifiMgmr.m.currentState == &stateConnectedIPNo) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 3;
        }
        else {
          iVar2 = 0x13;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState == &stateConnectedIPYes) {
        if (wifiMgmr.inf_ap_enabled == 0) {
          iVar2 = 4;
        }
        else {
          iVar2 = 0x14;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.m.currentState != &stateDisconnect) {
        if (wifiMgmr.m.currentState == &stateIfaceDown) {
          iVar2 = 6;
        }
        else {
          if (wifiMgmr.m.currentState != &stateSniffer) {
            *state = 0;
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          iVar2 = 7;
        }
        goto LAB_230262ac;
      }
      if (wifiMgmr.inf_ap_enabled != 0) {
        iVar2 = 0x15;
        goto LAB_230262ac;
      }
      iVar2 = 5;
    }
  }
  *state = iVar2;
  if (uVar1 == 8) {
    iVar2 = 8;
  }
  else {
    if (uVar1 != 0xc) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar2 = 9;
  }
LAB_230262ac:
  *state = iVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_rssi_get(int *rssi)

{
  *rssi = (int)wifiMgmr.wlan_sta.field_5;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_raw_80211_send(uint8_t *pkt,int len)

{
  if (len < 0x1e1) {
    wifi_mgmr_api_raw_send(pkt,len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int wifi_mgmr_scan(void *data,scan_complete_cb_t *cb)

{
  scan_cb = cb;
  scan_data = data;
  wifi_mgmr_api_fw_scan();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_cfg_req(uint32_t ops,uint32_t task,uint32_t element,uint32_t type,uint32_t length,
                     uint32_t *buf)

{
  int iVar1;
  undefined auStack100 [2];
  undefined uStack98;
  undefined uStack97;
  undefined uStack96;
  undefined uStack95;
  undefined uStack94;
  undefined uStack93;
  undefined uStack92;
  undefined uStack91;
  undefined uStack90;
  undefined uStack89;
  undefined uStack88;
  undefined uStack87;
  undefined uStack86;
  undefined uStack85;
  undefined uStack84;
  undefined uStack83;
  undefined uStack82;
  undefined uStack81;
  undefined uStack80;
  undefined uStack79;
  undefined uStack78;
  undefined uStack77;
  undefined uStack76;
  undefined uStack75;
  undefined uStack74;
  undefined uStack73;
  undefined uStack72;
  undefined uStack71;
  undefined uStack70;
  undefined uStack69;
  undefined uStack68;
  undefined auStack67 [39];
  
  if (length < 0x21) {
    memset(auStack100,0,0x41);
    auStack100[0] = WIFI_MGMR_EVENT_FW_CFG_REQ;
    auStack100[1] = 0x44;
    uStack98 = 0x33;
    uStack97 = 0x22;
    uStack96 = 0x11;
    uStack95 = 0x88;
    uStack94 = 0x77;
    iVar1 = length + 0xc6;
    uStack93 = 0x66;
    uStack92 = 0x55;
    uStack90 = (undefined)((uint)iVar1 >> 8);
    uStack89 = (undefined)((uint)iVar1 >> 0x10);
    uStack86 = (undefined)(ops >> 8);
    uStack85 = (undefined)(ops >> 0x10);
    uStack82 = (undefined)(task >> 8);
    uStack81 = (undefined)(task >> 0x10);
    uStack78 = (undefined)(element >> 8);
    uStack77 = (undefined)(element >> 0x10);
    uStack74 = (undefined)(type >> 8);
    uStack73 = (undefined)(type >> 0x10);
    uStack91 = (undefined)iVar1;
    uStack87 = (undefined)ops;
    uStack83 = (undefined)task;
    uStack79 = (undefined)element;
    uStack75 = (undefined)type;
    uStack70 = (undefined)(length >> 8);
    uStack69 = (undefined)(length >> 0x10);
    uStack88 = (undefined)((uint)iVar1 >> 0x18);
    uStack84 = (undefined)(ops >> 0x18);
    uStack80 = (undefined)(task >> 0x18);
    uStack76 = (undefined)(element >> 0x18);
    uStack72 = (undefined)(type >> 0x18);
    uStack71 = (undefined)length;
    uStack68 = (undefined)(length >> 0x18);
    if (length != 0) {
      memcpy(auStack67,buf,length);
    }
    wifi_mgmr_event_notify((wifi_mgmr_msg_t *)auStack100);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int wifi_mgmr_scan_filter_hidden_ssid(int filter)

{
  vTaskEnterCritical();
  if (filter == 0) {
    wifiMgmr.features = wifiMgmr.features | 1;
  }
  else {
    wifiMgmr.features = wifiMgmr.features & 0xfffffffe;
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_scan_complete_callback(void)

{
  undefined4 uStack20;
  int status;
  
  uStack20 = 0;
  printf("%s: scan complete\r\n","wifi_mgmr_scan_complete_callback");
  if (scan_cb != (scan_complete_cb_t *)0x0) {
    uStack20 = 1;
    (*scan_cb)(scan_data,&uStack20);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



char * wifi_mgmr_status_code_str(uint16_t status_code)

{
  undefined2 in_register_0000202a;
  
  if (CONCAT22(in_register_0000202a,status_code) < 0x11) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(char **)(CSWTCH_17 + CONCAT22(in_register_0000202a,status_code) * 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return "Unknown Status Code";
}



int wifi_mgmr_profile_add(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg,int index)

{
  wifi_mgmr_profile_t *__s;
  int iVar1;
  
  if (index == -1) {
    __s = mgmr->profiles;
    if (__s == (wifi_mgmr_profile_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
  }
  else {
    if (mgmr->profiles[0].isUsed == '\0') {
      iVar1 = 0;
    }
    else {
      if (mgmr->profiles[1].isUsed != '\0') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -1;
      }
      iVar1 = 1;
    }
    mgmr->profile_active_index = iVar1;
    __s = mgmr->profiles + iVar1;
    printf("[WF][PF] Using free profile, idx is @%d\r\n");
  }
  memset(__s,0,0xc4);
  *(undefined2 *)&__s->isActive = 0x100;
  __s->ssid_len = profile_msg->ssid_len;
  __s->psk_len = profile_msg->psk_len;
  __s->pmk_len = profile_msg->pmk_len;
  __s->priority = -1;
  memcpy(__s,profile_msg,0x21);
  memcpy(__s->psk,profile_msg->psk,0x41);
  memcpy(__s->pmk,profile_msg->pmk,0x41);
  memcpy(__s->mac,profile_msg->mac,6);
  __s->dhcp_use = profile_msg->dhcp_use;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_profile_get(wifi_mgmr_t *mgmr,wifi_mgmr_profile_msg_t *profile_msg)

{
  int iVar1;
  int iVar2;
  undefined4 uVar3;
  
  if (mgmr->profiles[0].isUsed == '\x01') {
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
    if (mgmr->profiles[1].isUsed != '\x01') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
  }
  printf("[WF][PF] Using profile, idx is @%d\r\n",iVar1);
  memset(profile_msg,0,0xb9);
  iVar2 = (int)&mgmr->wlan_sta + iVar1 * 0xc4 + -0xc;
  uVar3 = *(undefined4 *)(iVar2 + 0x114);
  *(char *)&profile_msg->ssid_len = (char)uVar3;
  *(char *)((int)&profile_msg->ssid_len + 1) = (char)((uint)uVar3 >> 8);
  *(char *)((int)&profile_msg->ssid_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(char *)((int)&profile_msg->ssid_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(iVar2 + 0x15c);
  *(char *)&profile_msg->psk_len = (char)uVar3;
  *(char *)((int)&profile_msg->psk_len + 1) = (char)((uint)uVar3 >> 8);
  *(char *)((int)&profile_msg->psk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(char *)((int)&profile_msg->psk_len + 3) = (char)((uint)uVar3 >> 0x18);
  uVar3 = *(undefined4 *)(iVar2 + 0x1a4);
  *(char *)&profile_msg->pmk_len = (char)uVar3;
  *(char *)((int)&profile_msg->pmk_len + 1) = (char)((uint)uVar3 >> 8);
  *(char *)((int)&profile_msg->pmk_len + 2) = (char)((uint)uVar3 >> 0x10);
  *(char *)((int)&profile_msg->pmk_len + 3) = (char)((uint)uVar3 >> 0x18);
  profile_msg->dhcp_use = *(uint8_t *)(iVar2 + 0x1ae);
  memcpy(profile_msg,mgmr->profiles + iVar1,0x21);
  memcpy(profile_msg->psk,mgmr->profiles[iVar1].psk,0x41);
  memcpy(profile_msg->pmk,mgmr->profiles[iVar1].pmk,0x41);
  memcpy(profile_msg->mac,mgmr->profiles[iVar1].mac,6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_profile_autoreconnect_is_enabled(wifi_mgmr_t *mgmr,int index)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(mgmr->disable_autoreconnect == '\0');
}



int wifi_mgmr_profile_autoreconnect_disable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_mgmr_profile_autoreconnect_enable(wifi_mgmr_t *mgmr,int index)

{
  mgmr->disable_autoreconnect = '\0';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int wifi_netif_dhcp_start(netif *netif)

{
  netifapi_netif_common(netif,(netifapi_void_fn)0x0,dhcp_start);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cb_rssi_ind(void *env,int8_t rssi)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifiMgmr.wlan_sta.field_5 = rssi;
  return;
}



void cb_probe_resp_ind(void *env)

{
  printf("timestamp = 0x%llx\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cb_beacon_ind(void *env,wifi_event_beacon_ind *ind)

{
  wifi_mgmr_api_scan_item_beacon
            (ind->channel,ind->rssi,ind->auth,(uint8_t *)ind,ind->ssid,ind->ssid_len,ind->ppm_abs,
             ind->ppm_rel,DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_disconnect_ind(void *env,wifi_event_sm_disconnect_ind *ind)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(local_20,0,0xd);
  printf("sending disconnect\r\n");
  local_20[0] = WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  wifiMgmr.wifi_mgmr_stat_info.type_ind = '\x02';
  wifiMgmr.wifi_mgmr_stat_info.status_code = ind->reason_code;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cb_connect_ind(void *env,wifi_event_sm_connect_ind *ind)

{
  undefined local_20 [2];
  undefined uStack30;
  undefined uStack29;
  wifi_mgmr_msg_t msg_wifi;
  
  memset(local_20,0,0xd);
  local_20[0] = (ind->status_code == 0) + WIFI_MGMR_EVENT_FW_IND_DISCONNECT;
  local_20[1] = 0x44;
  uStack30 = 0x33;
  uStack29 = 0x22;
  msg_wifi.ev = WIFI_MGMR_EVENT_FW_CHANNEL_SET;
  msg_wifi.data1._0_1_ = 0x88;
  msg_wifi.data1._1_1_ = 0x77;
  msg_wifi.data1._2_1_ = 0x66;
  msg_wifi.data1._3_1_ = 0x55;
  msg_wifi.data2._0_1_ = 0xd;
  msg_wifi.data2._1_1_ = 0;
  msg_wifi.data2._2_1_ = 0;
  msg_wifi.data2._3_1_ = 0;
  wifi_mgmr_set_connect_stat_info(ind,'\x01');
  wifi_mgmr_event_notify((wifi_mgmr_msg_t *)local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cb_event_ind(void *env,wifi_event *event)

{
  int iVar1;
  uint16_t code;
  uint32_t uVar2;
  
  uVar2 = event->id;
  if (uVar2 == 1) {
    puts("[WIFI] [IND] SCAN Done\r\n");
    wifi_mgmr_scan_complete_notify();
    code = 9;
LAB_23028b2c:
    aos_post_event(2,code,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (uVar2 == 0) {
    uVar2 = event[1].id;
    iVar1 = -400;
    wifiMgmr.channel = uVar2;
  }
  else {
    if (uVar2 == 2) {
      code = 10;
      goto LAB_23028b2c;
    }
    iVar1 = -0x154;
  }
  printf(" SKIP Notify for set Empty Address\r\n" + iVar1 + 0x20,uVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int wifi_mgmr_event_init(void)

{
  bl_rx_sm_connect_ind_cb_register((void *)0x0,cb_connect_ind);
  bl_rx_sm_disconnect_ind_cb_register((void *)0x0,cb_disconnect_ind);
  bl_rx_beacon_ind_cb_register((void *)0x0,cb_beacon_ind);
  bl_rx_probe_resp_ind_cb_register((void *)0x0,cb_probe_resp_ind);
  bl_rx_rssi_cb_register((void *)0x0,cb_rssi_ind);
  bl_rx_event_register((void *)0x0,cb_event_ind);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cmd_mgr_print(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar1 = (cmd_mgr->cmds).next;
  while (plVar1 != &cmd_mgr->cmds) {
    plVar1 = plVar1->next;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_complete(bl_cmd *cmd)

{
  ushort uVar1;
  int *in_a1;
  int iVar2;
  int *piVar3;
  
  (cmd->list).next = (list_head *)((int)&(cmd->list).next[-1].prev + 3);
  piVar3 = (int *)in_a1[1];
  iVar2 = *in_a1;
  *(int **)(iVar2 + 4) = piVar3;
  *piVar3 = iVar2;
  *in_a1 = 0x100100;
  in_a1[1] = 0x200200;
  uVar1 = *(ushort *)(in_a1 + 6);
  *(ushort *)(in_a1 + 6) = uVar1 | 0x20;
  if ((uVar1 & 1) != 0) {
    vPortFree(in_a1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((uVar1 & 0x18) == 0) {
    in_a1[0xf] = 0;
    xEventGroupSetBits((EventGroupHandle_t)(in_a1 + 7),1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int cmd_mgr_msgind(bl_cmd_mgr *cmd_mgr,ipc_e2a_msg *msg,msg_cb_fct *cb)

{
  bool bVar1;
  bl_cmd *pbVar2;
  int iVar3;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  pbVar2 = (bl_cmd *)(cmd_mgr->cmds).next;
  do {
    if (pbVar2 == (bl_cmd *)&cmd_mgr->cmds) {
      bVar1 = false;
LAB_23028c80:
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      if ((!bVar1) && (cb != (msg_cb_fct *)0x0)) {
        (*cb)((bl_hw *)&cmd_mgr[-1].drain,(bl_cmd *)0x0,msg);
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (((pbVar2->reqid == msg->id) && ((pbVar2->flags & 0x10) != 0)) &&
       ((cb == (msg_cb_fct *)0x0 ||
        (iVar3 = (*cb)((bl_hw *)&cmd_mgr[-1].drain,pbVar2,msg), iVar3 == 0)))) {
      pbVar2->flags = pbVar2->flags & 0xffef;
      if ((pbVar2->e2a_msg != (char *)0x0) && (msg->param_len != 0)) {
        memcpy(pbVar2->e2a_msg,msg->param,(uint)msg->param_len);
      }
      bVar1 = true;
      if ((pbVar2->flags & 0x18) == 0) {
        cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
      }
      goto LAB_23028c80;
    }
    pbVar2 = (bl_cmd *)(pbVar2->list).next;
  } while( true );
}



int cmd_mgr_llind(bl_cmd_mgr *cmd_mgr,bl_cmd *cmd)

{
  ushort uVar1;
  bl_cmd *msg_buf;
  bl_cmd *pbVar2;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  msg_buf = (bl_cmd *)(cmd_mgr->cmds).next;
  pbVar2 = (bl_cmd *)0x0;
  do {
    if (msg_buf == (bl_cmd *)&cmd_mgr->cmds) {
      msg_buf = (bl_cmd *)0x0;
      if (pbVar2 != (bl_cmd *)0x0) {
LAB_23028d50:
        uVar1 = cmd->flags;
        cmd->flags = uVar1 & 0xfff7;
        if ((uVar1 & 0x10) == 0) {
          cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
        }
        if (msg_buf != (bl_cmd *)0x0) {
LAB_23028d6c:
          msg_buf->flags = msg_buf->flags & 0xfffb;
          ipc_host_msg_push(*(ipc_host_env_tag **)(cmd_mgr + 1),msg_buf,
                            msg_buf->a2e_msg->param_len + 8);
          vPortFree(msg_buf->a2e_msg);
        }
      }
      xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if ((pbVar2 == (bl_cmd *)0x0) && ((list_head *)msg_buf->tkn == (list_head *)cmd->tkn)) {
      pbVar2 = msg_buf;
      if ((msg_buf != cmd) && (cmd_mgr_llind::lexical_block_0::__warned == false)) {
        printf("%s:%d\r\n","cmd_mgr_llind",0xcf);
        cmd_mgr_llind::lexical_block_0::__warned = true;
      }
    }
    else {
      if ((msg_buf->flags & 4) != 0) {
        if (pbVar2 == (bl_cmd *)0x0) goto LAB_23028d6c;
        goto LAB_23028d50;
      }
    }
    msg_buf = (bl_cmd *)(msg_buf->list).next;
  } while( true );
}



int cmd_mgr_queue(bl_cmd_mgr *cmd_mgr,bl_cmd *cmd)

{
  bool bVar1;
  ushort uVar2;
  int iVar3;
  EventBits_t EVar4;
  u32_conflict uVar5;
  list_head *plVar6;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  if (cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED) {
    cmd->result = 0x20;
    xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
    iVar3 = -0x20;
  }
  else {
    if (&cmd_mgr->cmds == (cmd_mgr->cmds).next) {
      bVar1 = false;
    }
    else {
      if (cmd_mgr->queue_sz == cmd_mgr->max_queue_sz) {
        cmd->result = 0xc;
        xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0xc;
      }
      bVar1 = false;
      if ((*(ushort *)&(cmd_mgr->cmds).prev[3].next & 0xc) != 0) {
        bVar1 = true;
        cmd->flags = cmd->flags | 4;
      }
    }
    if ((cmd->flags & 2) == 0) {
      uVar2 = 8;
    }
    else {
      uVar2 = 0x18;
    }
    cmd->flags = cmd->flags | uVar2;
    uVar5 = cmd_mgr->next_tkn;
    cmd_mgr->next_tkn = uVar5 + 1;
    cmd->tkn = uVar5;
    cmd->result = 4;
    if ((cmd->flags & 1) == 0) {
      xEventGroupCreateStatic((StaticEventGroup_t *)&cmd->complete);
    }
    plVar6 = (cmd_mgr->cmds).prev;
    (cmd_mgr->cmds).prev = (list_head *)cmd;
    (cmd->list).next = &cmd_mgr->cmds;
    (cmd->list).prev = plVar6;
    plVar6->next = (list_head *)cmd;
    uVar5 = cmd_mgr->queue_sz + 1;
    cmd_mgr->queue_sz = uVar5;
    xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
    if (!bVar1) {
      ipc_host_msg_push(*(ipc_host_env_tag **)(cmd_mgr + 1),cmd,cmd->a2e_msg->param_len + 8);
      vPortFree(cmd->a2e_msg);
    }
    if ((cmd->flags & 1) == 0) {
      EVar4 = xEventGroupWaitBits((EventGroupHandle_t)&cmd->complete,1,1,0,uVar5 * 1000000);
      if ((EVar4 & 1) == 0) {
        xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
        cmd_mgr->state = RWNX_CMD_MGR_STATE_CRASHED;
        if ((cmd->flags & 0x20) == 0) {
          cmd->result = 0x6e;
          cmd_complete((bl_cmd *)&cmd_mgr->queue_sz);
        }
        xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
      }
      vEventGroupDelete((EventGroupHandle_t)&cmd->complete);
    }
    else {
      cmd->result = 0;
    }
    iVar3 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



void cmd_mgr_drain(bl_cmd_mgr *cmd_mgr)

{
  list_head *plVar1;
  list_head *plVar2;
  list_head *plVar3;
  list_head *plVar4;
  
  xQueueSemaphoreTake((QueueHandle_t)cmd_mgr->lock,0xffffffff);
  plVar2 = (cmd_mgr->cmds).next;
  plVar3 = plVar2->next;
  while (plVar1 = plVar3, plVar2 != &cmd_mgr->cmds) {
    plVar4 = plVar2->prev;
    plVar3 = plVar2->next;
    plVar3->prev = plVar4;
    plVar4->next = plVar3;
    plVar2->next = (list_head *)0x100100;
    plVar2->prev = (list_head *)0x200200;
    cmd_mgr->queue_sz = cmd_mgr->queue_sz - 1;
    if ((*(ushort *)&plVar2[3].next & 1) == 0) {
      xEventGroupSetBits((EventGroupHandle_t)&plVar2[3].prev,1);
    }
    plVar3 = plVar1->next;
    plVar2 = plVar1;
  }
  xQueueGenericSend((QueueHandle_t)cmd_mgr->lock,(void *)0x0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_cmd_mgr_init(bl_cmd_mgr *cmd_mgr)

{
  QueueHandle_t pQVar1;
  
  (cmd_mgr->cmds).next = &cmd_mgr->cmds;
  (cmd_mgr->cmds).prev = &cmd_mgr->cmds;
  pQVar1 = xQueueCreateMutex('\x01');
  cmd_mgr->max_queue_sz = 8;
  cmd_mgr->queue = cmd_mgr_queue;
  cmd_mgr->print = cmd_mgr_print;
  cmd_mgr->drain = cmd_mgr_drain;
  cmd_mgr->llind = cmd_mgr_llind;
  cmd_mgr->lock = (os_mutex_t)pQVar1;
  cmd_mgr->msgind = cmd_mgr_msgind;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_irqs_init(bl_hw *bl_hw)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_irq_bottomhalf(bl_hw *bl_hw)

{
  uint uVar1;
  uint status;
  TickType_t TVar2;
  
  xTaskGetTickCount();
  uVar1 = 0;
  status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  do {
    while (status != 0) {
      uVar1 = uVar1 | status;
      ipc_host_irq(bl_hw->ipc_env,status);
      status = ipc_host_get_rawstatus(bl_hw->ipc_env);
    }
    TVar2 = xTaskGetTickCount();
    if ((uVar1 & 8) != 0) {
      (bl_hw->stats).last_rx = TVar2;
    }
    if ((uVar1 & 0x780) != 0) {
      (bl_hw->stats).last_tx = TVar2;
    }
    ipc_host_enable_irq(bl_hw->ipc_env,0x7ff);
    status = ipc_host_get_rawstatus(bl_hw->ipc_env);
  } while (status != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void goToErrorState(stateMachine *fsm,event *event)

{
  state *psVar1;
  
  fsm->previousState = fsm->currentState;
  psVar1 = fsm->errorState;
  fsm->currentState = psVar1;
  if ((psVar1 != (state *)0x0) &&
     (psVar1->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23029062. Too many branches
                    // WARNING: Treating indirect jump as call
    (*psVar1->entryAction)(psVar1->data);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void stateM_init(stateMachine *fsm,state *initialState,state *errorState)

{
  if (fsm != (stateMachine *)0x0) {
    fsm->currentState = initialState;
    fsm->previousState = (state *)0x0;
    fsm->errorState = errorState;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int stateM_handleEvent(stateMachine *fsm,event *event)

{
  state *psVar1;
  state *psVar2;
  int iVar3;
  int *piVar4;
  uint uVar5;
  
  if (fsm == (stateMachine *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -2;
  }
  iVar3 = -2;
  if (event != (event *)0x0) {
    psVar1 = fsm->currentState;
    if (psVar1 == (state *)0x0) {
LAB_23029090:
      goToErrorState(fsm,event);
      iVar3 = -1;
    }
    else {
      if (psVar1->numTransitions != 0) {
LAB_230290b6:
        uVar5 = 0;
        while( true ) {
          if (psVar1->numTransitions <= uVar5) goto code_r0x230290be;
          piVar4 = &psVar1->transitions->eventType + uVar5 * 5;
          if ((*piVar4 == event->type) &&
             (((code *)piVar4[2] == (code *)0x0 ||
              (iVar3 = (*(code *)piVar4[2])(piVar4[1],event), iVar3 != 0)))) break;
          uVar5 = uVar5 + 1;
        }
        psVar1 = (state *)piVar4[4];
        if ((state *)piVar4[4] == (state *)0x0) goto LAB_23029090;
        do {
          psVar2 = psVar1;
          psVar1 = psVar2->entryState;
        } while (psVar2->entryState != (state *)0x0);
        psVar1 = fsm->currentState;
        if ((psVar1 != psVar2) &&
           (psVar1->exitAction != (anon_subr_void_void_ptr_event_ptr_for_exitAction *)0x0)) {
          (*psVar1->exitAction)(psVar1->data,event);
        }
        if ((code *)piVar4[3] != (code *)0x0) {
          (*(code *)piVar4[3])(fsm->currentState->data,event,psVar2->data);
        }
        if ((fsm->currentState != psVar2) &&
           (psVar2->entryAction != (anon_subr_void_void_ptr_event_ptr_for_entryAction *)0x0)) {
          (*psVar2->entryAction)(psVar2->data,event);
        }
        psVar1 = fsm->currentState;
        fsm->currentState = psVar2;
        iVar3 = 1;
        fsm->previousState = psVar1;
        if (((psVar1 != psVar2) && (iVar3 = -1, fsm->errorState != psVar2)) &&
           (iVar3 = 0, psVar2->numTransitions == 0)) {
          iVar3 = 3;
        }
        goto LAB_2302909a;
      }
LAB_230290b2:
      iVar3 = 2;
    }
  }
LAB_2302909a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
code_r0x230290be:
  psVar1 = psVar1->parentState;
  if (psVar1 == (state *)0x0) goto LAB_230290b2;
  goto LAB_230290b6;
}



void netif_status_callback(netif *netif)

{
  uint32_t ip;
  char *pcVar1;
  ip_addr_t *piVar2;
  uint32_t mask;
  uint32_t gw;
  uint32_t dns1;
  
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->ip_addr);
  printf("[lwip] netif status callback\r\n  IP: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->netmask);
  printf("  MK: %s\r\n",pcVar1);
  pcVar1 = ip4addr_ntoa((ip4_addr_t *)&netif->gw);
  printf("  GW: %s\r\n",pcVar1);
  if (((ip4_addr_t *)&netif->ip_addr != (ip4_addr_t *)0x0) && ((netif->ip_addr).addr != 0)) {
    wifi_mgmr_api_ip_update();
    mask = (netif->netmask).addr;
    gw = (netif->gw).addr;
    ip = (netif->ip_addr).addr;
    piVar2 = dns_getserver('\0');
    dns1 = piVar2->addr;
    piVar2 = dns_getserver('\x01');
    wifi_mgmr_api_ip_got(ip,mask,gw,dns1,piVar2->addr);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  printf(" SKIP Notify for set Empty Address\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t wifi_tx(netif *netif,pbuf *p)

{
  err_t eVar1;
  TickType_t TVar2;
  pbuf *ppVar3;
  
  ppVar3 = p;
  if (p->tot_len < 0x5eb) {
    do {
      ppVar3 = ppVar3->next;
    } while (ppVar3 != (pbuf *)0x0);
    eVar1 = '\0';
    bl_output(bl606a0_sta,netif,p,(uint)(netif[-1].client_data[1] == (void *)0x0));
  }
  else {
    TVar2 = xTaskGetTickCount();
    eVar1 = -0xc;
    if (2000 < TVar2 - ticks_7281) {
      printf("[TX] %s, TX size too big: %u bytes\r\n",&__func___7282,(uint)p->tot_len);
      ticks_7281 = xTaskGetTickCount();
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t bl606a0_wifi_netif_init(netif *netif)

{
  netif->hostname = "bl606a0";
  netif->mtu = 0x5dc;
  *(undefined2 *)&netif->hwaddr_len = 0xa06;
  netif->output = etharp_output;
  netif->linkoutput = wifi_tx;
  netif_set_status_callback(netif,netif_status_callback);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



int bl606a0_wifi_init(wifi_conf_t *conf)

{
  int iVar1;
  byte bStack24;
  byte bStack23;
  byte bStack22;
  byte bStack21;
  uint8_t mac [6];
  
  printf("\r\n\r\n[BL] Initi Wi-Fi");
  memset(&bStack24,0,6);
  bl_wifi_mac_addr_get(&bStack24);
  printf(" with MAC #### %02X:%02X:%02X:%02X:%02X:%02X ####\r\n",(uint)bStack24,(uint)bStack23,
         (uint)bStack22,(uint)bStack21,(uint)mac[0],(uint)mac[1]);
  bl_msg_update_channel_cfg((char *)conf);
  printf("-----------------------------------------------------\r\n");
  bl_wifi_clock_enable();
  memset(&bl606a0_sta,0,4);
  iVar1 = bl_main_rtthread_start((bl_hw **)&bl606a0_sta);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int nextprop_(void *fdt,int offset)

{
  uint32_t uVar1;
  int iStack36;
  int nextoffset;
  
  while( true ) {
    uVar1 = fdt_next_tag(fdt,offset,&iStack36);
    if (uVar1 == 3) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return offset;
    }
    if (uVar1 == 9) break;
    offset = iStack36;
    if (uVar1 != 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
  }
  if (iStack36 < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iStack36;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xb;
}



fdt_property * fdt_get_property_by_offset_(void *fdt,int offset,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  
  uVar2 = fdt_check_prop_offset_(fdt,offset);
  if ((int)uVar2 < 0) {
    pfVar1 = (fdt_property *)0x0;
    if (lenp == (int *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (fdt_property *)0x0;
    }
  }
  else {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 8));
    pfVar1 = (fdt_property *)((int)fdt + uVar2 + offset);
    if (lenp == (int *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return pfVar1;
    }
    uVar2 = fdt32_ld(&pfVar1->len);
  }
  *lenp = uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pfVar1;
}



char * fdt_get_string(void *fdt,int stroffset,int *lenp)

{
  char *__s;
  uint32_t uVar1;
  void *pvVar2;
  uint __n;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0xc));
  pvVar2 = (void *)fdt_ro_probe_(fdt);
  if (pvVar2 == (void *)0x0) {
    uVar3 = uVar1 + stroffset;
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
    if (uVar3 < uVar1) {
      __n = uVar1 - uVar3;
      uVar1 = fdt32_ld((fdt32_t *)fdt);
      if (uVar1 == 0xd00dfeed) {
        if (-1 < stroffset) {
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
          if (0x10 < uVar1) {
            uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20));
            if (uVar1 <= (uint)stroffset) goto LAB_230294a2;
            if (uVar1 - stroffset < __n) {
              __n = uVar1 - stroffset;
            }
          }
LAB_23029442:
          __s = (char *)((int)fdt + uVar3);
          pvVar2 = memchr(__s,0,__n);
          if (pvVar2 != (void *)0x0) {
            pvVar2 = (void *)((int)pvVar2 - (int)__s);
            goto joined_r0x23029498;
          }
          pvVar2 = (void *)0xfffffff8;
          goto fail;
        }
      }
      else {
        if (uVar1 != 0x2ff20112) {
          pvVar2 = (void *)0xfffffff3;
          goto fail;
        }
        if ((stroffset < 0) &&
           (uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x20)), -uVar1 <= (uint)stroffset)) {
          if ((uint)-stroffset < __n) {
            __n = -stroffset;
          }
          goto LAB_23029442;
        }
      }
    }
LAB_230294a2:
    pvVar2 = (void *)0xfffffffc;
  }
fail:
  __s = (char *)0x0;
joined_r0x23029498:
  if (lenp != (int *)0x0) {
    *lenp = (int)pvVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



char * fdt_get_name(void *fdt,int nodeoffset,int *len)

{
  char *pcVar1;
  uint32_t uVar2;
  size_t sVar3;
  uint32_t uVar4;
  
  uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  sVar3 = fdt_ro_probe_(fdt);
  if ((sVar3 == 0) && (sVar3 = fdt_check_node_offset_(fdt,nodeoffset), -1 < (int)sVar3)) {
    uVar4 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    pcVar1 = (char *)((int)fdt + nodeoffset + uVar2 + 4);
    if (uVar4 < 0x10) {
      pcVar1 = strrchr(pcVar1,0x2f);
      if (pcVar1 == (char *)0x0) {
        sVar3 = 0xfffffff5;
        goto fail;
      }
      pcVar1 = pcVar1 + 1;
    }
    if (len == (int *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return pcVar1;
    }
    sVar3 = strlen(pcVar1);
  }
  else {
fail:
    pcVar1 = (char *)0x0;
    if (len == (int *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (char *)0x0;
    }
  }
  *len = sVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar1;
}



int fdt_subnode_offset_namelen(void *fdt,int offset,char *name,int namelen)

{
  int iVar1;
  char *__s1;
  void *pvVar2;
  int iStack40;
  int depth;
  int olen;
  
  iVar1 = fdt_ro_probe_(fdt);
  if (iVar1 == 0) {
    iStack40 = 0;
    while (-1 < offset) {
      if (iStack40 < 0) goto LAB_23029550;
      if ((((iStack40 == 1) && (__s1 = fdt_get_name(fdt,offset,&depth), __s1 != (char *)0x0)) &&
          (namelen <= depth)) && (iVar1 = memcmp(__s1,name,namelen), iVar1 == 0)) {
        if (__s1[namelen] == '\0') {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return offset;
        }
        pvVar2 = memchr(name,0x40,namelen);
        if ((pvVar2 == (void *)0x0) && (__s1[namelen] == '@')) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return offset;
        }
      }
      offset = fdt_next_node(fdt,offset,&iStack40);
    }
    iVar1 = offset;
    if (iStack40 < 0) {
LAB_23029550:
      iVar1 = -1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int fdt_subnode_offset(void *fdt,int parentoffset,char *name)

{
  size_t namelen;
  int iVar1;
  
  namelen = strlen(name);
  iVar1 = fdt_subnode_offset_namelen(fdt,parentoffset,name,namelen);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int fdt_first_property_offset(void *fdt,int nodeoffset)

{
  int iVar1;
  
  iVar1 = fdt_check_node_offset_(fdt,nodeoffset);
  if (-1 < iVar1) {
    iVar1 = nextprop_(fdt,iVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int fdt_next_property_offset(void *fdt,int offset)

{
  int iVar1;
  
  iVar1 = fdt_check_prop_offset_(fdt,offset);
  if (-1 < iVar1) {
    iVar1 = nextprop_(fdt,iVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: slen

fdt_property *
fdt_get_property_namelen_(void *fdt,int offset,char *name,int namelen,int *lenp,int *poffset)

{
  int offset_00;
  fdt_property *pfVar1;
  uint32_t stroffset;
  char *__s1;
  int iVar2;
  int iStack36;
  int slen;
  
  offset_00 = fdt_first_property_offset(fdt,offset);
  do {
    if (offset_00 < 0) {
LAB_2302964e:
      if (lenp != (int *)0x0) {
        *lenp = offset_00;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (fdt_property *)0x0;
    }
    pfVar1 = fdt_get_property_by_offset_(fdt,offset_00,lenp);
    if (pfVar1 == (fdt_property *)0x0) {
      offset_00 = -0xd;
      goto LAB_2302964e;
    }
    stroffset = fdt32_ld(&pfVar1->nameoff);
    __s1 = fdt_get_string(fdt,stroffset,&iStack36);
    if (((__s1 != (char *)0x0) && (namelen == iStack36)) &&
       (iVar2 = memcmp(__s1,name,namelen), iVar2 == 0)) {
      if (poffset == (int *)0x0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return pfVar1;
      }
      *poffset = offset_00;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return pfVar1;
    }
    offset_00 = fdt_next_property_offset(fdt,offset_00);
  } while( true );
}



void * fdt_getprop_namelen(void *fdt,int nodeoffset,char *name,int namelen,int *lenp)

{
  fdt_property *pfVar1;
  uint32_t uVar2;
  int iStack20;
  int poffset;
  
  pfVar1 = fdt_get_property_namelen_(fdt,nodeoffset,name,namelen,lenp,&iStack20);
  if (pfVar1 != (fdt_property *)0x0) {
    uVar2 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    if (((uVar2 < 0x10) && ((iStack20 + 0xcU & 7) != 0)) &&
       (uVar2 = fdt32_ld(&pfVar1->len), 7 < uVar2)) {
      pfVar1 = (fdt_property *)&pfVar1[1].len;
    }
    else {
      pfVar1 = pfVar1 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pfVar1;
}



void * fdt_getprop(void *fdt,int nodeoffset,char *name,int *lenp)

{
  size_t namelen;
  void *pvVar1;
  
  namelen = strlen(name);
  pvVar1 = fdt_getprop_namelen(fdt,nodeoffset,name,namelen,lenp);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar1;
}



// WARNING: Variable defined which should be unmapped: length

int fdt_stringlist_count(void *fdt,int nodeoffset,char *property)

{
  int iVar1;
  char *__string;
  size_t sVar2;
  char *pcVar3;
  int iStack20;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack20);
  iVar1 = iStack20;
  if (__string != (char *)0x0) {
    pcVar3 = __string + iStack20;
    iVar1 = 0;
    while (__string < pcVar3) {
      sVar2 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack20 = sVar2 + 1;
      __string = __string + iStack20;
      if (pcVar3 < __string) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0xf;
      }
      iVar1 = iVar1 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



char * fdt_stringlist_get(void *fdt,int nodeoffset,char *property,int idx,int *lenp)

{
  char *__string;
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  int iStack36;
  int length;
  
  __string = (char *)fdt_getprop(fdt,nodeoffset,property,&iStack36);
  if (__string == (char *)0x0) {
    if (lenp != (int *)0x0) {
      *lenp = iStack36;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (char *)0x0;
    }
  }
  else {
    pcVar3 = __string + iStack36;
    while (__string < pcVar3) {
      sVar1 = strnlen(__string,(size_t)(pcVar3 + -(int)__string));
      iStack36 = sVar1 + 1;
      if (pcVar3 < __string + iStack36) {
        iVar2 = -0xf;
        if (lenp == (int *)0x0) goto LAB_23029796;
        goto LAB_230297ce;
      }
      if (idx == 0) {
        if (lenp == (int *)0x0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return __string;
        }
        *lenp = sVar1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return __string;
      }
      idx = idx + -1;
      __string = __string + iStack36;
    }
    if (lenp != (int *)0x0) {
      iVar2 = -1;
LAB_230297ce:
      *lenp = iVar2;
    }
  }
LAB_23029796:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (char *)0x0;
}



void blfdt(char *buf,int len,int argc,char **argv)

{
  tc_fdt_wifi();
  tc_blfdtdump();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int blfdt_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



int fdt_ro_probe_(void *fdt)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = fdt32_ld((fdt32_t *)fdt);
  if (uVar1 == 0xd00dfeed) {
    uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
    iVar2 = -10;
    if (1 < uVar1) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x18));
      iVar2 = 0;
      if (0x11 < uVar1) {
        iVar2 = -10;
      }
    }
  }
  else {
    iVar2 = -9;
    if (uVar1 == 0x2ff20112) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
      iVar2 = 0;
      if (uVar1 == 0) {
        iVar2 = -7;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void * fdt_offset_ptr(void *fdt,int offset,uint len)

{
  uint32_t uVar1;
  void *pvVar2;
  uint uVar3;
  
  uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 8));
  uVar3 = uVar1 + offset;
  pvVar2 = (void *)0x0;
  if ((uint)offset <= uVar3) {
    pvVar2 = (void *)0x0;
    if (uVar3 <= uVar3 + len) {
      uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 4));
      pvVar2 = (void *)0x0;
      if (uVar3 + len <= uVar1) {
        uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
        if (0x10 < uVar1) {
          if (len + offset < (uint)offset) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return (void *)0x0;
          }
          uVar1 = fdt32_ld((fdt32_t *)((int)fdt + 0x24));
          if (uVar1 < len + offset) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return (void *)0x0;
          }
        }
        pvVar2 = (void *)((int)fdt + uVar3);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar2;
}



uint32_t fdt_next_tag(void *fdt,int startoffset,int *nextoffset)

{
  int offset;
  int offset_00;
  uint uVar1;
  uint *puVar2;
  char *pcVar3;
  void *pvVar4;
  uint32_t uVar5;
  uint uVar6;
  
  *nextoffset = -8;
  puVar2 = (uint *)fdt_offset_ptr(fdt,startoffset,4);
  if (puVar2 == (uint *)0x0) goto switchD_23029956_caseD_5;
  uVar1 = *puVar2;
  offset = startoffset + 4;
  uVar1 = uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 >> 8 & 0xff) << 0x10 | (uVar1 >> 0x10 & 0xff) << 8;
  *nextoffset = -0xb;
  offset_00 = offset;
  switch(uVar1) {
  case 1:
    do {
      offset = offset_00 + 1;
      pcVar3 = (char *)fdt_offset_ptr(fdt,offset_00,1);
      if (pcVar3 == (char *)0x0) goto switchD_23029956_caseD_5;
      offset_00 = offset;
    } while (*pcVar3 != '\0');
  case 2:
  case 4:
  case 9:
switchD_23029956_caseD_2:
    pvVar4 = fdt_offset_ptr(fdt,startoffset,offset - startoffset);
    if (pvVar4 != (void *)0x0) {
      *nextoffset = offset + 3U & 0xfffffffc;
      goto LAB_23029986;
    }
    break;
  case 3:
    puVar2 = (uint *)fdt_offset_ptr(fdt,offset,4);
    if (puVar2 != (uint *)0x0) {
      uVar6 = *puVar2;
      uVar6 = uVar6 << 0x18 | uVar6 >> 0x18 | (uVar6 >> 8 & 0xff) << 0x10 |
              (uVar6 >> 0x10 & 0xff) << 8;
      uVar5 = fdt32_ld((fdt32_t *)((int)fdt + 0x14));
      offset = startoffset + 0xcU + uVar6;
      if (((uVar5 < 0x10) && (7 < uVar6)) && ((startoffset + 0xcU & 7) != 0)) {
        offset = offset + 4;
      }
      goto switchD_23029956_caseD_2;
    }
  }
switchD_23029956_caseD_5:
  uVar1 = 9;
LAB_23029986:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int fdt_check_node_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 1)) {
    aiStack20[0] = -4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return aiStack20[0];
}



int fdt_check_prop_offset_(void *fdt,int offset)

{
  uint32_t uVar1;
  int aiStack20 [4];
  
  if (((offset < 0) || ((offset & 3U) != 0)) ||
     (aiStack20[0] = offset, uVar1 = fdt_next_tag(fdt,offset,aiStack20), uVar1 != 3)) {
    aiStack20[0] = -4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return aiStack20[0];
}



int fdt_next_node(void *fdt,int offset,int *depth)

{
  uint32_t uVar1;
  int iVar2;
  int iStack36;
  int nextoffset;
  
  iStack36 = 0;
  if (offset < 0) goto LAB_23029a68;
  iStack36 = fdt_check_node_offset_(fdt,offset);
  iVar2 = iStack36;
  do {
    if (iVar2 < 0) {
LAB_23029a96:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iStack36;
    }
LAB_23029a68:
    do {
      while (iVar2 = iStack36, uVar1 = fdt_next_tag(fdt,iStack36,&iStack36), uVar1 != 2) {
        if (uVar1 == 9) {
          if ((-1 < iStack36) || ((iStack36 == -8 && (depth == (int *)0x0)))) {
            iStack36 = -1;
          }
          goto LAB_23029a96;
        }
        if (uVar1 == 1) {
          iStack36 = iVar2;
          if (depth != (int *)0x0) {
            *depth = *depth + 1;
          }
          goto LAB_23029a96;
        }
      }
    } while (depth == (int *)0x0);
    iVar2 = *depth + -1;
    *depth = iVar2;
  } while( true );
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



uint64_t fdt64_to_cpu(void)

{
  uint64_t in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



uint32_t fdt32_ld(fdt32_t *p)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)*(byte *)((int)p + 2) << 8 |
         (uint)*(byte *)p << 0x18 | (uint)*(byte *)((int)p + 1) << 0x10 |
         (uint)*(byte *)((int)p + 3);
}



_Bool util_is_printable_string(void *data,int len)

{
  byte *pbVar1;
  _Bool _Var2;
  byte *pbVar3;
  byte *pbVar4;
  
  if (len == 0) {
LAB_23029ba0:
    _Var2 = false;
  }
  else {
    pbVar1 = (byte *)(len + (int)data);
    _Var2 = false;
    if (pbVar1[-1] == 0) {
      while (pbVar3 = (byte *)data, data < pbVar1) {
        do {
          pbVar4 = pbVar3;
          if ((*pbVar3 == 0) || ((_ctype_[*pbVar3 + 1] & 0x97) == 0)) break;
          pbVar3 = pbVar3 + 1;
          pbVar4 = pbVar1;
        } while (pbVar1 != pbVar3);
        if ((*pbVar4 != 0) || ((byte *)data == pbVar4)) goto LAB_23029ba0;
        data = pbVar4 + 1;
      }
      _Var2 = true;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



void utilfdt_print_data(char *data,int len)

{
  char *pcVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  size_t sVar3;
  uint32_t uVar4;
  int iVar5;
  
  if (len == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  _Var2 = util_is_printable_string(data,len);
  if (CONCAT31(extraout_var,_Var2) != 0) {
    printf(" = ");
    pcVar1 = data + len;
    while( true ) {
      printf("\"%s\"",data);
      sVar3 = strlen(data);
      data = data + sVar3 + 1;
      if (pcVar1 <= data) break;
      printf(", ");
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((len & 3U) == 0) {
    printf(" = <");
    iVar5 = 0;
    while (iVar5 < len / 4) {
      uVar4 = fdt32_to_cpu(*(fdt32_t *)(data + iVar5 * 4));
      pcVar1 = " ";
      if (len / 4 + -1 <= iVar5) {
        pcVar1 = "";
      }
      printf("0x%08x%s",uVar4,pcVar1);
      iVar5 = iVar5 + 1;
    }
    pcVar1 = ">";
  }
  else {
    printf(" = [");
    iVar5 = 0;
    while (iVar5 < len) {
      pcVar1 = " ";
      if (len + -1 <= iVar5) {
        pcVar1 = "";
      }
      printf("%02x%s",(uint)(byte)data[iVar5],pcVar1);
      iVar5 = iVar5 + 1;
    }
    pcVar1 = "]";
  }
  printf(pcVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int tc_blfdtdump(void)

{
  uint8_t *p;
  uint *puVar1;
  fdt32_t *pfVar2;
  fdt32_t *pfVar3;
  TickType_t TVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  uint32_t uVar10;
  uint uVar11;
  uint uVar12;
  undefined *puVar13;
  size_t sVar14;
  char *fmt;
  uint uVar15;
  uint uVar16;
  int iVar17;
  int iVar18;
  undefined *puVar19;
  int iVar20;
  fdt32_t *pfVar21;
  uint64_t uVar22;
  fdt32_t *pfStack72;
  
  p = tc_wifi_dtb;
  while( true ) {
    if ((int)(&UNK_2308063b + -(int)p) < 4) break;
    p = (uint8_t *)memchr(p,0xd0,(size_t)(tc_wifi_dtb + -(int)p + 0x12ab));
    if ((fdt32_t *)p == (fdt32_t *)0x0) goto LAB_23029ed2;
    uVar5 = fdt32_ld((fdt32_t *)p);
    if (uVar5 == 0xd00dfeed) {
      puVar19 = &UNK_2308063b + -(int)p;
      if ((((((undefined *)0x27 < puVar19) &&
            (uVar5 = fdt32_ld((fdt32_t *)((int)p + 0x14)), uVar5 < 0x12)) &&
           (uVar5 = fdt32_ld((fdt32_t *)((int)p + 0x18)), uVar5 < 0x12)) &&
          ((puVar13 = (undefined *)fdt32_ld((fdt32_t *)((int)p + 4)), puVar13 < puVar19 &&
           (puVar13 = (undefined *)fdt32_ld((fdt32_t *)((int)p + 8)), puVar13 < puVar19)))) &&
         (puVar13 = (undefined *)fdt32_ld((fdt32_t *)((int)p + 0xc)), puVar13 < puVar19))
      goto LAB_23029d34;
      printf("%s: skipping fdt magic at offset %#tx\r\n","fdtbuff",(fdt32_t *)((int)p + -0x2307f38c)
            );
    }
    p = (uint8_t *)((int)p + 1);
  }
  if (((fdt32_t *)p == (fdt32_t *)0x0) || (&UNK_2308063b + -(int)p < (undefined *)0x28)) {
LAB_23029ed2:
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] %s: could not locate fdt magic\r\n",TVar4,&DAT_23072bcc,
              "tc_blfdt_dump.c",0x149,"fdtbuff");
    printf("dump failed\r\n");
    iVar20 = -1;
  }
  else {
LAB_23029d34:
    printf("%s: found fdt at offset %#tx\r\n","fdtbuff",(fdt32_t *)((int)p + -0x2307f38c));
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] dump_blob.",TVar4,&DAT_2307f16c,"tc_blfdt_dump.c",0x153);
    uVar5 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x10));
    uVar6 = fdt32_to_cpu(*(fdt32_t *)((int)p + 8));
    uVar7 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0xc));
    uVar8 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x14));
    uVar9 = fdt32_to_cpu(*(fdt32_t *)((int)p + 4));
    printf("/dts-v1/;\r\n");
    uVar10 = fdt32_to_cpu(*(fdt32_t *)p);
    printf("// magic:\t\t0x%lx\r\n",uVar10);
    printf("// totalsize:\t\t0x%lx (%lu)\r\n",uVar9);
    printf("// off_dt_struct:\t0x%lx\r\n",uVar6);
    printf("// off_dt_strings:\t0x%lx\r\n",uVar7);
    printf("// off_mem_rsvmap:\t0x%lx\r\n",uVar5);
    printf("// version:\t\t%lu\r\n",uVar8);
    uVar9 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x18));
    printf("// last_comp_version:\t%lu\r\n",uVar9);
    if (1 < uVar8) {
      uVar9 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x1c));
      printf("// boot_cpuid_phys:\t0x%lx\r\n",uVar9);
      if (uVar8 != 2) {
        uVar9 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x20));
        printf("// size_dt_strings:\t0x%lx\r\n",uVar9);
        if (0x10 < uVar8) {
          uVar9 = fdt32_to_cpu(*(fdt32_t *)((int)p + 0x24));
          printf("// size_dt_struct:\t0x%lx\r\n",uVar9);
        }
      }
    }
    printf("\r\n");
    puVar1 = (uint *)(uVar5 + (int)p);
    while( true ) {
      uVar11 = *puVar1;
      uVar15 = puVar1[1];
      fdt64_to_cpu();
      uVar12 = puVar1[2];
      uVar16 = puVar1[3];
      uVar22 = fdt64_to_cpu();
      if ((uVar11 | uVar12 | uVar16 | uVar15) == 0) break;
      printf("/memreserve/ %#llx %#llx;\r\n",uVar12,uVar16,(int)uVar22);
      puVar1 = puVar1 + 4;
    }
    iVar20 = 0;
    pfStack72 = (fdt32_t *)&DAT_23085d30;
    pfVar3 = (fdt32_t *)((int)p + uVar6);
    while( true ) {
      pfVar21 = pfVar3 + 1;
      uVar5 = fdt32_to_cpu(*pfVar3);
      if (uVar5 == 9) break;
      puVar19 = &DAT_2307f0c0;
      if ((uVar5 < 10) &&
         (puVar19 = *(undefined **)(&names_3639 + uVar5 * 4),
         *(undefined **)(&names_3639 + uVar5 * 4) == (undefined *)0x0)) {
        puVar19 = &DAT_2307f0c0;
      }
      printf("// %04x: tag: 0x%08lx (%s)\r\n",(int)pfVar21 + (-4 - (int)p),uVar5,puVar19);
      if (uVar5 == 1) {
        sVar14 = strlen((char *)pfVar21);
        pfVar2 = pfVar21;
        if (*(char *)(pfVar3 + 1) == '\0') {
          pfVar2 = pfStack72;
        }
        printf("%*s%s {\r\n",iVar20 << 2,&DAT_23088e60,pfVar2);
        iVar20 = iVar20 + 1;
        pfVar3 = (fdt32_t *)((int)pfVar21 + sVar14 + 4 & 0xfffffffc);
      }
      else {
        if (uVar5 == 2) {
          iVar20 = iVar20 + -1;
          iVar17 = iVar20 * 4;
          fmt = "%*s};\r\n";
LAB_2302a036:
          printf(fmt,iVar17,&DAT_23088e60);
          pfVar3 = pfVar21;
        }
        else {
          iVar17 = iVar20 << 2;
          if (uVar5 == 4) {
            fmt = "%*s// [NOP]\r\n";
            goto LAB_2302a036;
          }
          if (uVar5 != 3) {
            if (TrapNetCounter == 0) {
              TVar4 = xTaskGetTickCount();
            }
            else {
              TVar4 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] %*s ** Unknown tag 0x%08lx\r\n",TVar4,&DAT_23072bcc,
                      "tc_blfdt_dump.c",0xf7,iVar17,&DAT_23088e60,uVar5);
            break;
          }
          pfVar21 = pfVar3 + 3;
          uVar5 = fdt32_to_cpu(pfVar3[1]);
          uVar6 = fdt32_to_cpu(pfVar3[2]);
          iVar18 = (int)p + uVar7 + uVar6;
          if ((uVar8 < 0x10) && (7 < (int)uVar5)) {
            pfVar21 = (fdt32_t *)((uint)((int)pfVar3 + 0x13) & 0xfffffff8);
          }
          printf("// %04x: string: %s\r\n",iVar18);
          printf("// %04x: value\r\n",(fdt32_t *)((int)pfVar21 - (int)p));
          printf("%*s%s",iVar17,&DAT_23088e60,iVar18);
          utilfdt_print_data((char *)pfVar21,uVar5);
          pfVar3 = (fdt32_t *)((int)pfVar21 + uVar5 + 3 & 0xfffffffc);
          printf(";\r\n");
        }
      }
    }
    printf("dump successed\r\n");
    iVar20 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar20;
}



int tc_fdt_wifi_module(void)

{
  int iVar1;
  int iVar2;
  TickType_t TVar3;
  char *pcVar4;
  int iVar5;
  uint *puVar6;
  void *pvVar7;
  int iVar8;
  undefined4 uVar9;
  uint uVar10;
  int iStack308;
  int lentmp;
  uint8_t sta_mac [6];
  
  iStack308 = 0;
  iVar2 = fdt_subnode_offset(tc_wifi_dtb,0,"wifi");
  if (iVar2 < 1) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar9 = 0x37;
    pcVar4 = "[%10u][%s: %s:%4d] wifi NULL.\r\n";
    goto LAB_2302a1c6;
  }
  iVar5 = fdt_subnode_offset(tc_wifi_dtb,iVar2,"region");
  if (0 < iVar5) {
    puVar6 = (uint *)fdt_getprop(tc_wifi_dtb,iVar5,"country_code",&iStack308);
    if (puVar6 == (uint *)0x0) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x42;
      pcVar4 = "[%10u][%s: %s:%4d] country_code NULL.\r\n";
      goto LAB_2302a1c6;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar10 = *puVar6;
    bl_printk("[%10u][%s: %s:%4d] value = %ld, lentmp = %d\r\n",TVar3,&DAT_2307f16c,
              "tc_blfdt_wifi.c",0x40,
              uVar10 << 0x18 | uVar10 >> 0x18 | (uVar10 >> 8 & 0xff) << 0x10 |
              (uVar10 >> 0x10 & 0xff) << 8,iStack308);
  }
  iVar5 = fdt_subnode_offset(tc_wifi_dtb,iVar2,"mac");
  if (0 < iVar5) {
    pvVar7 = fdt_getprop(tc_wifi_dtb,iVar5,"sta_mac_addr",&iStack308);
    if (iStack308 != 6) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x52;
      pcVar4 = "[%10u][%s: %s:%4d] sta_mac_addr NULL.\r\n";
      goto LAB_2302a1c6;
    }
    memcpy(&lentmp,pvVar7,6);
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sta_mac :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",0x4f);
    log_buf_out("tc_blfdt_wifi.c",0x50,&lentmp,6,LOG_BUF_OUT_DATA_TYPE_HEX);
    pvVar7 = fdt_getprop(tc_wifi_dtb,iVar5,"ap_mac_addr",&iStack308);
    if (iStack308 == 6) {
      memcpy(&lentmp,pvVar7,6);
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] ap_mac :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",0x5c);
      log_buf_out("tc_blfdt_wifi.c",0x5d,&lentmp,6,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
  }
  iVar5 = fdt_subnode_offset(tc_wifi_dtb,iVar2,"ap");
  if (iVar5 < 1) {
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar9 = 0x98;
LAB_2302a652:
    pcVar4 = "[%10u][%s: %s:%4d] ap NULL.\r\n";
LAB_2302a1c6:
    bl_printk(pcVar4,TVar3,&DAT_23072bcc,"tc_blfdt_wifi.c",uVar9);
  }
  else {
    iVar8 = fdt_stringlist_count(tc_wifi_dtb,iVar5,"ssid");
    if (iVar8 < 1) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x6e;
      goto LAB_2302a652;
    }
    iVar1 = 0;
    do {
      pcVar4 = fdt_stringlist_get(tc_wifi_dtb,iVar5,"ssid",iVar1,&iStack308);
      if (0 < iStack308) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap string[%d] = %s, lentmp = %d\r\n",TVar3,&DAT_2307f16c,
                  "tc_blfdt_wifi.c",0x6a,iVar1,pcVar4,iStack308);
      }
      iVar1 = iVar1 + 1;
    } while (iVar8 != iVar1);
    iVar8 = fdt_stringlist_count(tc_wifi_dtb,iVar5,"pwd");
    if (iVar8 < 1) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x7d;
      pcVar4 = "[%10u][%s: %s:%4d] pwd NULL.\r\n";
      goto LAB_2302a1c6;
    }
    iVar1 = 0;
    do {
      pcVar4 = fdt_stringlist_get(tc_wifi_dtb,iVar5,"pwd",iVar1,&iStack308);
      if (0 < iStack308) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] pwd string[%d] = %s, lentmp = %d\r\n",TVar3,&DAT_2307f16c,
                  "tc_blfdt_wifi.c",0x79,iVar1,pcVar4,iStack308);
      }
      iVar1 = iVar1 + 1;
    } while (iVar8 != iVar1);
    puVar6 = (uint *)fdt_getprop(tc_wifi_dtb,iVar5,"ap_channel",&iStack308);
    if (puVar6 == (uint *)0x0) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x86;
      pcVar4 = "[%10u][%s: %s:%4d] ap_channel NULL.\r\n";
      goto LAB_2302a1c6;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar10 = *puVar6;
    bl_printk("[%10u][%s: %s:%4d] ap_channel = %ld\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",0x84,
              uVar10 << 0x18 | uVar10 >> 0x18 | (uVar10 >> 8 & 0xff) << 0x10 |
              (uVar10 >> 0x10 & 0xff) << 8);
    iVar8 = fdt_stringlist_count(tc_wifi_dtb,iVar5,"auto_chan_detect");
    iVar1 = 0;
    if (iVar8 < 1) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0x94;
      pcVar4 = "[%10u][%s: %s:%4d] auto_chan_detect NULL.\r\n";
      goto LAB_2302a1c6;
    }
    do {
      pcVar4 = fdt_stringlist_get(tc_wifi_dtb,iVar5,"auto_chan_detect",iVar1,&iStack308);
      if (0 < iStack308) {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] auto_chan_detect string[%d] = %s, lentmp = %d\r\n",TVar3,
                  &DAT_2307f16c,"tc_blfdt_wifi.c",0x90,iVar1,pcVar4,iStack308);
      }
      iVar1 = iVar1 + 1;
    } while (iVar8 != iVar1);
    iVar2 = fdt_subnode_offset(tc_wifi_dtb,iVar2,"brd_rf");
    if (iVar2 < 1) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0xdc;
      pcVar4 = "[%10u][%s: %s:%4d] brd_rf NULL.\r\n";
      goto LAB_2302a1c6;
    }
    pvVar7 = fdt_getprop(tc_wifi_dtb,iVar2,"xtal",&iStack308);
    if (iStack308 != 0x14) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar9 = 0xa8;
      pcVar4 = "[%10u][%s: %s:%4d] xtal NULL.";
      goto LAB_2302a1c6;
    }
    memcpy(&lentmp,pvVar7,0x14);
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] xtal :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",0xa5);
    log_buf_out("tc_blfdt_wifi.c",0xa6,&lentmp,0x14,LOG_BUF_OUT_DATA_TYPE_HEX);
    pvVar7 = fdt_getprop(tc_wifi_dtb,iVar2,"pwr_table",&iStack308);
    if (iStack308 == 0x100) {
      memcpy(&lentmp,pvVar7,0x100);
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",0xb1);
      log_buf_out("tc_blfdt_wifi.c",0xb2,&lentmp,0x100,LOG_BUF_OUT_DATA_TYPE_HEX);
      pvVar7 = fdt_getprop(tc_wifi_dtb,iVar2,"channel_div_table",&iStack308);
      if (iStack308 == 0x3c) {
        memcpy(&lentmp,pvVar7,0x3c);
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c"
                  ,0xbd);
        log_buf_out("tc_blfdt_wifi.c",0xbe,&lentmp,0x3c,LOG_BUF_OUT_DATA_TYPE_HEX);
        pvVar7 = fdt_getprop(tc_wifi_dtb,iVar2,"channel_cnt_table",&iStack308);
        if (iStack308 == 0x38) {
          memcpy(&lentmp,pvVar7,0x38);
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] channel_cnt_table :\r\n",TVar3,&DAT_2307f16c,
                    "tc_blfdt_wifi.c",0xc9);
          log_buf_out("tc_blfdt_wifi.c",0xca,&lentmp,0x38,LOG_BUF_OUT_DATA_TYPE_HEX);
          pvVar7 = fdt_getprop(tc_wifi_dtb,iVar2,"lo_fcal_div",&iStack308);
          if (iStack308 == 4) {
            memcpy(&lentmp,pvVar7,4);
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] lo_fcal_div :\r\n",TVar3,&DAT_2307f16c,"tc_blfdt_wifi.c",
                      0xd5);
            log_buf_out("tc_blfdt_wifi.c",0xd6,&lentmp,4,LOG_BUF_OUT_DATA_TYPE_HEX);
            iVar2 = 0;
            goto LAB_2302a956;
          }
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          uVar9 = 0xd8;
          pcVar4 = "[%10u][%s: %s:%4d] lo_fcal_div NULL.\r\n";
        }
        else {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          uVar9 = 0xcc;
          pcVar4 = "[%10u][%s: %s:%4d] channel_cnt_table NULL.\r\n";
        }
      }
      else {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar9 = 0xc0;
        pcVar4 = "[%10u][%s: %s:%4d] channel_div_table NULL.\r\n";
      }
      goto LAB_2302a1c6;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_table NULL. lentmp = %d.\r\n",TVar3,&DAT_23072bcc,
              "tc_blfdt_wifi.c",0xb4,iStack308);
  }
  iVar2 = -1;
LAB_2302a956:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int tc_fdt_wifi(void)

{
  int iVar1;
  char *fmt;
  
  iVar1 = tc_fdt_wifi_module();
  if (iVar1 == 0) {
    fmt = "fdt wifi module successed\r\n";
  }
  else {
    fmt = "fdt wifi module failed\r\n";
  }
  printf(fmt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void cmd_blog_info_dump(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  blog_info_t *pbVar2;
  size_t sVar3;
  int iVar4;
  char *pcVar5;
  byte *pbVar6;
  byte **ppbVar7;
  char local_b0 [4];
  char name_buf [128];
  
  memset(local_b0,0,0x80);
  bl_printk("blog code1 = %p - %p\r\n",&_fsymc_info_bloop,&_fsymf_info_bloopbloop_base);
  bl_printk("blog code2 = %p - %p\r\n",&_fsymf_info_bloopbloop_base,&_bl_static_blogfile_code_end);
  bl_printk("blog code3 = %p - %p\r\n",&_bl_static_blogfile_code_end,&_bl_static_blogfile_code_end);
  pbVar1 = &_fsymc_info_bloop;
  do {
    if ((blog_info_t *)((int)&_fsymc_info_loopset.name + 3U) < pbVar1) {
LAB_2302aa9c:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    sVar3 = strlen(pbVar1->name);
    if (0x80 < sVar3) {
      bl_printk("name too long.\r\n");
      goto LAB_2302aa9c;
    }
    if (local_b0[0] == '\0') {
LAB_2302aada:
      bl_printk("[%-48s] = [%d]\r\n",pbVar1->name,(uint)*pbVar1->level);
      if ((local_b0[0] == '\0') || (iVar4 = strcmp(pbVar1->name,local_b0), iVar4 != 0)) {
        pbVar2 = &_fsymf_info_bloopbloop_base;
        strcpy(local_b0,pbVar1->name);
        while (pbVar2 < (blog_info_t *)&_bl_static_blogfile_code_end) {
          pcVar5 = strstr(pbVar2->name,pbVar1->name);
          if (pcVar5 == pbVar2->name) {
            ppbVar7 = (byte **)&_bl_static_blogfile_code_end;
            bl_printk("[%-48s] = [%d]\r\n",pcVar5,(uint)*pbVar2->level);
            while (ppbVar7 < &_bl_static_blogfile_code_end) {
              pbVar6 = (byte *)strstr((char *)ppbVar7[1],pbVar2->name);
              if (pbVar6 == ppbVar7[1]) {
                bl_printk("[%-48s] = [%d]\r\n",pbVar6,(uint)**ppbVar7);
              }
              ppbVar7 = ppbVar7 + 2;
            }
          }
          pbVar2 = pbVar2 + 1;
        }
      }
    }
    else {
      iVar4 = strcmp(local_b0,pbVar1->name);
      if (iVar4 != 0) {
        sVar3 = strlen(local_b0);
        memset(local_b0,0,sVar3);
        goto LAB_2302aada;
      }
    }
    pbVar1 = pbVar1 + 1;
  } while( true );
}



void cmd_blog_set_level(char *buf,int len,int argc,char **argv)

{
  blog_info_t *pbVar1;
  int iVar2;
  char *format;
  size_t sVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  blog_info_t *pbVar7;
  blog_level_t bVar8;
  int iVar9;
  
  if (argc != 3) {
    bl_printk("arg error.\r\n");
    goto LAB_2302ab82;
  }
  iVar2 = strcmp(argv[1],"all");
  if (iVar2 == 0) {
    bVar8 = BLOG_LEVEL_ALL;
LAB_2302ac30:
    pcVar5 = argv[2];
    sVar3 = strlen(pcVar5);
    iVar6 = 0;
    iVar2 = 0;
    while (iVar2 < (int)sVar3) {
      if (pcVar5[iVar2] == '.') {
        iVar6 = iVar6 + 1;
      }
      iVar2 = iVar2 + 1;
    }
    if (iVar6 == 0) {
      pbVar1 = &_fsymf_info_bloopbloop_base;
      pbVar7 = &_fsymc_info_bloop;
    }
    else {
      if (iVar6 == 1) {
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar7 = &_fsymf_info_bloopbloop_base;
      }
      else {
        if (iVar6 != 2) {
          pcVar5 = argv[2];
          format = "input name = %s not support.\r\n";
          goto LAB_2302ac28;
        }
        pbVar1 = (blog_info_t *)&_bl_static_blogfile_code_end;
        pbVar7 = (blog_info_t *)&_bl_static_blogfile_code_end;
      }
    }
    iVar2 = ((int)((int)pbVar1 - (int)pbVar7) >> 3) + -1;
    iVar6 = 0;
    while (pcVar5 = argv[2], iVar6 <= iVar2) {
      iVar9 = iVar6 + iVar2 >> 1;
      pbVar1 = pbVar7 + iVar9;
      iVar4 = strcmp(pbVar1->name,pcVar5);
      if (iVar4 < 0) {
        iVar6 = iVar9 + 1;
      }
      else {
        if (iVar4 == 0) {
          *pbVar1->level = bVar8;
          bl_printk("set %s = %d\r\n",pbVar1->name,(uint)*pbVar1->level);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        iVar2 = iVar9 + -1;
      }
    }
    format = "input name = %s not find.\r\n";
  }
  else {
    iVar2 = strcmp(argv[1],"debug");
    bVar8 = BLOG_LEVEL_DEBUG;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"info");
    bVar8 = BLOG_LEVEL_INFO;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"warn");
    bVar8 = BLOG_LEVEL_WARN;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"error");
    bVar8 = BLOG_LEVEL_ERROR;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"assert");
    bVar8 = BLOG_LEVEL_ASSERT;
    if (iVar2 == 0) goto LAB_2302ac30;
    iVar2 = strcmp(argv[1],"never");
    bVar8 = BLOG_LEVEL_NEVER;
    if (iVar2 == 0) goto LAB_2302ac30;
    pcVar5 = argv[1];
    format = "input level = %s not support.\r\n";
  }
LAB_2302ac28:
  bl_printk(format,pcVar5);
LAB_2302ab82:
  bl_printk("set blog error.\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void blog_init(void)

{
  blog_level_t **ppbVar1;
  undefined *puVar2;
  blog_info_t *pbVar3;
  undefined4 *puVar4;
  
  bl_printk("\r\nblog init set power on level %d, %d, %d.\r\n",2,2);
  pbVar3 = &_fsymc_info_bloop;
  while (pbVar3 < &_fsymf_info_bloopbloop_base) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  pbVar3 = &_fsymf_info_bloopbloop_base;
  while (pbVar3 < (blog_info_t *)&_bl_static_blogfile_code_end) {
    ppbVar1 = &pbVar3->level;
    pbVar3 = pbVar3 + 1;
    **ppbVar1 = BLOG_LEVEL_INFO;
  }
  puVar4 = (undefined4 *)&_bl_static_blogfile_code_end;
  while (puVar4 < &_bl_static_blogfile_code_end) {
    puVar2 = (undefined *)*puVar4;
    puVar4 = puVar4 + 2;
    *puVar2 = 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ota_dump_cmd(void)

{
  _dump_partition();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

void ota_tcp_cmd(char **argv)

{
  int iVar1;
  uint32_t uVar2;
  uint8_t uVar3;
  hostent *phVar4;
  char *pcVar5;
  int iVar6;
  uchar *input;
  undefined3 extraout_var;
  int iVar7;
  ssize_t sVar8;
  uint addr;
  int iVar9;
  uint ilen;
  int iVar10;
  bl_mtd_handle_t local_150;
  bl_mtd_handle_t handle;
  uint32_t address;
  uint32_t bin_size;
  sockaddr_in dest;
  uint8_t sha256_result [32];
  uint8_t sha256_img [32];
  char str [33];
  byte bStack206;
  HALPartition_Entry_Config ptEntry;
  iot_sha256_context ctx;
  
  phVar4 = lwip_gethostbyname(argv[1]);
  if (phVar4 == (hostent *)0x0) {
    pcVar5 = "gethostbyname Failed\r\n";
  }
  else {
    iVar6 = bl_mtd_open("FW",&local_150,1);
    if (iVar6 == 0) {
      iVar6 = lwip_socket(2,1,0);
      if (iVar6 < 0) {
        printf("Error in socket\r\n");
      }
      else {
        memset(&bin_size,0,0x10);
        bin_size._1_1_ = '\x02';
        bin_size._2_2_ = lwip_htons(0xd05);
        handle = (bl_mtd_handle_t)((ip4_addr_t *)((ip4_addr_t *)phVar4->h_addr_list)->addr)->addr;
        dest._0_4_ = (ip4_addr_t)handle;
        pcVar5 = ip4addr_ntoa((ip4_addr_t *)&handle);
        input = (uchar *)pvPortMalloc(0x200);
        uVar3 = hal_boot2_get_active_partition();
        printf("Starting OTA test. OTA bin addr is %p\r\n",input);
        printf("[OTA] [TEST] activeID is %u\r\n",CONCAT31(extraout_var,uVar3));
        iVar7 = hal_boot2_get_active_entries(0,(HALPartition_Entry_Config *)(str + 0x20));
        if (iVar7 == 0) {
          address = ptEntry.Address[(bStack206 == 0) + 1];
          iVar9 = *(int *)(ptEntry.name + (uint)(bStack206 == 0) * 4 + 5);
          printf("Starting OTA test. OTA size is %lu\r\n");
          printf("[OTA] [TEST] activeIndex is %u, use OTA address=%08x\r\n",(uint)bStack206,iVar9);
          printf("[OTA] [TEST] Erase flash with size %lu...",address);
          bl_mtd_erase_all(local_150);
          printf("Done\r\n");
          printf("Server ip Address : %s\r\n",pcVar5);
          iVar7 = lwip_connect(iVar6,(sockaddr *)&bin_size,0x10);
          if (iVar7 == 0) {
            utils_sha256_init((iot_sha256_context *)&ptEntry.age);
            utils_sha256_starts((iot_sha256_context *)&ptEntry.age);
            memset(dest.sin_zero + 4,0,0x20);
            iVar7 = 0;
            uVar2 = 0;
            addr = 0;
            ilen = 0;
LAB_2302af8e:
            while (sVar8 = lwip_read(iVar6,input + ilen,0x200 - ilen), -1 < sVar8) {
              uVar2 = uVar2 + sVar8;
              if (sVar8 == 0) {
                printf("[OTA] [TEST] seems ota file ends unexpectedly, already transfer %u\r\n",
                       uVar2);
                goto LAB_2302afbc;
              }
              printf("total = %d, ret = %d\n\r",uVar2,sVar8);
              ilen = ilen + sVar8;
              if (iVar7 != 0) {
                if (address != uVar2) goto code_r0x2302b164;
                goto LAB_2302b180;
              }
              if (0x1ff < ilen) {
                if (ilen != 0x200) {
                  printf("[OTA] [TCP] Assert for unexpected error %d\r\n",ilen);
                  do {
                    // WARNING: Do nothing block with infinite loop
                  } while( true );
                }
                memcpy(sha256_img + 0x1c,input,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ota header is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x10,4);
                str[0] = '\0';
                puts("[OTA] [HEADER] file type is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                pcVar5 = strstr((char *)(sha256_img + 0x1c),"XZ");
                memcpy(&address,input + 0x14,4);
                printf("[OTA] [HEADER] file length (exclude ota header) is %lu\r\n",address);
                memcpy(sha256_img + 0x1c,input + 0x20,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ver_hardware is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x30,0x10);
                str[12] = '\0';
                puts("[OTA] [HEADER] ver_software is ");
                puts((char *)(sha256_img + 0x1c));
                puts("\r\n");
                memcpy(sha256_img + 0x1c,input + 0x40,0x20);
                str[28] = '\0';
                puts("[OTA] [HEADER] sha256 is ");
                do {
                  iVar10 = iVar7 + 0x1c;
                  iVar7 = iVar7 + 1;
                  printf("%02X",(uint)sha256_img[iVar10]);
                } while (iVar7 != 0x20);
                puts("\r\n");
                memcpy(sha256_result + 0x1c,input + 0x40,0x20);
                iVar7 = -0x2f0;
                if (pcVar5 == (char *)0x0) {
                  iVar7 = -0x2ec;
                }
                uVar2 = uVar2 - 0x200;
                printf("[OTA] [TCP] Update bin_size to %lu, file status %s\r\n",address,
                       "\r\nCalculated SHA256 Checksum:" + iVar7 + 0x18);
                ilen = 0;
                iVar7 = 1;
              }
            }
            printf("ret = %d, err = %d\n\r",sVar8,errno);
LAB_2302afbc:
            lwip_close(iVar6);
            vPortFree(input);
            utils_sha256_free((iot_sha256_context *)&ptEntry.age);
            goto LAB_2302ae54;
          }
          printf("Error in connect\r\n");
          lwip_close(iVar6);
        }
        else {
          printf("PtTable_Get_Active_Entries fail\r\n");
        }
        vPortFree(input);
      }
LAB_2302ae54:
      bl_mtd_close(local_150);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    pcVar5 = "Open Default FW partition failed\r\n";
  }
  puts(pcVar5);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
code_r0x2302b164:
  if (0x1ff < ilen) {
    if (ilen != 0x200) {
      printf("[OTA] [TCP] Assert for unexpected error %d\r\n",ilen);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
LAB_2302b180:
    printf("Will Write %u to %08X from %p\r\n",ilen,iVar9 + addr,input);
    utils_sha256_update((iot_sha256_context *)&ptEntry.age,input,ilen);
    bl_mtd_write(local_150,addr,ilen,input);
    addr = addr + ilen;
    ilen = 0;
    if (uVar2 == address) {
      utils_sha256_finish((iot_sha256_context *)&ptEntry.age,(uint8_t *)(dest.sin_zero + 4));
      puts("\r\nCalculated SHA256 Checksum:");
      do {
        iVar10 = ilen + 4;
        ilen = ilen + 1;
        printf("%02X",(uint)(byte)dest.sin_zero[iVar10]);
      } while (ilen != 0x20);
      puts("\r\nHeader SET SHA256 Checksum:");
      iVar10 = 0;
      do {
        iVar1 = iVar10 + 0x1c;
        iVar10 = iVar10 + 1;
        printf("%02X",(uint)sha256_result[iVar1]);
      } while (iVar10 != 0x20);
      puts("\r\n");
      iVar10 = memcmp(sha256_result + 0x1c,dest.sin_zero + 4,0x20);
      if (iVar10 != 0) {
        printf("[OTA] [TCP] SHA256 NOT Correct\r\n");
        goto LAB_2302afbc;
      }
      printf("[OTA] [TCP] prepare OTA partition info\r\n");
      ptEntry.maxLen[1] = address;
      printf("[OTA] [TCP] Update PARTITION, partition len is %lu\r\n");
      hal_boot2_update_ptable((HALPartition_Entry_Config *)(str + 0x20));
      printf("[OTA] [TCP] Rebooting\r\n");
      hal_reboot();
      ilen = 0;
    }
  }
  goto LAB_2302af8e;
}



void ota_tcp_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("Usage: %s IP\r\n",*argv);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ota_tcp_cmd(argv);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_sys_ota_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void cmd_sys_time_now(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  uint local_30;
  uint64_t epoch_ms;
  undefined auStack36 [4];
  utils_time_date_t date;
  
  local_30 = 0;
  epoch_ms._0_4_ = 0;
  puts("BL SYS TIME time is\r\n");
  bl_sys_time_get((uint64_t *)&local_30);
  uVar1 = local_30;
  __udivdi3();
  utils_time_date_from_epoch(uVar1,auStack36);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_sys_time_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_sys_time_update(undefined4 param_1,undefined4 param_2)

{
  time_synced._0_4_ = xTaskGetTickCount();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  epoch_time._0_4_ = param_1;
  epoch_time._4_4_ = param_2;
  time_synced._4_4_ = 0;
  return;
}



int bl_sys_time_get(uint64_t *epoch)

{
  TickType_t TVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  
  if (((uint)epoch_time | epoch_time._4_4_) == 0) {
    iVar2 = -1;
  }
  else {
    TVar1 = xTaskGetTickCount();
    uVar4 = TVar1 - (int)time_synced;
    uVar3 = (uint)epoch_time + uVar4;
    iVar2 = ((int)uVar4 >> 0x1f) + epoch_time._4_4_;
    *(uint *)epoch = uVar3;
    *(uint *)((int)epoch + 4) = (uint)(uVar3 < uVar4) + iVar2;
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_sys_time_sync_state(uint32_t *xTicksToJump)

{
  bool bVar1;
  TickType_t TVar2;
  TickType_t TVar3;
  uint uVar4;
  
  if (sync_init != 0) {
    vTaskEnterCritical();
    TVar2 = xTaskGetTickCount();
    TVar3 = TVar2;
    bl_rtc_get_timestamp_ms();
    vTaskExitCritical();
    uVar4 = TVar3 - init_tick_rtc;
    bVar1 = TVar2 - init_tick_rtos < uVar4;
    if (bVar1) {
      *xTicksToJump = (init_tick_rtos - TVar2) + uVar4;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint)bVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xffffffff;
}



cli_command * cli_command_get(int idx,int *is_static_cmd)

{
  cli_st *pcVar1;
  cli_command *pcVar2;
  
  pcVar1 = cli;
  pcVar2 = (cli_command *)0xffffffff;
  if (-1 < idx) {
    pcVar2 = (cli_command *)0xffffffff;
    if ((uint)idx < cli->num_static_cmds + 8) {
      if ((uint)idx < cli->num_static_cmds) {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 1;
        }
        pcVar2 = pcVar1->static_cmds + idx;
      }
      else {
        if (is_static_cmd != (int *)0x0) {
          *is_static_cmd = 0;
        }
        pcVar2 = *(cli_command **)((int)pcVar1 + (idx - pcVar1->num_static_cmds) * 4 + 0xc);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar2;
}



void exit_cmd(char *buf,int len,int argc,char **argv)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  cliexit = 1;
  return;
}



int cb_idnoe(void *arg,inode_t *node)

{
  uint8_t uVar1;
  char *pcVar2;
  undefined4 uVar3;
  
                    // WARNING: Load size is inaccurate
  if (*arg == 0) {
    *(undefined4 *)arg = 1;
    printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
    printf("----------------------------------------------------------------------------------\r\n")
    ;
  }
  uVar1 = node->type;
  uVar3 = 0x1c;
  if ((1 < (byte)(uVar1 - 1)) && (uVar3 = 0x50, uVar1 != '\x03')) {
    uVar3 = 0;
  }
  if (uVar1 == '\x01') {
    pcVar2 = "Char Device";
  }
  else {
    if (uVar1 == '\x02') {
      pcVar2 = "Block Device";
    }
    else {
      if (uVar1 == '\x03') {
        pcVar2 = "File System";
      }
      else {
        pcVar2 = "Unknown";
      }
    }
  }
  printf("%10d\t\t%30s\t\t\t%s\r\n",uVar3,node->i_name,pcVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void ota_cmd(char *buf,int len,int argc,char **argv)

{
  aos_task_new("LOCAL OTA",tftp_ota_thread,(void *)0x0,0x1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tftp_ota_thread(void *arg)

{
  aos_task_exit(0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cat_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  ssize_t sVar1;
  byte local_11 [4];
  char ch;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    while (sVar1 = aos_read(fd,local_11,1), sVar1 == 1) {
      printf("%c",(uint)local_11[0]);
    }
    printf("\r\n");
    aos_close(fd);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void hexdump_cmd(char *buf,int len,int argc,char **argv)

{
  int fd;
  void *local_18;
  romfs_filebuf_t filebuf;
  
  if (argc != 2) {
    printf("invalid parameter!\r\n");
  }
  fd = aos_open(argv[1],0);
  if (fd < 0) {
    printf("open %s failed!\r\n",argv[1]);
  }
  else {
    memset(&local_18,0,8);
    aos_ioctl(fd,1,(ulong)&local_18);
    printf("Found file %s. XIP Addr %p, len %lu\r\n",argv[1],local_18,filebuf.buf);
    utils_hexdump(local_18,(uint)filebuf.buf);
    aos_close(fd);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_cli_init(int use_thread)

{
  cli_st *pcVar1;
  int iVar2;
  
  cli = (cli_st *)aos_malloc(0x244);
  iVar2 = 0xc;
  if (cli != (cli_st *)0x0) {
    memset(cli,0,0x244);
    pcVar1 = cli;
    cli->static_cmds = cmds_user;
    pcVar1->echo_disabled = 0;
    pcVar1->num_static_cmds = 0x6c;
    pcVar1->num_commands = 0x6c;
    pcVar1->initialized = 1;
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void * aos_cli_event_cb_read_get(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return console_cb_read;
}



int cli_putstr(char *msg)

{
  int iVar1;
  size_t sVar2;
  ssize_t sVar3;
  
  sVar2 = strlen(msg);
  iVar1 = 0;
  while ((iVar1 < (int)sVar2 &&
         (sVar3 = aos_write(fd_console,msg + iVar1,sVar2 - iVar1), -1 < sVar3))) {
    iVar1 = iVar1 + sVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void ps_cmd(char *buf,int len,int argc,char **argv)

{
  char *__dest;
  char *__dest_00;
  size_t sVar1;
  int iVar2;
  
  __dest_00 = (char *)pvPortMalloc(0x600);
  if (__dest_00 != (char *)0x0) {
    strcpy(__dest_00,"Task");
    sVar1 = strlen(__dest_00);
    __dest = __dest_00 + sVar1;
    sVar1 = strlen("Task");
    iVar2 = sVar1 - (int)__dest;
    while ((int)(__dest + iVar2) < 0xd) {
      *__dest = ' ';
      __dest = __dest + 1;
      *__dest = '\0';
    }
    strcpy(__dest,
           "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
          );
    sVar1 = strlen(
                  "State   Priority  Stack    #          Base\r\n********************************************************\r\n"
                  );
    vTaskList(__dest + sVar1);
    cli_putstr(__dest_00);
    vPortFree(__dest_00);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_cli_printf(char *msg,...)

{
  size_t sVar1;
  int iVar2;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  char message [256];
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  memset(&ap,0,0x100);
  sVar1 = 0;
  if (esc_tag_len != '\0') {
    strcpy((char *)&ap,esc_tag);
    sVar1 = strlen(esc_tag);
  }
  iVar2 = vsnprintf(message + (sVar1 - 4),0x100 - sVar1,msg,&uStack28);
  if (0 < iVar2) {
    cli_putstr((char *)&ap);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int proc_onecmd(int argc,char **argv)

{
  cli_st *pcVar1;
  cli_st *pcVar2;
  char *pcVar3;
  cli_command *pcVar4;
  int iVar5;
  uint idx;
  uint uVar6;
  char *__n;
  char *__s2;
  
  if (argc < 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  if (cli->echo_disabled == 0) {
    printf("\r\n");
  }
  __n = (char *)0x0;
  pcVar3 = strchr(*argv,0x2e);
  __s2 = *argv;
  if (pcVar3 != (char *)0x0) {
    __n = pcVar3 + -(int)__s2;
  }
  idx = 0;
  uVar6 = 0;
  do {
    if ((cli->num_static_cmds + 8 <= idx) || (cli->num_commands <= uVar6)) goto LAB_2302b7c6;
    pcVar4 = cli_command_get(idx,(int *)0x0);
    pcVar3 = pcVar4->name;
    if (pcVar3 != (char *)0x0) {
      if (__n == (char *)0x0) {
        iVar5 = strcmp(pcVar3,__s2);
      }
      else {
        iVar5 = strncmp(pcVar3,__s2,(size_t)__n);
      }
      pcVar1 = cli;
      if (iVar5 == 0) {
        pcVar3 = (char *)aos_malloc(0x200);
        pcVar2 = cli;
        pcVar1->outbuf = pcVar3;
        if (pcVar2->outbuf != (char *)0x0) {
          memset(pcVar2->outbuf,0,0x200);
          (*pcVar4->function)(cli->outbuf,0x200,argc,argv);
          aos_cli_printf("%s",cli->outbuf);
          aos_free(cli->outbuf);
          cli->outbuf = (char *)0x0;
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        aos_cli_printf("Error! cli alloc mem fail!\r\n");
LAB_2302b7c6:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 1;
      }
      uVar6 = uVar6 + 1;
    }
    idx = idx + 1;
  } while( true );
}



void ls_cmd(char *buf,int len,int argc,char **argv)

{
  stat *st;
  int iVar1;
  aos_dir_t *dir;
  aos_dirent_t *paVar2;
  char *pcVar3;
  size_t sVar4;
  size_t sVar5;
  undefined4 uStack180;
  int env;
  char path_name [128];
  
  uStack180 = 0;
  st = (stat *)pvPortMalloc(0x58);
  memset(stat,0,0x58);
  memset(&env,0,0x80);
  if (argc == 2) {
    iVar1 = strcmp(argv[1],"/sdcard");
    if (iVar1 == 0) {
      dir = aos_opendir("/sdcard");
      if (dir == (aos_dir_t *)0x0) {
        pcVar3 = "can not open sdcard\r\n";
LAB_2302b970:
        printf(pcVar3);
        goto LAB_2302b94a;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        snprintf((char *)&env,0x7f,"/sdcard/%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = 0x450;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = 0x46c;
          }
          printf("\r\nCalculated SHA256 Checksum:" + iVar1 + 0x18,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    else {
      pcVar3 = argv[1];
      sVar4 = strlen("/romfs");
      iVar1 = memcmp(pcVar3,"/romfs",sVar4);
      if (iVar1 != 0) {
        iVar1 = strcmp(argv[1],"/");
        if (iVar1 != 0) {
          pcVar3 = "un-supported direcotry!\r\n";
          goto LAB_2302ba96;
        }
        goto LAB_2302ba7e;
      }
      dir = aos_opendir(argv[1]);
      if (dir == (aos_dir_t *)0x0) {
        pcVar3 = "can not open romfs\r\n";
        goto LAB_2302b970;
      }
      printf("\tSize\t\t\t\t\t Name\t\t\tFiletype\r\n");
      printf(
            "----------------------------------------------------------------------------------\r\n"
            );
      while (paVar2 = aos_readdir(dir), paVar2 != (aos_dirent_t *)0x0) {
        memset(&env,0,0x80);
        snprintf((char *)&env,0x7f,"%s",argv[1]);
        sVar4 = strlen((char *)&env);
        if (*(char *)((int)&uStack180 + sVar4 + 3) != '/') {
          sVar4 = strlen((char *)&env);
          path_name[sVar4 - 4] = '/';
        }
        sVar4 = strlen((char *)&env);
        sVar5 = strlen((char *)&env);
        snprintf(path_name + (sVar4 - 4),0x7f - sVar5,"%s",&paVar2->field_0x5);
        iVar1 = aos_stat((char *)&env,st);
        if (iVar1 == 0) {
          iVar1 = 0x450;
          if (-1 < (int)(st->st_mode << 0x11)) {
            iVar1 = 0x46c;
          }
          printf("\r\nCalculated SHA256 Checksum:" + iVar1 + 0x18,st->st_size,&paVar2->field_0x5);
        }
      }
    }
    aos_closedir(dir);
  }
  else {
    if (argc != 1) {
      pcVar3 = "invalid parameter!\r\n";
LAB_2302ba96:
      aos_cli_printf(pcVar3);
      goto LAB_2302b94a;
    }
LAB_2302ba7e:
    inode_forearch_name(cb_idnoe,&uStack180);
  }
LAB_2302b94a:
  vPortFree(st);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void uptime_cmd(char *buf,int len,int argc,char **argv)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  longlong lVar5;
  DItype DVar6;
  
  lVar5 = aos_now_ms();
  aos_cli_printf("UP time in ms %llu\r\n",buf,len,(int)lVar5);
  pcVar1 = buf;
  iVar3 = len;
  __divdi3();
  __moddi3();
  pcVar2 = buf;
  iVar4 = len;
  __divdi3();
  __moddi3();
  __divdi3();
  __divdi3();
  DVar6 = __moddi3();
  aos_cli_printf("UP time in %llu days, %llu hours, %llu minutes, %llu seconds\r\n",buf,len,pcVar2,
                 iVar4,pcVar1,iVar3,(int)DVar6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void reset_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("system reset\r\n");
  hal_sys_reset();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void poweroff_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("poweroff\r\n");
  hal_poweroff();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void reboot_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("reboot\r\n");
  hal_reboot();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: desc

void version_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  size_t sVar2;
  int iStack76;
  int num;
  uint addr [4];
  uint size [4];
  char desc [4] [6];
  
  iStack76 = 4;
  aos_cli_printf("kernel version :posix\r\n");
  aos_cli_printf("release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty");
  aos_cli_printf("\r\n");
  iVar1 = bl_chip_memory_ram(&iStack76,(uint *)&num,addr + 3,(char (*) [6])(size + 3));
  if (iVar1 == 0) {
    aos_cli_printf("Memory Configuration on %d banks:\r\n",iStack76);
    while (iVar1 < iStack76) {
      aos_cli_printf("    [%d]%6s %6u Kbytes @ %p\r\n",iVar1,(int)size + iVar1 * 6 + 0xc,
                     addr[iVar1 + 3] >> 10,addr[iVar1 + -1]);
      iVar1 = iVar1 + 1;
    }
  }
  sVar2 = xPortGetFreeHeapSize();
  aos_cli_printf("Heap left: %d Bytes\r\n",sVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void devname_cmd(char *buf,int len,int argc,char **argv)

{
  aos_cli_printf("device name: %s\r\n",&UNK_23081328);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void echo_cmd(char *buf,int len,int argc,char **argv)

{
  int iVar1;
  char *pcVar2;
  
  if (argc == 1) {
    if (cli->echo_disabled == 0) {
      pcVar2 = "Enabled";
    }
    else {
      pcVar2 = "Disabled";
    }
    aos_cli_printf("Usage: echo on/off. Echo is currently %s\r\n",pcVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar1 = strcmp(argv[1],"on");
  if (iVar1 == 0) {
    aos_cli_printf("Enable echo\r\n");
    cli->echo_disabled = 0;
  }
  else {
    iVar1 = strcmp(argv[1],"off");
    if (iVar1 == 0) {
      aos_cli_printf("Disable echo\r\n");
      cli->echo_disabled = 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mmem_cmd(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  
  if (argc == 3) {
    iVar2 = 4;
LAB_2302bd2e:
    uVar1 = strtol(argv[2],(char **)0x0,0);
  }
  else {
    if (argc == 4) {
      iVar2 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302bd2e;
    }
    if (argc != 2) goto LAB_2302bd4c;
    uVar1 = 0;
    iVar2 = 4;
  }
  len = strtol(argv[1],(char **)0x0,0);
  if ((uint *)len != (uint *)0x0) {
    if (iVar2 == 1) {
      uVar3 = (uint)*(byte *)len;
      *(byte *)len = (byte)uVar1;
      uVar1 = (uint)*(byte *)len;
    }
    else {
      if (iVar2 == 2) {
        uVar3 = (uint)*(ushort *)len;
        *(ushort *)len = (ushort)uVar1;
        uVar1 = (uint)*(ushort *)len;
      }
      else {
        uVar3 = *(uint *)len;
        *(uint *)len = uVar1;
        uVar1 = *(uint *)len;
      }
    }
    aos_cli_printf("value on 0x%x change from 0x%x to 0x%x.\r\n",len,uVar3,uVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_2302bd4c:
  aos_cli_printf(
                 "m <addr> <value> <width>\r\naddr  : address to modify\r\nvalue : new value (default is 0)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                 ,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void pmem_cmd(char *buf,int len,int argc,char **argv)

{
  ushort uVar1;
  undefined4 *puVar2;
  int iVar3;
  undefined4 uVar4;
  long lVar5;
  uint uVar6;
  char *pcStack52;
  char *pos;
  
  pcStack52 = (char *)0x0;
  if (argc == 3) {
    lVar5 = 4;
LAB_2302be3e:
    iVar3 = strtol(argv[2],(char **)0x0,0);
    if (0x400 < iVar3) {
      iVar3 = 0x400;
    }
  }
  else {
    if (argc == 4) {
      lVar5 = strtol(argv[3],(char **)0x0,0);
      goto LAB_2302be3e;
    }
    lVar5 = 4;
    iVar3 = 0x10;
    puVar2 = (undefined4 *)0x0;
    if (argc != 2) goto LAB_2302be02;
  }
  puVar2 = (undefined4 *)strtol(argv[1],&pcStack52,0);
LAB_2302be02:
  if ((pcStack52 == (char *)0x0) || (pcStack52 == argv[1])) {
    aos_cli_printf(
                  "p <addr> <nunits> <width>\r\naddr  : address to display\r\nnunits: number of units to display (default is 16)\r\nwidth : width of unit, 1/2/4 (default is 4)\r\n"
                  );
  }
  else {
    if (lVar5 == 1) {
      uVar6 = 0;
      while ((int)uVar6 < iVar3) {
        if ((uVar6 & 0xf) == 0) {
          aos_cli_printf("0x%08x:",(byte *)((int)puVar2 + uVar6));
        }
        aos_cli_printf(" %02x",(uint)*(byte *)((int)puVar2 + uVar6));
        if ((uVar6 & 0xf) == 0xf) {
          aos_cli_printf("\r\n");
        }
        uVar6 = uVar6 + 1;
      }
    }
    else {
      if (lVar5 == 2) {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 7) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar1 = *(ushort *)puVar2;
          puVar2 = (undefined4 *)((int)puVar2 + 2);
          aos_cli_printf(" %04x",(uint)uVar1);
          if ((uVar6 & 7) == 7) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
      else {
        uVar6 = 0;
        while ((int)uVar6 < iVar3) {
          if ((uVar6 & 3) == 0) {
            aos_cli_printf("0x%08x:",puVar2);
          }
          uVar4 = *puVar2;
          puVar2 = puVar2 + 1;
          aos_cli_printf(" %08x",uVar4);
          if ((uVar6 & 3) == 3) {
            aos_cli_printf("\r\n");
          }
          uVar6 = uVar6 + 1;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void help_cmd(char *buf,int len,int argc,char **argv)

{
  cli_command *pcVar1;
  uint idx;
  char *pcVar2;
  uint uVar3;
  
  aos_cli_printf("====Build-in Commands====\r\n");
  pcVar1 = built_ins;
  aos_cli_printf("====Support %d cmds once, seperate by ; ====\r\n",4);
  do {
    if (pcVar1->name != (char *)0x0) {
      pcVar2 = pcVar1->help;
      if (pcVar1->help == (char *)0x0) {
        pcVar2 = "";
      }
      aos_cli_printf("%-25s: %s\r\n",pcVar2);
    }
    pcVar1 = pcVar1 + 1;
  } while (pcVar1 != cmds_user);
  aos_cli_printf("\r\n");
  aos_cli_printf("====User Commands====\r\n");
  uVar3 = 0x10;
  idx = 0;
  while ((idx < cli->num_static_cmds + 8 && (uVar3 < cli->num_commands))) {
    pcVar1 = cli_command_get(idx,(int *)0x0);
    if (((pcVar1 < built_ins) || ((cli_command *)((int)&built_ins[0xf].function + 3U) < pcVar1)) &&
       (pcVar1->name != (char *)0x0)) {
      pcVar2 = pcVar1->help;
      if (pcVar1->help == (char *)0x0) {
        pcVar2 = "";
      }
      aos_cli_printf("%-25s: %s\r\n",pcVar2);
      uVar3 = uVar3 + 1;
    }
    idx = idx + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int cli_getchar(char *inbuf)

{
  int32_t iVar1;
  uint uVar2;
  uint32_t local_50;
  uint32_t recv_size;
  uart_dev_t uart_stdio;
  
  local_50 = 0;
  memset(&recv_size,0,0x3c);
  recv_size._0_1_ = '\0';
  iVar1 = hal_uart_recv_II((uart_dev_t *)&recv_size,inbuf,1,&local_50,0xffffffff);
  if (iVar1 == 0) {
    uVar2 = (uint)(local_50 == 1);
  }
  else {
    uVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



// WARNING: Could not reconcile some variable overlaps

void cli_main_input(char *buffer,int count)

{
  byte bVar1;
  char cVar2;
  cli_st *pcVar3;
  cli_st *pcVar4;
  uint8_t uVar5;
  anon_struct_conflict181dab *paVar6;
  undefined1 *argv;
  size_t sVar7;
  cli_command *pcVar8;
  uint uVar9;
  char *pcVar10;
  char *pcVar11;
  anon_struct_conflict181dab aVar12;
  uint uVar13;
  int iVar14;
  byte *pbVar15;
  uint uVar16;
  char *pcVar17;
  int iVar18;
  size_t __n;
  int iVar19;
  uint uStack84;
  anon_struct_conflict181dab stat;
  char c;
  
  pcVar3 = cli;
  pcVar10 = cli->inbuf;
  if (pcVar10 != (char *)0x0) {
    iVar18 = 0;
    uVar5 = esc_tag_len;
LAB_2302c092:
    esc_tag_len = uVar5;
    if (buffer == (char *)0x0) {
      iVar19 = cli_getchar((char *)&stat);
      if (iVar19 != 1) goto LAB_2302c598;
    }
    else {
      if (count <= iVar18) goto LAB_2302c598;
      pbVar15 = (byte *)(buffer + iVar18);
      iVar18 = iVar18 + 1;
      stat = (anon_struct_conflict181dab)((uint)stat & 0xffffff00 | (uint)*pbVar15);
    }
    pcVar4 = cli;
    cVar2 = key1_4391;
    uVar16 = (uint)stat & 0xff;
    if ((uVar16 != 10) && (uVar16 != 0xd)) {
      uVar5 = esc_tag_len;
      if (uVar16 == 0x1b) {
        esc_4390 = '\x01';
        key1_4391 = -1;
        key2_4392 = -1;
        goto LAB_2302c092;
      }
      if (esc_4390 == '\0') {
        pcVar10[pcVar3->bp] = stat._0_1_;
        if ((uVar16 == 8) || (uVar16 == 0x7f)) {
          uVar5 = esc_tag_len;
          if ((pcVar3->bp != 0) &&
             (pcVar3->bp = pcVar3->bp - 1, uVar5 = esc_tag_len, cli->echo_disabled == 0)) {
            printf("%c %c",8,8);
            uVar5 = esc_tag_len;
          }
        }
        else {
          if (uVar16 != 9) goto LAB_2302c556;
          pcVar10[pcVar3->bp] = '\0';
          aos_cli_printf("\r\n");
          iVar19 = 0;
          uVar9 = 0;
          uVar16 = 0;
          pcVar17 = (char *)0x0;
          while ((uVar16 < cli->num_static_cmds + 8 && (uVar9 < cli->num_commands))) {
            pcVar8 = cli_command_get(uVar16,(int *)0x0);
            pcVar11 = pcVar17;
            if (pcVar8->name != (char *)0x0) {
              iVar14 = strncmp(pcVar10,pcVar8->name,pcVar3->bp);
              if (iVar14 == 0) {
                iVar19 = iVar19 + 1;
                pcVar11 = pcVar8->name;
                if (iVar19 != 1) {
                  if (iVar19 == 2) {
                    aos_cli_printf("%s %s ",pcVar17);
                    pcVar11 = pcVar17;
                  }
                  else {
                    aos_cli_printf("%s ",pcVar11);
                    pcVar11 = pcVar17;
                  }
                }
              }
              uVar9 = uVar9 + 1;
            }
            uVar16 = uVar16 + 1;
            pcVar17 = pcVar11;
          }
          if (iVar19 == 1) {
            if ((pcVar17 != (char *)0x0) && (sVar7 = strlen(pcVar17), sVar7 < 0x100)) {
              uVar16 = pcVar3->bp;
              memcpy(pcVar10 + uVar16,pcVar17 + uVar16,sVar7 - uVar16);
              iVar19 = (sVar7 - uVar16) + pcVar3->bp;
              pcVar3->bp = iVar19 + 1;
              pcVar10[iVar19] = ' ';
              pcVar10[pcVar3->bp] = '\0';
            }
          }
          else {
            if (1 < iVar19) {
              aos_cli_printf("\r\n");
            }
          }
          aos_cli_printf("%s%s",&DAT_230812a4,pcVar10);
          uVar5 = esc_tag_len;
        }
        goto LAB_2302c092;
      }
      if (key1_4391 < '\0') {
        pcVar11 = (char *)(int)stat._0_1_;
        key1_4391 = stat._0_1_;
        if (pcVar11 == (char *)0x5b) goto LAB_2302c092;
        pcVar10[pcVar3->bp] = '\x1b';
        uVar16 = pcVar3->bp + 1;
        pcVar3->bp = uVar16;
        pcVar10[uVar16] = stat._0_1_;
        pcVar3->bp = pcVar3->bp + 1;
        if (cli->echo_disabled == 0) {
          pcVar17 = "\x1b%c";
LAB_2302c1fa:
          printf(pcVar17,pcVar11);
        }
      }
      else {
        if ((key2_4392 < '\0') && (key2_4392 = stat._0_1_, stat._0_1_ == 't')) {
          esc_tag[0] = '\x1b';
          esc_tag[1] = key1_4391;
          esc_tag_len = '\x02';
        }
        uVar9 = SEXT14(key2_4392);
        if (((uVar9 & 0xff) - 0x41 & 0xff) < 2) {
          pcVar17 = pcVar10;
          if (uVar9 == 0x41) {
            iVar14 = cli->his_idx;
            iVar19 = iVar14;
            do {
              iVar19 = (iVar19 + 0xff) % 0x100;
              if (cli->history[iVar19] != '\0') {
                if (iVar14 != iVar19) {
                  do {
                    iVar19 = (iVar19 + 0xff) % 0x100;
                  } while (cli->history[iVar19] != '\0');
                  iVar19 = (iVar19 + 1) % 0x100;
                }
                break;
              }
            } while (iVar14 != iVar19);
            cli->his_idx = iVar19;
            while (pcVar4->history[iVar14] != '\0') {
              *pcVar17 = pcVar4->history[iVar14];
              iVar14 = (iVar14 + 1) % 0x100;
              pcVar17 = pcVar17 + 1;
            }
          }
          else {
            iVar14 = cli->his_idx;
            iVar19 = iVar14;
            while (cli->history[iVar19] != '\0') {
              iVar19 = (iVar19 + 1) % 0x100;
            }
            if (iVar14 != iVar19) {
              do {
                iVar19 = (iVar19 + 1) % 0x100;
              } while (cli->history[iVar19] == '\0');
            }
            cli->his_idx = iVar19;
            while (pcVar4->history[iVar14] != '\0') {
              *pcVar17 = pcVar4->history[iVar14];
              iVar14 = (iVar14 + 1) % 0x100;
              pcVar17 = pcVar17 + 1;
            }
          }
          *pcVar17 = '\0';
          printf("\r\n# %s",pcVar10);
          sVar7 = strlen(pcVar10);
          pcVar3->bp = sVar7;
          esc_tag[0] = '\0';
          esc_tag_len = '\0';
        }
        else {
          if (uVar9 == 0x74) {
            uVar9 = (uint)esc_tag_len;
            if (0x3f < uVar9) {
              esc_tag[0] = '\0';
              esc_tag_len = '\0';
              esc_4390 = '\0';
              printf("Error: esc_tag buffer overflow\r\n");
              uVar5 = esc_tag_len;
              goto LAB_2302c092;
            }
            uVar13 = uVar9 + 1 & 0xff;
            esc_tag[uVar9] = stat._0_1_;
            pcVar4 = cli;
            uVar5 = (uint8_t)uVar13;
            if (uVar16 != 0x6d) goto LAB_2302c092;
            esc_tag[uVar13] = '\0';
            esc_tag_len = esc_tag_len + '\x02';
            if (pcVar4->echo_disabled == 0) {
              pcVar11 = esc_tag;
              pcVar17 = "%s";
              goto LAB_2302c1fa;
            }
          }
          else {
            pcVar10[pcVar3->bp] = '\x1b';
            uVar16 = pcVar3->bp + 1;
            pcVar3->bp = uVar16;
            pcVar10[uVar16] = cVar2;
            uVar16 = pcVar3->bp + 1;
            pcVar3->bp = uVar16;
            pcVar10[uVar16] = (char)(uVar9 & 0xff);
            pcVar3->bp = pcVar3->bp + 1;
            if (cli->echo_disabled == 0) {
              printf("\x1b%c%c");
            }
            esc_tag[0] = '\0';
            esc_tag_len = '\0';
          }
        }
      }
      esc_4390 = '\0';
      uVar5 = esc_tag_len;
      goto LAB_2302c092;
    }
    pcVar10[pcVar3->bp] = '\0';
    pcVar10 = pcVar4->inbuf;
    pcVar3->bp = 0;
    sVar7 = strlen(pcVar10);
    if (sVar7 != 0) {
      pcVar11 = cli->inbuf;
      sVar7 = strlen(pcVar11);
      pcVar3 = cli;
      sVar7 = sVar7 + 1;
      iVar18 = cli->his_cur;
      __n = 0x100 - iVar18;
      cli->his_idx = iVar18;
      pcVar17 = pcVar3->history + iVar18;
      iVar19 = iVar18 + sVar7 + -1;
      if ((int)__n < (int)sVar7) {
        iVar19 = iVar19 % 0x100;
        cVar2 = pcVar3->history[iVar19];
        strncpy(pcVar17,pcVar11,__n);
        sVar7 = sVar7 - __n;
        pcVar11 = pcVar11 + __n;
        pcVar17 = cli->history;
      }
      else {
        cVar2 = pcVar3->history[iVar18 + sVar7 + -1];
      }
      strncpy(pcVar17,pcVar11,sVar7);
      pcVar3 = cli;
      iVar18 = (iVar19 + 1) % 0x100;
      cli->his_cur = iVar18;
      if (cVar2 != '\0') {
        while (iVar19 = (int)pcVar3->dynamic_cmds + iVar18 + -0xc, *(char *)(iVar19 + 0x144) != '\0'
              ) {
          *(undefined *)(iVar19 + 0x144) = 0;
          iVar18 = (iVar18 + 1) % 0x100;
        }
      }
    }
    stat = (anon_struct_conflict181dab)0x0;
    memset(argvall_4313,0,0x100);
    memset(&stat,0,0x10);
    memset(&uStack84,0,4);
    iVar18 = 0;
    paVar6 = &stat;
    iVar19 = 0;
    do {
      pbVar15 = (byte *)(pcVar10 + iVar18);
      bVar1 = *pbVar15;
      if (bVar1 != 0x20) {
        if (0x20 < bVar1) {
          if (bVar1 == 0x22) {
            if (((iVar18 == 0) || (pcVar17 = pcVar10 + iVar18 + -1, *pcVar17 != '\\')) ||
               ((uStack84 & 1) == 0)) {
              uVar16 = uStack84 & 3;
              if (uVar16 != 1) {
                if (uVar16 == 2) goto LAB_2302c80a;
                if (uVar16 == 0) {
                  aVar12 = *paVar6;
                  uStack84 = uStack84 & 0xfffffffc | 3;
                  *paVar6 = (anon_struct_conflict181dab)((int)aVar12 + 1);
                  *(char **)(argvall_4313 + (iVar19 * 0x10 + (int)aVar12) * 4) =
                       pcVar10 + iVar18 + 1;
                }
                else {
                  if (uVar16 == 3) {
                    uStack84._0_1_ = (byte)uStack84 & 0xfc;
                    goto LAB_2302c7d0;
                  }
                }
              }
            }
            else {
LAB_2302c76c:
              iVar18 = iVar18 + -1;
              sVar7 = strlen((char *)pbVar15);
              memcpy(pcVar17,pbVar15,sVar7 + 1);
            }
          }
          else {
            if (bVar1 != 0x3b) goto LAB_2302c13a;
            if (((iVar18 != 0) && (pcVar17 = pcVar10 + iVar18 + -1, *pcVar17 == '\\')) &&
               ((uStack84 & 1) != 0)) goto LAB_2302c76c;
            if ((uStack84 & 2) != 0) goto LAB_2302c80a;
            if ((uStack84 & 3) == 1) {
              uStack84 = uStack84 & 0xfffffffe;
              *pbVar15 = 0;
              if ((*paVar6 != (anon_struct_conflict181dab)0x0) && (iVar19 = iVar19 + 1, iVar19 < 4))
              {
                paVar6 = &stat + iVar19;
              }
            }
          }
          goto LAB_2302c6c4;
        }
        if (bVar1 != 0) {
LAB_2302c13a:
          if ((uStack84 & 1) == 0) {
            aVar12 = *paVar6;
            uStack84 = uStack84 | 1;
            *paVar6 = (anon_struct_conflict181dab)((int)aVar12 + 1);
            *(byte **)(argvall_4313 + (iVar19 * 0x10 + (int)aVar12) * 4) = pbVar15;
          }
          goto LAB_2302c6c4;
        }
        if ((uStack84 & 2) == 0) {
          uStack84 = uStack84 | 4;
          goto LAB_2302c6c4;
        }
LAB_2302c80a:
        aos_cli_printf("syntax error\r\n");
        goto LAB_2302c72c;
      }
      if (((iVar18 != 0) && (pcVar17 = pcVar10 + iVar18 + -1, *pcVar17 == '\\')) &&
         ((uStack84 & 1) != 0)) goto LAB_2302c76c;
      if ((uStack84 & 3) == 1) {
        uStack84._0_1_ = (byte)uStack84 & 0xfe;
LAB_2302c7d0:
        uStack84 = uStack84 & 0xffffff00 | (uint)(byte)uStack84;
        *pbVar15 = 0;
      }
LAB_2302c6c4:
    } while ((((uStack84 & 4) == 0) && (iVar18 = iVar18 + 1, iVar18 < 0x100)) &&
            ((iVar19 < 4 && ((int)*paVar6 < 0x10))));
    if ((uStack84 & 2) != 0) goto LAB_2302c80a;
    paVar6 = &stat;
    argv = argvall_4313;
    uVar16 = 0;
    iVar18 = 0;
    do {
      iVar18 = iVar18 + 1;
      uVar9 = proc_onecmd((int)*paVar6,(char **)argv);
      uVar16 = uVar16 | uVar9;
      if (iVar19 < iVar18) break;
      paVar6 = paVar6 + 1;
      argv = (undefined1 *)((int)argv + 0x40);
    } while (iVar18 != 4);
    if (uVar16 == 1) {
      if (pcVar10 != (char *)0x0) {
        aos_cli_printf("command \'%s\' not found\r\n",pcVar10);
      }
    }
    else {
      if (uVar16 == 2) goto LAB_2302c80a;
    }
LAB_2302c72c:
    aos_cli_printf("\r\n");
    esc_tag[0] = '\0';
    esc_tag_len = '\0';
    pcVar10 = "# ";
    goto LAB_2302c170;
  }
  pcVar10 = "inbuf_null\r\n";
LAB_2302c170:
  aos_cli_printf(pcVar10);
LAB_2302c598:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
LAB_2302c556:
  if (cli->echo_disabled == 0) {
    printf("%c",uVar16);
  }
  uVar16 = pcVar3->bp + 1;
  pcVar3->bp = uVar16;
  uVar5 = esc_tag_len;
  if (0xff < uVar16) goto code_r0x2302c57c;
  goto LAB_2302c092;
code_r0x2302c57c:
  aos_cli_printf("Error: input buffer overflow\r\n");
  aos_cli_printf("# ");
  pcVar3->bp = 0;
  goto LAB_2302c598;
}



void console_cb_read(int fd,void *param)

{
  ssize_t count;
  char acStack32 [4];
  char buffer [16];
  
  count = aos_read(fd,acStack32,0x10);
  if (0 < count) {
    if (count < 0x11) {
      fd_console = fd;
      cli_main_input(acStack32,count);
    }
    else {
      printf("-------------BUG from aos_read for ret\r\n");
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: qry
// WARNING: Could not reconcile some variable overlaps

void get_dns_request(void *arg,udp_pcb *upcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u16_t uVar1;
  int iVar2;
  pbuf *buf;
  short sVar3;
  char *pcVar4;
  char *dataptr;
  ushort uVar5;
  uint local_50;
  int len;
  dns_ans_hdr hdr;
  dns_ans_hdr hdr_1;
  dns_ans_ans qry;
  
  *(udp_pcb **)((int)arg + 0x108) = upcb;
  *(ip_addr_t **)((int)arg + 0x10c) = addr;
  *(u16_t *)((int)arg + 0x110) = port;
  if (0xb < p->tot_len) {
    pbuf_copy_partial(p,&len,0xc,0);
    uVar1 = lwip_htons((u16_t)len);
    *(u16_t *)((int)arg + 0x100) = uVar1;
    uVar1 = lwip_htons(hdr.id);
    *(u16_t *)((int)arg + 0x102) = uVar1;
    local_50 = (uint)p->tot_len;
    if (0xff < local_50) {
      local_50 = 0xff;
    }
    pbuf_copy_partial(p,arg,(u16_t)local_50,0xc);
    iVar2 = utils_dns_domain_get((uint8_t *)arg,(uint8_t *)arg,(int *)&local_50);
    if (iVar2 == 0) {
      if ((0 < (int)local_50) && (*(char *)((int)arg + (local_50 - 1)) == '.')) {
        local_50 = local_50 - 1;
      }
      *(undefined *)(local_50 + (int)arg) = 0;
    }
  }
  pbuf_free(p);
  buf = pbuf_alloc(PBUF_TRANSPORT,0x200,PBUF_RAM);
  if (buf != (pbuf *)0x0) {
    memset(&hdr.numauthrr,0,0xc);
    pcVar4 = (char *)((int)arg + -1);
    uVar1 = 0xc;
    hdr.numauthrr = lwip_htons(*(u16_t *)((int)arg + 0x100));
    hdr.numextrarr = lwip_htons(0x8180);
    hdr_1.id = lwip_htons(1);
    hdr_1.flag = lwip_htons(1);
    hdr_1.numquestions = lwip_htons(0);
    hdr_1.numanswers = lwip_htons(0);
    pbuf_take(buf,&hdr.numauthrr,0xc);
    do {
      dataptr = pcVar4 + 1;
      uVar5 = 0;
      pcVar4 = dataptr;
      while ((*pcVar4 != '.' && (*pcVar4 != '\0'))) {
        uVar5 = uVar5 + 1 & 0xff;
        pcVar4 = pcVar4 + 1;
      }
      pbuf_put_at(buf,uVar1,(u8_t)uVar5);
      sVar3 = uVar1 + uVar5;
      pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(pcVar4 + -(int)dataptr) * 0x10000) >> 0x10),
                   uVar1 + 1);
      uVar1 = sVar3 + 1;
    } while (*pcVar4 != '\0');
    pbuf_put_at(buf,uVar1,'\0');
    hdr_1.numauthrr = lwip_htons(1);
    hdr_1.numextrarr = lwip_htons(1);
    lwip_htons(0xc00c);
    lwip_htons(1);
    lwip_htons(1);
    lwip_htons(0);
    lwip_htonl(0x3c0004);
    lwip_htonl(0xc0a8a901);
    pbuf_take_at(buf,&hdr_1.numauthrr,0x14,sVar3 + 2);
    pbuf_realloc(buf,sVar3 + 0x16);
    udp_sendto(*(udp_pcb **)((int)arg + 0x108),buf,*(ip_addr_t **)((int)arg + 0x10c),
               *(u16_t *)((int)arg + 0x110));
    pbuf_free(buf);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dns_server_init(void)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  void *__s;
  
  pcb = udp_new();
  if (pcb == (udp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  eVar1 = udp_bind(pcb,&ip_addr_any,0x35);
  if ((CONCAT31(extraout_var,eVar1) == 0) && (__s = pvPortMalloc(0x114), __s != (void *)0x0)) {
    memset(__s,0,4);
    udp_recv(pcb,get_dns_request,__s);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  udp_remove(pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



EfErrCode easyflash_init(void)

{
  int iVar1;
  EfErrCode EVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  char *format;
  size_t local_18;
  size_t default_env_set_size;
  ef_env *default_env_set;
  
  local_18 = 0;
  EVar2 = ef_port_init((ef_env **)&default_env_set_size,&local_18);
  iVar1 = CONCAT31(extraout_var,EVar2);
  if (iVar1 == 0) {
    EVar2 = ef_env_init((ef_env *)default_env_set_size,local_18);
    iVar1 = CONCAT31(extraout_var_00,EVar2);
    if (iVar1 == 0) {
      format = "EasyFlash V%s is initialize success.\r\n";
      goto LAB_2302cb10;
    }
  }
  format = "EasyFlash V%s is initialize fail.\r\n";
LAB_2302cb10:
  ef_log_info(format,&UNK_23081918);
  ef_log_info("You can get the latest version on https://github.com/armink/EasyFlash .\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)iVar1;
}



size_t get_status(uint8_t *status_table,size_t status_num)

{
  size_t sVar1;
  size_t sVar2;
  
  sVar2 = status_num - 1;
  do {
    sVar1 = sVar2;
    sVar2 = sVar1 - 1;
    if (sVar2 == 0xffffffff) break;
  } while (status_table[sVar2] != '\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



void update_sector_cache(uint32_t sec_addr,uint32_t empty_addr)

{
  sector_cache_node *psVar1;
  int iVar2;
  int iVar3;
  uint32_t uVar4;
  
  psVar1 = sector_cache_table;
  iVar2 = 4;
  iVar3 = 0;
  do {
    uVar4 = psVar1->addr;
    if ((sec_addr < empty_addr) && (empty_addr < sec_addr + 0x1000)) {
      if (sec_addr == uVar4) {
        psVar1 = sector_cache_table + iVar3;
        goto LAB_2302cb84;
      }
      if ((uVar4 == 0xffffffff) && (iVar2 == 4)) {
        iVar2 = iVar3;
      }
    }
    else {
      if (sec_addr == uVar4) {
        sector_cache_table[iVar3].addr = 0xffffffff;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    iVar3 = iVar3 + 1;
    psVar1 = psVar1 + 1;
  } while (iVar3 != 4);
  if (iVar2 != 4) {
    psVar1 = sector_cache_table + iVar2;
    psVar1->addr = sec_addr;
LAB_2302cb84:
    psVar1->empty_addr = empty_addr;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t get_next_sector_addr(sector_meta_data_t pre_sec)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = env_start_addr;
  if (pre_sec->addr != 0xffffffff) {
    if (pre_sec->combined == 0xffffffff) {
      iVar1 = 0x1000;
    }
    else {
      iVar1 = pre_sec->combined << 0xc;
    }
    uVar2 = iVar1 + pre_sec->addr;
    if (env_start_addr + 0x8000 <= uVar2) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0xffffffff;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



_Bool gc_check_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok != false) {
                    // WARNING: Load size is inaccurate
    *(int *)arg1 = *arg1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void update_env_cache(char *name,size_t name_len,uint32_t addr)

{
  uint32_t uVar1;
  int iVar2;
  env_cache_node *peVar3;
  int iVar4;
  int iVar5;
  ushort uVar6;
  
  uVar1 = ef_calc_crc32(0,name,name_len);
  peVar3 = env_cache_table;
  uVar6 = 0xffff;
  iVar5 = 0x10;
  iVar2 = 0x10;
  iVar4 = 0;
  do {
    if (addr == 0xffffffff) {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        peVar3 = env_cache_table + iVar4;
        env_cache_table[iVar4].addr = 0xffffffff;
        goto LAB_2302cc82;
      }
    }
    else {
      if ((uint)peVar3->name_crc == uVar1 >> 0x10) {
        env_cache_table[iVar4].addr = addr;
        goto LAB_2302cc32;
      }
      if (peVar3->addr == 0xffffffff) {
        if (iVar2 == 0x10) {
          iVar2 = iVar4;
        }
      }
      else {
        if (peVar3->active != 0) {
          peVar3->active = peVar3->active - 1;
        }
        if (peVar3->active < uVar6) {
          iVar5 = iVar4;
          uVar6 = peVar3->active;
        }
      }
    }
    iVar4 = iVar4 + 1;
    peVar3 = peVar3 + 1;
  } while (iVar4 != 0x10);
  if ((iVar2 != 0x10) || (iVar2 = iVar5, iVar5 != 0x10)) {
    peVar3 = env_cache_table + iVar2;
    env_cache_table[iVar2].addr = addr;
    peVar3->name_crc = (uint16_t)(uVar1 >> 0x10);
LAB_2302cc82:
    peVar3->active = 0;
  }
LAB_2302cc32:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool find_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  char cVar1;
  size_t sVar2;
  int iVar3;
  
  sVar2 = strlen((char *)arg1);
  if ((((env->name_len == sVar2) && (cVar1 = env->crc_is_ok, (_Bool)cVar1 != false)) &&
      (env->status == ENV_WRITE)) &&
     (iVar3 = strncmp(env->name,(char *)arg1,(uint)env->name_len), iVar3 == 0)) {
    *(undefined *)arg2 = 1;
  }
  else {
    cVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar1;
}



_Bool sector_statistics_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_store_status_t sVar1;
  
  if (sector->check_ok != false) {
    sVar1 = (sector->status).store;
    if (sVar1 == SECTOR_STORE_EMPTY) {
                    // WARNING: Load size is inaccurate
      *(int *)arg1 = *arg1 + 1;
    }
    else {
      if (sVar1 == SECTOR_STORE_USING) {
                    // WARNING: Load size is inaccurate
        *(int *)arg2 = *arg2 + 1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool alloc_env_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  sector_dirty_status_t sVar1;
  char cVar2;
  
  cVar2 = sector->check_ok;
  if ((_Bool)cVar2 != false) {
                    // WARNING: Load size is inaccurate
    if ((*arg1 < sector->remain) &&
       ((sVar1 = (sector->status).dirty, sVar1 == SECTOR_DIRTY_FALSE ||
        ((sVar1 == SECTOR_DIRTY_TRUE && (gc_request == false)))))) {
      *(uint32_t *)arg2 = sector->empty_env;
    }
    else {
      cVar2 = '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar2;
}



EfErrCode write_status(uint32_t addr,uint8_t *status_table,size_t status_num,size_t status_index)

{
  EfErrCode EVar1;
  
  if (status_num <= status_index) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x111,
                 "(%s) has assert failed at %s.\r\n","status_index < status_num","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (status_table == (uint8_t *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x112,
                 "(%s) has assert failed at %s.\r\n","status_table","write_status");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(status_table,0xff,status_num * 8 - 1 >> 3);
  status_table[status_index - 1] = 0;
  EVar1 = ef_port_write(addr + (status_index - 1),(uint32_t *)(status_table + (status_index - 1)),1)
  ;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar1;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_env(env_node_obj_t env)

{
  uint uVar1;
  uint32_t uVar2;
  size_t sVar3;
  uint uVar4;
  uint32_t uStack92;
  env_hdr_data env_hdr;
  uint8_t buf [32];
  
  ef_port_read((env->addr).start,&uStack92,0x1c);
  sVar3 = get_status((uint8_t *)&uStack92,6);
  env->status = (env_status_t)(sVar3 & 0xff);
  env->len = env_hdr.magic;
  uVar4 = env_hdr.magic - 0x14;
  if (uVar4 < 0x7fed) {
    if (env_hdr.magic - 0xfed < 0x7013) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x223
                   ,"(%s) has assert failed at %s.\r\n","0","read_env");
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
    uVar1 = 0;
    uVar2 = 0;
    while (uVar1 < uVar4) {
      sVar3 = 0x20;
      if (uVar4 <= uVar1 + 0x20) {
        sVar3 = uVar4 - uVar1;
      }
      ef_port_read((env->addr).start + 0x14 + uVar1,&env_hdr.value_len,sVar3);
      uVar2 = ef_calc_crc32(uVar2,&env_hdr.value_len,sVar3);
      uVar1 = uVar1 + sVar3;
    }
    if (env_hdr.len == uVar2) {
      uVar2 = (env->addr).start + 0x1c;
      env->crc_is_ok = true;
      ef_port_read(uVar2,(uint32_t *)env->name,(uint)(byte)env_hdr.crc32);
      (env->addr).value = uVar2 + (byte)env_hdr.crc32;
      env->value_len = env_hdr._20_4_;
      env->name_len = (byte)env_hdr.crc32;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return EF_NO_ERR;
    }
  }
  else {
    env->len = 0x1c;
    if ((sVar3 & 0xff) != 5) {
      env->status = ENV_ERR_HDR;
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x21c
                   ,"Error: The ENV @0x%08X length has an error.\r\n",(env->addr).start);
      write_status((env->addr).start,(uint8_t *)&uStack92,6,5);
    }
  }
  env->crc_is_ok = false;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EF_READ_ERR;
}



// WARNING: Variable defined which should be unmapped: status_table

EfErrCode update_sec_status(sector_meta_data_t sector,size_t new_env_len,_Bool *is_full)

{
  sector_store_status_t sVar1;
  EfErrCode EVar2;
  uint8_t auStack20 [4];
  uint8_t status_table [3];
  
  sVar1 = (sector->status).store;
  if (sVar1 == SECTOR_STORE_EMPTY) {
    EVar2 = write_status(sector->addr,auStack20,4,2);
  }
  else {
    EVar2 = EF_NO_ERR;
    if (sVar1 == SECTOR_STORE_USING) {
      if ((sector->remain < 0x5c) || (sector->remain - new_env_len < 0x5c)) {
        EVar2 = write_status(sector->addr,auStack20,4,3);
        update_sector_cache(sector->addr,sector->addr + 0x1000);
        if (is_full != (_Bool *)0x0) {
          *is_full = true;
        }
      }
      else {
        if (is_full != (_Bool *)0x0) {
          *is_full = false;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps

EfErrCode format_sector(uint32_t addr)

{
  uint uVar1;
  EfErrCode EVar2;
  undefined3 extraout_var;
  undefined4 uStack36;
  sector_hdr_data sec_hdr;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x3b5,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0","format_sector");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  EVar2 = ef_port_erase(addr,0x1000);
  uVar1 = CONCAT31(extraout_var,EVar2);
  if (uVar1 == 0) {
    memset(&uStack36,0xff,0x14);
    memset(&uStack36,0xff,3);
    uStack36._0_1_ = 0;
    memset((undefined *)((int)&uStack36 + 3),0xff,3);
    sec_hdr._4_4_ = 0x30344645;
    uStack36._3_1_ = 0;
    sec_hdr.magic = 0xffffffff;
    sec_hdr.combined = 0xffffffff;
    EVar2 = ef_port_write(addr,&uStack36,0x14);
    uVar1 = (uint)EVar2;
    update_sector_cache(addr,addr + 0x1000);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)uVar1;
}



_Bool check_sec_hdr_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if (sector->check_ok == false) {
    ef_log_info("Warning: Sector header check failed. Format this sector (0x%08x).\r\n",sector->addr
               );
                    // WARNING: Load size is inaccurate
    *(int *)arg1 = *arg1 + 1;
    format_sector(sector->addr);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool print_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  _Bool _Var1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t size;
  int iVar5;
  char cVar6;
  uint32_t local_50;
  uint8_t buf [32];
  
  _Var1 = env->crc_is_ok;
  if ((_Var1 != false) &&
     (*(uint32_t *)arg1 = *arg1 + env->len, env->status == ENV_WRITE
                    // WARNING: Load size is inaccurate)) {
    ef_print("%.*s=",(uint)env->name_len,env->name);
    if (env->value_len < 0xf8c) {
      iVar5 = 2;
      cVar6 = '\0';
      while( true ) {
        uVar2 = 0;
        while (uVar3 = env->value_len, uVar2 < uVar3) {
          size = 0x20;
          if (uVar3 <= uVar2 + 0x20) {
            size = uVar3 - uVar2;
          }
          ef_port_read((env->addr).value + uVar2,&local_50,size);
          sVar4 = 0;
          if (cVar6 == '\0') {
            while (size != sVar4) {
              if (0x5e < *(byte *)((int)&local_50 + sVar4) - 0x20) goto LAB_2302d108;
              sVar4 = sVar4 + 1;
            }
          }
          else {
            ef_print("%.*s",size,&local_50);
          }
          uVar2 = uVar2 + size;
        }
        if (iVar5 == 1) break;
        iVar5 = 1;
        cVar6 = _Var1;
      }
    }
    else {
LAB_2302d108:
      ef_print("blob @0x%08X %dbytes",(env->addr).value,env->value_len);
    }
    ef_print("\r\n");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Variable defined which should be unmapped: buf

uint32_t get_next_env_addr(sector_meta_data_t sector,env_node_obj_t pre_env)

{
  uint uVar1;
  uint32_t uVar2;
  sector_cache_node *psVar3;
  uint uVar4;
  int iVar5;
  uint32_t *puVar6;
  uint32_t uVar7;
  uint32_t local_40;
  uint8_t buf [32];
  
  if ((sector->status).store != SECTOR_STORE_EMPTY) {
    uVar4 = (pre_env->addr).start;
    uVar7 = sector->addr;
    if (uVar4 == 0xffffffff) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar7 + 0x14;
    }
    if (uVar4 <= uVar7 + 0x1000) {
      uVar1 = uVar4 + 1;
      if (pre_env->crc_is_ok != false) {
        uVar1 = pre_env->len + uVar4;
      }
      psVar3 = sector_cache_table;
      iVar5 = 0;
      do {
        if ((uVar1 & 0xfffff000) == psVar3->addr) {
          if (uVar1 == sector_cache_table[iVar5].empty_addr) goto LAB_2302d1b4;
          break;
        }
        iVar5 = iVar5 + 1;
        psVar3 = psVar3 + 1;
      } while (iVar5 != 4);
      uVar4 = uVar1;
      while (uVar4 < uVar7 + 0xfec) {
        ef_port_read(uVar4,&local_40,0x20);
        uVar2 = uVar4 - 8;
        puVar6 = &local_40;
        do {
          if (uVar7 + 0xfe4 == uVar2) break;
          if ((*puVar6 == 0x3034564b) && (uVar1 <= uVar2)) goto LAB_2302d1b6;
          uVar2 = uVar2 + 1;
          puVar6 = (uint32_t *)((int)puVar6 + 1);
        } while (uVar4 + 0x14 != uVar2);
        uVar4 = uVar4 + 0x1c;
      }
LAB_2302d1b4:
      uVar2 = 0xffffffff;
LAB_2302d1b6:
      if ((sector->addr + 0x1000 < uVar2) || (pre_env->len == 0)) {
        uVar2 = 0xffffffff;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xffffffff;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode read_sector_meta_data(uint32_t addr,sector_meta_data_t sector,_Bool traversal)

{
  uint8_t uVar1;
  EfErrCode EVar2;
  uint uVar3;
  size_t sVar4;
  undefined3 in_register_00002031;
  sector_cache_node *psVar5;
  int iVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  size_t sVar9;
  uint addr_00;
  uint8_t uVar10;
  uint32_t uVar11;
  undefined4 uStack188;
  sector_hdr_data sec_hdr;
  uint8_t buf [32];
  env_node_obj env_meta;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x24a,
                 "(%s) has assert failed at %s.\r\n","addr % SECTOR_SIZE == 0",
                 "read_sector_meta_data");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_read(addr,&uStack188,0x14);
  sector->addr = addr;
  sector->magic = sec_hdr._4_4_;
  if (sec_hdr._4_4_ == 0x30344645) {
    sector->combined = sec_hdr.magic;
    sector->check_ok = true;
    sVar4 = get_status((uint8_t *)&uStack188,4);
    uVar3 = sVar4 & 0xff;
    EVar2 = (EfErrCode)uVar3;
    (sector->status).store = EVar2;
    sVar4 = get_status((uint8_t *)((int)&uStack188 + 3),4);
    (sector->status).dirty = (sector_dirty_status_t)sVar4;
    if (CONCAT31(in_register_00002031,traversal) != 0) {
      sector->remain = 0;
      sector->empty_env = addr + 0x14;
      if (uVar3 == 1) {
        sector->remain = 0xfec;
      }
      else {
        if (uVar3 == 2) {
          psVar5 = sector_cache_table;
          iVar6 = 0;
          do {
            if (addr == psVar5->addr) {
              uVar7 = sector_cache_table[iVar6].empty_addr;
              sector->empty_env = uVar7;
              sector->remain = (addr + 0x1000) - uVar7;
              goto LAB_2302d302;
            }
            iVar6 = iVar6 + 1;
            psVar5 = psVar5 + 1;
          } while (iVar6 != 4);
          sector->remain = 0xfec;
          while (uVar7 = get_next_env_addr(sector,(env_node_obj_t)(buf + 0x1c)), uVar7 != 0xffffffff
                ) {
            read_env((env_node_obj_t)(buf + 0x1c));
            if ((buf[29] == '\0') && ((buf[28] & 0xfb) != 1)) {
              ef_log_info("Error: The ENV (@0x%08X) CRC32 check failed!\r\n",uVar7);
              sector->remain = 0;
              goto LAB_2302d3a0;
            }
            sector->empty_env = sector->empty_env + env_meta.magic;
            sector->remain = sector->remain - env_meta.magic;
          }
          EVar2 = EF_NO_ERR;
LAB_2302d3a0:
          uVar8 = sector->addr;
          uVar7 = sector->empty_env;
          uVar3 = uVar8 + 0x1000;
          uVar10 = '\0';
          uVar11 = uVar7;
          while (addr_00 = uVar11, addr_00 < uVar3) {
            uVar11 = addr_00 + 0x20;
            sVar4 = 0x20;
            if (uVar3 <= uVar11) {
              sVar4 = (uVar8 + 0x1020) - uVar11;
            }
            ef_port_read(addr_00,&sec_hdr.reserved,sVar4);
            sVar9 = 0;
            while (sVar4 != sVar9) {
              uVar1 = (&sec_hdr.status_table)[2].dirty[sVar9 + 1];
              if ((uVar10 != -1) && (uVar1 == -1)) {
                uVar7 = addr_00 + sVar9;
              }
              sVar9 = sVar9 + 1;
              uVar10 = uVar1;
            }
          }
          if (uVar10 != -1) {
            uVar7 = uVar3;
          }
          if (sector->empty_env != uVar7) {
            sector->empty_env = uVar7;
            sector->remain = (sector->addr + 0x1000) - uVar7;
          }
          update_sector_cache(sector->addr,sector->empty_env);
          goto LAB_2302d2ba;
        }
      }
    }
LAB_2302d302:
    EVar2 = EF_NO_ERR;
  }
  else {
    sector->check_ok = false;
    sector->combined = 0xffffffff;
    EVar2 = EF_ENV_INIT_FAILED;
  }
LAB_2302d2ba:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar2;
}



void sector_iterator(sector_meta_data_t sector,sector_store_status_t status,void *arg1,void *arg2,
                    anon_subr__Bool_sector_meta_data_t_void_ptr_void_ptr *callback,
                    _Bool traversal_env)

{
  _Bool _Var1;
  uint32_t addr;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  undefined3 in_register_0000203d;
  
  sector->addr = 0xffffffff;
  do {
    do {
      addr = get_next_sector_addr(sector);
      if (addr == 0xffffffff) goto LAB_2302d468;
      read_sector_meta_data(addr,sector,false);
    } while ((CONCAT31(in_register_0000202d,status) != 0) &&
            ((uint)(sector->status).store != CONCAT31(in_register_0000202d,status)));
    if (CONCAT31(in_register_0000203d,traversal_env) != 0) {
      read_sector_meta_data(addr,sector,true);
    }
    _Var1 = (*callback)(sector,arg1,arg2);
  } while (CONCAT31(extraout_var,_Var1) == 0);
LAB_2302d468:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: using_sector

uint32_t alloc_env(sector_meta_data_t sector,size_t env_size)

{
  size_t asStack36 [2];
  uint32_t local_1c;
  uint32_t empty_env;
  size_t empty_sector;
  size_t using_sector;
  
  local_1c = 0xffffffff;
  empty_env = 0;
  empty_sector = 0;
  asStack36[0] = env_size;
  sector_iterator(sector,SECTOR_STORE_UNUSED,&empty_env,&empty_sector,sector_statistics_cb,false);
  if (empty_sector != 0) {
    sector_iterator(sector,SECTOR_STORE_USING,asStack36,&local_1c,alloc_env_cb,true);
  }
  if ((empty_env != 0) && (local_1c == 0xffffffff)) {
    if ((empty_env < 2) && (gc_request == false)) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x42d
                   ,"Trigger a GC check after alloc ENV failed.\r\n");
      gc_request = true;
    }
    else {
      sector_iterator(sector,SECTOR_STORE_EMPTY,asStack36,&local_1c,alloc_env_cb,true);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return local_1c;
}



void gc_collect(void)

{
  uint uStack44;
  size_t empty_sec;
  sector_meta_data sector;
  
  uStack44 = 0;
  sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_EMPTY,&uStack44,(void *)0x0,
                  gc_check_cb,false);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4fa,
               "The remain empty sector is %d, GC threshold is %d.\r\n",uStack44,1);
  if (uStack44 < 2) {
    sector_iterator((sector_meta_data_t)&empty_sec,SECTOR_STORE_UNUSED,(void *)0x0,(void *)0x0,do_gc
                    ,false);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  gc_request = false;
  return;
}



uint32_t new_env(sector_meta_data_t sector,size_t env_size)

{
  uint32_t uVar1;
  
  uVar1 = alloc_env(sector,env_size);
  if ((uVar1 == 0xffffffff) && (gc_request != false)) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4b6,
                 "Warning: Alloc an ENV (size %d) failed when new ENV. Now will GC then retry.\r\n",
                 env_size);
    gc_collect();
    uVar1 = alloc_env(sector,env_size);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



_Bool check_and_recovery_gc_cb(sector_meta_data_t sector,void *arg1,void *arg2)

{
  if ((sector->check_ok != false) && ((sector->status).dirty == SECTOR_DIRTY_GC)) {
    gc_request = true;
    gc_collect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



void env_iterator(env_node_obj_t env,void *arg1,void *arg2,
                 anon_subr__Bool_env_node_obj_t_void_ptr_void_ptr *callback)

{
  EfErrCode EVar1;
  _Bool _Var2;
  uint32_t uVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined auStack56 [4];
  sector_meta_data sector;
  
  sector._0_4_ = 0xffffffff;
  do {
    do {
      uVar3 = get_next_sector_addr((sector_meta_data_t)auStack56);
      if (uVar3 == 0xffffffff) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      EVar1 = read_sector_meta_data(uVar3,(sector_meta_data_t)auStack56,false);
    } while ((CONCAT31(extraout_var,EVar1) != 0) || (1 < (byte)(auStack56[1] + ~SECTOR_STORE_EMPTY))
            );
    (env->addr).start = 0xffffffff;
    while( true ) {
      uVar3 = get_next_env_addr((sector_meta_data_t)auStack56,env);
      (env->addr).start = uVar3;
      if (uVar3 == 0xffffffff) break;
      read_env(env);
      _Var2 = (*callback)(env,arg1,arg2);
      if (CONCAT31(extraout_var_00,_Var2) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  } while( true );
}



_Bool find_env(char *key,env_node_obj_t env)

{
  char cVar1;
  int iVar2;
  size_t size;
  uint32_t uVar3;
  int iVar4;
  uint16_t uVar5;
  env_cache_node *peVar6;
  char local_70;
  char saved_name [64];
  
  size = strlen(key);
  uVar3 = ef_calc_crc32(0,key,size);
  peVar6 = env_cache_table;
  iVar2 = 0;
  do {
    if ((peVar6->addr != 0xffffffff) && ((uint)peVar6->name_crc == uVar3 >> 0x10)) {
      ef_port_read(peVar6->addr + 0x1c,(uint32_t *)&local_70,0x40);
      iVar4 = strncmp(key,&local_70,size);
      if (iVar4 == 0) {
        (env->addr).start = env_cache_table[iVar2].addr;
        uVar5 = 0xffff;
        if (env_cache_table[iVar2].active < 0xffef) {
          uVar5 = env_cache_table[iVar2].active + 0x10;
        }
        env_cache_table[iVar2].active = uVar5;
        read_env(env);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return true;
      }
    }
    iVar2 = iVar2 + 1;
    peVar6 = peVar6 + 1;
  } while (iVar2 != 0x10);
  local_70 = '\0';
  env_iterator(env,key,&local_70,find_env_cb);
  cVar1 = local_70;
  if (local_70 != '\0') {
    update_env_cache(key,size,(env->addr).start);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar1;
}



EfErrCode del_env(char *key,env_node_obj_t old_env,_Bool complete_del)

{
  uint uVar1;
  _Bool _Var2;
  EfErrCode EVar3;
  undefined3 extraout_var;
  uint32_t uVar4;
  undefined3 extraout_var_00;
  size_t sVar5;
  undefined3 extraout_var_01;
  size_t name_len;
  undefined3 in_register_00002031;
  uint32_t uStack128;
  uint8_t status_table [5];
  env_node_obj env;
  
  if (old_env == (env_node_obj_t)0x0) {
    _Var2 = find_env(key,(env_node_obj_t)(status_table + 4));
    if (CONCAT31(extraout_var,_Var2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x447
                   ,"Not found \'%s\' in ENV.\r\n",key);
      uVar1 = 4;
      goto LAB_2302d818;
    }
    old_env = (env_node_obj_t)(status_table + 4);
  }
  uVar4 = (old_env->addr).start;
  if (CONCAT31(in_register_00002031,complete_del) == 0) {
    EVar3 = write_status(uVar4,(uint8_t *)&uStack128,6,3);
    uVar1 = CONCAT31(extraout_var_00,EVar3);
    del_env::last_is_complete_del = true;
  }
  else {
    EVar3 = write_status(uVar4,(uint8_t *)&uStack128,6,4);
    uVar1 = CONCAT31(extraout_var_01,EVar3);
    if ((del_env::last_is_complete_del == false) && (uVar1 == 0)) {
      if (key == (char *)0x0) {
        name_len = (size_t)old_env->name_len;
        key = old_env->name;
      }
      else {
        name_len = strlen(key);
      }
      update_env_cache(key,name_len,0xffffffff);
    }
    del_env::last_is_complete_del = false;
  }
  if (uVar1 == 0) {
    uVar4 = ((old_env->addr).start & 0xfffff000) + 3;
    ef_port_read(uVar4,&uStack128,3);
    sVar5 = get_status((uint8_t *)&uStack128,4);
    if (sVar5 == 1) {
      EVar3 = write_status(uVar4,(uint8_t *)&uStack128,4,2);
      uVar1 = (uint)EVar3;
    }
  }
LAB_2302d818:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)uVar1;
}



EfErrCode move_env(env_node_obj_t env)

{
  EfErrCode EVar1;
  uint32_t addr;
  uint uVar2;
  size_t sVar3;
  uint uVar4;
  char *__src;
  char cStack229;
  undefined auStack228 [3];
  _Bool find_ok;
  sector_meta_data sector;
  uint8_t status_table [5];
  undefined auStack136 [4];
  env_node_obj env_bak;
  
  if (env->status == ENV_WRITE) {
    del_env((char *)0x0,env,false);
  }
  addr = alloc_env((sector_meta_data_t)auStack228,env->len);
  if (addr == 0xffffffff) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return EF_ENV_FULL;
  }
  __src = env->name;
  if (in_recovery_check != false) {
    memset(&sector.empty_env,0,0x41);
    strncpy((char *)&sector.empty_env,__src,(uint)env->name_len);
    cStack229 = '\0';
    env_iterator((env_node_obj_t)auStack136,&sector.empty_env,&cStack229,find_env_cb);
    EVar1 = EF_NO_ERR;
    if (cStack229 != '\0') goto __exit;
  }
  sVar3 = env->len;
  update_sec_status((sector_meta_data_t)auStack228,sVar3,(_Bool *)0x0);
  write_status(addr,(uint8_t *)&sector.empty_env,6,1);
  uVar4 = sVar3 - 8;
  uVar2 = 0;
  EVar1 = EF_NO_ERR;
  while (uVar2 < uVar4) {
    sVar3 = 0x20;
    if (uVar4 <= uVar2 + 0x20) {
      sVar3 = uVar4 - uVar2;
    }
    ef_port_read((env->addr).start + 8 + uVar2,(uint32_t *)auStack136,sVar3);
    EVar1 = ef_port_write(addr + 8 + uVar2,(uint32_t *)auStack136,sVar3);
    uVar2 = uVar2 + sVar3;
  }
  write_status(addr,(uint8_t *)&sector.empty_env,6,2);
  update_sector_cache(addr & 0xfffff000,env->value_len + 0x1c + (uint)env->name_len + addr);
  update_env_cache(__src,(uint)env->name_len,addr);
  ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4a6,
               "Moved the ENV (%.*s) from 0x%08X to 0x%08X.\r\n",(uint)env->name_len,__src,
               (env->addr).start,addr);
__exit:
  del_env((char *)0x0,env,true);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar1;
}



_Bool check_and_recovery_env_cb(env_node_obj_t env,void *arg1,void *arg2)

{
  char cVar1;
  EfErrCode EVar2;
  undefined3 extraout_var;
  uint8_t auStack24 [4];
  uint8_t status_table [5];
  
  cVar1 = env->crc_is_ok;
  if (((_Bool)cVar1 == false) || (env->status != ENV_PRE_DELETE)) {
    cVar1 = '\0';
    if (env->status == ENV_PRE_WRITE) {
      write_status((env->addr).start,auStack24,6,5);
      cVar1 = '\x01';
    }
  }
  else {
    ef_log_info("Found an ENV (%.*s) which has changed value failed. Now will recovery it.\r\n",
                (uint)env->name_len,env->name);
    EVar2 = move_env(env);
    if (CONCAT31(extraout_var,EVar2) == 0) {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d5
                   ,"Recovery the ENV successful.\r\n");
      cVar1 = '\0';
    }
    else {
      ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x6d7
                   ,
                   "Warning: Moved an ENV (size %d) failed when recovery. Now will GC then retry.\r\n"
                   ,env->len);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar1;
}



// WARNING: Could not reconcile some variable overlaps

_Bool do_gc(sector_meta_data_t sector,void *arg1,void *arg2)

{
  EfErrCode EVar1;
  undefined3 extraout_var;
  uint8_t auStack124 [4];
  uint8_t status_table [3];
  env_node_obj env;
  
  if ((sector->check_ok != false) && ((byte)((sector->status).dirty + ~SECTOR_DIRTY_FALSE) < 2)) {
    write_status(sector->addr + 3,auStack124,4,3);
    env.name._60_4_ = 0xffffffff;
    while( true ) {
      env.name._60_4_ = get_next_env_addr(sector,(env_node_obj_t)status_table);
      if (env.name._60_4_ == 0xffffffff) break;
      read_env((env_node_obj_t)status_table);
      if ((((_Bool)status_table[1] != false) && ((byte)(status_table[0] + ~ENV_PRE_WRITE) < 2)) &&
         (EVar1 = move_env((env_node_obj_t)status_table), CONCAT31(extraout_var,EVar1) != 0)) {
        ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",
                     0x4e1,"Error: Moved the ENV (%.*s) for GC failed.\r\n",(uint)status_table[2],
                     &env.value_len);
      }
    }
    format_sector(sector->addr);
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x4e6,
                 "Collect a sector @0x%08X\r\n",sector->addr);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return false;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



// WARNING: Could not reconcile some variable overlaps

EfErrCode create_env_blob(sector_meta_data_t sector,char *key,void *value,size_t len)

{
  size_t size;
  int iVar1;
  uint uVar2;
  uint32_t addr;
  EfErrCode EVar3;
  size_t sVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined auStack64 [3];
  _Bool _Stack61;
  uint8_t align_data [1];
  _Bool is_full;
  env_hdr_data env_hdr;
  
  addr = sector->empty_env;
  _Stack61 = false;
  sVar4 = strlen(key);
  if (sVar4 < 0x41) {
    memset(align_data,0xff,0x1c);
    env_hdr._4_4_ = 0x3034564b;
    sVar4 = strlen(key);
    env_hdr.crc32._0_1_ = (byte)sVar4;
    env_hdr.magic = len + 0x1c + (sVar4 & 0xff);
    env_hdr._20_4_ = len;
    if (env_hdr.magic < 0xfed) {
      if (addr == 0xffffffff) {
        addr = new_env(sector,env_hdr.magic);
        iVar1 = 6;
        if (addr == 0xffffffff) goto LAB_2302db38;
      }
      EVar3 = update_sec_status(sector,env_hdr.magic,&_Stack61);
      iVar1 = CONCAT31(extraout_var,EVar3);
      if (iVar1 == 0) {
        env_hdr.len = ef_calc_crc32(0,&env_hdr.crc32,8);
        env_hdr.len = ef_calc_crc32(env_hdr.len,key,(uint)(byte)env_hdr.crc32);
        env_hdr.len = ef_calc_crc32(env_hdr.len,value,env_hdr._20_4_);
        EVar3 = write_status(addr,align_data,6,1);
        iVar1 = CONCAT31(extraout_var_00,EVar3);
        if (iVar1 == 0) {
          EVar3 = ef_port_write(addr + 8,(uint32_t *)(env_hdr.status_table + 4),0x14);
          iVar1 = CONCAT31(extraout_var_01,EVar3);
          if (iVar1 == 0) {
            uVar2 = (uint)(byte)env_hdr.crc32;
            memset(auStack64,0xff,1);
            EVar3 = ef_port_write(addr + 0x1c,(uint32_t *)key,uVar2);
            iVar1 = CONCAT31(extraout_var_02,EVar3);
            if (_Stack61 == false) {
              update_sector_cache(sector->addr,
                                  env_hdr._20_4_ + 0x1c + (uint)(byte)env_hdr.crc32 + addr);
            }
            update_env_cache(key,(uint)(byte)env_hdr.crc32,addr);
            size = env_hdr._20_4_;
            if (iVar1 == 0) {
              uVar2 = (uint)(byte)env_hdr.crc32;
              memset(auStack64,0xff,1);
              EVar3 = ef_port_write(uVar2 + 0x1c + addr,(uint32_t *)value,size);
              iVar1 = CONCAT31(extraout_var_03,EVar3);
              if (iVar1 == 0) {
                EVar3 = write_status(addr,align_data,6,2);
                iVar1 = CONCAT31(extraout_var_04,EVar3);
                if ((iVar1 == 0) && (_Stack61 != false)) {
                  ef_log_debug(
                               "/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c"
                               ,0x562,"Trigger a GC check after created ENV.\r\n");
                  gc_request = true;
                }
              }
            }
          }
        }
      }
    }
    else {
      ef_log_info("Error: The ENV size is too big\r\n");
      iVar1 = 6;
    }
  }
  else {
    ef_log_info("Error: The ENV name length is more than %d\r\n",0x40);
    iVar1 = 4;
  }
LAB_2302db38:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)iVar1;
}



size_t ef_get_env_blob(char *key,void *value_buf,size_t buf_len,size_t *saved_value_len)

{
  size_t sVar1;
  _Bool _Var2;
  TickType_t TVar3;
  char *format;
  size_t sVar4;
  undefined3 extraout_var;
  undefined4 uVar5;
  undefined auStack120 [4];
  env_node_obj env;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    sVar1 = 0;
  }
  else {
    if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      uVar5 = 0x34c;
      format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
    }
    else {
      sVar4 = strlen(key);
      if (sVar4 < 0x41) {
        ef_port_env_lock();
        _Var2 = find_env(key,(env_node_obj_t)auStack120);
        sVar1 = 0;
        if (CONCAT31(extraout_var,_Var2) != 0) {
          if (saved_value_len != (size_t *)0x0) {
            *saved_value_len = env.len;
          }
          if (env.len < buf_len) {
            buf_len = env.len;
          }
          ef_port_read(env.addr.start,(uint32_t *)value_buf,buf_len);
          sVar1 = buf_len;
        }
        ef_port_env_unlock();
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return sVar1;
      }
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      key = (char *)strlen(key);
      value_buf = (void *)0x40;
      uVar5 = 0x351;
      format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    }
    bl_printk(format,TVar3,&DAT_23081ce8,&UNK_23081cdc,uVar5,key,value_buf);
    sVar1 = 8;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



EfErrCode ef_del_env(char *key)

{
  EfErrCode EVar1;
  TickType_t TVar2;
  size_t sVar3;
  EfErrCode result;
  
  if (init_ok == false) {
    ef_log_info("Error: ENV isn\'t initialize OK.\r\n");
    EVar1 = EF_ENV_INIT_FAILED;
  }
  else {
    if ((key == (char *)0x0) || (sVar3 = strlen(key), 0x40 < sVar3)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] key = %p\r\n",TVar2,&DAT_23081ce8,&UNK_23081cdc,0x57d,key);
      EVar1 = EF_NO_ERR;
    }
    else {
      ef_port_env_lock();
      EVar1 = del_env(key,(env_node_obj_t)0x0,true);
      ef_port_env_unlock();
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar1;
}



EfErrCode ef_set_env_blob(char *key,void *value_buf,size_t buf_len)

{
  uint uVar1;
  _Bool _Var2;
  EfErrCode EVar3;
  TickType_t TVar4;
  char *format;
  size_t sVar5;
  uint32_t uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined4 uVar7;
  
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return EF_ENV_INIT_FAILED;
  }
  if ((key == (char *)0x0) || (value_buf == (void *)0x0)) {
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x5d4;
    format = "[%10u][%s: %s:%4d] key = %p, value_buf = %p\r\n";
LAB_2302de8c:
    bl_printk(format,TVar4,&DAT_23081ce8,&UNK_23081cdc,uVar7,key,value_buf);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return EF_ENV_ARG_ERR;
  }
  sVar5 = strlen(key);
  if (0x40 < sVar5) {
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    key = (char *)strlen(key);
    value_buf = (void *)0x40;
    uVar7 = 0x5d9;
    format = "[%10u][%s: %s:%4d] key err. %d > %d\r\n";
    goto LAB_2302de8c;
  }
  if (0xf8c < buf_len) {
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    value_buf = (void *)0xf8c;
    uVar7 = 0x5de;
    format = "[%10u][%s: %s:%4d] buf_len err. %d > %d\r\n";
    key = (char *)buf_len;
    goto LAB_2302de8c;
  }
  ef_port_env_lock();
  sVar5 = strlen(key);
  uVar6 = new_env((sector_meta_data_t)sector_3152,buf_len + 0x1c + sVar5);
  EVar3 = EF_ENV_FULL;
  if (uVar6 == 0xffffffff) goto LAB_2302dfa8;
  _Var2 = find_env(key,(env_node_obj_t)env_3151);
  if (CONCAT31(extraout_var,_Var2) == 0) {
LAB_2302df64:
    EVar3 = create_env_blob((sector_meta_data_t)sector_3152,key,value_buf,buf_len);
    uVar1 = CONCAT31(extraout_var_00,EVar3);
    if ((CONCAT31(extraout_var,_Var2) != 0) && (uVar1 == 0)) {
      EVar3 = del_env(key,(env_node_obj_t)env_3151,true);
      uVar1 = (uint)EVar3;
    }
  }
  else {
    EVar3 = del_env(key,(env_node_obj_t)env_3151,false);
    uVar1 = CONCAT31(extraout_var_01,EVar3);
    if (uVar1 == 0) goto LAB_2302df64;
  }
  EVar3 = (EfErrCode)uVar1;
  if (gc_request != false) {
    gc_collect();
  }
LAB_2302dfa8:
  ef_port_env_unlock();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar3;
}



EfErrCode ef_set_env(char *key,char *value)

{
  EfErrCode EVar1;
  size_t buf_len;
  
  buf_len = strlen(value);
  EVar1 = ef_set_env_blob(key,value,buf_len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar1;
}



EfErrCode ef_save_env(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EF_NO_ERR;
}



EfErrCode ef_env_set_default(void)

{
  uint uVar1;
  uint32_t addr;
  EfErrCode EVar2;
  int iVar3;
  undefined3 extraout_var;
  size_t len;
  ef_env *peVar4;
  undefined auStack56 [4];
  sector_meta_data sector;
  
  if (default_env_set == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x621,
                 "(%s) has assert failed at %s.\r\n","default_env_set","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (default_env_set_size == 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x622,
                 "(%s) has assert failed at %s.\r\n","default_env_set_size","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_env_lock();
  addr = env_start_addr;
  while (addr < env_start_addr + 0x8000) {
    EVar2 = format_sector(addr);
    iVar3 = CONCAT31(extraout_var,EVar2);
    if (iVar3 != 0) goto __exit;
    addr = addr + 0x1000;
  }
  uVar1 = 0;
  while (uVar1 < default_env_set_size) {
    len = default_env_set[uVar1].value_len;
    if (len == 0) {
      len = strlen((char *)default_env_set[uVar1].value);
    }
    sector.remain = 0xffffffff;
    peVar4 = default_env_set + uVar1;
    uVar1 = uVar1 + 1;
    create_env_blob((sector_meta_data_t)auStack56,peVar4->key,peVar4->value,len);
  }
  iVar3 = 0;
__exit:
  ef_port_env_unlock();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)iVar3;
}



void ef_print_env(void)

{
  int local_6c;
  size_t using_size;
  env_node_obj env;
  
  local_6c = 0;
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
  }
  else {
    ef_port_env_lock();
    env_iterator((env_node_obj_t)&using_size,&local_6c,(void *)0x0,print_env_cb);
    ef_print("\r\nmode: next generation\r\n");
    ef_print("size: %lu/%lu bytes.\r\n",local_6c + 0x8c,0x7000);
    ef_port_env_unlock();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: env

EfErrCode ef_load_env(void)

{
  int iStack132;
  size_t check_failed_count;
  sector_meta_data sector;
  env_node_obj env;
  
  in_recovery_check = true;
  iStack132 = 0;
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,&iStack132,(void *)0x0
                  ,check_sec_hdr_cb,false);
  if (iStack132 == 8) {
    ef_log_info("Warning: All sector header check failed. Set it to default.\r\n");
    ef_env_set_default();
  }
  ef_port_env_lock();
  sector_iterator((sector_meta_data_t)&check_failed_count,SECTOR_STORE_UNUSED,(void *)0x0,
                  (void *)0x0,check_and_recovery_gc_cb,false);
  while (env_iterator((env_node_obj_t)&sector.empty_env,(void *)0x0,(void *)0x0,
                      check_and_recovery_env_cb), gc_request != false) {
    gc_collect();
  }
  in_recovery_check = false;
  ef_port_env_unlock();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EF_NO_ERR;
}



EfErrCode ef_env_init(ef_env *default_env,size_t default_env_size)

{
  EfErrCode EVar1;
  int iVar2;
  undefined3 extraout_var;
  env_cache_node *peVar3;
  
  if (default_env == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x71e,
                 "(%s) has assert failed at %s.\r\n","default_env","ef_env_init");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iVar2 = 0;
  if (init_ok == false) {
    sector_cache_table[0].addr = 0xffffffff;
    sector_cache_table[1].addr = 0xffffffff;
    sector_cache_table[2].addr = 0xffffffff;
    sector_cache_table[3].addr = 0xffffffff;
    peVar3 = env_cache_table;
    do {
      peVar3->addr = 0xffffffff;
      peVar3 = peVar3 + 1;
    } while (peVar3 != (env_cache_node *)sector_3152);
    env_start_addr = 0;
    default_env_set = default_env;
    default_env_set_size = default_env_size;
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x738,
                 "ENV start address is 0x%08X, size is %d bytes.\r\n",0,0x8000);
    EVar1 = ef_load_env();
    iVar2 = CONCAT31(extraout_var,EVar1);
    if (iVar2 == 0) {
      init_ok = true;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)iVar2;
}



EfErrCode ef_port_read(uint32_t addr,uint32_t *buf,size_t size)

{
  int iVar1;
  
  iVar1 = bl_mtd_read(handle,addr,size,(uint8_t *)buf);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)((iVar1 < 0) << 1);
}



EfErrCode ef_port_write(uint32_t addr,uint32_t *buf,size_t size)

{
  EfErrCode EVar1;
  int iVar2;
  
  iVar2 = bl_mtd_write(handle,addr,size,(uint8_t *)buf);
  if (iVar2 < 0) {
    EVar1 = EF_WRITE_ERR;
  }
  else {
    EVar1 = EF_NO_ERR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EVar1;
}



void ef_port_env_lock(void)

{
  xQueueSemaphoreTake((QueueHandle_t)env_cache_lock,0xffffffff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ef_port_env_unlock(void)

{
  xQueueGenericSend((QueueHandle_t)env_cache_lock,(void *)0x0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ef_log_debug(char *file,long line,char *format,...)

{
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



EfErrCode ef_port_erase(uint32_t addr,size_t size)

{
  int iVar1;
  
  if ((addr & 0xfff) != 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_port.c",0x77,
                 "(%s) has assert failed at %s.\r\n","addr % EF_ERASE_MIN_SIZE == 0","ef_port_erase"
                );
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iVar1 = bl_mtd_erase(handle,addr,size);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)((uint)iVar1 >> 0x1f);
}



void ef_log_info(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack28);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: info

EfErrCode ef_port_init(ef_env **default_env,size_t *default_env_size)

{
  int iVar1;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("PSM",&handle,2);
  if (iVar1 < 0) {
    ef_log_info("[EF] [PART] [XIP] error when get PSM partition %d\r\n",iVar1);
    puts("[EF] [PART] [XIP] Dead Loop. Reason: no Valid PSM partition found\r\n");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(auStack44,0,0x1c);
  bl_mtd_info(handle,(bl_mtd_info_t *)auStack44);
  ef_log_info("[EF] Found Valid PSM partition, XIP Addr %08x, flash addr %08x\r\n",info.size,
              info.name._12_4_);
  *default_env = default_env_set;
  *default_env_size = 1;
  printf("*default_env_size = 0x%08x\r\n",1);
  env_cache_lock = (SemaphoreHandle_t)xQueueCreateMutex('\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return EF_NO_ERR;
}



void ef_print(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack28 = in_a1;
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  vprint(format,&uStack28);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t ef_calc_crc32(uint32_t crc,void *buf,size_t size)

{
  uint uVar1;
  byte *pbVar2;
  
  uVar1 = ~crc;
  pbVar2 = (byte *)buf;
  while (pbVar2 != (byte *)(size + (int)buf)) {
    uVar1 = uVar1 >> 8 ^ crc32_table[(*pbVar2 ^ uVar1) & 0xff];
    pbVar2 = pbVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ~uVar1;
}



void psm_get_cmd(char *buf,int len,int argc,char **argv)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void psm_test_cmd(char *buf,int len,int argc,char **argv)

{
  size_t *psVar1;
  EfErrCode EVar2;
  void *__s;
  void *__s_00;
  TickType_t TVar3;
  undefined3 extraout_var;
  size_t __n;
  char *format;
  int iVar4;
  undefined *puVar5;
  undefined4 uVar6;
  size_t sVar7;
  size_t sVar8;
  size_t sStack92;
  size_t read_len;
  uint32_t tbuf [6];
  
  psVar1 = &read_len;
  memcpy(&read_len,&DAT_23082570,0x18);
  do {
    sVar8 = *psVar1;
    sStack92 = 0;
    sVar7 = sVar8 + 1;
    __s = pvPortMalloc(sVar7);
    __s_00 = pvPortMalloc(sVar7);
    if ((__s == (void *)0x0) || (__s_00 == (void *)0x0)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] kvbin malloc %d byte error\r\n",TVar3,&DAT_2307f16c,
                "easyflash_cli.c",0x3d);
      if (__s != (void *)0x0) goto LAB_2302e4c6;
    }
    else {
      memset(__s,0,sVar7);
      memset(__s_00,0,sVar7);
      sVar7 = 0;
      while (sVar7 != sVar8) {
        *(undefined *)((int)__s + sVar7) = 0x76;
        sVar7 = sVar7 + 1;
      }
      EVar2 = ef_set_env_blob("1234567890123456789012345678901234567890123456789012345678901234",__s
                              ,sVar7);
      iVar4 = CONCAT31(extraout_var,EVar2);
      __n = ef_get_env_blob("1234567890123456789012345678901234567890123456789012345678901234",
                            __s_00,sVar7,&sStack92);
      if ((iVar4 == 0) && (sVar7 == __n)) {
        iVar4 = memcmp(__s_00,__s,__n);
        if (iVar4 == 0) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          bl_printk(
                    "[%10u][%s: %s:%4d] kvbin set %ld byte bin -> read %ld byte -> memcmp success.\r\n"
                    ,TVar3,&DAT_2307f16c,"easyflash_cli.c",0x56,__n,__n);
          goto LAB_2302e4c6;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        iVar4 = 0;
        uVar6 = 0x52;
        puVar5 = &DAT_23072bcc;
        format = 
        "[%10u][%s: %s:%4d] kvbin set/get %ld byte , res1 = %ld, res2 = %d. memcmp error\r\n";
        sVar8 = __n;
      }
      else {
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar6 = 0x4d;
        puVar5 = &DAT_23081ce8;
        format = "[%10u][%s: %s:%4d] kvbin set/get %ld byte error, res1 = %ld, res2 = %d.\r\n";
      }
      bl_printk(format,TVar3,puVar5,"easyflash_cli.c",uVar6,sVar8,iVar4,__n);
LAB_2302e4c6:
      vPortFree(__s);
    }
    if (__s_00 != (void *)0x0) {
      vPortFree(__s_00);
    }
    psVar1 = psVar1 + 1;
    if (psVar1 == tbuf + 5) {
      ef_del_env("1234567890123456789012345678901234567890123456789012345678901234");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  } while( true );
}



EfErrCode psm_erase_cmd(void)

{
  uint uVar1;
  uint32_t addr;
  EfErrCode EVar2;
  int iVar3;
  undefined3 extraout_var;
  size_t len;
  ef_env *peVar4;
  sector_meta_data sStack56;
  
  if (default_env_set == (ef_env *)0x0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x621,
                 "(%s) has assert failed at %s.\r\n","default_env_set","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (default_env_set_size == 0) {
    ef_log_debug("/home/yangff/Projects/bl_iot_sdk/components/stage/easyflash4/src/ef_env.c",0x622,
                 "(%s) has assert failed at %s.\r\n","default_env_set_size","ef_env_set_default");
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  ef_port_env_lock();
  addr = env_start_addr;
  while (addr < env_start_addr + 0x8000) {
    EVar2 = format_sector(addr);
    iVar3 = CONCAT31(extraout_var,EVar2);
    if (iVar3 != 0) goto __exit;
    addr = addr + 0x1000;
  }
  uVar1 = 0;
  while (uVar1 < default_env_set_size) {
    len = default_env_set[uVar1].value_len;
    if (len == 0) {
      len = strlen((char *)default_env_set[uVar1].value);
    }
    sStack56.empty_env = 0xffffffff;
    peVar4 = default_env_set + uVar1;
    uVar1 = uVar1 + 1;
    create_env_blob((sector_meta_data_t)&sStack56,peVar4->key,peVar4->value,len);
  }
  iVar3 = 0;
__exit:
  ef_port_env_unlock();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EfErrCode)iVar3;
}



void psm_dump_cmd(void)

{
  int iStack108;
  env_node_obj eStack104;
  
  iStack108 = 0;
  if (init_ok == false) {
    ef_log_info("ENV isn\'t initialize OK.\r\n");
  }
  else {
    ef_port_env_lock();
    env_iterator((env_node_obj_t)&eStack104,&iStack108,(void *)0x0,print_env_cb);
    ef_print("\r\nmode: next generation\r\n");
    ef_print("size: %lu/%lu bytes.\r\n",iStack108 + 0x8c,0x7000);
    ef_port_env_unlock();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void psm_unset_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("usage: psm_unset [key]\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ef_del_env(argv[1]);
  ef_save_env();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void psm_set_cmd(char *buf,int len,int argc,char **argv)

{
  if (argc != 3) {
    printf("usage: psm_set [key] [value]\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ef_set_env(argv[1],argv[2]);
  ef_save_env();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int easyflash_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x2302e680)
// WARNING: Removing unreachable block (ram,0x2302e696)

EventGroupHandle_t xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)

{
  size_t xSize;
  
  if (pxEventGroupBuffer == (StaticEventGroup_t *)0x0) {
    vAssertCalled();
  }
  else {
    pxEventGroupBuffer->xDummy1 = 0;
    vListInitialise((List_t *)&pxEventGroupBuffer->xDummy2);
    pxEventGroupBuffer->ucDummy4 = '\x01';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (EventGroupHandle_t)pxEventGroupBuffer;
}



EventBits_t
xEventGroupWaitBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToWaitFor,
                   BaseType_t xClearOnExit,BaseType_t xWaitForAllBits,TickType_t xTicksToWait)

{
  uint uVar1;
  BaseType_t BVar2;
  uint uVar3;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if (((uxBitsToWaitFor & 0xff000000) == 0) && (uxBitsToWaitFor != 0)) {
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 != 0) goto LAB_2302e6c8;
LAB_2302e748:
    if (xTicksToWait == 0) goto LAB_2302e6c8;
    vAssertCalled();
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits != 0) goto LAB_2302e70c;
LAB_2302e6d8:
    if (uVar3 == 0) goto LAB_2302e710;
LAB_2302e6da:
    if (xClearOnExit != 0) {
      xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
      xTaskResumeAll();
      goto LAB_2302e6ec;
    }
  }
  else {
    vAssertCalled();
    BVar2 = xTaskGetSchedulerState();
    if (BVar2 == 0) goto LAB_2302e748;
LAB_2302e6c8:
    vTaskSuspendAll();
    uVar1 = xEventGroup->uxEventBits;
    uVar3 = uxBitsToWaitFor & uVar1;
    if (xWaitForAllBits == 0) goto LAB_2302e6d8;
LAB_2302e70c:
    if (uxBitsToWaitFor == uVar3) goto LAB_2302e6da;
LAB_2302e710:
    if (xTicksToWait != 0) {
      uVar1 = (uint)(xClearOnExit != 0) << 0x18;
      if (xWaitForAllBits != 0) {
        uVar1 = uVar1 | 0x4000000;
      }
      vTaskPlaceOnUnorderedEventList
                (&xEventGroup->xTasksWaitingForBits,uVar1 | uxBitsToWaitFor,xTicksToWait);
      BVar2 = xTaskResumeAll();
      if (BVar2 == 0) {
        ecall();
      }
      uVar1 = uxTaskResetEventItemValue();
      if (-1 < (int)(uVar1 << 6)) {
        vTaskEnterCritical();
        uVar1 = xEventGroup->uxEventBits;
        if (xWaitForAllBits == 0) {
          if ((uxBitsToWaitFor & uVar1) != 0) {
LAB_2302e788:
            if (xClearOnExit != 0) {
              xEventGroup->uxEventBits = ~uxBitsToWaitFor & uVar1;
            }
          }
        }
        else {
          if (uxBitsToWaitFor == (uxBitsToWaitFor & uVar1)) goto LAB_2302e788;
        }
        vTaskExitCritical();
      }
      uVar1 = uVar1 & 0xffffff;
      goto LAB_2302e6ec;
    }
  }
  xTaskResumeAll();
LAB_2302e6ec:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup,EventBits_t uxBitsToSet)

{
  xLIST_ITEM *pxEventListItem;
  xLIST_ITEM *pxVar1;
  uint uVar2;
  EventBits_t EVar3;
  uint uVar4;
  xLIST_ITEM *pxVar5;
  uint uVar6;
  
  if (xEventGroup == (EventGroupHandle_t)0x0) {
    vAssertCalled();
  }
  if ((uxBitsToSet & 0xff000000) != 0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  pxEventListItem = (xEventGroup->xTasksWaitingForBits).xListEnd.pxNext;
  pxVar5 = (xLIST_ITEM *)&(xEventGroup->xTasksWaitingForBits).xListEnd;
  EVar3 = uxBitsToSet | xEventGroup->uxEventBits;
  xEventGroup->uxEventBits = EVar3;
  if (pxVar5 != pxEventListItem) {
    uVar6 = 0;
    do {
      while( true ) {
        uVar4 = ((ListItem_t *)pxEventListItem)->xItemValue;
        uVar2 = uVar4 & 0xffffff;
        pxVar1 = ((ListItem_t *)pxEventListItem)->pxNext;
        if ((int)(uVar4 << 5) < 0) break;
        if ((uVar2 & EVar3) != 0) {
LAB_2302e806:
          if ((int)(uVar4 << 7) < 0) {
            uVar6 = uVar6 | uVar2;
          }
          vTaskRemoveFromUnorderedEventList((ListItem_t *)pxEventListItem,EVar3 | 0x2000000);
          EVar3 = xEventGroup->uxEventBits;
        }
        pxEventListItem = pxVar1;
        if (pxVar5 == pxVar1) goto LAB_2302e81c;
      }
      if (uVar2 == (uVar2 & EVar3)) goto LAB_2302e806;
      pxEventListItem = pxVar1;
    } while (pxVar5 != pxVar1);
LAB_2302e81c:
    EVar3 = EVar3 & ~uVar6;
  }
  xEventGroup->uxEventBits = EVar3;
  xTaskResumeAll();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xEventGroup->uxEventBits;
}



void vEventGroupDelete(EventGroupHandle_t xEventGroup)

{
  ListItem_t *pxEventListItem;
  UBaseType_t UVar1;
  
  vTaskSuspendAll();
  UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  while (UVar1 != 0) {
    while (pxEventListItem = (ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,
          pxEventListItem != (ListItem_t *)&(xEventGroup->xTasksWaitingForBits).xListEnd) {
      vTaskRemoveFromUnorderedEventList(pxEventListItem,0x2000000);
      if ((xEventGroup->xTasksWaitingForBits).uxNumberOfItems == 0) goto LAB_2302e890;
    }
    vAssertCalled();
    vTaskRemoveFromUnorderedEventList
              ((ListItem_t *)(xEventGroup->xTasksWaitingForBits).xListEnd.pxNext,0x2000000);
    UVar1 = (xEventGroup->xTasksWaitingForBits).uxNumberOfItems;
  }
LAB_2302e890:
  if (xEventGroup->ucStaticallyAllocated != '\0') {
    xTaskResumeAll();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vPortFree(xEventGroup);
  xTaskResumeAll();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vListInitialise(List_t *pxList)

{
  ListItem_t *pLVar1;
  
  pLVar1 = (ListItem_t *)&pxList->xListEnd;
  pxList->pxIndex = pLVar1;
  (pxList->xListEnd).xItemValue = 0xffffffff;
  (pxList->xListEnd).pxNext = (xLIST_ITEM *)pLVar1;
  (pxList->xListEnd).pxPrevious = (xLIST_ITEM *)pLVar1;
  pxList->uxNumberOfItems = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vListInitialiseItem(ListItem_t *pxItem)

{
  pxItem->pvContainer = (xLIST *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vListInsertEnd(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  ListItem_t *pLVar2;
  
  pLVar2 = pxList->pxIndex;
  pxNewListItem->pxNext = (xLIST_ITEM *)pLVar2;
  pxVar1 = pLVar2->pxPrevious;
  pxNewListItem->pxPrevious = pxVar1;
  pxVar1->pxNext = (xLIST_ITEM *)pxNewListItem;
  pLVar2->pxPrevious = (xLIST_ITEM *)pxNewListItem;
  pxNewListItem->pvContainer = (xLIST *)pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vListInsert(List_t *pxList,ListItem_t *pxNewListItem)

{
  xLIST_ITEM *pxVar1;
  xLIST_ITEM *pxVar2;
  
  pxVar2 = (xLIST_ITEM *)&pxList->xListEnd;
  if (pxNewListItem->xItemValue == 0xffffffff) {
    pxVar1 = (pxList->xListEnd).pxPrevious;
    pxVar2 = pxVar1->pxNext;
  }
  else {
    do {
      pxVar1 = pxVar2;
      pxVar2 = pxVar1->pxNext;
    } while (pxVar2->xItemValue <= pxNewListItem->xItemValue);
  }
  pxNewListItem->pxNext = pxVar2;
  pxVar2->pxPrevious = (xLIST_ITEM *)pxNewListItem;
  pxNewListItem->pxPrevious = pxVar1;
  pxVar1->pxNext = (xLIST_ITEM *)pxNewListItem;
  pxNewListItem->pvContainer = (xLIST *)pxList;
  pxList->uxNumberOfItems = pxList->uxNumberOfItems + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



UBaseType_t uxListRemove(ListItem_t *pxItemToRemove)

{
  xLIST_ITEM *pxVar1;
  xLIST *pxVar2;
  
  pxVar1 = pxItemToRemove->pxPrevious;
  pxVar2 = pxItemToRemove->pvContainer;
  pxItemToRemove->pxNext->pxPrevious = pxVar1;
  pxVar1->pxNext = pxItemToRemove->pxNext;
  if (pxVar2->pxIndex != pxItemToRemove) {
    pxItemToRemove->pvContainer = (xLIST *)0x0;
    pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return pxVar2->uxNumberOfItems;
  }
  pxVar2->pxIndex = (ListItem_t *)pxItemToRemove->pxPrevious;
  pxItemToRemove->pvContainer = (xLIST *)0x0;
  pxVar2->uxNumberOfItems = pxVar2->uxNumberOfItems - 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pxVar2->uxNumberOfItems;
}



BaseType_t prvCopyDataToQueue(Queue_t *pxQueue,void *pvItemToQueue,BaseType_t xPosition)

{
  UBaseType_t UVar1;
  BaseType_t BVar2;
  UBaseType_t UVar3;
  size_t __n;
  int8_t *piVar4;
  int8_t *piVar5;
  
  __n = pxQueue->uxItemSize;
  UVar1 = pxQueue->uxMessagesWaiting;
  if (__n == 0) {
    UVar1 = UVar1 + 1;
    BVar2 = 0;
    if (pxQueue->pcHead == (int8_t *)0x0) {
      BVar2 = xTaskPriorityDisinherit(*(TaskHandle_t *)&pxQueue->u);
      *(undefined4 *)&pxQueue->u = 0;
    }
  }
  else {
    if (xPosition == 0) {
      UVar1 = UVar1 + 1;
      memcpy(pxQueue->pcWriteTo,pvItemToQueue,__n);
      piVar4 = pxQueue->pcWriteTo;
      BVar2 = 0;
      pxQueue->pcWriteTo = piVar4 + pxQueue->uxItemSize;
      if (*(int8_t **)&pxQueue->u <= piVar4 + pxQueue->uxItemSize) {
        pxQueue->uxMessagesWaiting = UVar1;
        pxQueue->pcWriteTo = pxQueue->pcHead;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    else {
      memcpy(*(void **)((int)&pxQueue->u + 4),pvItemToQueue,__n);
      UVar3 = pxQueue->uxItemSize;
      piVar4 = pxQueue->pcHead;
      piVar5 = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + -UVar3);
      *(int8_t **)((int)&pxQueue->u + 4) = piVar5;
      if (piVar5 < piVar4) {
        *(UBaseType_t *)((int)&pxQueue->u + 4) = -UVar3 + *(int *)&pxQueue->u;
      }
      if (xPosition != 2) {
        pxQueue->uxMessagesWaiting = UVar1 + 1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      BVar2 = 0;
      if (UVar1 == 0) {
        UVar1 = 1;
      }
    }
  }
  pxQueue->uxMessagesWaiting = UVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



void prvCopyDataFromQueue(Queue_t *pxQueue,void *pvBuffer)

{
  int8_t *__src;
  size_t __n;
  int8_t *piVar1;
  
  __n = pxQueue->uxItemSize;
  if (__n != 0) {
    piVar1 = *(int8_t **)&pxQueue->u;
    __src = (int8_t *)(*(int *)((int)&pxQueue->u + 4) + __n);
    *(int8_t **)((int)&pxQueue->u + 4) = __src;
    if (piVar1 <= __src) {
      __src = pxQueue->pcHead;
      *(int8_t **)((int)&pxQueue->u + 4) = __src;
    }
    memcpy(pvBuffer,__src,__n);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvUnlockQueue(Queue_t *pxQueue)

{
  char cVar1;
  int iVar2;
  BaseType_t BVar3;
  uint uVar4;
  
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cTxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToReceive);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToReceive).uxNumberOfItems != 0));
  }
  pxQueue->cTxLock = -1;
  vTaskExitCritical();
  vTaskEnterCritical();
  iVar2 = (int)pxQueue->cRxLock;
  if ((0 < iVar2) && ((pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0)) {
    do {
      BVar3 = xTaskRemoveFromEventList(&pxQueue->xTasksWaitingToSend);
      if (BVar3 == 0) {
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
      else {
        vTaskMissedYield();
        uVar4 = iVar2 - 1U & 0xff;
        cVar1 = (char)uVar4;
      }
    } while ((uVar4 != 0) &&
            (iVar2 = (int)cVar1, (pxQueue->xTasksWaitingToSend).uxNumberOfItems != 0));
  }
  pxQueue->cRxLock = -1;
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BaseType_t xQueueGenericReset(QueueHandle_t xQueue,BaseType_t xNewQueue)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  int iVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  piVar2 = xQueue->pcHead;
  xQueue->uxMessagesWaiting = 0;
  iVar3 = xQueue->uxItemSize * xQueue->uxLength;
  xQueue->cRxLock = -1;
  xQueue->pcWriteTo = piVar2;
  xQueue->cTxLock = -1;
  *(int8_t **)&xQueue->u = piVar2 + iVar3;
  *(int8_t **)((int)&xQueue->u + 4) = piVar2 + (iVar3 - xQueue->uxItemSize);
  if (xNewQueue == 0) {
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
      vTaskExitCritical();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 1;
    }
    vTaskExitCritical();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  vListInitialise(&xQueue->xTasksWaitingToSend);
  vListInitialise(&xQueue->xTasksWaitingToReceive);
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



// WARNING: Removing unreachable block (ram,0x2302eb7e)

QueueHandle_t
xQueueGenericCreateStatic
          (UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t *pucQueueStorage,
          StaticQueue_t *pxStaticQueue,uint8_t ucQueueType)

{
  size_t xSize;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (pxStaticQueue == (StaticQueue_t *)0x0) {
    vAssertCalled();
  }
  if (pucQueueStorage == (uint8_t *)0x0) {
    if (uxItemSize == 0) goto LAB_2302eb82;
  }
  else {
    if (uxItemSize != 0) goto LAB_2302eb82;
  }
  vAssertCalled();
LAB_2302eb82:
  if (pxStaticQueue != (StaticQueue_t *)0x0) {
    pxStaticQueue->ucDummy6 = '\x01';
    if (uxItemSize == 0) {
      pucQueueStorage = (uint8_t *)pxStaticQueue;
    }
    pxStaticQueue->pvDummy1[0] = pucQueueStorage;
    pxStaticQueue->uxDummy4[1] = uxQueueLength;
    pxStaticQueue->uxDummy4[2] = uxItemSize;
    xQueueGenericReset((QueueHandle_t)pxStaticQueue,1);
    pxStaticQueue->ucDummy9 = ucQueueType;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (QueueHandle_t)pxStaticQueue;
}



QueueHandle_t
xQueueGenericCreate(UBaseType_t uxQueueLength,UBaseType_t uxItemSize,uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  if (uxQueueLength == 0) {
    vAssertCalled();
  }
  if (uxItemSize == 0) {
    xQueue = (QueueHandle_t)pvPortMalloc(0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    xQueue->pcHead = (int8_t *)xQueue;
  }
  else {
    xQueue = (QueueHandle_t)pvPortMalloc(uxQueueLength * uxItemSize + 0x50);
    if (xQueue == (QueueHandle_t)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (QueueHandle_t)0x0;
    }
    xQueue->ucStaticallyAllocated = '\0';
    xQueue->pcHead = (int8_t *)(xQueue + 1);
  }
  xQueue->uxLength = uxQueueLength;
  xQueue->uxItemSize = uxItemSize;
  xQueueGenericReset(xQueue,1);
  xQueue->ucQueueType = ucQueueType;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xQueue;
}



QueueHandle_t xQueueCreateCountingSemaphore(UBaseType_t uxMaxCount,UBaseType_t uxInitialCount)

{
  bool bVar1;
  QueueHandle_t pQVar2;
  
  if (uxMaxCount == 0) {
    vAssertCalled();
    bVar1 = uxInitialCount == 0;
  }
  else {
    bVar1 = uxInitialCount <= uxMaxCount;
  }
  if (!bVar1) {
    vAssertCalled();
  }
  pQVar2 = xQueueGenericCreate(uxMaxCount,0,'\x02');
  if (pQVar2 != (QueueHandle_t)0x0) {
    pQVar2->uxMessagesWaiting = uxInitialCount;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pQVar2;
}



// WARNING: Variable defined which should be unmapped: xTimeOut

BaseType_t
xQueueGenericSend(QueueHandle_t xQueue,void *pvItemToQueue,TickType_t xTicksToWait,
                 BaseType_t xCopyPosition)

{
  bool bVar1;
  BaseType_t BVar2;
  int iVar3;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if ((xCopyPosition == 2) && (xQueue->uxLength != 1)) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  bVar1 = false;
  if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
    do {
      if (xCopyPosition == 2) break;
      if (local_34[0] == 0) {
        vTaskExitCritical();
        BVar2 = 0;
        goto LAB_2302ed58;
      }
      if (!bVar1) {
        vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
      }
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar2 != 0) {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        BVar2 = 0;
        goto LAB_2302ed58;
      }
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == xQueue->uxLength) {
        vTaskExitCritical();
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToSend,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
      bVar1 = true;
      vTaskEnterCritical();
    } while (xQueue->uxLength <= xQueue->uxMessagesWaiting);
  }
  iVar3 = prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if ((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) {
    iVar3 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive);
  }
  if (iVar3 != 0) {
    ecall();
  }
  vTaskExitCritical();
  BVar2 = 1;
LAB_2302ed58:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



QueueHandle_t xQueueCreateMutexStatic(uint8_t ucQueueType,StaticQueue_t *pxStaticQueue)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreateStatic(1,0,(uint8_t *)0x0,pxStaticQueue,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xQueue;
}



BaseType_t xQueueGiveMutexRecursive(QueueHandle_t xMutex)

{
  BaseType_t BVar1;
  TaskHandle_t ptVar2;
  int iVar3;
  TaskHandle_t ptVar4;
  
  if (xMutex == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  ptVar4 = *(TaskHandle_t *)&xMutex->u;
  ptVar2 = xTaskGetCurrentTaskHandle();
  BVar1 = 0;
  if (ptVar4 == ptVar2) {
    iVar3 = *(int *)((int)&xMutex->u + 4) + -1;
    *(int *)((int)&xMutex->u + 4) = iVar3;
    BVar1 = 1;
    if (iVar3 == 0) {
      xQueueGenericSend(xMutex,(void *)0x0,0,0);
      BVar1 = 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



QueueHandle_t xQueueCreateMutex(uint8_t ucQueueType)

{
  QueueHandle_t xQueue;
  
  xQueue = xQueueGenericCreate(1,0,ucQueueType);
  if (xQueue != (QueueHandle_t)0x0) {
    *(undefined4 *)&xQueue->u = 0;
    xQueue->pcHead = (int8_t *)0x0;
    *(undefined4 *)((int)&xQueue->u + 4) = 0;
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xQueue;
}



BaseType_t
xQueueGenericSendFromISR
          (QueueHandle_t xQueue,void *pvItemToQueue,BaseType_t *pxHigherPriorityTaskWoken,
          BaseType_t xCopyPosition)

{
  char cVar1;
  BaseType_t BVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvItemToQueue == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  if (xCopyPosition == 2) {
    if (xQueue->uxLength != 1) {
      vAssertCalled();
    }
  }
  else {
    if (xQueue->uxLength <= xQueue->uxMessagesWaiting) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  cVar1 = xQueue->cTxLock;
  prvCopyDataToQueue((Queue_t *)xQueue,pvItemToQueue,xCopyPosition);
  if (cVar1 == -1) {
    if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
        (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar2 != 0)) &&
       (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
      *pxHigherPriorityTaskWoken = 1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  xQueue->cTxLock = cVar1 + '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



BaseType_t xQueueGiveFromISR(QueueHandle_t xQueue,BaseType_t *pxHigherPriorityTaskWoken)

{
  BaseType_t BVar1;
  int8_t *piVar2;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize == 0) {
    piVar2 = xQueue->pcHead;
  }
  else {
    vAssertCalled();
    piVar2 = xQueue->pcHead;
  }
  if ((piVar2 == (int8_t *)0x0) && (*(int *)&xQueue->u != 0)) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xQueue->uxMessagesWaiting < xQueue->uxLength) {
    xQueue->uxMessagesWaiting = xQueue->uxMessagesWaiting + 1;
    if (xQueue->cTxLock == -1) {
      if ((((xQueue->xTasksWaitingToReceive).uxNumberOfItems != 0) &&
          (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToReceive), BVar1 != 0)) &&
         (pxHigherPriorityTaskWoken != (BaseType_t *)0x0)) {
        *pxHigherPriorityTaskWoken = 1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 1;
      }
    }
    else {
      xQueue->cTxLock = xQueue->cTxLock + '\x01';
    }
    BVar1 = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



BaseType_t xQueueReceive(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  UBaseType_t UVar2;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if ((pvBuffer == (void *)0x0) && (xQueue->uxItemSize != 0)) {
    vAssertCalled();
  }
  BVar1 = xTaskGetSchedulerState();
  if ((BVar1 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar2 = xQueue->uxMessagesWaiting;
  if (UVar2 != 0) {
LAB_2302f0a0:
    prvCopyDataFromQueue((Queue_t *)xQueue,pvBuffer);
    xQueue->uxMessagesWaiting = UVar2 - 1;
    if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
       (BVar1 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar1 != 0)) {
      ecall();
    }
    vTaskExitCritical();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  if (local_34[0] != 0) {
    vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskExitCritical();
      vTaskSuspendAll();
      vTaskEnterCritical();
      if (xQueue->cRxLock == -1) {
        xQueue->cRxLock = '\0';
      }
      if (xQueue->cTxLock == -1) {
        xQueue->cTxLock = '\0';
      }
      vTaskExitCritical();
      BVar1 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
      if (BVar1 == 0) {
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) {
          vTaskExitCritical();
          vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
          prvUnlockQueue((Queue_t *)xQueue);
          BVar1 = xTaskResumeAll();
          if (BVar1 == 0) {
            ecall();
          }
          goto LAB_2302f094;
        }
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      else {
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
        vTaskEnterCritical();
        if (xQueue->uxMessagesWaiting == 0) break;
        vTaskExitCritical();
LAB_2302f094:
        vTaskEnterCritical();
        UVar2 = xQueue->uxMessagesWaiting;
      }
      if (UVar2 != 0) goto LAB_2302f0a0;
    } while (local_34[0] != 0);
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



BaseType_t xQueueSemaphoreTake(QueueHandle_t xQueue,TickType_t xTicksToWait)

{
  bool bVar1;
  BaseType_t BVar2;
  TaskHandle_t ptVar3;
  UBaseType_t UVar4;
  int iVar5;
  TickType_t local_34 [3];
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  local_34[0] = xTicksToWait;
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  if (xQueue->uxItemSize != 0) {
    vAssertCalled();
  }
  BVar2 = xTaskGetSchedulerState();
  if ((BVar2 == 0) && (local_34[0] != 0)) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar4 = xQueue->uxMessagesWaiting;
  iVar5 = 0;
  bVar1 = false;
  do {
    if (UVar4 != 0) {
      xQueue->uxMessagesWaiting = UVar4 - 1;
      if (xQueue->pcHead == (int8_t *)0x0) {
        ptVar3 = pvTaskIncrementMutexHeldCount();
        *(TaskHandle_t *)&xQueue->u = ptVar3;
      }
      if (((xQueue->xTasksWaitingToSend).uxNumberOfItems != 0) &&
         (BVar2 = xTaskRemoveFromEventList(&xQueue->xTasksWaitingToSend), BVar2 != 0)) {
        ecall();
      }
      vTaskExitCritical();
      iVar5 = 1;
LAB_2302f214:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar5;
    }
    if (local_34[0] == 0) {
      if (iVar5 != 0) {
        vAssertCalled();
      }
      vTaskExitCritical();
      iVar5 = 0;
      goto LAB_2302f214;
    }
    if (!bVar1) {
      vTaskInternalSetTimeOutState((TimeOut_t *)auStack40);
    }
    vTaskExitCritical();
    vTaskSuspendAll();
    vTaskEnterCritical();
    if (xQueue->cRxLock == -1) {
      xQueue->cRxLock = '\0';
    }
    if (xQueue->cTxLock == -1) {
      xQueue->cTxLock = '\0';
    }
    vTaskExitCritical();
    BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,local_34);
    if (BVar2 == 0) {
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (xQueue->pcHead == (int8_t *)0x0) {
          vTaskEnterCritical();
          iVar5 = xTaskPriorityInherit(*(TaskHandle_t *)&xQueue->u);
          vTaskExitCritical();
        }
        vTaskPlaceOnEventList(&xQueue->xTasksWaitingToReceive,local_34[0]);
        prvUnlockQueue((Queue_t *)xQueue);
        BVar2 = xTaskResumeAll();
        if (BVar2 == 0) {
          ecall();
        }
      }
      else {
        vTaskExitCritical();
        prvUnlockQueue((Queue_t *)xQueue);
        xTaskResumeAll();
      }
    }
    else {
      prvUnlockQueue((Queue_t *)xQueue);
      xTaskResumeAll();
      vTaskEnterCritical();
      if (xQueue->uxMessagesWaiting == 0) {
        vTaskExitCritical();
        if (iVar5 != 0) {
          vTaskEnterCritical();
          UVar4 = (xQueue->xTasksWaitingToReceive).uxNumberOfItems;
          if (UVar4 != 0) {
            UVar4 = 0x20 - ((xQueue->xTasksWaitingToReceive).xListEnd.pxNext)->xItemValue;
          }
          iVar5 = 0;
          vTaskPriorityDisinheritAfterTimeout(*(TaskHandle_t *)&xQueue->u,UVar4);
          vTaskExitCritical();
        }
        goto LAB_2302f214;
      }
      vTaskExitCritical();
    }
    bVar1 = true;
    vTaskEnterCritical();
    UVar4 = xQueue->uxMessagesWaiting;
  } while( true );
}



BaseType_t xQueueTakeMutexRecursive(QueueHandle_t xMutex,TickType_t xTicksToWait)

{
  TaskHandle_t ptVar1;
  TaskHandle_t ptVar2;
  BaseType_t BVar3;
  
  if (xMutex == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  ptVar1 = *(TaskHandle_t *)&xMutex->u;
  ptVar2 = xTaskGetCurrentTaskHandle();
  if (ptVar1 != ptVar2) {
    BVar3 = xQueueSemaphoreTake(xMutex,xTicksToWait);
    if (BVar3 != 0) {
      *(int *)((int)&xMutex->u + 4) = *(int *)((int)&xMutex->u + 4) + 1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return BVar3;
  }
  *(int *)((int)&xMutex->u + 4) = *(int *)((int)&xMutex->u + 4) + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



UBaseType_t uxQueueMessagesWaiting(QueueHandle_t xQueue)

{
  UBaseType_t UVar1;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  UVar1 = xQueue->uxMessagesWaiting;
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar1;
}



void vQueueDelete(QueueHandle_t xQueue)

{
  QueueHandle_t *ppQVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  if (xQueue == (QueueHandle_t)0x0) {
    vAssertCalled();
    iVar2 = 0;
    pQVar3 = xQueueRegistry;
    do {
      ppQVar1 = &pQVar3->xHandle;
      pQVar3 = pQVar3 + 1;
      if (*ppQVar1 == (QueueHandle_t)0x0) {
        xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
        xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
        break;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 8);
    if (cRam00000046 != '\0') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    vPortFree((void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppQVar1 = &pQVar3->xHandle;
    pQVar3 = pQVar3 + 1;
    if (xQueue == *ppQVar1) {
      xQueueRegistry[iVar2].pcQueueName = (char *)0x0;
      xQueueRegistry[iVar2].xHandle = (QueueHandle_t)0x0;
      break;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  if (xQueue->ucStaticallyAllocated != '\0') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vPortFree(xQueue);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vQueueAddToRegistry(QueueHandle_t xQueue,char *pcQueueName)

{
  char **ppcVar1;
  int iVar2;
  QueueRegistryItem_t *pQVar3;
  
  iVar2 = 0;
  pQVar3 = xQueueRegistry;
  do {
    ppcVar1 = &pQVar3->pcQueueName;
    pQVar3 = pQVar3 + 1;
    if (*ppcVar1 == (char *)0x0) {
      xQueueRegistry[iVar2].pcQueueName = pcQueueName;
      xQueueRegistry[iVar2].xHandle = xQueue;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vQueueWaitForMessageRestricted
               (QueueHandle_t xQueue,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  vTaskEnterCritical();
  if (xQueue->cRxLock == -1) {
    xQueue->cRxLock = '\0';
  }
  if (xQueue->cTxLock == -1) {
    xQueue->cTxLock = '\0';
  }
  vTaskExitCritical();
  if (xQueue->uxMessagesWaiting != 0) {
    prvUnlockQueue((Queue_t *)xQueue);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vTaskPlaceOnEventListRestricted(&xQueue->xTasksWaitingToReceive,xTicksToWait,xWaitIndefinitely);
  prvUnlockQueue((Queue_t *)xQueue);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvInitialiseNewStreamBuffer
               (StreamBuffer_t *pxStreamBuffer,uint8_t *pucBuffer,size_t xBufferSizeBytes,
               size_t xTriggerLevelBytes,uint8_t ucFlags)

{
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)memset(pucBuffer,0x55,xBufferSizeBytes);
  if (pucBuffer != puVar1) {
    vAssertCalled();
  }
  memset(pxStreamBuffer,0,0x24);
  pxStreamBuffer->pucBuffer = pucBuffer;
  pxStreamBuffer->xLength = xBufferSizeBytes;
  pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
  pxStreamBuffer->ucFlags = ucFlags;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



size_t prvWriteBytesToBuffer(StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xCount)

{
  uint uVar1;
  uint uVar2;
  size_t __n;
  
  if (xCount == 0) {
    vAssertCalled();
    uVar1 = pxStreamBuffer->xHead;
    if (pxStreamBuffer->xLength < uVar1) {
      __n = 0;
      goto LAB_2302f4f8;
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,0);
    uVar2 = pxStreamBuffer->xLength;
    if (uVar1 < uVar2) goto LAB_2302f4d6;
  }
  else {
    uVar1 = pxStreamBuffer->xHead;
    __n = pxStreamBuffer->xLength - uVar1;
    if (xCount < __n) {
      uVar2 = uVar1 + xCount;
      __n = xCount;
    }
    else {
      uVar2 = uVar1 + __n;
    }
    if (pxStreamBuffer->xLength < uVar2) {
LAB_2302f4f8:
      vAssertCalled();
    }
    memcpy(pxStreamBuffer->pucBuffer + uVar1,pucData,__n);
    if (__n < xCount) {
      uVar2 = xCount - __n;
      if (pxStreamBuffer->xLength < uVar2) {
        vAssertCalled();
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n,uVar2);
      }
      else {
        memcpy(pxStreamBuffer->pucBuffer,pucData + __n,uVar2);
      }
    }
    uVar2 = pxStreamBuffer->xLength;
    uVar1 = uVar1 + xCount;
    if (uVar1 < uVar2) goto LAB_2302f4d6;
  }
  uVar1 = uVar1 - uVar2;
LAB_2302f4d6:
  pxStreamBuffer->xHead = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xCount;
}



size_t prvReadBytesFromBuffer
                 (StreamBuffer_t *pxStreamBuffer,uint8_t *pucData,size_t xMaxCount,
                 size_t xBytesAvailable)

{
  size_t sVar1;
  uint __n;
  
  if (xMaxCount <= xBytesAvailable) {
    xBytesAvailable = xMaxCount;
  }
  if (xBytesAvailable == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  sVar1 = pxStreamBuffer->xTail;
  __n = pxStreamBuffer->xLength - sVar1;
  if (xBytesAvailable < __n) {
    __n = xBytesAvailable;
    if (xBytesAvailable <= xMaxCount) goto LAB_2302f566;
LAB_2302f5c0:
    vAssertCalled();
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_2302f56e;
  }
  else {
    if (xMaxCount < __n) goto LAB_2302f5c0;
LAB_2302f566:
    if (sVar1 + __n <= pxStreamBuffer->xLength) goto LAB_2302f56e;
  }
  vAssertCalled();
LAB_2302f56e:
  memcpy(pucData,pxStreamBuffer->pucBuffer + sVar1,__n);
  if (__n < xBytesAvailable) {
    if (xMaxCount < xBytesAvailable) {
      vAssertCalled();
    }
    memcpy(pucData + __n,pxStreamBuffer->pucBuffer,xBytesAvailable - __n);
  }
  sVar1 = sVar1 + xBytesAvailable;
  if (pxStreamBuffer->xLength <= sVar1) {
    sVar1 = sVar1 - pxStreamBuffer->xLength;
  }
  pxStreamBuffer->xTail = sVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xBytesAvailable;
}



StreamBufferHandle_t
xStreamBufferGenericCreate
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer)

{
  StreamBuffer_t *pxStreamBuffer;
  uint8_t ucFlags;
  size_t sVar1;
  size_t sVar2;
  
  if (xIsMessageBuffer == 1) {
    sVar1 = 1;
    sVar2 = 1;
    if (4 < xBufferSizeBytes) goto LAB_2302f5f4;
    vAssertCalled();
    if (xBufferSizeBytes < xTriggerLevelBytes) goto LAB_2302f62a;
LAB_2302f5f8:
    ucFlags = (uint8_t)sVar2;
  }
  else {
    sVar1 = 0;
    if (xBufferSizeBytes == 0) {
      vAssertCalled();
      sVar2 = xBufferSizeBytes;
      if (xTriggerLevelBytes == 0) goto LAB_2302f5f8;
    }
    else {
LAB_2302f5f4:
      sVar2 = sVar1;
      if (xTriggerLevelBytes <= xBufferSizeBytes) goto LAB_2302f5f8;
    }
LAB_2302f62a:
    ucFlags = (uint8_t)sVar2;
    vAssertCalled();
  }
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  pxStreamBuffer = (StreamBuffer_t *)pvPortMalloc(xBufferSizeBytes + 0x25);
  if (pxStreamBuffer != (StreamBuffer_t *)0x0) {
    prvInitialiseNewStreamBuffer
              (pxStreamBuffer,(uint8_t *)(pxStreamBuffer + 1),xBufferSizeBytes + 1,
               xTriggerLevelBytes,ucFlags);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (StreamBufferHandle_t)pxStreamBuffer;
}



// WARNING: Removing unreachable block (ram,0x2302f6dc)

StreamBufferHandle_t
xStreamBufferGenericCreateStatic
          (size_t xBufferSizeBytes,size_t xTriggerLevelBytes,BaseType_t xIsMessageBuffer,
          uint8_t *pucStreamBufferStorageArea,StaticStreamBuffer_t *pxStaticStreamBuffer)

{
  size_t xSize;
  
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    vAssertCalled();
  }
  if (pxStaticStreamBuffer == (StaticStreamBuffer_t *)0x0) {
    vAssertCalled();
  }
  if (xBufferSizeBytes < xTriggerLevelBytes) {
    vAssertCalled();
  }
  if (xTriggerLevelBytes == 0) {
    xTriggerLevelBytes = 1;
  }
  if (xBufferSizeBytes < 5) {
    vAssertCalled();
  }
  if (pucStreamBufferStorageArea == (uint8_t *)0x0) {
    pxStaticStreamBuffer = (StaticStreamBuffer_t *)0x0;
  }
  else {
    if (pxStaticStreamBuffer != (StaticStreamBuffer_t *)0x0) {
      prvInitialiseNewStreamBuffer
                ((StreamBuffer_t *)pxStaticStreamBuffer,pucStreamBufferStorageArea,xBufferSizeBytes,
                 xTriggerLevelBytes,(xIsMessageBuffer != 0) + '\x02');
      pxStaticStreamBuffer->ucDummy3 = pxStaticStreamBuffer->ucDummy3 | 2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (StreamBufferHandle_t)pxStaticStreamBuffer;
}



void vStreamBufferDelete(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    if ((bRam0000001c & 2) == 0) {
      vPortFree((void *)0x0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    memset((void *)0x0,0,0x24);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((xStreamBuffer->ucFlags & 2) == 0) {
    vPortFree(xStreamBuffer);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memset(xStreamBuffer,0,0x24);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

size_t xStreamBufferSpacesAvailable(StreamBufferHandle_t xStreamBuffer)

{
  size_t sVar1;
  uint uVar2;
  
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
    sVar1 = (_DAT_00000008 + ___EM_SIZE + -1) - _DAT_00000004;
    if (_DAT_00000008 <= sVar1) {
      sVar1 = sVar1 - _DAT_00000008;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return sVar1;
  }
  uVar2 = xStreamBuffer->xLength;
  sVar1 = (uVar2 + xStreamBuffer->xTail + -1) - xStreamBuffer->xHead;
  if (uVar2 <= sVar1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return sVar1 - uVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



size_t xStreamBufferSend(StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                        TickType_t xTicksToWait)

{
  TaskHandle_t ptVar1;
  BaseType_t BVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  TickType_t aTStack52 [2];
  size_t sStack44;
  undefined auStack40 [4];
  TimeOut_t xTimeOut;
  
  aTStack52[0] = xTicksToWait;
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar5 = xDataLengthBytes;
  if (((xStreamBuffer->ucFlags & 1) == 0) ||
     (sVar5 = xDataLengthBytes + 4, xDataLengthBytes < sVar5)) {
    if (aTStack52[0] != 0) goto LAB_2302f7ba;
LAB_2302f85c:
    uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
    if (uVar3 != 0) goto LAB_2302f80c;
LAB_2302f868:
    sVar5 = 0;
  }
  else {
    vAssertCalled();
    if (aTStack52[0] == 0) goto LAB_2302f85c;
LAB_2302f7ba:
    vTaskSetTimeOutState((TimeOut_t *)auStack40);
    do {
      vTaskEnterCritical();
      uVar3 = xStreamBufferSpacesAvailable(xStreamBuffer);
      if (sVar5 <= uVar3) {
        vTaskExitCritical();
        break;
      }
      xTaskNotifyStateClear((TaskHandle_t)0x0);
      if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
        vAssertCalled();
      }
      ptVar1 = xTaskGetCurrentTaskHandle();
      xStreamBuffer->xTaskWaitingToSend = ptVar1;
      vTaskExitCritical();
      xTaskNotifyWait(0,0,(uint32_t *)0x0,aTStack52[0]);
      xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      BVar2 = xTaskCheckForTimeOut((TimeOut_t *)auStack40,aTStack52);
    } while (BVar2 == 0);
    if (uVar3 == 0) goto LAB_2302f85c;
LAB_2302f80c:
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      sStack44 = xDataLengthBytes;
      if (uVar3 < xDataLengthBytes) {
        sStack44 = uVar3;
      }
    }
    else {
      if (uVar3 < sVar5) goto LAB_2302f868;
      sStack44 = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&sStack44,4);
    }
    sVar5 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,sStack44);
    if (sVar5 != 0) {
      uVar3 = xStreamBuffer->xLength;
      uVar4 = (xStreamBuffer->xHead + uVar3) - xStreamBuffer->xTail;
      if (uVar3 <= uVar4) {
        uVar4 = uVar4 - uVar3;
      }
      if (xStreamBuffer->xTriggerLevelBytes <= uVar4) {
        vTaskSuspendAll();
        if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
          xTaskGenericNotify(xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0);
          xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
        }
        xTaskResumeAll();
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar5;
}



size_t xStreamBufferSendFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvTxData,size_t xDataLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  size_t sVar1;
  uint uVar2;
  uint uVar3;
  size_t sVar4;
  size_t asStack36 [3];
  
  if (pvTxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  sVar4 = xDataLengthBytes;
  if ((xStreamBuffer->ucFlags & 1) != 0) {
    sVar4 = xDataLengthBytes + 4;
  }
  sVar1 = xStreamBufferSpacesAvailable(xStreamBuffer);
  if (sVar1 == 0) {
LAB_2302f8de:
    sVar4 = 0;
  }
  else {
    if ((xStreamBuffer->ucFlags & 1) == 0) {
      asStack36[0] = xDataLengthBytes;
      if (sVar1 < xDataLengthBytes) {
        asStack36[0] = sVar1;
      }
    }
    else {
      if (sVar1 < sVar4) goto LAB_2302f8de;
      asStack36[0] = xDataLengthBytes;
      prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)asStack36,4);
    }
    sVar4 = prvWriteBytesToBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvTxData,asStack36[0]);
    if (sVar4 != 0) {
      uVar2 = xStreamBuffer->xLength;
      uVar3 = (xStreamBuffer->xHead + uVar2) - xStreamBuffer->xTail;
      if (uVar2 <= uVar3) {
        uVar3 = uVar3 - uVar2;
      }
      if ((xStreamBuffer->xTriggerLevelBytes <= uVar3) &&
         (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0)) {
        xTaskGenericNotifyFromISR
                  (xStreamBuffer->xTaskWaitingToReceive,0,eNoAction,(uint32_t *)0x0,
                   pxHigherPriorityTaskWoken);
        xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar4;
}



size_t xStreamBufferReceive
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 TickType_t xTicksToWait)

{
  bool bVar1;
  byte bVar2;
  size_t sVar3;
  TaskHandle_t ptVar4;
  uint uVar5;
  uint uVar6;
  uint xMaxCount;
  size_t sVar7;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  bVar2 = xStreamBuffer->ucFlags;
  uVar6 = bVar2 & 1;
  xMaxCount = uVar6 * 4;
  if (xTicksToWait == 0) {
LAB_2302f988:
    uVar5 = xStreamBuffer->xLength;
    sVar3 = (xStreamBuffer->xHead + uVar5) - xStreamBuffer->xTail;
    if (uVar5 <= sVar3) {
      sVar3 = sVar3 - uVar5;
    }
    if (xMaxCount < sVar3) goto LAB_2302f9ce;
  }
  else {
    vTaskEnterCritical();
    uVar5 = xStreamBuffer->xLength;
    sVar3 = (xStreamBuffer->xHead + uVar5) - xStreamBuffer->xTail;
    if (uVar5 <= sVar3) {
      sVar3 = sVar3 - uVar5;
    }
    if (sVar3 <= xMaxCount) {
      xTaskNotifyStateClear((TaskHandle_t)0x0);
      if (xStreamBuffer->xTaskWaitingToReceive != (TaskHandle_t)0x0) {
        vAssertCalled();
      }
      ptVar4 = xTaskGetCurrentTaskHandle();
      xStreamBuffer->xTaskWaitingToReceive = ptVar4;
      vTaskExitCritical();
      xTaskNotifyWait(0,0,(uint32_t *)0x0,xTicksToWait);
      xStreamBuffer->xTaskWaitingToReceive = (TaskHandle_t)0x0;
      goto LAB_2302f988;
    }
    vTaskExitCritical();
LAB_2302f9ce:
    if ((bVar2 & 1) != 0) {
      sVar7 = xStreamBuffer->xTail;
      prvReadBytesFromBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,sVar3);
      sVar3 = sVar3 + uVar6 * -4;
      bVar1 = xBufferLengthBytes < uStack36;
      xBufferLengthBytes = uStack36;
      if (bVar1) {
        xStreamBuffer->xTail = sVar7;
        xBufferLengthBytes = 0;
      }
    }
    sVar3 = prvReadBytesFromBuffer
                      ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,sVar3)
    ;
    if (sVar3 != 0) {
      vTaskSuspendAll();
      if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
        xTaskGenericNotify(xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0);
        xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      }
      xTaskResumeAll();
      goto LAB_2302f99e;
    }
  }
  sVar3 = 0;
LAB_2302f99e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar3;
}



// WARNING: Variable defined which should be unmapped: xTempNextMessageLength

size_t xStreamBufferReceiveFromISR
                 (StreamBufferHandle_t xStreamBuffer,void *pvRxData,size_t xBufferLengthBytes,
                 BaseType_t *pxHigherPriorityTaskWoken)

{
  bool bVar1;
  size_t sVar2;
  uint uVar3;
  uint uVar4;
  uint xMaxCount;
  size_t sVar5;
  uint uStack36;
  size_t xTempNextMessageLength;
  
  if (pvRxData == (void *)0x0) {
    vAssertCalled();
  }
  if (xStreamBuffer == (StreamBufferHandle_t)0x0) {
    vAssertCalled();
  }
  uVar3 = xStreamBuffer->xLength;
  uVar4 = xStreamBuffer->ucFlags & 1;
  sVar2 = (xStreamBuffer->xHead + uVar3) - xStreamBuffer->xTail;
  xMaxCount = uVar4 * 4;
  if (uVar3 <= sVar2) {
    sVar2 = sVar2 - uVar3;
  }
  if (xMaxCount < sVar2) {
    if ((xStreamBuffer->ucFlags & 1) != 0) {
      sVar5 = xStreamBuffer->xTail;
      prvReadBytesFromBuffer((StreamBuffer_t *)xStreamBuffer,(uint8_t *)&uStack36,xMaxCount,sVar2);
      sVar2 = sVar2 + uVar4 * -4;
      bVar1 = xBufferLengthBytes < uStack36;
      xBufferLengthBytes = uStack36;
      if (bVar1) {
        xStreamBuffer->xTail = sVar5;
        xBufferLengthBytes = 0;
      }
    }
    sVar2 = prvReadBytesFromBuffer
                      ((StreamBuffer_t *)xStreamBuffer,(uint8_t *)pvRxData,xBufferLengthBytes,sVar2)
    ;
    if (sVar2 != 0) {
      if (xStreamBuffer->xTaskWaitingToSend != (TaskHandle_t)0x0) {
        xTaskGenericNotifyFromISR
                  (xStreamBuffer->xTaskWaitingToSend,0,eNoAction,(uint32_t *)0x0,
                   pxHigherPriorityTaskWoken);
        xStreamBuffer->xTaskWaitingToSend = (TaskHandle_t)0x0;
      }
      goto LAB_2302fa9a;
    }
  }
  sVar2 = 0;
LAB_2302fa9a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BaseType_t xStreamBufferIsEmpty(StreamBufferHandle_t xStreamBuffer)

{
  if (xStreamBuffer != (StreamBufferHandle_t)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint)(xStreamBuffer->xHead == xStreamBuffer->xTail);
  }
  vAssertCalled();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(_DAT_00000004 == ___EM_SIZE);
}



void prvResetNextTaskUnblockTime(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  xNextTaskUnblockTime = *(TickType_t *)((int)((pxDelayedTaskList->xListEnd).pxNext)->pvOwner + 4);
  return;
}



void prvInitialiseNewTask
               (TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
               UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask,TCB_t *pxNewTCB)

{
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  StackType_t *pSVar4;
  
  memset(pxNewTCB->pxStack,0xa5,ulStackDepth * 4);
  pSVar4 = pxNewTCB->pxStack;
  if (pcName == (char *)0x0) {
    pxNewTCB->pcTaskName[0] = '\0';
  }
  else {
    pcVar2 = pcName + 0x10;
    pcVar3 = pxNewTCB->pcTaskName;
    do {
      cVar1 = *pcName;
      pcName = pcName + 1;
      *pcVar3 = cVar1;
      if (cVar1 == '\0') break;
      pcVar3 = pcVar3 + 1;
    } while (pcName != pcVar2);
    pxNewTCB->pcTaskName[0xf] = '\0';
  }
  if (0x1f < uxPriority) {
    uxPriority = 0x1f;
  }
  pxNewTCB->uxPriority = uxPriority;
  pxNewTCB->uxBasePriority = uxPriority;
  pxNewTCB->uxMutexesHeld = 0;
  vListInitialiseItem(&pxNewTCB->xStateListItem);
  vListInitialiseItem(&pxNewTCB->xEventListItem);
  pxNewTCB->ulNotifiedValue = 0;
  (pxNewTCB->xStateListItem).pvOwner = pxNewTCB;
  (pxNewTCB->xEventListItem).xItemValue = 0x20 - uxPriority;
  (pxNewTCB->xEventListItem).pvOwner = pxNewTCB;
  pxNewTCB->uxCriticalNesting = 0;
  pxNewTCB->ucNotifyState = '\0';
  pSVar4 = (StackType_t *)
           pxPortInitialiseStack
                     ((uint)(pSVar4 + (ulStackDepth - 1)) & 0xfffffff8,pxTaskCode,pvParameters);
  pxNewTCB->pxTopOfStack = pSVar4;
  if (pxCreatedTask != (TaskHandle_t *)0x0) {
    *pxCreatedTask = (TaskHandle_t)pxNewTCB;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvDeleteTCB(TCB_t *pxTCB)

{
  uint8_t uVar1;
  
  uVar1 = pxTCB->ucStaticallyAllocated;
  if (uVar1 == '\0') {
    vPortFree(pxTCB->pxStack);
    vPortFree(pxTCB);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (uVar1 != '\x01') {
    if (uVar1 == '\x02') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    vAssertCalled();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vPortFree(pxTCB);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait,BaseType_t xCanBlockIndefinitely)

{
  TickType_t TVar1;
  uint uVar2;
  UBaseType_t UVar3;
  
  TVar1 = xTickCount;
  UVar3 = uxListRemove(&pxCurrentTCB->xStateListItem);
  if (UVar3 == 0) {
    uxTopReadyPriority = ~(1 << (pxCurrentTCB->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((xTicksToWait == 0xffffffff) && (xCanBlockIndefinitely != 0)) {
    vListInsertEnd(&xSuspendedTaskList,&pxCurrentTCB->xStateListItem);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar2 = xTicksToWait + TVar1;
  (pxCurrentTCB->xStateListItem).xItemValue = uVar2;
  if (TVar1 <= uVar2) {
    vListInsert(pxDelayedTaskList,&pxCurrentTCB->xStateListItem);
    if (uVar2 < xNextTaskUnblockTime) {
      xNextTaskUnblockTime = uVar2;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vListInsert(pxOverflowDelayedTaskList,&pxCurrentTCB->xStateListItem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskEnterCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskExitCritical(void)

{
  pxCurrentTCB->uxCriticalNesting = pxCurrentTCB->uxCriticalNesting - 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvAddNewTaskToReadyList(TCB_t *pxNewTCB)

{
  uint uVar1;
  List_t *pxList;
  List_t *pLVar2;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  uxCurrentNumberOfTasks = uxCurrentNumberOfTasks + 1;
  if (pxCurrentTCB == (TCB_t *)0x0) {
    if (uxCurrentNumberOfTasks == 1) {
      pxList = pxReadyTasksLists;
      pxCurrentTCB = pxNewTCB;
      do {
        pLVar2 = pxList + 1;
        vListInitialise(pxList);
        pxList = pLVar2;
      } while (pLVar2 != &xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList1);
      vListInitialise(&xDelayedTaskList2);
      vListInitialise(&xPendingReadyList);
      vListInitialise(&xTasksWaitingTermination);
      vListInitialise(&xSuspendedTaskList);
      pxDelayedTaskList = &xDelayedTaskList1;
      pxOverflowDelayedTaskList = &xDelayedTaskList2;
      uVar1 = pxNewTCB->uxPriority;
    }
    else {
      uVar1 = pxNewTCB->uxPriority;
      pxCurrentTCB = pxNewTCB;
    }
  }
  else {
    uVar1 = pxNewTCB->uxPriority;
    if ((xSchedulerRunning == 0) && (pxCurrentTCB->uxPriority <= uVar1)) {
      pxCurrentTCB = pxNewTCB;
    }
  }
  uxTaskNumber = uxTaskNumber + 1;
  uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
  pxNewTCB->uxTCBNumber = uxTaskNumber;
  vListInsertEnd(pxReadyTasksLists + uVar1,&pxNewTCB->xStateListItem);
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority)) {
    ecall();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvIdleTask(void *pvParameters)

{
  TCB_t *pxTCB;
  
  do {
    while (uxDeletedTasksWaitingCleanUp != 0) {
      if (xSchedulerRunning != 0) {
        vTaskEnterCritical();
      }
      pxTCB = (TCB_t *)(xTasksWaitingTermination.xListEnd.pxNext)->pvOwner;
      uxListRemove(&pxTCB->xStateListItem);
      uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1;
      uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp - 1;
      if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
        vTaskExitCritical();
      }
      prvDeleteTCB(pxTCB);
    }
    if (1 < pxReadyTasksLists[0].uxNumberOfItems) {
      ecall();
    }
    vApplicationIdleHook();
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x2302ff8e)
// WARNING: Removing unreachable block (ram,0x2302ffd4)

TaskHandle_t
xTaskCreateStatic(TaskFunction_t *pxTaskCode,char *pcName,uint32_t ulStackDepth,void *pvParameters,
                 UBaseType_t uxPriority,StackType_t *puxStackBuffer,StaticTask_t *pxTaskBuffer)

{
  TaskHandle_t ptVar1;
  size_t xSize;
  TaskHandle_t xReturn;
  
  ptVar1 = (TaskHandle_t)xSize;
  if (puxStackBuffer == (StackType_t *)0x0) {
    vAssertCalled();
    ptVar1 = (TaskHandle_t)xSize;
  }
  if (pxTaskBuffer == (StaticTask_t *)0x0) {
    vAssertCalled();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (TaskHandle_t)0x0;
  }
  xSize = 0;
  if (puxStackBuffer != (StackType_t *)0x0) {
    pxTaskBuffer->uxDummy20 = '\x02';
    pxTaskBuffer->pxDummy6 = puxStackBuffer;
    xSize = (size_t)ptVar1;
    prvInitialiseNewTask
              (pxTaskCode,pcName,ulStackDepth,pvParameters,uxPriority,(TaskHandle_t *)&xSize,
               (TCB_t *)pxTaskBuffer);
    prvAddNewTaskToReadyList((TCB_t *)pxTaskBuffer);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (TaskHandle_t)xSize;
}



BaseType_t
xTaskCreate(TaskFunction_t *pxTaskCode,char *pcName,uint16_t usStackDepth,void *pvParameters,
           UBaseType_t uxPriority,TaskHandle_t *pxCreatedTask)

{
  StackType_t *pv;
  TCB_t *pxNewTCB;
  BaseType_t BVar1;
  undefined2 in_register_00002032;
  
  pv = (StackType_t *)pvPortMalloc(CONCAT22(in_register_00002032,usStackDepth) << 2);
  if (pv == (StackType_t *)0x0) {
    BVar1 = -1;
  }
  else {
    pxNewTCB = (TCB_t *)pvPortMalloc(0x60);
    if (pxNewTCB == (TCB_t *)0x0) {
      vPortFree(pv);
      BVar1 = -1;
    }
    else {
      pxNewTCB->pxStack = pv;
      pxNewTCB->ucStaticallyAllocated = '\0';
      prvInitialiseNewTask
                (pxTaskCode,pcName,CONCAT22(in_register_00002032,usStackDepth),pvParameters,
                 uxPriority,pxCreatedTask,pxNewTCB);
      prvAddNewTaskToReadyList(pxNewTCB);
      BVar1 = 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



void vTaskDelete(TaskHandle_t xTaskToDelete)

{
  UBaseType_t UVar1;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (xTaskToDelete == (TaskHandle_t)0x0) {
    xTaskToDelete = (TaskHandle_t)pxCurrentTCB;
  }
  UVar1 = uxListRemove(&((TCB_t *)xTaskToDelete)->xStateListItem);
  if ((UVar1 == 0) && (pxReadyTasksLists[((TCB_t *)xTaskToDelete)->uxPriority].uxNumberOfItems == 0)
     ) {
    uxTopReadyPriority = ~(1 << (((TCB_t *)xTaskToDelete)->uxPriority & 0x1f)) & uxTopReadyPriority;
  }
  if ((((TCB_t *)xTaskToDelete)->xEventListItem).pvContainer != (xLIST *)0x0) {
    uxListRemove(&((TCB_t *)xTaskToDelete)->xEventListItem);
  }
  uxTaskNumber = uxTaskNumber + 1;
  if (pxCurrentTCB == (TCB_t *)xTaskToDelete) {
    vListInsertEnd(&xTasksWaitingTermination,&((TCB_t *)xTaskToDelete)->xStateListItem);
    uxDeletedTasksWaitingCleanUp = uxDeletedTasksWaitingCleanUp + 1;
  }
  else {
    uxCurrentNumberOfTasks = uxCurrentNumberOfTasks - 1;
    prvDeleteTCB((TCB_t *)xTaskToDelete);
    if (pxDelayedTaskList->uxNumberOfItems == 0) {
      xNextTaskUnblockTime = 0xffffffff;
    }
    else {
      prvResetNextTaskUnblockTime();
    }
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB == (TCB_t *)xTaskToDelete)) {
    if (uxSchedulerSuspended == 0) {
      ecall();
    }
    else {
      vAssertCalled();
      ecall();
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



eTaskState eTaskGetState(TaskHandle_t xTask)

{
  List_t *pLVar1;
  List_t *pLVar2;
  List_t *pLVar3;
  eTaskState eVar4;
  
  if (xTask == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  eVar4 = eRunning;
  if (pxCurrentTCB != (TCB_t *)xTask) {
    if (xSchedulerRunning != 0) {
      vTaskEnterCritical();
    }
    pLVar2 = pxOverflowDelayedTaskList;
    pLVar1 = pxDelayedTaskList;
    pLVar3 = (List_t *)(xTask->xStateListItem).pvContainer;
    if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
      vTaskExitCritical();
    }
    if ((pLVar3 == pLVar1) || (pLVar3 == pLVar2)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eBlocked;
    }
    if (pLVar3 == &xSuspendedTaskList) {
      eVar4 = eBlocked;
      if ((xTask->xEventListItem).pvContainer == (xLIST *)0x0) {
        eVar4 = (xTask->ucNotifyState != '\x01') + eBlocked;
      }
    }
    else {
      if (pLVar3 == &xTasksWaitingTermination) {
        eVar4 = eDeleted;
      }
      else {
        eVar4 = (-(pLVar3 == (List_t *)0x0) & 3U) + eReady;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar4;
}



void vTaskStartScheduler(void)

{
  TaskHandle_t ptVar1;
  BaseType_t BVar2;
  StaticTask_t *pSStack28;
  StaticTask_t *pxIdleTaskTCBBuffer;
  StackType_t *pxIdleTaskStackBuffer;
  uint32_t ulIdleTaskStackSize;
  
  pSStack28 = (StaticTask_t *)0x0;
  pxIdleTaskTCBBuffer = (StaticTask_t *)0x0;
  vApplicationGetIdleTaskMemory
            (&pSStack28,(StackType_t **)&pxIdleTaskTCBBuffer,(uint32_t *)&pxIdleTaskStackBuffer);
  ptVar1 = xTaskCreateStatic(prvIdleTask,"IDLE",(uint32_t)pxIdleTaskStackBuffer,(void *)0x0,0,
                             (StackType_t *)pxIdleTaskTCBBuffer,pSStack28);
  if (ptVar1 != (TaskHandle_t)0x0) {
    BVar2 = xTimerCreateTimerTask();
    if (BVar2 == 1) {
      xNextTaskUnblockTime = 0xffffffff;
      xTickCount = 0;
      xSchedulerRunning = BVar2;
      xPortStartScheduler();
    }
    else {
      if (BVar2 == -1) {
        vAssertCalled();
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskSuspendAll(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  return;
}



TickType_t xTaskGetTickCount(void)

{
  return xTickCount;
}



BaseType_t xTaskGetTickCount2(TickType_t *ticks,BaseType_t *overflow)

{
  BaseType_t BVar1;
  
  BVar1 = xNumOfOverflows;
  *ticks = xTickCount;
  *overflow = BVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



TickType_t xTaskGetTickCountFromISR(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xTickCount;
}



char * pcTaskGetName(TaskHandle_t xTaskToQuery)

{
  if ((xTaskToQuery == (TaskHandle_t)0x0) &&
     (xTaskToQuery = (TaskHandle_t)pxCurrentTCB, pxCurrentTCB == (TCB_t *)0x0)) {
    vAssertCalled();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (char *)0x34;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ((TCB_t *)xTaskToQuery)->pcTaskName;
}



BaseType_t xTaskIncrementTick(void)

{
  List_t *pLVar1;
  List_t *pLVar2;
  TickType_t TVar3;
  void *pvVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint32_t uStack52;
  uint32_t tmp;
  
  iVar6 = bl_sys_time_sync_state(&uStack52);
  if (iVar6 != 0) {
    if (uxSchedulerSuspended == 0) {
      uVar7 = xTickCount + 1;
      xTickCount = uVar7;
      if (uVar7 == 0) {
        if (pxDelayedTaskList->uxNumberOfItems != 0) {
          vAssertCalled();
        }
        pLVar2 = pxOverflowDelayedTaskList;
        pLVar1 = pxDelayedTaskList;
        pxDelayedTaskList = pxOverflowDelayedTaskList;
        pxOverflowDelayedTaskList = pLVar1;
        xNumOfOverflows = xNumOfOverflows + 1;
        if (pLVar2->uxNumberOfItems == 0) {
          xNextTaskUnblockTime = 0xffffffff;
        }
        else {
          prvResetNextTaskUnblockTime();
        }
      }
      if (uVar7 < xNextTaskUnblockTime) {
        iVar6 = 0;
        TVar3 = xNextTaskUnblockTime;
      }
      else {
        iVar6 = 0;
        while (iVar5 = iVar6, pxDelayedTaskList->uxNumberOfItems != 0) {
          while( true ) {
            pvVar4 = ((pxDelayedTaskList->xListEnd).pxNext)->pvOwner;
            TVar3 = *(uint *)((int)pvVar4 + 4);
            if (uVar7 < *(uint *)((int)pvVar4 + 4)) goto LAB_230304b2;
            uxListRemove((ListItem_t *)((int)pvVar4 + 4));
            if (*(int *)((int)pvVar4 + 0x28) != 0) {
              uxListRemove((ListItem_t *)((int)pvVar4 + 0x18));
            }
            uxTopReadyPriority = 1 << (*(uint *)((int)pvVar4 + 0x2c) & 0x1f) | uxTopReadyPriority;
            vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar4 + 0x2c),
                           (ListItem_t *)((int)pvVar4 + 4));
            if (*(uint *)((int)pvVar4 + 0x2c) < pxCurrentTCB->uxPriority) break;
            iVar6 = 1;
            iVar5 = 1;
            if (pxDelayedTaskList->uxNumberOfItems == 0) goto LAB_23030498;
          }
        }
LAB_23030498:
        xNextTaskUnblockTime = 0xffffffff;
        iVar6 = iVar5;
        TVar3 = xNextTaskUnblockTime;
      }
LAB_230304b2:
      xNextTaskUnblockTime = TVar3;
      if (1 < pxReadyTasksLists[pxCurrentTCB->uxPriority].uxNumberOfItems) {
        iVar6 = 1;
      }
    }
    else {
      iVar6 = 0;
      uxPendedTicks = uxPendedTicks + 1;
    }
    if (xYieldPending != 0) {
      iVar6 = 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar6;
}



BaseType_t xTaskResumeAll(void)

{
  UBaseType_t UVar1;
  BaseType_t BVar2;
  void *pvVar3;
  
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  uxSchedulerSuspended = uxSchedulerSuspended - 1;
  if ((uxSchedulerSuspended == 0) && (uxCurrentNumberOfTasks != 0)) {
    pvVar3 = (void *)0x0;
    while (xPendingReadyList.uxNumberOfItems != 0) {
      while( true ) {
        pvVar3 = (xPendingReadyList.xListEnd.pxNext)->pvOwner;
        uxListRemove((ListItem_t *)((int)pvVar3 + 0x18));
        uxListRemove((ListItem_t *)((int)pvVar3 + 4));
        uxTopReadyPriority = 1 << (*(uint *)((int)pvVar3 + 0x2c) & 0x1f) | uxTopReadyPriority;
        vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar3 + 0x2c),
                       (ListItem_t *)((int)pvVar3 + 4));
        if (*(uint *)((int)pvVar3 + 0x2c) < pxCurrentTCB->uxPriority) break;
        xYieldPending = 1;
        if (xPendingReadyList.uxNumberOfItems == 0) goto LAB_230305a8;
      }
    }
LAB_230305a8:
    if (pvVar3 != (void *)0x0) {
      if (pxDelayedTaskList->uxNumberOfItems == 0) {
        xNextTaskUnblockTime = 0xffffffff;
      }
      else {
        prvResetNextTaskUnblockTime();
      }
    }
    UVar1 = uxPendedTicks;
    if (uxPendedTicks != 0) {
      do {
        BVar2 = xTaskIncrementTick();
        UVar1 = UVar1 - 1;
        if (BVar2 != 0) {
          xYieldPending = 1;
        }
      } while (UVar1 != 0);
      uxPendedTicks = 0;
    }
    if (xYieldPending != 0) {
      ecall();
      BVar2 = 1;
      goto LAB_230305ec;
    }
  }
  BVar2 = 0;
LAB_230305ec:
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



void vTaskDelay(TickType_t xTicksToDelay)

{
  BaseType_t BVar1;
  
  if (xTicksToDelay == 0) {
    ecall();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (uxSchedulerSuspended != 0) {
    vAssertCalled();
  }
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  prvAddCurrentTaskToDelayedList(xTicksToDelay,0);
  BVar1 = xTaskResumeAll();
  if (BVar1 == 0) {
    ecall();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskSwitchContext(void)

{
  int iVar1;
  StackType_t *pSVar2;
  xLIST_ITEM *pxVar3;
  
  if (uxSchedulerSuspended == 0) {
    xYieldPending = 0;
    pSVar2 = pxCurrentTCB->pxStack;
    if ((((*pSVar2 != 0xa5a5a5a5) || (pSVar2[1] != 0xa5a5a5a5)) || (pSVar2[2] != 0xa5a5a5a5)) ||
       (pSVar2[3] != 0xa5a5a5a5)) {
      vApplicationStackOverflowHook((TaskHandle_t)pxCurrentTCB,pxCurrentTCB->pcTaskName);
    }
    iVar1 = __clzsi2(uxTopReadyPriority);
    iVar1 = 0x1f - iVar1;
    if (pxReadyTasksLists[iVar1].uxNumberOfItems == 0) {
      vAssertCalled();
    }
    pxVar3 = (pxReadyTasksLists[iVar1].pxIndex)->pxNext;
    pxReadyTasksLists[iVar1].pxIndex = (ListItem_t *)pxVar3;
    if (pxVar3 == (xLIST_ITEM *)(iVar1 * 0x14 + 0x42012544)) {
      pxVar3 = pxVar3->pxNext;
      pxReadyTasksLists[iVar1].pxIndex = (ListItem_t *)pxVar3;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    pxCurrentTCB = (TCB_t *)pxVar3->pvOwner;
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  xYieldPending = 1;
  return;
}



void vTaskPlaceOnEventList(List_t *pxEventList,TickType_t xTicksToWait)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsert(pxEventList,&pxCurrentTCB->xEventListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskPlaceOnUnorderedEventList
               (List_t *pxEventList,TickType_t xItemValue,TickType_t xTicksToWait)

{
  ListItem_t *pxNewListItem;
  
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
  }
  pxNewListItem = &pxCurrentTCB->xEventListItem;
  (pxCurrentTCB->xEventListItem).xItemValue = xItemValue | 0x80000000;
  vListInsertEnd(pxEventList,pxNewListItem);
  prvAddCurrentTaskToDelayedList(xTicksToWait,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskPlaceOnEventListRestricted
               (List_t *pxEventList,TickType_t xTicksToWait,BaseType_t xWaitIndefinitely)

{
  if (pxEventList == (List_t *)0x0) {
    vAssertCalled();
  }
  vListInsertEnd(pxEventList,&pxCurrentTCB->xEventListItem);
  if (xWaitIndefinitely != 0) {
    xTicksToWait = 0xffffffff;
  }
  prvAddCurrentTaskToDelayedList(xTicksToWait,xWaitIndefinitely);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BaseType_t xTaskRemoveFromEventList(List_t *pxEventList)

{
  bool bVar1;
  void *pvVar2;
  
  pvVar2 = ((pxEventList->xListEnd).pxNext)->pvOwner;
  if (pvVar2 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove((ListItem_t *)((int)pvVar2 + 0x18));
  if (uxSchedulerSuspended == 0) {
    uxListRemove((ListItem_t *)((int)pvVar2 + 4));
    uxTopReadyPriority = 1 << (*(uint *)((int)pvVar2 + 0x2c) & 0x1f) | uxTopReadyPriority;
    vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar2 + 0x2c),(ListItem_t *)((int)pvVar2 + 4)
                  );
  }
  else {
    vListInsertEnd(&xPendingReadyList,(ListItem_t *)((int)pvVar2 + 0x18));
  }
  bVar1 = pxCurrentTCB->uxPriority < *(uint *)((int)pvVar2 + 0x2c);
  if (bVar1) {
    xYieldPending = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



void vTaskRemoveFromUnorderedEventList(ListItem_t *pxEventListItem,TickType_t xItemValue)

{
  void *pvVar1;
  
  if (uxSchedulerSuspended == 0) {
    vAssertCalled();
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  else {
    pvVar1 = pxEventListItem->pvOwner;
    pxEventListItem->xItemValue = xItemValue | 0x80000000;
  }
  if (pvVar1 == (void *)0x0) {
    vAssertCalled();
  }
  uxListRemove(pxEventListItem);
  uxListRemove((ListItem_t *)((int)pvVar1 + 4));
  uxTopReadyPriority = 1 << (*(uint *)((int)pvVar1 + 0x2c) & 0x1f) | uxTopReadyPriority;
  vListInsertEnd(pxReadyTasksLists + *(uint *)((int)pvVar1 + 0x2c),(ListItem_t *)((int)pvVar1 + 4));
  if (pxCurrentTCB->uxPriority < *(uint *)((int)pvVar1 + 0x2c)) {
    xYieldPending = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskSetTimeOutState(TimeOut_t *pxTimeOut)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  
  if (pxTimeOut == (TimeOut_t *)0x0) {
    vAssertCalled();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  TVar2 = xTickCount;
  BVar1 = xSchedulerRunning;
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = TVar2;
  if ((BVar1 != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskInternalSetTimeOutState(TimeOut_t *pxTimeOut)

{
  TickType_t TVar1;
  
  TVar1 = xTickCount;
  pxTimeOut->xOverflowCount = xNumOfOverflows;
  pxTimeOut->xTimeOnEntering = TVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BaseType_t xTaskCheckForTimeOut(TimeOut_t *pxTimeOut,TickType_t *pxTicksToWait)

{
  int iVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  BaseType_t BVar4;
  uint uVar5;
  uint uVar6;
  
  if (pxTimeOut == (TimeOut_t *)0x0) {
    vAssertCalled();
  }
  if (pxTicksToWait == (TickType_t *)0x0) {
    vAssertCalled();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  TVar3 = xTickCount;
  iVar1 = xSchedulerRunning;
  BVar2 = xNumOfOverflows;
  uVar6 = *pxTicksToWait;
  BVar4 = 0;
  if ((uVar6 != 0xffffffff) &&
     ((uVar5 = pxTimeOut->xTimeOnEntering, pxTimeOut->xOverflowCount == xNumOfOverflows ||
      (BVar4 = 1, xTickCount < uVar5)))) {
    if (xTickCount - uVar5 < uVar6) {
      *pxTicksToWait = (uVar6 - xTickCount) + uVar5;
      pxTimeOut->xOverflowCount = BVar2;
      pxTimeOut->xTimeOnEntering = TVar3;
      BVar4 = 0;
      iVar1 = xSchedulerRunning;
    }
    else {
      *pxTicksToWait = 0;
      BVar4 = 1;
    }
  }
  if ((iVar1 != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar4;
}



void vTaskMissedYield(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  xYieldPending = 1;
  return;
}



void vTaskGetInfo(TaskHandle_t xTask,TaskStatus_t *pxTaskStatus,BaseType_t xGetFreeStackSpace,
                 eTaskState eState)

{
  eTaskState eVar1;
  undefined3 in_register_00002035;
  UBaseType_t UVar2;
  uint uVar3;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  pxTaskStatus->pcTaskName = xTask->pcTaskName;
  pxTaskStatus->xHandle = xTask;
  pxTaskStatus->uxCurrentPriority = xTask->uxPriority;
  pxTaskStatus->pxStackBase = xTask->pxStack;
  pxTaskStatus->xTaskNumber = xTask->uxTCBNumber;
  UVar2 = xTask->uxBasePriority;
  pxTaskStatus->ulRunTimeCounter = 0;
  pxTaskStatus->uxBasePriority = UVar2;
  if (CONCAT31(in_register_00002035,eState) == 5) {
    eVar1 = eTaskGetState(xTask);
    pxTaskStatus->eCurrentState = eVar1;
  }
  else {
    if (pxCurrentTCB == (TCB_t *)xTask) {
      pxTaskStatus->eCurrentState = eRunning;
    }
    else {
      pxTaskStatus->eCurrentState = eState;
      if (CONCAT31(in_register_00002035,eState) == 3) {
        uxSchedulerSuspended = uxSchedulerSuspended + 1;
        if ((xTask->xEventListItem).pvContainer != (xLIST *)0x0) {
          pxTaskStatus->eCurrentState = eBlocked;
        }
        xTaskResumeAll();
      }
    }
  }
  if (xGetFreeStackSpace != 0) {
    if (*(char *)xTask->pxStack == -0x5b) {
      uVar3 = 0;
      do {
        uVar3 = uVar3 + 1;
      } while (*(char *)((int)xTask->pxStack + uVar3) == -0x5b);
      pxTaskStatus->usStackHighWaterMark = (uint16_t)(uVar3 >> 2);
    }
    else {
      pxTaskStatus->usStackHighWaterMark = 0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  pxTaskStatus->usStackHighWaterMark = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



UBaseType_t
prvListTasksWithinSingleList(TaskStatus_t *pxTaskStatusArray,List_t *pxList,eTaskState eState)

{
  TaskHandle_t xTask;
  xLIST_ITEM *pxVar1;
  int iVar2;
  TaskHandle_t ptVar3;
  
  pxVar1 = pxList->pxIndex->pxNext;
  pxList->pxIndex = (ListItem_t *)pxVar1;
  if (pxVar1 == (xLIST_ITEM *)&pxList->xListEnd) {
    pxVar1 = (pxList->xListEnd).pxNext;
    pxList->pxIndex = (ListItem_t *)pxVar1;
  }
  ptVar3 = (TaskHandle_t)pxVar1->pvOwner;
  iVar2 = 0;
  while( true ) {
    pxVar1 = pxVar1->pxNext;
    pxList->pxIndex = (ListItem_t *)pxVar1;
    if ((xLIST_ITEM *)&pxList->xListEnd == pxVar1) {
      pxVar1 = (pxList->xListEnd).pxNext;
      pxList->pxIndex = (ListItem_t *)pxVar1;
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    else {
      xTask = (TaskHandle_t)pxVar1->pvOwner;
      vTaskGetInfo(xTask,pxTaskStatusArray,1,eState);
    }
    if (ptVar3 == xTask) break;
    iVar2 = iVar2 + 1;
    pxTaskStatusArray = pxTaskStatusArray + 1;
    pxVar1 = (xLIST_ITEM *)pxList->pxIndex;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2 + 1;
}



UBaseType_t
uxTaskGetSystemState
          (TaskStatus_t *pxTaskStatusArray,UBaseType_t uxArraySize,uint32_t *pulTotalRunTime)

{
  int iVar1;
  UBaseType_t UVar2;
  int iVar3;
  TaskStatus_t *pxTaskStatusArray_00;
  UBaseType_t UVar4;
  List_t *pxList;
  
  uxSchedulerSuspended = uxSchedulerSuspended + 1;
  UVar4 = 0;
  if (uxCurrentNumberOfTasks <= uxArraySize) {
    pxList = pxReadyTasksLists + 0x1f;
    iVar1 = 0x20;
    UVar4 = 0;
    iVar3 = 0;
    do {
      iVar1 = iVar1 + -1;
      pxTaskStatusArray_00 = (TaskStatus_t *)(&pxTaskStatusArray->xHandle + iVar3 + UVar4);
      if (pxReadyTasksLists[iVar1].uxNumberOfItems != 0) {
        UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxList,eReady);
        UVar4 = UVar4 + UVar2;
        iVar3 = UVar4 * 8;
        pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
      }
      pxList = pxList + -1;
    } while (iVar1 != 0);
    if (pxDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (pxOverflowDelayedTaskList->uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,pxOverflowDelayedTaskList,eBlocked);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xTasksWaitingTermination.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xTasksWaitingTermination,eDeleted);
      UVar4 = UVar4 + UVar2;
      pxTaskStatusArray_00 = pxTaskStatusArray + UVar4;
    }
    if (xSuspendedTaskList.uxNumberOfItems != 0) {
      UVar2 = prvListTasksWithinSingleList(pxTaskStatusArray_00,&xSuspendedTaskList,eSuspended);
      UVar4 = UVar4 + UVar2;
    }
    if (pulTotalRunTime != (uint32_t *)0x0) {
      *pulTotalRunTime = 0;
    }
  }
  xTaskResumeAll();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar4;
}



UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask)

{
  char cVar1;
  uint uVar2;
  StackType_t *pSVar3;
  
  if (xTask == (TaskHandle_t)0x0) {
    pSVar3 = pxCurrentTCB->pxStack;
    cVar1 = *(char *)pSVar3;
  }
  else {
    pSVar3 = xTask->pxStack;
    cVar1 = *(char *)pSVar3;
  }
  if (cVar1 == -0x5b) {
    uVar2 = 0;
    do {
      uVar2 = uVar2 + 1;
    } while (*(char *)((int)pSVar3 + uVar2) == -0x5b);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return uVar2 >> 2 & 0xffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



TaskHandle_t xTaskGetCurrentTaskHandle(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (TaskHandle_t)pxCurrentTCB;
}



BaseType_t xTaskGetSchedulerState(void)

{
  BaseType_t BVar1;
  
  BVar1 = 1;
  if (xSchedulerRunning != 0) {
    BVar1 = (uint)(uxSchedulerSuspended == 0) << 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



BaseType_t xTaskPriorityInherit(TaskHandle_t pxMutexHolder)

{
  UBaseType_t UVar1;
  uint uVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uVar2 = pxMutexHolder->uxPriority;
  if (uVar2 < pxCurrentTCB->uxPriority) {
    if (-1 < (int)(pxMutexHolder->xEventListItem).xItemValue) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer != pxReadyTasksLists + uVar2) {
      pxMutexHolder->uxPriority = pxCurrentTCB->uxPriority;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 1;
    }
    UVar1 = uxListRemove(&pxMutexHolder->xStateListItem);
    if ((UVar1 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
      uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
    }
    uVar2 = pxCurrentTCB->uxPriority;
    uxTopReadyPriority = 1 << (uVar2 & 0x1f) | uxTopReadyPriority;
    pxMutexHolder->uxPriority = uVar2;
    vListInsertEnd(pxReadyTasksLists + uVar2,&pxMutexHolder->xStateListItem);
    uVar2 = 1;
  }
  else {
    uVar2 = (uint)(pxMutexHolder->uxBasePriority < pxCurrentTCB->uxPriority);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



BaseType_t xTaskPriorityDisinherit(TaskHandle_t pxMutexHolder)

{
  uint uVar1;
  UBaseType_t UVar2;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  if (pxCurrentTCB != (TCB_t *)pxMutexHolder) {
    vAssertCalled();
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) goto LAB_23030e5a;
  }
  else {
    UVar2 = pxMutexHolder->uxMutexesHeld - 1;
    pxMutexHolder->uxMutexesHeld = UVar2;
    if (pxMutexHolder->uxPriority == pxMutexHolder->uxBasePriority) goto LAB_23030e5a;
  }
  if (UVar2 == 0) {
    UVar2 = uxListRemove(&pxMutexHolder->xStateListItem);
    if ((UVar2 == 0) && (pxReadyTasksLists[pxMutexHolder->uxPriority].uxNumberOfItems == 0)) {
      uxTopReadyPriority = ~(1 << (pxMutexHolder->uxPriority & 0x1f)) & uxTopReadyPriority;
    }
    uVar1 = pxMutexHolder->uxBasePriority;
    uxTopReadyPriority = 1 << (uVar1 & 0x1f) | uxTopReadyPriority;
    pxMutexHolder->uxPriority = uVar1;
    (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uVar1;
    vListInsertEnd(pxReadyTasksLists + uVar1,&pxMutexHolder->xStateListItem);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
LAB_23030e5a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void vTaskPriorityDisinheritAfterTimeout
               (TaskHandle_t pxMutexHolder,UBaseType_t uxHighestPriorityWaitingTask)

{
  uint uVar1;
  uint uVar2;
  TickType_t TVar3;
  UBaseType_t UVar4;
  int iVar5;
  UBaseType_t UVar6;
  
  if (pxMutexHolder == (TaskHandle_t)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (pxMutexHolder->uxMutexesHeld == 0) {
    vAssertCalled();
    UVar6 = pxMutexHolder->uxBasePriority;
    if (uxHighestPriorityWaitingTask <= UVar6) goto LAB_23030f20;
LAB_23030f3a:
    UVar4 = pxMutexHolder->uxPriority;
    if (UVar4 == uxHighestPriorityWaitingTask) goto LAB_23030f2e;
  }
  else {
    UVar6 = pxMutexHolder->uxBasePriority;
    if (UVar6 < uxHighestPriorityWaitingTask) goto LAB_23030f3a;
LAB_23030f20:
    UVar4 = pxMutexHolder->uxPriority;
    uxHighestPriorityWaitingTask = UVar6;
    if (UVar4 == UVar6) goto LAB_23030f2e;
  }
  if (pxMutexHolder->uxMutexesHeld == 1) {
    if (pxCurrentTCB == (TCB_t *)pxMutexHolder) {
      vAssertCalled();
      UVar4 = pxMutexHolder->uxPriority;
    }
    TVar3 = (pxMutexHolder->xEventListItem).xItemValue;
    pxMutexHolder->uxPriority = uxHighestPriorityWaitingTask;
    if (-1 < (int)TVar3) {
      (pxMutexHolder->xEventListItem).xItemValue = 0x20 - uxHighestPriorityWaitingTask;
    }
    if ((List_t *)(pxMutexHolder->xStateListItem).pvContainer == pxReadyTasksLists + UVar4) {
      UVar6 = uxListRemove(&pxMutexHolder->xStateListItem);
      if (UVar6 == 0) {
        uVar1 = pxMutexHolder->uxPriority;
        iVar5 = uVar1 * 4;
        uVar2 = 1 << (uVar1 & 0x1f);
        if (pxReadyTasksLists[uVar1].uxNumberOfItems == 0) {
          uxTopReadyPriority = ~uVar2 & uxTopReadyPriority;
        }
      }
      else {
        uVar1 = pxMutexHolder->uxPriority;
        uVar2 = 1 << (uVar1 & 0x1f);
        iVar5 = uVar1 << 2;
      }
      uxTopReadyPriority = uVar2 | uxTopReadyPriority;
      vListInsertEnd((List_t *)(&pxReadyTasksLists[0].uxNumberOfItems + iVar5 + uVar1),
                     &pxMutexHolder->xStateListItem);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
LAB_23030f2e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskEnterCritical(void)

{
  if (xSchedulerRunning == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  vTaskEnterCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vTaskExitCritical(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    return;
  }
  return;
}



void vTaskList(char *pcWriteBuffer)

{
  TaskStatus_t *pTVar1;
  TaskStatus_t *pxTaskStatusArray;
  UBaseType_t UVar2;
  size_t sVar3;
  char *pcVar4;
  uint uVar5;
  
  UVar2 = uxCurrentNumberOfTasks;
  *pcWriteBuffer = '\0';
  pxTaskStatusArray = (TaskStatus_t *)pvPortMalloc(UVar2 * 0x24);
  if (pxTaskStatusArray != (TaskStatus_t *)0x0) {
    UVar2 = uxTaskGetSystemState(pxTaskStatusArray,UVar2,(uint32_t *)0x0);
    if (UVar2 != 0) {
      pTVar1 = pxTaskStatusArray;
      do {
        uVar5 = 0;
        if (pTVar1->eCurrentState < 5) {
          uVar5 = (uint)(byte)"XRBSD"[pTVar1->eCurrentState];
        }
        strcpy(pcWriteBuffer,pTVar1->pcTaskName);
        sVar3 = strlen(pcWriteBuffer);
        if (sVar3 < 0xf) {
          pcVar4 = pcWriteBuffer + sVar3;
          do {
            *pcVar4 = ' ';
            pcVar4 = pcVar4 + 1;
          } while (pcWriteBuffer + 0xf != pcVar4);
          sVar3 = 0xf;
        }
        pcVar4 = pcWriteBuffer + sVar3;
        *pcVar4 = '\0';
        sprintf(pcVar4,"\t%c\t%u\t%u\t%u\t%p\r\n",uVar5,pTVar1->uxCurrentPriority,
                (uint)pTVar1->usStackHighWaterMark,pTVar1->xTaskNumber,pTVar1->pxStackBase);
        sVar3 = strlen(pcVar4);
        pTVar1 = pTVar1 + 1;
        pcWriteBuffer = pcVar4 + sVar3;
      } while (pTVar1 != pxTaskStatusArray + UVar2);
    }
    vPortFree(pxTaskStatusArray);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



TickType_t uxTaskResetEventItemValue(void)

{
  TickType_t TVar1;
  
  TVar1 = (pxCurrentTCB->xEventListItem).xItemValue;
  (pxCurrentTCB->xEventListItem).xItemValue = 0x20 - pxCurrentTCB->uxPriority;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TVar1;
}



TaskHandle_t pvTaskIncrementMutexHeldCount(void)

{
  if (pxCurrentTCB != (TCB_t *)0x0) {
    pxCurrentTCB->uxMutexesHeld = pxCurrentTCB->uxMutexesHeld + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (TaskHandle_t)pxCurrentTCB;
}



uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit,TickType_t xTicksToWait)

{
  uint32_t uVar1;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if ((pxCurrentTCB->ulNotifiedValue == 0) &&
     (pxCurrentTCB->ucNotifyState = '\x01', xTicksToWait != 0)) {
    prvAddCurrentTaskToDelayedList(xTicksToWait,1);
    ecall();
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  uVar1 = pxCurrentTCB->ulNotifiedValue;
  if (uVar1 != 0) {
    if (xClearCountOnExit == 0) {
      pxCurrentTCB->ulNotifiedValue = uVar1 - 1;
    }
    else {
      pxCurrentTCB->ulNotifiedValue = 0;
    }
  }
  pxCurrentTCB->ucNotifyState = '\0';
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



BaseType_t
xTaskNotifyWait(uint32_t ulBitsToClearOnEntry,uint32_t ulBitsToClearOnExit,
               uint32_t *pulNotificationValue,TickType_t xTicksToWait)

{
  bool bVar1;
  
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (pxCurrentTCB->ucNotifyState != '\x02') {
    pxCurrentTCB->ulNotifiedValue = ~ulBitsToClearOnEntry & pxCurrentTCB->ulNotifiedValue;
    pxCurrentTCB->ucNotifyState = '\x01';
    if (xTicksToWait != 0) {
      prvAddCurrentTaskToDelayedList(xTicksToWait,1);
      ecall();
    }
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (pulNotificationValue != (uint32_t *)0x0) {
    *pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
  }
  bVar1 = pxCurrentTCB->ucNotifyState == '\x02';
  if (bVar1) {
    pxCurrentTCB->ulNotifiedValue = ~ulBitsToClearOnExit & pxCurrentTCB->ulNotifiedValue;
  }
  pxCurrentTCB->ucNotifyState = '\0';
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



// WARNING: Type propagation algorithm not settling

BaseType_t
xTaskGenericNotify(TaskHandle_t xTaskToNotify,uint32_t ulValue,eNotifyAction eAction,
                  uint32_t *pulPreviousNotificationValue)

{
  uint8_t uVar1;
  BaseType_t BVar2;
  undefined3 in_register_00002031;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  if (pulPreviousNotificationValue != (uint32_t *)0x0) {
    *pulPreviousNotificationValue = xTaskToNotify->ulNotifiedValue;
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  switch(CONCAT31(in_register_00002031,eAction)) {
  case 0:
    break;
  case 1:
    xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue | ulValue;
    break;
  case 2:
    xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
    break;
  case 4:
    BVar2 = 0;
    if (uVar1 == '\x02') goto LAB_23031360;
  case 3:
    xTaskToNotify->ulNotifiedValue = ulValue;
    break;
  default:
    if (xTaskToNotify->ulNotifiedValue != 0xffffffff) {
      vAssertCalled();
    }
  }
  if (uVar1 == '\x01') {
    uxListRemove(&xTaskToNotify->xStateListItem);
    uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
    vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      ecall();
    }
  }
  BVar2 = 1;
LAB_23031360:
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



BaseType_t
xTaskGenericNotifyFromISR
          (TaskHandle_t xTaskToNotify,uint32_t ulValue,eNotifyAction eAction,
          uint32_t *pulPreviousNotificationValue,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  BaseType_t BVar2;
  undefined3 in_register_00002031;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  if (pulPreviousNotificationValue != (uint32_t *)0x0) {
    *pulPreviousNotificationValue = xTaskToNotify->ulNotifiedValue;
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  switch(CONCAT31(in_register_00002031,eAction)) {
  case 0:
    break;
  case 1:
    xTaskToNotify->ulNotifiedValue = ulValue | xTaskToNotify->ulNotifiedValue;
    break;
  case 2:
    xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
    break;
  case 4:
    BVar2 = 0;
    if (uVar1 == '\x02') goto LAB_2303146e;
  case 3:
    xTaskToNotify->ulNotifiedValue = ulValue;
    break;
  default:
    if (xTaskToNotify->ulNotifiedValue != 0xffffffff) {
      vAssertCalled();
    }
  }
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      xYieldPending = 1;
    }
  }
  BVar2 = 1;
LAB_2303146e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar2;
}



void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify,BaseType_t *pxHigherPriorityTaskWoken)

{
  uint8_t uVar1;
  
  if (xTaskToNotify == (TaskHandle_t)0x0) {
    vAssertCalled();
  }
  uVar1 = xTaskToNotify->ucNotifyState;
  xTaskToNotify->ucNotifyState = '\x02';
  xTaskToNotify->ulNotifiedValue = xTaskToNotify->ulNotifiedValue + 1;
  if (uVar1 == '\x01') {
    if ((xTaskToNotify->xEventListItem).pvContainer != (xLIST *)0x0) {
      vAssertCalled();
    }
    if (uxSchedulerSuspended == 0) {
      uxListRemove(&xTaskToNotify->xStateListItem);
      uxTopReadyPriority = 1 << (xTaskToNotify->uxPriority & 0x1f) | uxTopReadyPriority;
      vListInsertEnd(pxReadyTasksLists + xTaskToNotify->uxPriority,&xTaskToNotify->xStateListItem);
    }
    else {
      vListInsertEnd(&xPendingReadyList,&xTaskToNotify->xEventListItem);
    }
    if (pxCurrentTCB->uxPriority < xTaskToNotify->uxPriority) {
      if (pxHigherPriorityTaskWoken != (BaseType_t *)0x0) {
        *pxHigherPriorityTaskWoken = 1;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      xYieldPending = 1;
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BaseType_t xTaskNotifyStateClear(TaskHandle_t xTask)

{
  bool bVar1;
  
  if (xTask == (TaskHandle_t)0x0) {
    xTask = (TaskHandle_t)pxCurrentTCB;
  }
  if (xSchedulerRunning != 0) {
    vTaskEnterCritical();
  }
  bVar1 = ((TCB_t *)xTask)->ucNotifyState == '\x02';
  if (bVar1) {
    ((TCB_t *)xTask)->ucNotifyState = '\0';
  }
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



void prvCheckForValidListAndQueue(void)

{
  vTaskEnterCritical();
  if (xTimerQueue == (QueueHandle_t)0x0) {
    vListInitialise(&xActiveTimerList1);
    vListInitialise(&xActiveTimerList2);
    pxCurrentTimerList = &xActiveTimerList1;
    pxOverflowTimerList = &xActiveTimerList2;
    xTimerQueue = xQueueGenericCreateStatic
                            (4,0x10,prvCheckForValidListAndQueue::lexical_block_0::
                                    ucStaticTimerQueueStorage,
                             &prvCheckForValidListAndQueue::lexical_block_0::xStaticTimerQueue,'\0')
    ;
    if (xTimerQueue != (QueueHandle_t)0x0) {
      vQueueAddToRegistry(xTimerQueue,"TmrQ");
    }
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



BaseType_t
prvInsertTimerInActiveList
          (Timer_t *pxTimer,TickType_t xNextExpiryTime,TickType_t xTimeNow,TickType_t xCommandTime)

{
  (pxTimer->xTimerListItem).xItemValue = xNextExpiryTime;
  (pxTimer->xTimerListItem).pvOwner = pxTimer;
  if (xTimeNow < xNextExpiryTime) {
    if ((xCommandTime <= xTimeNow) || (xNextExpiryTime < xCommandTime)) {
      vListInsert(pxCurrentTimerList,&pxTimer->xTimerListItem);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  else {
    if (xTimeNow - xCommandTime < pxTimer->xTimerPeriodInTicks) {
      vListInsert(pxOverflowTimerList,&pxTimer->xTimerListItem);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



BaseType_t xTimerCreateTimerTask(void)

{
  StaticTask_t *pSStack28;
  StaticTask_t *pxTimerTaskTCBBuffer;
  StackType_t *pxTimerTaskStackBuffer;
  uint32_t ulTimerTaskStackSize;
  
  prvCheckForValidListAndQueue();
  if (xTimerQueue != (QueueHandle_t)0x0) {
    pSStack28 = (StaticTask_t *)0x0;
    pxTimerTaskTCBBuffer = (StaticTask_t *)0x0;
    vApplicationGetTimerTaskMemory
              (&pSStack28,(StackType_t **)&pxTimerTaskTCBBuffer,(uint32_t *)&pxTimerTaskStackBuffer)
    ;
    xTimerTaskHandle =
         xTaskCreateStatic(prvTimerTask,"Tmr Svc",(uint32_t)pxTimerTaskStackBuffer,(void *)0x0,0x1f,
                           (StackType_t *)pxTimerTaskTCBBuffer,pSStack28);
    if (xTimerTaskHandle != (TaskHandle_t)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 1;
    }
  }
  vAssertCalled();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x230317ba)

TimerHandle_t
xTimerCreateStatic(char *pcTimerName,TickType_t xTimerPeriodInTicks,UBaseType_t uxAutoReload,
                  void *pvTimerID,TimerCallbackFunction_t *pxCallbackFunction,
                  StaticTimer_t *pxTimerBuffer)

{
  size_t xSize;
  
  if (pxTimerBuffer == (StaticTimer_t *)0x0) {
    vAssertCalled();
  }
  else {
    pxTimerBuffer->ucDummy8 = '\x02';
    if (xTimerPeriodInTicks == 0) {
      vAssertCalled();
    }
    prvCheckForValidListAndQueue();
    pxTimerBuffer->pvDummy1 = pcTimerName;
    pxTimerBuffer->xDummy3 = xTimerPeriodInTicks;
    pxTimerBuffer->pvDummy5 = pvTimerID;
    pxTimerBuffer->pvDummy6 = (TaskFunction_t *)pxCallbackFunction;
    vListInitialiseItem((ListItem_t *)&pxTimerBuffer->xDummy2);
    if (uxAutoReload != 0) {
      pxTimerBuffer->ucDummy8 = pxTimerBuffer->ucDummy8 | 4;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (TimerHandle_t)pxTimerBuffer;
}



// WARNING: Could not reconcile some variable overlaps

BaseType_t
xTimerGenericCommand
          (TimerHandle_t xTimer,BaseType_t xCommandID,TickType_t xOptionalValue,
          BaseType_t *pxHigherPriorityTaskWoken,TickType_t xTicksToWait)

{
  BaseType_t BVar1;
  BaseType_t BStack48;
  DaemonTaskMessage_t xMessage;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  BVar1 = 0;
  if (xTimerQueue != (QueueHandle_t)0x0) {
    BStack48 = xCommandID;
    xMessage.xMessageID = xOptionalValue;
    xMessage.u._0_4_ = xTimer;
    if (5 < xCommandID) {
      BVar1 = xQueueGenericSendFromISR(xTimerQueue,&BStack48,pxHigherPriorityTaskWoken,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return BVar1;
    }
    BVar1 = xTaskGetSchedulerState();
    if (BVar1 == 2) {
      BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,xTicksToWait,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return BVar1;
    }
    BVar1 = xQueueGenericSend(xTimerQueue,&BStack48,0,0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



void prvSwitchTimerLists(void)

{
  List_t *pLVar1;
  TimerHandle_t xTimer;
  BaseType_t BVar2;
  xLIST_ITEM *pxVar3;
  uint uVar4;
  uint xOptionalValue;
  
  while (pLVar1 = pxCurrentTimerList, pxCurrentTimerList->uxNumberOfItems != 0) {
    pxVar3 = (pxCurrentTimerList->xListEnd).pxNext;
    xTimer = (TimerHandle_t)pxVar3->pvOwner;
    xOptionalValue = pxVar3->xItemValue;
    uxListRemove(&xTimer->xTimerListItem);
    (*xTimer->pxCallbackFunction)(xTimer);
    pLVar1 = pxCurrentTimerList;
    if ((xTimer->ucStatus & 4) != 0) {
      uVar4 = xTimer->xTimerPeriodInTicks + xOptionalValue;
      if (xOptionalValue < uVar4) {
        (xTimer->xTimerListItem).xItemValue = uVar4;
        (xTimer->xTimerListItem).pvOwner = xTimer;
        vListInsert(pLVar1,&xTimer->xTimerListItem);
      }
      else {
        BVar2 = xTimerGenericCommand(xTimer,0,xOptionalValue,(BaseType_t *)0x0,0);
        if (BVar2 == 0) {
          vAssertCalled();
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  pxCurrentTimerList = pxOverflowTimerList;
  pxOverflowTimerList = pLVar1;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void prvTimerTask(void *pvParameters)

{
  uint xTimeNow;
  BaseType_t BVar1;
  TickType_t xTimeNow_00;
  TickType_t TVar2;
  uint xWaitIndefinitely;
  UBaseType_t xCommandTime;
  Timer_t *pTVar3;
  uint uStack64;
  DaemonTaskMessage_t xMessage;
  
  do {
    xCommandTime = pxCurrentTimerList->uxNumberOfItems;
    if (xCommandTime == 0) {
      vTaskSuspendAll();
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) goto LAB_23031aa2;
      xWaitIndefinitely = (uint)(pxOverflowTimerList->uxNumberOfItems == 0);
LAB_2303199c:
      xLastTime_2297 = xTimeNow;
      vQueueWaitForMessageRestricted(xTimerQueue,xCommandTime - xTimeNow,xWaitIndefinitely);
      BVar1 = xTaskResumeAll();
      if (BVar1 == 0) {
        ecall();
      }
    }
    else {
      xCommandTime = ((pxCurrentTimerList->xListEnd).pxNext)->xItemValue;
      vTaskSuspendAll();
      xTimeNow = xTaskGetTickCount();
      if (xTimeNow < xLastTime_2297) {
LAB_23031aa2:
        prvSwitchTimerLists();
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
      }
      else {
        xWaitIndefinitely = 0;
        if (xTimeNow < xCommandTime) goto LAB_2303199c;
        xLastTime_2297 = xTimeNow;
        xTaskResumeAll();
        pTVar3 = (Timer_t *)((pxCurrentTimerList->xListEnd).pxNext)->pvOwner;
        uxListRemove(&pTVar3->xTimerListItem);
        if ((pTVar3->ucStatus & 4) == 0) {
          pTVar3->ucStatus = pTVar3->ucStatus & 0xfe;
        }
        else {
          BVar1 = prvInsertTimerInActiveList
                            (pTVar3,pTVar3->xTimerPeriodInTicks + xCommandTime,xTimeNow,xCommandTime
                            );
          if ((BVar1 != 0) &&
             (BVar1 = xTimerGenericCommand((TimerHandle_t)pTVar3,0,xCommandTime,(BaseType_t *)0x0,0)
             , BVar1 == 0)) {
            vAssertCalled();
          }
        }
        (*pTVar3->pxCallbackFunction)((TimerHandle_t)pTVar3);
      }
    }
    while (BVar1 = xQueueReceive(xTimerQueue,&uStack64,0), BVar1 != 0) {
      if ((-1 < (int)uStack64) ||
         ((*(code *)xMessage.xMessageID)((Timer_t *)xMessage.u,xMessage.u._4_4_,xMessage.xMessageID)
         , -1 < (int)uStack64)) {
        pTVar3 = (Timer_t *)xMessage.u;
        if ((((Timer_t *)xMessage.u)->xTimerListItem).pvContainer != (xLIST *)0x0) {
          uxListRemove(&((Timer_t *)xMessage.u)->xTimerListItem);
        }
        xTimeNow_00 = xTaskGetTickCount();
        if (xTimeNow_00 < xLastTime_2297) {
          prvSwitchTimerLists();
        }
        xLastTime_2297 = xTimeNow_00;
        switch(uStack64) {
        case 0:
        case 1:
        case 2:
        case 6:
        case 7:
          pTVar3->ucStatus = pTVar3->ucStatus | 1;
          BVar1 = prvInsertTimerInActiveList
                            (pTVar3,pTVar3->xTimerPeriodInTicks + xMessage.xMessageID,xTimeNow_00,
                             xMessage.xMessageID);
          if (((BVar1 != 0) &&
              ((*pTVar3->pxCallbackFunction)((TimerHandle_t)pTVar3), (pTVar3->ucStatus & 4) != 0))
             && (BVar1 = xTimerGenericCommand
                                   ((TimerHandle_t)pTVar3,0,
                                    xMessage.xMessageID + pTVar3->xTimerPeriodInTicks,
                                    (BaseType_t *)0x0,0), BVar1 == 0)) {
            vAssertCalled();
          }
          break;
        case 3:
        case 8:
          pTVar3->ucStatus = pTVar3->ucStatus & 0xfe;
          break;
        case 4:
        case 9:
          pTVar3->ucStatus = pTVar3->ucStatus | 1;
          pTVar3->xTimerPeriodInTicks = xMessage.xMessageID;
          TVar2 = xMessage.xMessageID;
          if (xMessage.xMessageID == 0) {
            vAssertCalled();
            TVar2 = pTVar3->xTimerPeriodInTicks;
          }
          prvInsertTimerInActiveList(pTVar3,TVar2 + xTimeNow_00,xTimeNow_00,xTimeNow_00);
          break;
        case 5:
          if ((pTVar3->ucStatus & 2) == 0) {
            vPortFree(pTVar3);
          }
          else {
            pTVar3->ucStatus = pTVar3->ucStatus & 0xfe;
          }
        }
      }
    }
  } while( true );
}



void * pvTimerGetTimerID(TimerHandle_t xTimer)

{
  void *pvVar1;
  
  if (xTimer == (TimerHandle_t)0x0) {
    vAssertCalled();
  }
  vTaskEnterCritical();
  pvVar1 = xTimer->pvTimerID;
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void vPortSetupTimerInterrupt(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_02004000 = _DAT_0200bff8 + 10000;
  _DAT_02004004 = (uint)(_DAT_0200bff8 + 10000 < _DAT_0200bff8) + _DAT_0200bffc;
  ullNextTime._0_4_ = _DAT_0200bff8 + 20000;
  ullNextTime._4_4_ = _DAT_0200bffc + (uint)(_DAT_0200bff8 + 20000 < _DAT_0200bff8);
  return;
}



// WARNING: Removing unreachable block (ram,0x23031b98)
// WARNING: Removing unreachable block (ram,0x23031bcc)

BaseType_t xPortStartScheduler(void)

{
  uint32_t mtvec;
  
  vPortSetupTimerInterrupt();
  DAT_02800407 = 1;
  xPortStartFirstTask();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x23031d4e)
// WARNING: Removing unreachable block (ram,0x23031cba)
// WARNING: Removing unreachable block (ram,0x23031c3c)
// WARNING: Removing unreachable block (ram,0x23031caa)
// WARNING: Removing unreachable block (ram,0x23031d4a)
// WARNING: Removing unreachable block (ram,0x23031d52)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8
freertos_risc_v_trap_handler
          (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
          undefined4 param_9,undefined4 param_10,undefined4 param_11,undefined4 param_12,
          undefined4 param_13,undefined4 param_14,undefined4 param_15,undefined4 param_16)

{
  uint64_t *puVar1;
  uint mcause;
  BaseType_t BVar2;
  int iVar3;
  uint32_t in_mepc;
  uint in_mcause;
  uint32_t in_mtval;
  StackType_t local_100 [11];
  undefined4 uStack212;
  undefined4 uStack208;
  undefined4 uStack204;
  undefined4 uStack200;
  undefined4 uStack196;
  undefined4 uStack192;
  undefined4 uStack188;
  undefined4 uStack184;
  undefined4 uStack92;
  undefined4 uStack88;
  undefined4 uStack84;
  undefined4 uStack80;
  undefined4 uStack76;
  undefined4 uStack72;
  undefined4 uStack68;
  undefined4 uStack64;
  
  *pTrapNetCounter = *pTrapNetCounter + 1;
  pxCurrentTCB->pxTopOfStack = local_100;
  puVar1 = pullNextTime;
  mcause = in_mcause & 0x807fffff;
  uStack212 = param_9;
  uStack208 = param_10;
  uStack204 = param_11;
  uStack200 = param_12;
  uStack196 = param_13;
  uStack192 = param_14;
  uStack188 = param_15;
  uStack184 = param_16;
  uStack92 = param_1;
  uStack88 = param_2;
  uStack84 = param_3;
  uStack80 = param_4;
  uStack76 = param_5;
  uStack72 = param_6;
  uStack68 = param_7;
  uStack64 = param_8;
  if ((int)mcause < 0) {
    if (mcause == 0x80000007) {
      _DAT_02004000 = *(uint *)pullNextTime;
      _DAT_02004004 = *(int *)((int)pullNextTime + 4);
      iVar3 = _DAT_02004004 + (uint)(_DAT_02004000 + 10000 < _DAT_02004000);
      *(uint *)pullNextTime = _DAT_02004000 + 10000;
      *(int *)((int)puVar1 + 4) = iVar3;
      BVar2 = xTaskIncrementTick();
      if (BVar2 != 0) {
        vTaskSwitchContext();
      }
    }
    else {
      interrupt_entry(mcause);
    }
  }
  else {
    local_100[0] = in_mepc + 4;
    if (mcause == 0xb) {
      vTaskSwitchContext();
    }
    else {
      exception_entry(in_mcause,in_mepc,in_mtval,local_100);
    }
  }
  *pTrapNetCounter = *pTrapNetCounter + -1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return *(undefined8 *)(pxCurrentTCB->pxTopOfStack + 0xb);
}



undefined8 xPortStartFirstTask(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return *(undefined8 *)(pxCurrentTCB->pxTopOfStack + 0xb);
}



// WARNING: Removing unreachable block (ram,0x23032000)

void pxPortInitialiseStack(int param_1,undefined4 param_2,undefined4 param_3)

{
  int iVar1;
  undefined4 *puVar2;
  uint in_mstatus;
  
  *(uint *)(param_1 + -4) = in_mstatus & 0xfffffff7 | 0x1880;
  *(undefined4 *)(param_1 + -0x5c) = param_3;
  puVar2 = (undefined4 *)(param_1 + -0x74);
  *puVar2 = 0;
  iVar1 = 0x22;
  while (iVar1 != 0) {
    puVar2 = puVar2 + -1;
    *puVar2 = 0;
    iVar1 = iVar1 + -1;
  }
  puVar2[-1] = param_2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void prvInsertBlockIntoFreeList(BlockLink_t *pxBlockToInsert)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  
  pBVar3 = &xStart;
  do {
    pBVar2 = pBVar3;
    pBVar3 = (BlockLink_t *)pBVar2->pxNextFreeBlock;
  } while (pBVar3 < pxBlockToInsert);
  sVar1 = pxBlockToInsert->xBlockSize;
  if (pxBlockToInsert == (BlockLink_t *)(pBVar2->xBlockSize + (int)&pBVar2->pxNextFreeBlock)) {
    sVar1 = pBVar2->xBlockSize + sVar1;
    pBVar2->xBlockSize = sVar1;
    pxBlockToInsert = pBVar2;
  }
  if ((pBVar3 == (BlockLink_t *)(sVar1 + (int)&pxBlockToInsert->pxNextFreeBlock)) &&
     (pBVar3 != pxEnd)) {
    pxBlockToInsert->xBlockSize = sVar1 + pBVar3->xBlockSize;
    pxBlockToInsert->pxNextFreeBlock = pBVar2->pxNextFreeBlock->pxNextFreeBlock;
  }
  else {
    pxBlockToInsert->pxNextFreeBlock = (A_BLOCK_LINK *)pBVar3;
  }
  if (pxBlockToInsert != pBVar2) {
    pBVar2->pxNextFreeBlock = (A_BLOCK_LINK *)pxBlockToInsert;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * pvPortMalloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pBVar5;
  uint uVar6;
  uint uVar7;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar7 = xWantedSize + 8;
    if ((uVar7 & 7) != 0) {
      uVar7 = (uVar7 & 0xfffffff8) + 8;
    }
    if ((uVar7 == 0) || (xFreeBytesRemaining < uVar7)) goto LAB_230321ba;
    pAVar4 = xStart.pxNextFreeBlock;
    pBVar3 = &xStart;
    do {
      pBVar5 = pBVar3;
      pBVar3 = (BlockLink_t *)pAVar4;
      if (uVar7 <= pBVar3->xBlockSize) break;
      pAVar4 = pBVar3->pxNextFreeBlock;
    } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
    if (pxEnd == pBVar3) goto LAB_230321ba;
    pAVar4 = pBVar5->pxNextFreeBlock;
    pBVar5->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
    uVar6 = pBVar3->xBlockSize;
    pAVar4 = pAVar4 + 1;
    if (0x10 < uVar6 - uVar7) {
      pBVar5 = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar7);
      pBVar5->xBlockSize = uVar6 - uVar7;
      pBVar3->xBlockSize = uVar7;
      prvInsertBlockIntoFreeList(pBVar5);
      uVar6 = pBVar3->xBlockSize;
    }
    xFreeBytesRemaining = sVar2 - uVar6;
    if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
      xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    }
    pBVar3->xBlockSize = sVar1 | uVar6;
    pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
    xTaskResumeAll();
    if (pAVar4 != (A_BLOCK_LINK *)0x0) goto LAB_230321c4;
  }
  else {
LAB_230321ba:
    xTaskResumeAll();
  }
  vApplicationMallocFailedHook();
  pAVar4 = (A_BLOCK_LINK *)0x0;
LAB_230321c4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pAVar4;
}



void vPortFree(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      goto LAB_230322ce;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_230322ce;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_230322ce:
  *(size_t *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



size_t xPortGetFreeHeapSize(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xFreeBytesRemaining;
}



void vPortDefineHeapRegions(HeapRegion_t *pxHeapRegions)

{
  size_t sVar1;
  BlockLink_t *pBVar2;
  BlockLink_t *pBVar3;
  BlockLink_t *pBVar4;
  A_BLOCK_LINK *pAVar5;
  int iVar6;
  size_t sVar7;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    sVar1 = pxHeapRegions->xSizeInBytes;
    if (sVar1 != 0) goto LAB_23032340;
LAB_230323fc:
    xMinimumEverFreeBytesRemaining = 0;
  }
  else {
    vAssertCalled();
    sVar1 = pxHeapRegions->xSizeInBytes;
    if (sVar1 == 0) goto LAB_230323fc;
LAB_23032340:
    iVar6 = 0;
    sVar7 = 0;
    pBVar4 = pxEnd;
    do {
      pBVar2 = (BlockLink_t *)pxHeapRegions->pucStartAddress;
      pBVar3 = pBVar2;
      if (((uint)pBVar2 & 7) != 0) {
        pBVar3 = (BlockLink_t *)((int)&pBVar2->xBlockSize + 3U & 0xfffffff8);
        sVar1 = (int)pBVar2 + (sVar1 - (int)pBVar3);
      }
      if (iVar6 == 0) {
        xStart.xBlockSize = 0;
        pBVar2 = pBVar4;
        xStart.pxNextFreeBlock = (A_BLOCK_LINK *)pBVar3;
      }
      else {
        if (pBVar4 == (BlockLink_t *)0x0) {
          vAssertCalled();
          pBVar4 = pxEnd;
        }
        pBVar2 = pBVar4;
        if (pBVar3 <= pBVar4) {
          vAssertCalled();
          pBVar2 = pxEnd;
        }
      }
      pBVar4 = (BlockLink_t *)((int)&pBVar3[-1].pxNextFreeBlock + sVar1 & 0xfffffff8);
      ((A_BLOCK_LINK *)pBVar4)->xBlockSize = 0;
      ((A_BLOCK_LINK *)pBVar4)->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
      pAVar5 = (A_BLOCK_LINK *)((int)pBVar4 - (int)pBVar3);
      pxEnd = pBVar4;
      pBVar3->xBlockSize = (size_t)pAVar5;
      pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)pBVar4;
      if (pBVar2 != (BlockLink_t *)0x0) {
        pBVar2->pxNextFreeBlock = (A_BLOCK_LINK *)pBVar3;
        pAVar5 = (A_BLOCK_LINK *)pBVar3->xBlockSize;
      }
      sVar1 = pxHeapRegions[1].xSizeInBytes;
      sVar7 = (int)&pAVar5->pxNextFreeBlock + sVar7;
      iVar6 = iVar6 + 1;
      pxHeapRegions = pxHeapRegions + 1;
    } while (sVar1 != 0);
    xFreeBytesRemaining = sVar7;
    xMinimumEverFreeBytesRemaining = sVar7;
    if (sVar7 != 0) goto LAB_230323ba;
  }
  xFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
  vAssertCalled();
LAB_230323ba:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  xBlockAllocatedBit = 0x80000000;
  return;
}



void uart_generic_notify_handler(uint8_t id)

{
  uint uVar1;
  uint uVar2;
  undefined3 in_register_00002029;
  int iVar3;
  uint32_t uVar4;
  
  iVar3 = CONCAT31(in_register_00002029,id);
  uVar4 = uartAddr[iVar3];
  uVar2 = *(uint *)(uVar4 + 0x20);
  uVar1 = *(uint *)(uVar4 + 0x24);
  if (((uVar2 & 1) != 0) && ((uVar1 & 1) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 1;
  }
  if (((uVar2 & 2) != 0) && ((uVar1 & 2) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 2;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 4) != 0) && ((uVar1 & 4) == 0)) {
    if (g_uart_notify_arg[iVar3].tx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].tx_cb)(g_uart_notify_arg[iVar3].tx_cb_arg);
    }
  }
  if (((uVar2 & 8) != 0) && ((uVar1 & 8) == 0)) {
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x10) != 0) && ((uVar1 & 0x10) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x10;
    if (g_uart_notify_arg[iVar3].rx_cb != (cb_uart_notify_t *)0x0) {
      (*g_uart_notify_arg[iVar3].rx_cb)(g_uart_notify_arg[iVar3].rx_cb_arg);
    }
  }
  if (((uVar2 & 0x20) != 0) && ((uVar1 & 0x20) == 0)) {
    *(undefined4 *)(uVar4 + 0x28) = 0x20;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void UART0_IRQHandler(void)

{
  uart_generic_notify_handler('\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void UART1_IRQHandler(void)

{
  uart_generic_notify_handler('\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int bl_uart_init(uint8_t id,uint8_t tx_pin,uint8_t rx_pin,uint8_t cts_pin,uint8_t rts_pin,
                uint32_t baudrate)

{
  GLB_UART_SIG_FUN_Type fun;
  undefined3 in_register_00002029;
  GLB_UART_SIG_FUN_Type fun_00;
  UART_FifoCfg_Type UStack60;
  UART_FifoCfg_Type fifoCfg;
  GLB_GPIO_Cfg_Type cfg;
  UART_CFG_Type uartCfg;
  
  memcpy(&cfg.drive,&DAT_23082820,0x10);
  UStack60 = DAT_4200d9c0;
  if (bl_uart_init::uart_clk_init == '\0') {
    GLB_Set_UART_CLK('\x01',HBN_UART_CLK_160M,'\x03');
    bl_uart_init::uart_clk_init = '\x01';
  }
  fifoCfg.rxFifoDmaThreshold = '\a';
  fifoCfg._2_2_ = 2;
  cfg._0_2_ = 0x101;
  fifoCfg.txFifoDmaThreshold = rx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  fifoCfg._2_2_ = 2;
  fifoCfg.txFifoDmaThreshold = tx_pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)&fifoCfg);
  if (CONCAT31(in_register_00002029,id) == 0) {
    fun = GLB_UART_SIG_FUN_UART0_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART0_TXD;
  }
  else {
    fun = GLB_UART_SIG_FUN_UART1_RXD;
    fun_00 = GLB_UART_SIG_FUN_UART1_TXD;
  }
  GLB_UART_Fun_Sel(tx_pin & 7,fun_00);
  GLB_UART_Fun_Sel(rx_pin & 7,fun);
  stack0xffffffd0 = 40000000;
  UART_IntMask(id,UART_INT_ALL,MASK);
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)&cfg.drive);
  UART_TxFreeRun(id,ENABLE);
  UART_FifoConfig(id,&UStack60);
  UART_Enable(id,UART_TXRX);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_data_send(uint8_t id,uint8_t data)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  do {
    uVar2 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar2) == 0);
  *(uint8_t *)(uVar1 + 0x88) = data;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_data_recv(uint8_t id)

{
  uint32_t uVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,id)];
  uVar2 = UART_GetRxFifoCount(id);
  if (CONCAT31(extraout_var,uVar2) == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    uVar3 = (uint)*(byte *)(uVar1 + 0x8c);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



int bl_uart_int_rx_enable(uint8_t id)

{
  UART_SetRxTimeoutValue(id,'\x18');
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,UNMASK);
  UART_IntMask(id,UART_INT_RX_END,UNMASK);
  UART_IntMask(id,UART_INT_RTO,UNMASK);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_int_rx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_RX_FIFO_REQ,MASK);
  UART_IntMask(id,UART_INT_RX_END,MASK);
  UART_IntMask(id,UART_INT_RTO,MASK);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_int_tx_enable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,UNMASK);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_int_tx_disable(uint8_t id)

{
  UART_IntMask(id,UART_INT_TX_FIFO_REQ,MASK);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_flush(uint8_t id)

{
  uint8_t uVar1;
  undefined3 extraout_var;
  
  do {
    uVar1 = UART_GetTxFifoCount(id);
  } while (CONCAT31(extraout_var,uVar1) != 0x20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_uart_getdefconfig(uint8_t id,uint8_t *parity)

{
  if (parity != (uint8_t *)0x0) {
    *parity = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: UartCfg

void bl_uart_setconfig(uint8_t id,uint32_t baudrate,UART_Parity_Type parity)

{
  undefined auStack32 [4];
  UART_CFG_Type UartCfg;
  
  memcpy(auStack32,&DAT_23082830,0x10);
  UartCfg.uartClk = baudrate;
  UartCfg.baudRate._2_1_ = parity;
  UART_Disable(id,UART_TXRX);
  UART_Init(id,(UART_CFG_Type *)auStack32);
  UART_TxFreeRun(id,ENABLE);
  UART_Enable(id,UART_TXRX);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_uart_setbaud(uint8_t id,uint32_t baud)

{
  bl_uart_setconfig(id,baud,UART_PARITY_NONE);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_uart_int_enable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\0');
    bl_irq_register(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    bl_uart_int_rx_enable(id);
    bl_uart_int_tx_enable('\x01');
    bl_irq_register(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_enable(source);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_int_disable(uint8_t id)

{
  undefined3 in_register_00002029;
  uint source;
  
  if (CONCAT31(in_register_00002029,id) == 0) {
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\0');
    bl_irq_unregister(0x2d,UART0_IRQHandler);
    source = 0x2d;
  }
  else {
    if (CONCAT31(in_register_00002029,id) != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    bl_uart_int_rx_disable(id);
    bl_uart_int_tx_disable('\x01');
    bl_irq_unregister(0x2e,UART1_IRQHandler);
    source = 0x2e;
  }
  bl_irq_disable(source);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_uart_int_rx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].rx_cb = cb;
    g_uart_notify_arg[uVar1].rx_cb_arg = arg;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int bl_uart_int_tx_notify_register(uint8_t id,cb_uart_notify_t *cb,void *arg)

{
  undefined3 in_register_00002029;
  uint uVar1;
  
  uVar1 = CONCAT31(in_register_00002029,id);
  if (uVar1 < 2) {
    g_uart_notify_arg[uVar1].tx_cb = cb;
    g_uart_notify_arg[uVar1].tx_cb_arg = arg;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Removing unreachable block (ram,0x23032876)

int bl_chip_info(char *info)

{
  char *pcVar1;
  undefined *__src;
  uint uVar2;
  uint in_register_90000c04;
  uint32_t misa;
  
  uVar2 = in_register_90000c04 >> 0x1e;
  if (uVar2 == 2) {
    memcpy(info,&DAT_23082b04,4);
    pcVar1 = info + 4;
  }
  else {
    if (uVar2 == 3) {
      memcpy(info,"RV128",5);
      pcVar1 = info + 5;
    }
    else {
      pcVar1 = info + 4;
      if (uVar2 == 1) {
        __src = &DAT_23082afc;
      }
      else {
        __src = &DAT_23082b14;
      }
      memcpy(info,__src,4);
    }
  }
  *pcVar1 = '-';
  pcVar1 = pcVar1 + 1;
  uVar2 = 0;
  do {
    if ((1 << (uVar2 & 0x1f) & in_register_90000c04) != 0) {
      *pcVar1 = (char)uVar2 + 'A';
      pcVar1 = pcVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 0x1a);
  *pcVar1 = '\0';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_chip_banner(char **banner)

{
  *banner = bannder_shadow_bl602;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_chip_memory_ram(int *num,uint *addr,uint *size,char (*desc) [6])

{
  if (2 < *num) {
    *num = 3;
    *addr = (uint)bl602_start;
    *size = 0x400000;
    strcpy((char *)desc,"flash");
    addr[1] = (uint)&__global_pointer_head_;
    size[1] = (uint)&_ld_ram_size1;
    strcpy((char *)desc[1],"tcm");
    addr[2] = (uint)&ipc_shared_env;
    size[2] = (uint)&_ld_ram_size2;
    strcpy((char *)desc[2],"wifi");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void _cb_cmd(void *arg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [DMA] [TEST] Callback is working, arg is %p\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0xe5,arg);
  }
  *(undefined4 *)((int)arg + 8) = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: last
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_cks_test(void)

{
  TickType_t TVar1;
  char *pcVar2;
  undefined *puVar3;
  undefined4 uVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  undefined2 local_80;
  ushort uStack126;
  uint16_t data_segment_one;
  uint16_t cks_result;
  uint32_t cks_cmd_list [2];
  bl_dma_item first;
  bl_dma_item second;
  bl_dma_item last;
  
  second.arg = &local_80;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] --->>> case1 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x137);
  }
  DAT_4000a700 = 1;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with LE is %04x, should be %02x%02x\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0x40,uVar6,0x61,0xb8);
  }
  DAT_4000a700 = 2;
  iVar5 = 0;
  do {
    DAT_4000a704 = data_src1_2802[iVar5];
    iVar5 = iVar5 + 1;
  } while (iVar5 != 0x14);
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS result with BE is %04x, should be %02x%02x\r\n",TVar1,
              &DAT_2307f16c,"bl_cks.c",0x48,uVar6,0x61,0xb8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case2 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x139);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0x61,uVar6,0xc0e0);
  }
  DAT_4000a700 = 2;
  DAT_4000a704 = 0x3f;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
                0x73,uVar6,0xc0e0);
      if (uVar6 != 0xc0e0) goto LAB_2303332e;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032c88;
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc0e0;
      uVar4 = 0x75;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_23032c7a:
      bl_printk(pcVar2,TVar1,&DAT_2307f16c,"bl_cks.c",uVar4,uVar6);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case3 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13b);
      }
    }
    else {
      if (uVar6 != 0xc0e0) goto LAB_23033338;
    }
  }
  else {
    if (uVar6 != 0xc0e0) {
LAB_2303332e:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23033338:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar1 = xTaskGetTickCount();
          }
          else {
            TVar1 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0x77;
          pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_23032c7a;
        }
      }
    }
  }
LAB_23032c88:
  DAT_4000a700 = 1;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0x91,uVar7,~uVar6 & 0xffff);
  }
  DAT_4000a700 = 2;
  iVar5 = 1000;
  do {
    DAT_4000a704 = 0x3f;
    iVar5 = iVar5 + -1;
  } while (iVar5 != 0);
  uVar6 = 0xf69118;
  while (uVar6 >> 0x10 != 0) {
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  }
  uVar7 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0xa3,uVar7,~uVar6 & 0xffff);
  }
  if (uVar7 == (~uVar6 & 0xffff)) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa5;
      puVar3 = &DAT_2307f16c;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230330f0:
      bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,uVar7);
      goto LAB_230330f4;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar4 = 0xa7;
      puVar3 = &DAT_23072bcc;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
      goto LAB_230330f0;
    }
LAB_230330f4:
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] --->>> case4 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13d);
    }
  }
  DAT_4000a700 = 1;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] CKS LE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
              0xc4,uVar6,0xc03f);
  }
  DAT_4000a700 = 2;
  DAT_4000a704 = 0xa1;
  uVar6 = (uint)_DAT_4000a708;
  if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
    if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] CKS BE result is %04x, %04x\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",
                0xd8,uVar6,0xc03f);
      if (uVar6 != 0xc03f) goto LAB_230332da;
      if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks)
         ) goto LAB_23032ef6;
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      uVar6 = 0xc03f;
      uVar4 = 0xda;
      puVar3 = &DAT_2307f16c;
      pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
LAB_230331c2:
      bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,uVar6);
LAB_230331c6:
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_WARN)
         ) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] --->>> case5 test\r\n",TVar1,&DAT_2307f16c,"bl_cks.c",0x13f);
      }
    }
    else {
      if (uVar6 != 0xc03f) goto LAB_230332e4;
    }
  }
  else {
    if (uVar6 != 0xc03f) {
LAB_230332da:
      if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
LAB_230332e4:
        if (_fsymf_level_hal_drvbl_cks < BLOG_LEVEL_ASSERT) {
          if (TrapNetCounter == 0) {
            TVar1 = xTaskGetTickCount();
          }
          else {
            TVar1 = xTaskGetTickCountFromISR();
          }
          uVar4 = 0xdc;
          puVar3 = &DAT_23072bcc;
          pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
          goto LAB_230331c2;
        }
      }
      goto LAB_230331c6;
    }
  }
LAB_23032ef6:
  first.cb = (anon_subr_void_void_ptr_for_cb *)(cks_cmd_list + 1);
  local_80 = 0x3f1f;
  _data_segment_one = 1;
  cks_cmd_list[0] = 2;
  uStack126 = 0;
  memset(first.cb,0,0x1c);
  memset(&first.ctrl,0,0x1c);
  memset(&second.ctrl,0,0x1c);
  first.arg = &data_segment_one;
  first.src = (uint32_t)&DAT_4000a700;
  first.dst = (uint32_t)&second.arg;
  first.next = 0x4480002;
  first.item = (utils_list_hdr *)_cb_cmd;
  second.src = (uint32_t)&DAT_4000a704;
  last.arg = &DAT_4000a708;
  second.dst = (uint32_t)&last.arg;
  last.src = (uint32_t)&uStack126;
  second.next = 0x403e8;
  second.item = (utils_list_hdr *)0x0;
  second.cb = (anon_subr_void_void_ptr_for_cb *)0x0;
  last.dst = 0;
  last.next = 0x80240001;
  last.item = (utils_list_hdr *)0x0;
  last.cb = (anon_subr_void_void_ptr_for_cb *)0x0;
  bl_dma_copy((bl_dma_item *)first.cb);
  while (first.cb != (anon_subr_void_void_ptr_for_cb *)0x0) {
    vTaskDelay(2);
  }
  if (uStack126 == 0x6df1) {
    if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) || (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_cks))
    goto LAB_23032fea;
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    uVar4 = 0x12f;
    puVar3 = &DAT_2307f16c;
    pcVar2 = "[%10u][%s: %s:%4d] ====== Success %04X Checksum=====\r\n";
  }
  else {
    if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) || (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_cks)
       ) goto LAB_23032fea;
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    uVar4 = 0x131;
    puVar3 = &DAT_23072bcc;
    pcVar2 = "[%10u][%s: %s:%4d] ====== Failed %04X Checksum======\r\n";
  }
  bl_printk(pcVar2,TVar1,puVar3,"bl_cks.c",uVar4,(uint)uStack126);
LAB_23032fea:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void _cb_cmd(void *arg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [DMA] [TEST] Callback is working, arg is %p\r\n",TVar1,
              &DAT_2307f16c,"bl_dma.c",0x19c,arg);
  }
  *(undefined4 *)((int)arg + 8) = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_dma_int_process(void)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int *piStack52;
  dma_ctx *pstctx;
  
  uVar1 = _DAT_4000c00c;
  uVar2 = _DAT_4000c004;
  uVar5 = 0;
  bl_irq_ctx_get(0x1f,&piStack52);
  do {
    uVar4 = 1 << (uVar5 & 0x1f);
    uVar7 = uVar4 & uVar2;
    uVar6 = uVar4 & uVar1;
    if (uVar7 == 0) {
      if (uVar6 != 0) {
LAB_23033424:
        uVar2 = _DAT_4000c010 | uVar4;
        _DAT_4000c010 = uVar2;
        goto LAB_2303342e;
      }
    }
    else {
      uVar2 = _DAT_4000c008 | uVar4;
      _DAT_4000c008 = uVar2;
      if (uVar6 != 0) goto LAB_23033424;
LAB_2303342e:
      iVar3 = *(int *)(*piStack52 + 4);
      while (iVar3 != *piStack52) {
        if (*(uint *)(iVar3 + 8) == uVar5) {
          if ((*(code **)(iVar3 + 0xc) != (code *)0x0) && (uVar7 != 0)) {
            (**(code **)(iVar3 + 0xc))();
          }
          if ((*(code **)(iVar3 + 0x10) != (code *)0x0) && (uVar6 != 0)) {
            (**(code **)(iVar3 + 0x10))();
          }
        }
        iVar3 = *(int *)(iVar3 + 4);
      }
    }
    uVar5 = uVar5 + 1;
    if (uVar5 == 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_dma_int_clear(int ch)

{
  uint uVar1;
  
  uVar1 = 1 << (ch & 0x1fU);
  if ((_DAT_4000c004 & uVar1 & 0xff) != 0) {
    _DAT_4000c008 = _DAT_4000c008 | uVar1;
  }
  if ((_DAT_4000c00c & uVar1 & 0xff) != 0) {
    _DAT_4000c010 = uVar1 | _DAT_4000c010;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void bl_dma_IRQHandler(void)

{
  utils_list_hdr *puVar1;
  TickType_t TVar2;
  
  bl_dma_int_clear(0);
  puVar1 = utils_list_pop_front(&dma_copy_list);
  if (puVar1 == (utils_list_hdr *)0x0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN))
    {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] [INT] ASSERT here for empty chain\r\n",TVar2,&DAT_2307f16c,
                "bl_dma.c",0x9d);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  if (puVar1[1].next != (utils_list_hdr *)0x0) {
    (*(code *)puVar1[1].next)(puVar1[2].next);
  }
  if (dma_copy_list.first != (utils_list_hdr *)0x0) {
    DMA_LLI_Update('\0',(uint32_t)(dma_copy_list.first + 3));
    DMA_Channel_Enable('\0');
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_dma_copy(bl_dma_item *first)

{
  vTaskEnterCritical();
  if (dma_copy_list.first == (utils_list_hdr *)0x0) {
    DMA_LLI_Update('\0',(uint32_t)&first->src);
    DMA_Channel_Enable('\0');
  }
  utils_list_push_back(&dma_copy_list,(utils_list_hdr *)first);
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_dma_irq_register(int channel,void *tc_handler,void *interr_handler,void *ctx)

{
  int iVar1;
  TickType_t TVar2;
  int *piVar3;
  int **ppiVar4;
  int *piStack36;
  dma_ctx *pstctx;
  
  if (((uint)channel < 5) && (tc_handler != (void *)0x0)) {
    bl_irq_ctx_get(0x1f,&piStack36);
    iVar1 = *(int *)(*piStack36 + 4);
    while (*piStack36 != iVar1) {
      if (channel == *(int *)(iVar1 + 8)) {
        if (BLOG_LEVEL_WARN < _fsymc_level_hal_drv) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (BLOG_LEVEL_WARN < _fsymf_level_hal_drvbl_dma) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar2 = xTaskGetTickCount();
        }
        else {
          TVar2 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel %d already register \r\n",TVar2,&DAT_23081ce8,
                  "bl_dma.c",0x124,*(undefined4 *)(iVar1 + 8));
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -1;
      }
      iVar1 = *(int *)(iVar1 + 4);
    }
    piVar3 = (int *)pvPortMalloc(0x18);
    if (((piVar3 == (int *)0x0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] malloc dma node failed. \r\n",TVar2,&DAT_23072bcc,"bl_dma.c",
                0x12a);
    }
    piVar3[2] = channel;
    piVar3[3] = (int)tc_handler;
    piVar3[4] = (int)interr_handler;
    piVar3[5] = (int)ctx;
    iVar1 = *piStack36;
    ppiVar4 = *(int ***)(iVar1 + 4);
    *piVar3 = iVar1;
    piVar3[1] = (int)ppiVar4;
    *(int **)(iVar1 + 4) = piVar3;
    *ppiVar4 = piVar3;
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] not valid para \r\n",TVar2,&DAT_23072bcc,"bl_dma.c",0x11c);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void bl_dma_init(void)

{
  void **ctx;
  char *format;
  void *pvVar1;
  undefined4 uVar2;
  undefined2 uStack20;
  DMA_Periph_Req_Type DStack18;
  DMA_LLI_Cfg_Type lliCfg;
  
  uStack20 = 0;
  DStack18 = DMA_REQ_NONE;
  utils_list_init(&dma_copy_list);
  ctx = (void **)pvPortMalloc(4);
  if (ctx == (void **)0x0) {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x180;
    format = "[%10u][%s: %s:%4d] malloc dma ctx failed \r\n";
  }
  else {
    pvVar1 = pvPortMalloc(8);
    *ctx = pvVar1;
    if (pvVar1 != (void *)0x0) {
      *(void **)((int)pvVar1 + 4) = pvVar1;
      *(void **)pvVar1 = pvVar1;
      DMA_Enable();
      DMA_IntMask('\0',DMA_INT_ALL,MASK);
      DMA_IntMask('\0',DMA_INT_TCOMPLETED,UNMASK);
      DMA_IntMask('\0',DMA_INT_ERR,UNMASK);
      DMA_LLI_Init('\0',(DMA_LLI_Cfg_Type *)&uStack20);
      bl_irq_register_with_ctx(0x1f,bl_dma_int_process,ctx);
      bl_dma_irq_register(0,bl_dma_IRQHandler,(void *)0x0,(void *)0x0);
      bl_irq_enable(0x1f);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_dma) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar2 = 0x187;
    format = "[%10u][%s: %s:%4d] malloc dma pstqueue failed \r\n";
  }
  bl_printk(format,&DAT_23072bcc,"bl_dma.c",uVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_dma_test(void)

{
  bl_dma_item *first;
  void *__s;
  void *__s_00;
  TickType_t TVar1;
  
  first = (bl_dma_item *)pvPortMalloc(0x1c);
  __s = pvPortMalloc(0x44);
  __s_00 = pvPortMalloc(0x44);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_dma < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [TEST] [DMA] first %p, src %p, dst %p\r\n",TVar1,&DAT_2307f16c,
              "bl_dma.c",0x1af,first,__s,__s_00);
  }
  memset(first,0,0x1c);
  memset(__s,1,0x44);
  memset(__s_00,0xff,0x44);
  first->ctrl = 0x8c49b011;
  first->src = (uint32_t)__s;
  first->dst = (uint32_t)__s_00;
  first->next = 0;
  first->cb = _cb_cmd;
  first->arg = first;
  bl_dma_copy(first);
  while (first->arg != (void *)0x0) {
    vTaskDelay(2);
  }
  vPortFree((void *)first->src);
  vPortFree((void *)first->dst);
  vPortFree(first);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void _irq_num_check(int irqnum)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] illegal irqnum %d\r\n",TVar1,&DAT_23072bcc,"bl_irq.c",0x70,irqnum)
    ;
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_irq_enable(uint source)

{
  (&DAT_02800400)[source] = 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_disable(uint source)

{
  (&DAT_02800400)[source] = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_exception_trigger(BL_IRQ_EXCEPTION_TYPE_T type,void *ptr)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined4 uVar2;
  undefined auStack20 [4];
  uint32_t fun_val;
  
  uVar1 = CONCAT31(in_register_00002029,type);
  if (uVar1 < 3) {
    if (uVar1 == 0) {
                    // WARNING: Load size is inaccurate
      uVar2 = *ptr;
    }
    else {
      uVar2 = 0x12345678;
      *(undefined4 *)ptr = 0x12345678;
    }
  }
  else {
    uVar2 = 0x12345678;
    if (uVar1 == 3) {
      (*(code *)auStack20)(0x12345678,auStack20);
      uVar2 = 0x12345678;
    }
  }
  printf("Trigger exception val is %08lx\r\n",uVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_register_with_ctx(int irqnum,void *handler,void *ctx)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (handler_list[irqnum] == (anon_subr_void *)0x0) goto LAB_23033a6a;
  if (handler_list[irqnum] == (anon_subr_void *)handler) {
LAB_23033adc:
    handler_list[irqnum] = (anon_subr_void *)handler;
    if ((anon_subr_void *)ctx == (anon_subr_void *)0x0) {
      handler_list[1][irqnum] = (anon_subr_void *)0x0;
    }
    else {
      handler_list[1][irqnum] = (anon_subr_void *)ctx;
    }
  }
  else {
    if (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR) {
      if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] IRQ %d already registered with %p \r\n",TVar1,&DAT_23081ce8,
                  "bl_irq.c",0x7e,irqnum,handler_list[irqnum]);
        goto LAB_23033a6a;
      }
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_23033adc;
    }
    else {
LAB_23033a6a:
      if ((anon_subr_void *)handler != (anon_subr_void *)0x0) goto LAB_23033adc;
      if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    if (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ASSERT) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] handler is NULL pointer! \r\n",TVar1,&DAT_23072bcc,"bl_irq.c",
                0x82);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_ctx_get(int irqnum,void **ctx)

{
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  *ctx = handler_list[1][irqnum];
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_register(int irqnum,void *handler)

{
  bl_irq_register_with_ctx(irqnum,handler,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_unregister(int irqnum,void *handler)

{
  TickType_t TVar1;
  
  if (0x4f < (uint)irqnum) {
    _irq_num_check(irqnum);
  }
  if (((handler_list[irqnum] != (anon_subr_void *)handler) &&
      (_fsymc_level_hal_drv < BLOG_LEVEL_ERROR)) && (_fsymf_level_hal_drvbl_irq < BLOG_LEVEL_ERROR))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] IRQ %d:%p Not match with registered %p\r\n",TVar1,&DAT_23081ce8,
              "bl_irq.c",0xa8,irqnum,handler,handler_list[irqnum]);
  }
  handler_list[irqnum] = (anon_subr_void *)handler;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void interrupt_entry(uint32_t mcause)

{
  anon_subr_void *UNRECOVERED_JUMPTABLE_00;
  uint uVar1;
  
  uVar1 = mcause & 0x7ffffff;
  if (uVar1 < 0x50) {
    UNRECOVERED_JUMPTABLE_00 = handler_list[uVar1];
    if (UNRECOVERED_JUMPTABLE_00 != (anon_subr_void *)0x0) {
      if (handler_list[1][uVar1] != (anon_subr_void *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23033c02. Too many branches
                    // WARNING: Treating indirect jump as call
        (*UNRECOVERED_JUMPTABLE_00)();
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
                    // WARNING: Could not recover jumptable at 0x23033c04. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE_00)();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  printf("Cannot handle mcause 0x%lx:%lu, adjust to externel(0x%lx:%lu)\r\n",uVar1,uVar1 - 0x10);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void exception_entry(uint32_t mcause,uint32_t mepc,uint32_t mtval,uintptr_t *regs)

{
  char *s;
  
  if ((mcause & 0x3ff) == 4) {
    misaligned_load_trap((int *)regs,(uint *)mepc);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((mcause & 0x3ff) != 6) {
    puts("Exception Entry--->>>\r\n");
    printf("mcause %08lx, mepc %08lx, mtval %08lx\r\n",mcause,mepc,mtval);
    printf("Exception code: %lu\r\n",mcause & 0xffff);
    switch(mcause & 0xffff) {
    case 0:
      s = "  msg: Instruction address misaligned\r\n";
      break;
    case 1:
      s = "  msg: Instruction access fault\r\n";
      break;
    case 2:
      s = "  msg: Illegal instruction\r\n";
      break;
    case 3:
      s = "  msg: Breakpoint\r\n";
      break;
    case 4:
      s = "  msg: Load address misaligned\r\n";
      break;
    case 5:
      s = "  msg: Load access fault\r\n";
      break;
    case 6:
      s = "  msg: Store/AMO access misaligned\r\n";
      break;
    case 7:
      s = "  msg: Store/AMO access fault\r\n";
      break;
    case 8:
      s = "  msg: Environment call from U-mode\r\n";
      break;
    case 9:
      s = "  msg: Environment call from S-mode\r\n";
      break;
    case 10:
    case 0xe:
      s = "  msg: Reserved\r\n";
      break;
    case 0xb:
      s = "  msg: Environment call from M-mode\r\n";
      break;
    case 0xc:
      s = "  msg: Instruction page fault\r\n";
      break;
    case 0xd:
      s = "  msg: Load page fault\r\n";
      break;
    case 0xf:
      s = "  msg: Store/AMO page fault\r\n";
      break;
    default:
      s = "  msg: Reserved default exception\r\n";
    }
    puts(s);
    backtrace_riscv(printf,regs);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  misaligned_store_trap((int *)regs,(uint *)mepc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_irq_init(void)

{
  undefined *puVar1;
  
  puts("[IRQ] Clearing and Disable all the pending IRQ...\r\n");
  puVar1 = &DAT_02800400;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800480);
  puVar1 = &DAT_02800000;
  do {
    *puVar1 = 0;
    puVar1 = puVar1 + 1;
  } while (puVar1 != (undefined *)0x2800080);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void _trng_trigger(void)

{
  if ((_DAT_40004200 & 1) == 0) {
    _DAT_40004200 = _DAT_40004200 | 0x606;
    _DAT_4000422c = trng_buffer[0];
    _DAT_40004230 = trng_buffer[1];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void wait_trng4feed(void)

{
  do {
  } while ((_DAT_40004200 & 1) != 0);
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] Feed random number is %08lx\r\n","DEBUG ","bl_sec.c",0x5b,
              trng_buffer[0]);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void sec_trng_IRQHandler(uint param_1,int param_2)

{
  aos_now_ms();
  if ((param_2 < 1) && ((param_2 != 0 || (param_1 < 2000)))) {
    puts("[BL] [SEC] TRNG Handler\r\n");
  }
  _DAT_40004200 = _DAT_40004200 & 0xfffffffd | 0x200;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] random number is %08lx\r\n","DEBUG ","bl_sec.c",0xab,
              trng_buffer[0]);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trng_buffer[0] = _DAT_40004208;
  trng_buffer[1] = _DAT_4000420c;
  trng_buffer[2] = _DAT_40004210;
  trng_buffer[3] = _DAT_40004214;
  trng_buffer[4] = _DAT_40004218;
  trng_buffer[5] = _DAT_4000421c;
  trng_buffer[6] = _DAT_40004220;
  trng_buffer[7] = _DAT_40004224;
  return;
}



void bl_sec_pka_IRQHandler(void)

{
  puts("--->>> PKA IRQ\r\n");
  SEC_Eng_IntMask(SEC_ENG_INT_PKA,MASK);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t bl_sec_get_random_word(void)

{
  uint uVar1;
  
  uVar1 = trng_idx & 7;
  if (uVar1 == 0) {
    trng_idx = uVar1;
    _trng_trigger();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trng_idx = uVar1 + 1;
  return trng_buffer[uVar1];
}



void bl_rand_stream(uint8_t *buf,int len)

{
  size_t __n;
  int iVar1;
  
  if (trng_idx != 0) {
    _trng_trigger();
    wait_trng4feed();
    trng_idx = 0;
  }
  iVar1 = 0;
  while (0 < len) {
    if (trng_idx != 0) {
      _trng_trigger();
      wait_trng4feed();
      trng_idx = 0;
    }
    __n = len;
    if (0x20 < len) {
      __n = 0x20;
    }
    memcpy(buf + iVar1,trng_buffer,__n);
    iVar1 = iVar1 + __n;
    len = len - __n;
    trng_idx = 0x1f;
  }
  _trng_trigger();
  wait_trng4feed();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  trng_idx = 0;
  return;
}



int bl_rand(void)

{
  int iVar1;
  uint32_t uVar2;
  
  iVar1 = 0x13;
  do {
    uVar2 = bl_sec_get_random_word();
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      puts("[BL] [SEC] Failed after loop (17)\r\n");
      break;
    }
  } while (uVar2 == 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2 >> 1;
}



int bl_sec_init(void)

{
  g_bl_sec_sha_mutex =
       (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&sha_mutex_buf);
  _trng_trigger();
  wait_trng4feed();
  _trng_trigger();
  wait_trng4feed();
  bl_irq_register(0x1c,sec_trng_IRQHandler);
  bl_irq_enable(0x1c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_sec_test(void)

{
  int iVar1;
  
  bl_printk("------------------TRNG TEST---------------------------------\r\n");
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  iVar1 = bl_rand();
  bl_printk("**********TRNG TEST rand[%08x]**************\r\n",iVar1);
  bl_printk("------------------------------------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void _dump_rsa_data(uint8_t *data,int size)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (size <= (int)uVar1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((uVar1 & 0xf) == 0) {
      bl_printk("[%04X]:",uVar1);
LAB_2303415a:
      bl_printk(" %02X",(uint)data[uVar1]);
    }
    else {
      if ((uVar1 & 0xf) != 0xf) goto LAB_2303415a;
      bl_printk(" %02X",(uint)data[uVar1]);
      puts("\r\n");
    }
    uVar1 = uVar1 + 1;
  } while( true );
}



void _pka_test_case_xgcd(void)

{
  uint8_t uStack273;
  uint8_t pka_a_eq_0;
  uint32_t result [64];
  
  uStack273 = '\0';
  Sec_Eng_PKA_Reset();
  Sec_Eng_PKA_BigEndian_Enable();
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)_pka_test_case_xgcd::n,0x40,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x02','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x03','\0','\x01');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\0',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_LMUL2N('\n','\x01','\b','\0',0x800,'\0');
  Sec_Eng_PKA_LDIV('\b','\0','\n','\x01','\b','\x01','\0');
  Sec_Eng_PKA_MREM('\b','\x04','\n','\x01','\b','\x01','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x01','\0','\x01');
  Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x01','\0');
  Sec_Eng_PKA_Move_Data('\b','\x01','\b','\x04','\x01');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x04',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x05',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x06',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\a',(uint32_t *)"",0x40,'\0');
  Sec_Eng_PKA_LMUL('\b','\b','\b','\0','\b','\x05','\0');
  Sec_Eng_PKA_LSUB('\b','\b','\b','\x04','\b','\b','\0');
  Sec_Eng_PKA_LMUL('\b','\t','\b','\0','\b','\a','\0');
  Sec_Eng_PKA_LSUB('\b','\t','\b','\x06','\b','\t','\0');
  Sec_Eng_PKA_Move_Data('\b','\x04','\b','\x05','\0');
  Sec_Eng_PKA_Move_Data('\b','\x05','\b','\b','\0');
  Sec_Eng_PKA_Move_Data('\b','\x06','\b','\a','\0');
  Sec_Eng_PKA_Move_Data('\b','\a','\b','\t','\x01');
  while (uStack273 == '\0') {
    Sec_Eng_PKA_LDIV('\b','\0','\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_MREM('\b','\x03','\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_LMUL('\b','\b','\b','\0','\b','\x05','\0');
    Sec_Eng_PKA_LSUB('\b','\b','\b','\x04','\b','\b','\0');
    Sec_Eng_PKA_LMUL('\b','\t','\b','\0','\b','\a','\0');
    Sec_Eng_PKA_LSUB('\b','\t','\b','\x06','\b','\t','\0');
    Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x01','\0');
    Sec_Eng_PKA_Move_Data('\b','\x04','\b','\x05','\0');
    Sec_Eng_PKA_Move_Data('\b','\x05','\b','\b','\0');
    Sec_Eng_PKA_Move_Data('\b','\x06','\b','\a','\0');
    Sec_Eng_PKA_Move_Data('\b','\a','\b','\t','\x01');
    Sec_Eng_PKA_Move_Data('\b','\x01','\b','\x03','\x01');
    Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\n',(uint32_t *)"",0x40,'\0');
    Sec_Eng_PKA_LCMP(&uStack273,'\b','\x01','\b','\n');
  }
  Sec_Eng_PKA_Read_Data(SEC_ENG_PKA_REG_SIZE_256,'\x06',(uint32_t *)&stack0xfffffef0,'@');
  _dump_rsa_data(&stack0xfffffef0,0x100);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void _pka_test_case2(uint8_t param_1)

{
  bool bVar1;
  uint32_t *puVar2;
  uint8_t *puVar3;
  char *pcVar4;
  undefined *puVar5;
  undefined4 uVar6;
  int iVar7;
  uint32_t local_130;
  uint32_t result [64];
  
  Sec_Eng_PKA_Reset();
  Sec_Eng_PKA_BigEndian_Enable();
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\0',(uint32_t *)_pka_test_case2::n,0x40,'\0');
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)_pka_test_case2::nprime,0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x02',(uint32_t *)_pka_test_case2::m,0x40,'\0');
  Sec_Eng_PKA_Write_Data(SEC_ENG_PKA_REG_SIZE_256,'\x03',(uint32_t *)"",1,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x04','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x05','\0','\x01');
  Sec_Eng_PKA_LMUL2N('\n','\x02','\b','\x02',0x800,'\0');
  Sec_Eng_PKA_MREM('\b','\x02','\n','\x02','\b','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x02','\0','\x01');
  Sec_Eng_PKA_MEXP('\b','\x04','\b','\x02','\b','\x03','\b','\0',param_1);
  Sec_Eng_PKA_Move_Data('\b','\x02','\b','\x04','\x01');
  Sec_Eng_PKA_Write_Data
            (SEC_ENG_PKA_REG_SIZE_256,'\x01',(uint32_t *)_pka_test_case2::inv_r,0x40,'\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x04','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_256,'\x05','\0','\x01');
  Sec_Eng_PKA_LMUL('\n','\x02','\b','\x02','\b','\x01','\0');
  Sec_Eng_PKA_MREM('\b','\x02','\n','\x02','\b','\0','\0');
  Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_512,'\x02','\0','\x01');
  Sec_Eng_PKA_Read_Data(SEC_ENG_PKA_REG_SIZE_256,'\x02',&local_130,'@');
  _dump_rsa_data((uint8_t *)&local_130,0x100);
  puVar2 = &local_130;
  puVar3 = _pka_test_case2::encrypted;
  bVar1 = false;
  iVar7 = 0;
  while (iVar7 != 0x100) {
    if (((*(uint8_t *)puVar2 != *puVar3) && (bVar1 = true, _fsymc_level_hal_drv < BLOG_LEVEL_WARN))
       && (_fsymf_level_hal_drvbl_sec < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        xTaskGetTickCount();
      }
      else {
        xTaskGetTickCountFromISR();
      }
      pcVar4 = "S";
      if (*(uint8_t *)puVar2 != *puVar3) {
        pcVar4 = "F";
      }
      bl_printk("[%10u][%s: %s:%4d] %s[%02d], %02x %02x\r\n",&DAT_2307f16c,"bl_sec.c",0xf9,pcVar4,
                iVar7);
      bVar1 = true;
    }
    iVar7 = iVar7 + 1;
    puVar2 = (uint32_t *)((int)puVar2 + 1);
    puVar3 = puVar3 + 1;
  }
  if (bVar1) {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_sec) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar6 = 0xfd;
    puVar5 = &DAT_23072bcc;
    pcVar4 = "[%10u][%s: %s:%4d] ====== Failed %lu Bytes======\r\n";
  }
  else {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_sec) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      xTaskGetTickCount();
    }
    else {
      xTaskGetTickCountFromISR();
    }
    uVar6 = 0xff;
    puVar5 = &DAT_2307f16c;
    pcVar4 = "[%10u][%s: %s:%4d] ====== Success %lu Bytes=====\r\n";
  }
  bl_printk(pcVar4,puVar5,"bl_sec.c",uVar6,0x100);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_pka_test(void)

{
  bl_irq_register(0x1b,bl_sec_pka_IRQHandler);
  bl_irq_enable(0x1b);
  _pka_test_case2(DAT_00000010);
  _pka_test_case_xgcd();
  _pka_test_case2(DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void int_timer_cb(void)

{
  BaseType_t BVar1;
  
  TIMER_ClearIntStatus(TIMER_CH1,TIMER_COMP_ID_0);
  BVar1 = xTaskIncrementTick();
  if (BVar1 != 0) {
    vTaskSwitchContext();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t bl_timer_now_us(void)

{
  uint32_t uVar1;
  
  uVar1 = _DAT_0200bff8;
  __udivdi3();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int bl_timer_tick_enable(void)

{
  undefined auStack40 [4];
  TIMER_CFG_Type timerCh1Cfg;
  
  memcpy(auStack40,&DAT_23083d64,0x18);
  TIMER_IntMask(TIMER_CH1,TIMER_INT_ALL,MASK);
  TIMER_Disable(auStack40[0]);
  TIMER_Init((TIMER_CFG_Type *)auStack40);
  TIMER_ClearIntStatus(auStack40[0],TIMER_COMP_ID_0);
  TIMER_ClearIntStatus(auStack40[0],TIMER_COMP_ID_1);
  TIMER_ClearIntStatus(auStack40[0],TIMER_COMP_ID_2);
  TIMER_IntMask(auStack40[0],TIMER_INT_COMP_0,UNMASK);
  TIMER_IntMask(auStack40[0],TIMER_INT_COMP_1,MASK);
  TIMER_IntMask(auStack40[0],TIMER_INT_COMP_2,MASK);
  TIMER_Enable(auStack40[0]);
  bl_irq_enable(0x35);
  bl_irq_register(0x35,int_timer_cb);
  return 0;
}



// WARNING: Variable defined which should be unmapped: val

void cmd_gpio_get(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  undefined *puVar4;
  uint8_t auStack17 [4];
  uint8_t val;
  
  if (argc == 2) {
    iVar2 = atoi(argv[1]);
    if (iVar2 < 0) {
      puts("Illegal arg\r\n");
    }
    else {
      iVar3 = bl_gpio_input_get((uint8_t)iVar2,auStack17);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          if (auStack17[0] == '\0') {
            puVar4 = &UNK_23083e38;
          }
          else {
            puVar4 = &UNK_23083e30;
          }
        }
        else {
          puVar4 = &UNK_23083e2c;
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d val is %s\r\n",TVar1,&DAT_2307f16c,"bl_gpio_cli.c",0x72
                  ,iVar2,puVar4);
      }
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24\r\n  get GPIO24 value\r\n",TVar1,&DAT_2307f16c,
                "bl_gpio_cli.c",0x66,*argv);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_gpio_set(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  undefined *puVar4;
  
  if (argc == 3) {
    iVar2 = atoi(argv[1]);
    iVar3 = atoi(argv[2]);
    if ((-1 < iVar2) && (-1 < iVar3)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          puVar4 = &UNK_23083ebc;
        }
        else {
          puVar4 = &UNK_23083e30;
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d is set to %s\r\n",TVar1,&DAT_2307f16c,"bl_gpio_cli.c",
                  0x59,iVar2,puVar4);
      }
      bl_gpio_output_set((uint8_t)iVar2,iVar3 != 0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Illegal arg\r\n",TVar1,&DAT_23072bcc,"bl_gpio_cli.c",0x53);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24 1\r\n  set GPIO24 output to high\r\n",TVar1,
                &DAT_2307f16c,"bl_gpio_cli.c",0x4d,*argv);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_gpio_func(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  
  if (argc == 5) {
    iVar2 = atoi(argv[1]);
    iVar3 = atoi(argv[2]);
    iVar4 = atoi(argv[3]);
    iVar5 = atoi(argv[4]);
    if ((((-1 < iVar2) && (-1 < iVar3)) && (-1 < iVar4)) && (-1 < iVar5)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        if (iVar3 == 0) {
          pcVar6 = "output";
        }
        else {
          pcVar6 = "input";
        }
        if (iVar4 == 0) {
          pcVar7 = "null";
        }
        else {
          pcVar7 = "Active";
        }
        bl_printk("[%10u][%s: %s:%4d] GPIO%d is set %s with %s pullup %s pulldown\r\n",TVar1,
                  &DAT_2307f16c,"bl_gpio_cli.c",0x3e,iVar2,pcVar6,pcVar7);
      }
      if (iVar3 != 0) {
        bl_gpio_enable_input((uint8_t)iVar2,iVar4 != 0,iVar5 != 0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      bl_gpio_enable_output((uint8_t)iVar2,iVar4 != 0,iVar5 != 0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Illegal arg\r\n",TVar1,&DAT_23072bcc,"bl_gpio_cli.c",0x36);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvbl_gpio_cli < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Usage: %s 24 1 1 0\r\n  set GPIO24 to input with pullup\r\n",
                TVar1,&DAT_2307f16c,"bl_gpio_cli.c",0x2e,*argv);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_gpio_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_efuse_read_mac(uint8_t *mac)

{
  EF_Ctrl_Read_MAC_Address(mac);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_efuse_read_mac_factory(uint8_t *mac)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_macaddr(mac,'\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_capcode(uint8_t *capcode)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_xtal_capcode(capcode,'\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



int bl_efuse_read_pwroft(int8_t *poweroffset)

{
  int8_t iVar1;
  undefined3 extraout_var;
  
  iVar1 = mfg_media_read_poweroffset(poweroffset,'\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(CONCAT31(extraout_var,iVar1) != 0);
}



void Aes_Compare_Data(uint8_t *expected,uint8_t *input,uint32_t len)

{
  bool bVar1;
  uint32_t uVar2;
  TickType_t TVar3;
  char *pcVar4;
  undefined *puVar5;
  undefined4 uVar6;
  
  bVar1 = false;
  uVar2 = 0;
  while (uVar2 != len) {
    if (((input[uVar2] != expected[uVar2]) && (bVar1 = true, _fsymc_level_hal_drv < BLOG_LEVEL_WARN)
        ) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar3 = xTaskGetTickCount();
      }
      else {
        TVar3 = xTaskGetTickCountFromISR();
      }
      pcVar4 = "S";
      if (input[uVar2] != expected[uVar2]) {
        pcVar4 = "F";
      }
      bl_printk("[%10u][%s: %s:%4d] %s[%02d], %02x %02x\r\n",TVar3,&DAT_2307f16c,"bl_sec_aes.c",0x3b
                ,pcVar4,uVar2);
      bVar1 = true;
    }
    uVar2 = uVar2 + 1;
  }
  if (bVar1) {
    if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
       (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvbl_sec_aes)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x3f;
    puVar5 = &DAT_23072bcc;
    pcVar4 = "[%10u][%s: %s:%4d] ====== Failed %lu Bytes======\r\n";
  }
  else {
    if (BLOG_LEVEL_INFO < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (BLOG_LEVEL_INFO < _fsymf_level_hal_drvbl_sec_aes) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar6 = 0x41;
    puVar5 = &DAT_2307f16c;
    pcVar4 = "[%10u][%s: %s:%4d] ====== Success %lu Bytes=====\r\n";
  }
  bl_printk(pcVar4,TVar3,puVar5,"bl_sec_aes.c",uVar6,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void _dump_iv_status(SEC_Eng_AES_Link_Config_Type *linkCfg)

{
  byte bVar1;
  uint32_t *puVar2;
  
  puVar2 = &linkCfg->aesIV0;
  do {
    bVar1 = *(byte *)puVar2;
    puVar2 = (uint32_t *)((int)puVar2 + 1);
    bl_printk("%02x",(uint)bVar1);
  } while (puVar2 != &linkCfg->aesKey0);
  bl_printk("\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_sec_aes_IRQHandler(void)

{
  bl_printk("--->>> AES IRQ\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004100 = _DAT_40004100 | 0x200;
  return;
}



// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID_Type aesId)

{
  TickType_t TVar1;
  uint8_t auStack124 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x12400;
  Sec_Eng_AES_Enable_Link(aesId);
  puts("[CBC] AES-128-CBC case...\r\n");
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status Initial, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x84,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CBC_128::aesResult_entrypted_cbc_128,
                   (uint8_t *)linkCfg.aesSrcAddr,0x20);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x88,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CBC_128::aesResult_entrypted_cbc_128 + 0x20,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x8d,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CBC_128::aesResult_entrypted_cbc_128 + 0x30,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CBC] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0x92,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Disable_Link(aesId);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID_Type aesId)

{
  TickType_t TVar1;
  uint8_t auStack124 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x11400;
  Sec_Eng_AES_Enable_Link(aesId);
  puts("[CTR] AES-128-CTR case...\r\n");
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status Initial, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xbe,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CTR_128::aesResult_entrypted_ctr_128,
                   (uint8_t *)linkCfg.aesSrcAddr,0x20);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xc4,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CTR_128::aesResult_entrypted_ctr_128 + 0x20,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xc9,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack124);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_CTR_128::aesResult_entrypted_ctr_128 + 0x30,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_sec_aes < BLOG_LEVEL_WARN)
     ) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [CTR] IV Status After, %08lx\r\n",TVar1,&DAT_2307f16c,
              "bl_sec_aes.c",0xce,linkCfg._0_4_);
  }
  _dump_iv_status((SEC_Eng_AES_Link_Config_Type *)(aesDstBuf + 0x1c));
  Sec_Eng_AES_Disable_Link(aesId);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: linkCfg
// WARNING: Could not reconcile some variable overlaps

void Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID_Type aesId)

{
  uint8_t auStack108 [4];
  uint8_t aesDstBuf [32];
  SEC_Eng_AES_Link_Config_Type linkCfg;
  
  memset(aesDstBuf + 0x1c,0,0x3c);
  aesDstBuf._28_4_ = 0x10400;
  puts("[ECB] AES-128-ECB case...\r\n");
  Sec_Eng_AES_Enable_Link(aesId);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data,0x20,auStack108);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_ECB_128::aesResult_entrypted_ecb_128,
                   (uint8_t *)linkCfg.aesSrcAddr,0x20);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x20,0x10,auStack108);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_ECB_128::aesResult_entrypted_ecb_128 + 0x20,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  Sec_Eng_AES_Link_Work(aesId,(uint32_t)(aesDstBuf + 0x1c),aesSrcBuf_data + 0x30,0x10,auStack108);
  Aes_Compare_Data(Sec_Eng_AES_Link_Case_ECB_128::aesResult_entrypted_ecb_128 + 0x30,
                   (uint8_t *)linkCfg.aesSrcAddr,0x10);
  Sec_Eng_AES_Disable_Link(aesId);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_sec_aes_test(void)

{
  bl_irq_register(0x1d,bl_sec_aes_IRQHandler);
  bl_irq_enable(0x1d);
  bl_printk(
           "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n"
           );
  Sec_Eng_AES_Link_Case_CBC_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_CTR_128(SEC_ENG_AES_ID0);
  bl_printk(
           "####################################################################################\r\n"
           );
  Sec_Eng_AES_Link_Case_ECB_128(SEC_ENG_AES_ID0);
  bl_printk(
           "------------------------------------------------------------------------------------\r\n"
           );
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_sec_sha_IRQHandler(void)

{
  puts("--->>> SHA IRQ\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004000 = _DAT_40004000 | 0x200;
  return;
}



int bl_sha_mutex_take(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_bl_sec_sha_mutex,0xffffffff);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr take failed\r\n",TVar2,&DAT_23072bcc,"bl_sec_sha.c",
              0x36);
    iVar3 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int bl_sha_mutex_give(void)

{
  BaseType_t BVar1;
  TickType_t TVar2;
  int iVar3;
  
  BVar1 = xQueueGenericSend((QueueHandle_t)g_bl_sec_sha_mutex,(void *)0x0,0,0);
  iVar3 = 0;
  if (((BVar1 != 1) && (iVar3 = -1, _fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvbl_sec_sha < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] sha semphr give failed\\n",TVar2,&DAT_23072bcc,"bl_sec_sha.c",0x3f
             );
    iVar3 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



void bl_sha_init(bl_sha_ctx_t *ctx,bl_sha_type_t type)

{
  Sec_Eng_SHA256_Init((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,type,ctx->tmp,ctx->pad);
  Sec_Eng_SHA_Start(SEC_ENG_SHA_ID0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_sha_update(bl_sha_ctx_t *ctx,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Update((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,input,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CONCAT31(extraout_var,BVar1);
}



int bl_sha_finish(bl_sha_ctx_t *ctx,uint8_t *hash)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  
  BVar1 = Sec_Eng_SHA256_Finish((SEC_Eng_SHA256_Ctx *)ctx,SEC_ENG_SHA_ID0,hash);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CONCAT31(extraout_var,BVar1);
}



void sha256_test_case0(void)

{
  undefined *puVar1;
  int iVar2;
  char *format;
  bool bVar3;
  undefined auStack220 [4];
  sha256_link_item_t sha256_link;
  
  memset(auStack220,0,0xbc);
  sha256_link.ctx.linkAddr = 0x10400;
  sha256_link.linkCfg._0_4_ = 0x50020000;
  bl_irq_register(0x1e,bl_sec_sha_IRQHandler);
  bl_irq_enable(0x1e);
  Sec_Eng_SHA_Enable_Link(SEC_ENG_SHA_ID0);
  Sec_Eng_SHA256_Link_Init
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             (uint32_t)&sha256_link.ctx.linkAddr,sha256_link.linkCfg.result + 7,
             sha256_link.tmp + 0xf);
  Sec_Eng_SHA256_Link_Update
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             "1111111111111111111111111111111111111111111111111111111111111111hal_drv.bl_sec_sha",
             0x40);
  Sec_Eng_SHA256_Link_Finish
            ((SEC_Eng_SHA256_Link_Ctx *)auStack220,SEC_ENG_SHA_ID0,
             (uint8_t *)&sha256_link.linkCfg.shaSrcAddr);
  Sec_Eng_SHA_Disable_Link(SEC_ENG_SHA_ID0);
  puVar1 = auStack220;
  bVar3 = false;
  iVar2 = 0;
  do {
    if (sha256_test_case0::sha256_test_result[iVar2] != puVar1[0x1c]) {
      bl_printk("%s[%02d], %02x %02x\r\n",&UNK_23083384,iVar2);
      bVar3 = true;
    }
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 1;
  } while (iVar2 != 0x20);
  if (bVar3) {
    format = "====== Failed %lu Bytes======\r\n";
  }
  else {
    format = "====== Success %lu Bytes=====\r\n";
  }
  bl_printk(format);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_sec_sha_test(void)

{
  puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  puts("^^^^^^^^^^^^^^^^^^^^^^^SHA256 TEST CASE^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n");
  sha256_test_case0();
  puts("------------------------------------------------------------------------------------\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_clock_enable(void)

{
  if (bl_wifi_clock_enable::called == 0) {
    bl_wifi_clock_enable::called = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_enable_irq(void)

{
  bl_irq_register(0x46,mac_irq);
  bl_irq_register(0x4f,bl_irq_handler);
  bl_irq_enable(0x46);
  bl_irq_enable(0x4f);
  puts("Enable BMX IRQ\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_sta_mac_addr_set(uint8_t *mac)

{
  memcpy(&wifi_env,mac,6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_ap_mac_addr_set(uint8_t *mac)

{
  memcpy(wifi_env.ap_mac_addr_board,mac,6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_mac_addr_get(uint8_t *mac)

{
  memcpy(mac,&wifi_env,6);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_wifi_country_code_set(uint8_t country_code)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifi_env.country_code = country_code;
  return 0;
}



int bl_wifi_ap_info_set(uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,uint8_t chan)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.ap_info,0,99);
  memcpy(&wifi_env.ap_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.ap_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifi_env.ap_info.chan = chan;
  wifi_env.ap_info_en = '\x01';
  return 0;
}



int bl_wifi_sta_info_set
              (uint8_t *ssid,uint8_t ssid_len,uint8_t *psk,uint8_t psk_len,int autoconnect)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002035;
  
  memset(&wifi_env.sta_info,0,99);
  memcpy(&wifi_env.sta_info,ssid,CONCAT31(in_register_0000202d,ssid_len));
  memcpy(wifi_env.sta_info.psk,psk,CONCAT31(in_register_00002035,psk_len));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  wifi_env.sta_info_en = (uint8_t)autoconnect;
  return 0;
}



int bl_wifi_sta_info_get(bl_wifi_ap_info_t *sta_info)

{
  if (wifi_env.sta_info_en == '\x01') {
    memcpy(sta_info,&wifi_env.sta_info,99);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int cmd_timer_start(void)

{
  TIMER_CFG_Type TStack40;
  
  memcpy(&TStack40,&DAT_23083d64,0x18);
  TIMER_IntMask(TIMER_CH1,TIMER_INT_ALL,MASK);
  TIMER_Disable(TStack40.timerCh);
  TIMER_Init(&TStack40);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_0);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_1);
  TIMER_ClearIntStatus(TStack40.timerCh,TIMER_COMP_ID_2);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_0,UNMASK);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_1,MASK);
  TIMER_IntMask(TStack40.timerCh,TIMER_INT_COMP_2,MASK);
  TIMER_Enable(TStack40.timerCh);
  bl_irq_enable(0x35);
  bl_irq_register(0x35,int_timer_cb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wdt_disable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void cmd_wdt_feed(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



void cmd_wdt_init(char *buf,int len,int argc,char **argv)

{
  TickType_t TVar1;
  int ms;
  
  if (argc != 2) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] Usage: %s ms\r\n",TVar1,&DAT_2307f16c,"bl_wdt_cli.c",0x2a,*argv);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  ms = atoi(argv[1]);
  if (TrapNetCounter == 0) {
    TVar1 = xTaskGetTickCount();
  }
  else {
    TVar1 = xTaskGetTickCountFromISR();
  }
  bl_printk("[%10u][%s: %s:%4d] Init WDT with %dms\r\n",TVar1,&DAT_2307f16c,"bl_wdt_cli.c",0x2e,ms);
  if (0 < ms) {
    bl_wdt_init(ms);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_wdt_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



int dev_uart_init(uint8_t id,char *path,uint32_t rx_buf_size,uint32_t tx_buf_size)

{
  uart_dev_t **ppuVar1;
  undefined3 in_register_00002029;
  uint uVar2;
  TickType_t TVar3;
  char *format;
  uart_dev_t *puVar4;
  void *pvVar5;
  int iVar6;
  undefined4 uVar7;
  
  uVar2 = CONCAT31(in_register_00002029,id);
  if ((uVar2 < 3) && (path != (char *)0x0)) {
    if (uVar2 == 0) {
      ppuVar1 = &dev_uart0;
      puVar4 = dev_uart0;
    }
    else {
      if (uVar2 != 1) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar7 = 0x74;
        format = "[%10u][%s: %s:%4d] err.\r\n";
        goto LAB_23035abc;
      }
      ppuVar1 = &dev_uart1;
      puVar4 = dev_uart1;
    }
    if (puVar4 == (uart_dev_t *)0x0) {
      puVar4 = (uart_dev_t *)pvPortMalloc(0x3c);
      *ppuVar1 = puVar4;
      if (puVar4 == (uart_dev_t *)0x0) {
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar7 = 0x3c;
      }
      else {
        memset(puVar4,0,0x3c);
        (*ppuVar1)->read_block_flag = '\x02';
        (*ppuVar1)->priv = (void *)0x0;
        puVar4 = *ppuVar1;
        pvVar5 = pvPortMalloc(4);
        puVar4->priv = pvVar5;
        if ((*ppuVar1)->priv != (void *)0x0) {
          memset((*ppuVar1)->priv,0,4);
          (*ppuVar1)->rx_buf_size = rx_buf_size;
          (*ppuVar1)->tx_buf_size = tx_buf_size;
          if (*ppuVar1 == (uart_dev_t *)0x0) {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] mem err.\r\n",TVar3,&DAT_23072bcc,"hal_uart.c",0x50);
            }
          }
          else {
            (*ppuVar1)->port = id;
            (*ppuVar1)->read_block_flag = '\x02';
            ((*ppuVar1)->config).baud_rate = 0x1c200;
            ((*ppuVar1)->config).data_width = DATA_WIDTH_8BIT;
            ((*ppuVar1)->config).parity = NO_PARITY;
            ((*ppuVar1)->config).stop_bits = STOP_BITS_1;
            ((*ppuVar1)->config).flow_control = FLOW_CONTROL_DISABLED;
            ((*ppuVar1)->config).mode = MODE_TX_RX;
          }
          iVar6 = aos_register_driver(path,(file_ops_t *)&uart_ops,*ppuVar1);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return iVar6;
        }
        if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -1;
        }
        if (TrapNetCounter == 0) {
          TVar3 = xTaskGetTickCount();
        }
        else {
          TVar3 = xTaskGetTickCountFromISR();
        }
        uVar7 = 0x45;
      }
      format = "[%10u][%s: %s:%4d] mem err.\r\n";
      goto LAB_23035abc;
    }
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x36;
  }
  else {
    if (BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    if (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_uart) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    if (TrapNetCounter == 0) {
      TVar3 = xTaskGetTickCount();
    }
    else {
      TVar3 = xTaskGetTickCountFromISR();
    }
    uVar7 = 0x65;
  }
  format = "[%10u][%s: %s:%4d] arg err.\r\n";
LAB_23035abc:
  bl_printk(format,TVar3,&DAT_23072bcc,"hal_uart.c",uVar7);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int32_t hal_uart_send_trigger(uart_dev_t *uart)

{
  bl_uart_int_tx_enable(uart->port);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int32_t hal_uart_send_trigger_off(uart_dev_t *uart)

{
  bl_uart_int_tx_disable(uart->port);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int32_t hal_uart_init(uart_dev_t *uart)

{
  int iVar1;
  int iVar2;
  hal_uart_parity_t ahStack17 [4];
  uint8_t parity;
  
  iVar2 = aos_mutex_new((aos_mutex_t *)uart->priv);
  iVar1 = -1;
  if (iVar2 == 0) {
    bl_uart_getdefconfig(uart->port,ahStack17);
    if (ahStack17[0] == NO_PARITY) {
      (uart->config).parity = NO_PARITY;
    }
    else {
      if (ahStack17[0] != ODD_PARITY) {
        ahStack17[0] = EVEN_PARITY;
      }
      (uart->config).parity = ahStack17[0];
    }
    bl_uart_int_enable(uart->port);
    iVar1 = iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int32_t hal_uart_recv_II(uart_dev_t *uart,void *data,uint32_t expect_size,uint32_t *recv_size,
                        uint32_t timeout)

{
  uint32_t uVar1;
  int iVar2;
  
  uVar1 = 0;
  while (uVar1 != expect_size) {
    iVar2 = bl_uart_data_recv(uart->port);
    if (iVar2 < 0) break;
    *(char *)((int)data + uVar1) = (char)iVar2;
    uVar1 = uVar1 + 1;
  }
  *recv_size = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int32_t hal_uart_send(uart_dev_t *uart,void *data,uint32_t size,uint32_t timeout)

{
  uint8_t data_00;
  uint8_t *puVar1;
  
  puVar1 = (uint8_t *)((int)data + size);
  while ((uint8_t *)data != puVar1) {
                    // WARNING: Load size is inaccurate
    data_00 = *data;
    data = (void *)((int)data + 1);
    bl_uart_data_send(uart->port,data_00);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int32_t hal_uart_finalize(uart_dev_t *uart)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)uart->priv;
  bl_uart_int_disable(uart->port);
  aos_mutex_free(mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int32_t hal_uart_notify_register(uart_dev_t *uart,hal_uart_int_t type,anon_subr_void_void_ptr *cb)

{
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_0000202d,type) == 0) {
    bl_uart_int_tx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  else {
    if (CONCAT31(in_register_0000202d,type) != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    bl_uart_int_rx_notify_register(uart->port,(cb_uart_notify_t *)cb,uart);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int vfs_uart_init(uint32_t fdt,uint32_t dtb_uart_offset)

{
  int iVar1;
  TickType_t TVar2;
  char *pcVar3;
  int iVar4;
  fdt32_t *pfVar5;
  uint32_t baudrate;
  uint32_t uVar6;
  int iVar7;
  char *__s2;
  uint32_t uVar8;
  undefined4 uVar9;
  int iVar10;
  char *pcVar11;
  fdt32_t x;
  fdt32_t x_00;
  char **ppcVar12;
  uint32_t rx_buf_size;
  uint32_t tx_buf_size;
  fdt32_t x_01;
  uint8_t uStack152;
  char **ppcStack148;
  uint local_7c;
  int lentmp;
  char *uart_node [2];
  _feature_pin feature_pin [4];
  
  if (inited != '\x01') {
    lentmp = 0x23084688;
    uart_node[0] = "uart@4000A100";
    local_7c = 0;
    memcpy(uart_node + 1,&PTR_DAT_230845d0,0x30);
    ppcStack148 = (char **)&lentmp;
    iVar10 = 0;
    do {
      pcVar11 = *ppcStack148;
      iVar1 = fdt_subnode_offset((void *)fdt,dtb_uart_offset,pcVar11);
      if (iVar1 < 1) {
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          uVar9 = 300;
          goto LAB_23035e5a;
        }
      }
      else {
        pcVar11 = (char *)fdt_stringlist_count((void *)fdt,iVar1,"status");
        if (pcVar11 == (char *)0x1) {
          pcVar11 = fdt_stringlist_get((void *)fdt,iVar1,"status",0,(int *)&local_7c);
          if ((local_7c == 4) && (iVar4 = memcmp(&DAT_23084714,pcVar11,4), iVar4 == 0)) {
            pcVar11 = (char *)fdt_stringlist_count((void *)fdt,iVar1,"path");
            if (pcVar11 == (char *)0x1) {
              pcVar11 = fdt_stringlist_get((void *)fdt,iVar1,"path",0,(int *)&local_7c);
              if (((0x20 < local_7c) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
                 (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar2 = xTaskGetTickCount();
                }
                else {
                  TVar2 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] uart[%d] path lentmp = %d\r\n",TVar2,&DAT_2307f16c,
                          "hal_uart.c",0x144,iVar10,local_7c);
              }
              pfVar5 = (fdt32_t *)fdt_getprop((void *)fdt,iVar1,"baudrate",(int *)&local_7c);
              if (pfVar5 == (fdt32_t *)0x0) {
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                   (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                  if (TrapNetCounter == 0) {
                    TVar2 = xTaskGetTickCount();
                  }
                  else {
                    TVar2 = xTaskGetTickCountFromISR();
                  }
                  uVar9 = 0x14b;
                  pcVar11 = "[%10u][%s: %s:%4d] uart[%d] baudrate NULL.\r\n";
LAB_23036086:
                  bl_printk(pcVar11,TVar2,&DAT_2307f16c,"hal_uart.c",uVar9,iVar10);
                }
              }
              else {
                x_00 = *pfVar5;
                pfVar5 = (fdt32_t *)fdt_getprop((void *)fdt,iVar1,"id",(int *)&local_7c);
                if (pfVar5 == (fdt32_t *)0x0) {
                  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                     (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                    if (TrapNetCounter == 0) {
                      TVar2 = xTaskGetTickCount();
                    }
                    else {
                      TVar2 = xTaskGetTickCountFromISR();
                    }
                    uVar9 = 0x153;
                    pcVar11 = "[%10u][%s: %s:%4d] uart[%d] id NULL.\r\n";
                    goto LAB_23036086;
                  }
                }
                else {
                  x = *pfVar5;
                  iVar4 = fdt_subnode_offset((void *)fdt,iVar1,"buf_size");
                  if (iVar4 < 1) {
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] uart[%d] buf_size NULL, will use default.\r\n",
                                TVar2,&DAT_2307f16c,"hal_uart.c",0x15b,iVar10);
                    }
                    tx_buf_size = 0x200;
                    rx_buf_size = 0x200;
LAB_2303620a:
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] uart[%d] rx_buf_size %d, tx_buf_size %d\r\n",
                                TVar2,&DAT_2307f16c,"hal_uart.c",0x16c,iVar10,rx_buf_size,
                                tx_buf_size);
                    }
                    baudrate = fdt32_to_cpu(x_00);
                    uVar6 = fdt32_to_cpu(x);
                    ppcVar12 = uart_node + 1;
                    do {
                      iVar4 = fdt_subnode_offset((void *)fdt,iVar1,"feature");
                      if (iVar4 < 1) {
                        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                           (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                          if (TrapNetCounter == 0) {
                            TVar2 = xTaskGetTickCount();
                          }
                          else {
                            TVar2 = xTaskGetTickCountFromISR();
                          }
                          bl_printk("[%10u][%s: %s:%4d] uart[%d] feature NULL.\r\n",TVar2,
                                    &DAT_2307f16c,"hal_uart.c",0x171,iVar10);
                        }
                      }
                      else {
                        pcVar3 = *ppcVar12;
                        iVar7 = fdt_stringlist_count((void *)fdt,iVar4,pcVar3);
                        if (iVar7 == 1) {
                          __s2 = fdt_stringlist_get((void *)fdt,iVar4,pcVar3,0,(int *)&local_7c);
                          if ((local_7c == 4) && (iVar4 = memcmp(&DAT_23084714,__s2,4), iVar4 == 0))
                          {
                            iVar4 = fdt_subnode_offset((void *)fdt,iVar1,"pin");
                            if (iVar4 < 1) {
                              if ((BLOG_LEVEL_INFO < _fsymc_level_hal_drv) ||
                                 (BLOG_LEVEL_INFO < _fsymf_level_hal_drvhal_uart))
                              goto LAB_230363c4;
                              if (TrapNetCounter == 0) {
                                TVar2 = xTaskGetTickCount();
                              }
                              else {
                                TVar2 = xTaskGetTickCountFromISR();
                              }
                              bl_printk("[%10u][%s: %s:%4d] uart[%d] pin NULL.\r\n",TVar2,
                                        &DAT_2307f16c,"hal_uart.c",0x182,iVar10);
                              break;
                            }
                            pcVar3 = ppcVar12[1];
                            pfVar5 = (fdt32_t *)
                                     fdt_getprop((void *)fdt,iVar4,pcVar3,(int *)&local_7c);
                            if (pfVar5 == (fdt32_t *)0x0) {
                              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                                 (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                                if (TrapNetCounter == 0) {
                                  TVar2 = xTaskGetTickCount();
                                }
                                else {
                                  TVar2 = xTaskGetTickCountFromISR();
                                }
                                bl_printk("[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n",TVar2,
                                          &DAT_2307f16c,"hal_uart.c",0x187,iVar10,pcVar3);
                              }
                            }
                            else {
                              uVar8 = fdt32_to_cpu(*pfVar5);
                              *(char *)(ppcVar12 + 2) = (char)uVar8;
                            }
                          }
                          else {
                            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                              if (TrapNetCounter == 0) {
                                TVar2 = xTaskGetTickCount();
                              }
                              else {
                                TVar2 = xTaskGetTickCountFromISR();
                              }
                              bl_printk("[%10u][%s: %s:%4d] uart[%d] %s status = %s lentmp = %d\r\n"
                                        ,TVar2,&DAT_2307f16c,"hal_uart.c",0x17b,iVar10,pcVar3,__s2);
                            }
                          }
                        }
                        else {
                          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                            if (TrapNetCounter == 0) {
                              TVar2 = xTaskGetTickCount();
                            }
                            else {
                              TVar2 = xTaskGetTickCountFromISR();
                            }
                            bl_printk("[%10u][%s: %s:%4d] uart[%d] %s countindex = %d.\r\n",TVar2,
                                      &DAT_2307f16c,"hal_uart.c",0x176,iVar10,pcVar3,iVar7);
                          }
                        }
                      }
                      ppcVar12 = ppcVar12 + 3;
                    } while ((char **)&feature_pin[3].value != ppcVar12);
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk(
                                "[%10u][%s: %s:%4d] id = %d, %s = %d, %s = %d, %s = %d, %s = %d baudrate = %ld.\r\n"
                                ,TVar2,&DAT_2307f16c,"hal_uart.c",0x192,uVar6 & 0xff,
                                feature_pin[0].featue_name,(uint)(byte)feature_pin[0].pin_name);
                    }
LAB_230363c4:
                    uStack152 = (uint8_t)uVar6;
                    bl_uart_flush(uStack152);
                    bl_uart_init(uStack152,(byte)feature_pin[0].pin_name,
                                 (uint8_t)feature_pin[1].pin_name,(uint8_t)feature_pin[2].pin_name,
                                 (uint8_t)feature_pin[3].pin_name,baudrate);
                    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d ok.\r\n",TVar2,&DAT_2307f16c,
                                "hal_uart.c",0x19a,uVar6 & 0xff);
                      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                        if (TrapNetCounter == 0) {
                          TVar2 = xTaskGetTickCount();
                        }
                        else {
                          TVar2 = xTaskGetTickCountFromISR();
                        }
                        bl_printk("[%10u][%s: %s:%4d] bl_uart_init %d baudrate = %ld ok.\r\n",TVar2,
                                  &DAT_2307f16c,"hal_uart.c",0x19b,uVar6 & 0xff,baudrate);
                      }
                    }
                    iVar1 = dev_uart_init(uStack152,pcVar11,rx_buf_size,tx_buf_size);
                    if (((iVar1 != 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
                       (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_ASSERT)) {
                      if (TrapNetCounter == 0) {
                        TVar2 = xTaskGetTickCount();
                      }
                      else {
                        TVar2 = xTaskGetTickCountFromISR();
                      }
                      bl_printk("[%10u][%s: %s:%4d] dev_uart_init err.\r\n",TVar2,&DAT_23072bcc,
                                "hal_uart.c",0x19e);
                    }
                  }
                  else {
                    pfVar5 = (fdt32_t *)fdt_getprop((void *)fdt,iVar4,"rx_size",(int *)&local_7c);
                    if (pfVar5 == (fdt32_t *)0x0) {
                      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                        if (TrapNetCounter == 0) {
                          TVar2 = xTaskGetTickCount();
                        }
                        else {
                          TVar2 = xTaskGetTickCountFromISR();
                        }
                        pcVar11 = "rx_size";
                        uVar9 = 0x161;
LAB_23035e5a:
                        pcVar3 = "[%10u][%s: %s:%4d] uart[%d] %s NULL.\r\n";
                        goto LAB_23035ece;
                      }
                    }
                    else {
                      x_01 = *pfVar5;
                      pfVar5 = (fdt32_t *)fdt_getprop((void *)fdt,iVar4,"tx_size",(int *)&local_7c);
                      if (pfVar5 != (fdt32_t *)0x0) {
                        rx_buf_size = fdt32_to_cpu(x_01);
                        tx_buf_size = fdt32_to_cpu(*pfVar5);
                        goto LAB_2303620a;
                      }
                      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                         (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                        if (TrapNetCounter == 0) {
                          TVar2 = xTaskGetTickCount();
                        }
                        else {
                          TVar2 = xTaskGetTickCountFromISR();
                        }
                        pcVar11 = "tx_size";
                        uVar9 = 0x167;
                        goto LAB_23035e5a;
                      }
                    }
                  }
                }
              }
            }
            else {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar2 = xTaskGetTickCount();
                }
                else {
                  TVar2 = xTaskGetTickCountFromISR();
                }
                uVar9 = 0x13e;
                pcVar3 = "[%10u][%s: %s:%4d] uart[%d] path_countindex = %d NULL.\r\n";
                goto LAB_23035ece;
              }
            }
          }
          else {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                TVar2 = xTaskGetTickCount();
              }
              else {
                TVar2 = xTaskGetTickCountFromISR();
              }
              uVar9 = 0x137;
              pcVar3 = "[%10u][%s: %s:%4d] uart[%d] status = %s\r\n";
              goto LAB_23035ece;
            }
          }
        }
        else {
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvhal_uart < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              TVar2 = xTaskGetTickCount();
            }
            else {
              TVar2 = xTaskGetTickCountFromISR();
            }
            uVar9 = 0x132;
            pcVar3 = "[%10u][%s: %s:%4d] uart[%d] status_countindex = %d NULL.\r\n";
LAB_23035ece:
            bl_printk(pcVar3,TVar2,&DAT_2307f16c,"hal_uart.c",uVar9,iVar10,pcVar11);
          }
        }
      }
      ppcStack148 = ppcStack148 + 1;
      if (iVar10 != 0) goto code_r0x23035f08;
      iVar10 = 1;
    } while( true );
  }
LAB_23035f0e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
code_r0x23035f08:
  inited = (int8_t)iVar10;
  goto LAB_23035f0e;
}



int32_t hal_uart_send_flush(uart_dev_t *uart,uint32_t timeout)

{
  bl_uart_flush(uart->port);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void hal_uart_setbaud(uart_dev_t *uart,uint32_t baud)

{
  bl_uart_setbaud(uart->port,baud);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void hal_uart_setconfig(uart_dev_t *uart,uint32_t baud,hal_uart_parity_t parity)

{
  bl_uart_setconfig(uart->port,baud,parity);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int hal_gpio_init_from_dts(uint32_t fdt,uint32_t dtb_offset)

{
  bool bVar1;
  uint uVar2;
  uint *puVar3;
  TickType_t TVar4;
  int nodeoffset;
  char *pcVar5;
  int iVar6;
  char *format;
  undefined *puVar7;
  undefined4 uVar8;
  uint uVar9;
  int iVar10;
  int local_5c;
  int lentmp;
  char node [12];
  gpio_feature_config gpio_config;
  
  node._8_4_ = 0;
  puVar3 = (uint *)fdt_getprop((void *)fdt,dtb_offset,"max_num",(int *)(node + 8));
  uVar2 = 0xffffffff;
  if (puVar3 != (uint *)0x0) {
    uVar2 = *puVar3;
    uVar2 = uVar2 << 0x18 | uVar2 >> 0x18 | (uVar2 >> 8 & 0xff) << 0x10 |
            (uVar2 >> 0x10 & 0xff) << 8;
  }
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [GPIO] Max num is %d\r\n",TVar4,&DAT_2307f16c,"hal_gpio.c",
              0xb5,uVar2);
  }
  iVar10 = 0;
  do {
    if ((int)uVar2 <= iVar10) {
LAB_23036728:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    snprintf((char *)&lentmp,0xb,"gpio%u",iVar10);
    node[7] = '\0';
    local_5c = 0;
    nodeoffset = fdt_subnode_offset((void *)fdt,dtb_offset,(char *)&lentmp);
    if (nodeoffset < 0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar4 = xTaskGetTickCount();
        }
        else {
          TVar4 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] %s NOT found\r\n",TVar4,&DAT_2307f16c,"hal_gpio.c",0x61,
                  &lentmp);
      }
      goto LAB_23036728;
    }
    memset(node + 8,0,0xc);
    bVar1 = false;
    pcVar5 = fdt_stringlist_get((void *)fdt,nodeoffset,"status",0,&local_5c);
    if ((local_5c == 4) && (iVar6 = memcmp(&DAT_23084714,pcVar5,4), iVar6 == 0)) {
      puVar3 = (uint *)fdt_getprop((void *)fdt,nodeoffset,"pin",&local_5c);
      if (puVar3 == (uint *)0x0) {
        if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_2303678a;
        if (TrapNetCounter == 0) {
          TVar4 = xTaskGetTickCount();
        }
        else {
          TVar4 = xTaskGetTickCountFromISR();
        }
        uVar8 = 0x70;
        pcVar5 = "[%10u][%s: %s:%4d] no pin found for %s\r\n";
LAB_23036848:
        bl_printk(pcVar5,TVar4,&DAT_23072bcc,"hal_gpio.c",uVar8,&lentmp);
      }
      else {
        uVar9 = *puVar3;
        node._8_4_ = (uVar9 >> 0x10 & 0xff) << 8 |
                     uVar9 << 0x18 | uVar9 >> 0x18 | (uVar9 >> 8 & 0xff) << 0x10;
        pcVar5 = fdt_stringlist_get((void *)fdt,nodeoffset,"feature",0,&local_5c);
        if ((local_5c != 3) || (iVar6 = memcmp("led",pcVar5,3), iVar6 != 0)) {
          if ((BLOG_LEVEL_ERROR < _fsymc_level_hal_drv) ||
             (BLOG_LEVEL_ERROR < _fsymf_level_hal_drvhal_gpio)) goto LAB_2303678a;
          if (TrapNetCounter == 0) {
            TVar4 = xTaskGetTickCount();
          }
          else {
            TVar4 = xTaskGetTickCountFromISR();
          }
          uVar8 = 0x79;
LAB_230369ca:
          puVar7 = &DAT_23072bcc;
          format = "[%10u][%s: %s:%4d] %s: unvalid GPIO config %3s\r\n";
          goto LAB_2303687e;
        }
        gpio_config.pin._1_1_ = 0;
        pcVar5 = fdt_stringlist_get((void *)fdt,nodeoffset,"active",0,&local_5c);
        if (local_5c == 2) {
          iVar6 = memcmp(&DAT_23084b70,pcVar5,2);
          if (iVar6 == 0) {
            gpio_config.pin._2_1_ = 1;
          }
          else {
            if ((local_5c != 2) || (iVar6 = memcmp(&DAT_23084b74,pcVar5,2), iVar6 != 0))
            goto LAB_23036a06;
            gpio_config.pin._2_1_ = 0;
          }
          pcVar5 = fdt_stringlist_get((void *)fdt,nodeoffset,"mode",0,&local_5c);
          if (((local_5c == 5) && (iVar6 = memcmp("blink",pcVar5,5), iVar6 == 0)) ||
             ((local_5c == 9 && (iVar6 = memcmp("heartbeat",pcVar5,9), iVar6 == 0)))) {
            puVar3 = (uint *)fdt_getprop((void *)fdt,nodeoffset,"time",&local_5c);
            if (puVar3 == (uint *)0x0) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
                 (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
                if (TrapNetCounter == 0) {
                  TVar4 = xTaskGetTickCount();
                }
                else {
                  TVar4 = xTaskGetTickCountFromISR();
                }
                uVar8 = 0x93;
                pcVar5 = "[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n";
                goto LAB_23036848;
              }
            }
            else {
              uVar9 = *puVar3;
              gpio_config._4_4_ =
                   (uVar9 >> 0x10 & 0xff) << 8 |
                   uVar9 << 0x18 | uVar9 >> 0x18 | (uVar9 >> 8 & 0xff) << 0x10;
              bVar1 = true;
            }
          }
          else {
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
               (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
              if (TrapNetCounter == 0) {
                TVar4 = xTaskGetTickCount();
              }
              else {
                TVar4 = xTaskGetTickCountFromISR();
              }
              uVar8 = 0x8d;
              goto LAB_230369ca;
            }
          }
        }
        else {
LAB_23036a06:
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
             (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
            if (TrapNetCounter == 0) {
              TVar4 = xTaskGetTickCount();
            }
            else {
              TVar4 = xTaskGetTickCountFromISR();
            }
            uVar8 = 0x83;
            goto LAB_230369ca;
          }
        }
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar4 = xTaskGetTickCount();
        }
        else {
          TVar4 = xTaskGetTickCountFromISR();
        }
        uVar8 = 0x6a;
        puVar7 = &DAT_2307f16c;
        format = "[%10u][%s: %s:%4d] [%s] status = %s\r\n";
LAB_2303687e:
        bl_printk(format,TVar4,puVar7,"hal_gpio.c",uVar8,&lentmp,pcVar5);
      }
    }
LAB_2303678a:
    if (bVar1) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar4 = xTaskGetTickCount();
        }
        else {
          TVar4 = xTaskGetTickCountFromISR();
        }
        bl_printk(
                  "[%10u][%s: %s:%4d] New CONF: GPIO%02u: feature %u, active %u, mode %u, time %u\r\n"
                  ,TVar4,&DAT_2307f16c,"hal_gpio.c",0xa6,node._8_4_,(uint)gpio_config.pin._1_1_,
                  (uint)gpio_config.pin._2_1_);
      }
      loopset_led_trigger(node._8_4_,gpio_config._4_4_);
    }
    else {
      if (((!bVar1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
         (_fsymf_level_hal_drvhal_gpio < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar4 = xTaskGetTickCount();
        }
        else {
          TVar4 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] %s: unvalid GPIO config\r\n",TVar4,&DAT_23072bcc,"hal_gpio.c",
                  0xc3,&lentmp);
      }
    }
    iVar10 = iVar10 + 1;
  } while( true );
}



void _dump_partition(void)

{
  int iVar1;
  anon_struct_conflict1ae139 *paVar2;
  
  bl_printk("======= PtTable_Config @%p=======\r\n",0x4200d9cc);
  bl_printk("magicCode 0x%08X;",boot2_partition_table.table.ptTable.magicCode);
  bl_printk(" version 0x%04X;",(uint)boot2_partition_table.table.ptTable.version);
  bl_printk(" entryCnt %u;",(uint)boot2_partition_table.table.ptTable.entryCnt);
  bl_printk(" age %lu;",boot2_partition_table.table.ptTable.age);
  bl_printk(" crc32 0x%08X\r\n");
  bl_printk(
           "idx  type device activeIndex     name   Address[0]  Address[1]  Length[0]   Length[1]   age\r\n"
           );
  iVar1 = 0;
  paVar2 = &boot2_partition_table;
  while( true ) {
    if ((int)(uint)boot2_partition_table.table.ptTable.entryCnt <= iVar1) break;
    bl_printk("[%02d] ",iVar1);
    iVar1 = iVar1 + 1;
    bl_printk(" %02u",(uint)(paVar2->table).ptEntries[0].type);
    bl_printk("     %u",(uint)(paVar2->table).ptEntries[0].device);
    bl_printk("         %u",(uint)(paVar2->table).ptEntries[0].activeIndex);
    bl_printk("      %8s",(paVar2->table).ptEntries[0].name);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].Address[1]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[0]);
    bl_printk("  %p",(paVar2->table).ptEntries[0].maxLen[1]);
    bl_printk("  %lu\r\n");
    paVar2 = (anon_struct_conflict1ae139 *)((paVar2->table).ptEntries[0].Address + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int hal_boot2_update_ptable(HALPartition_Entry_Config *ptEntry_hal)

{
  uint8_t uVar1;
  PtTable_Error_Type PVar2;
  undefined3 extraout_var;
  
  ptEntry_hal->activeIndex = ptEntry_hal->activeIndex == '\0';
  uVar1 = boot2_partition_table.partition_active_idx;
  ptEntry_hal->age = ptEntry_hal->age + 1;
  PVar2 = PtTable_Update_Entry
                    ((SPI_Flash_Cfg_Type *)0x0,uVar1 == '\0',&boot2_partition_table.table,
                     (PtTable_Entry_Config *)ptEntry_hal);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CONCAT31(extraout_var,PVar2);
}



uint32_t hal_boot2_get_flash_addr(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint32_t)(ram_heap + (uint)boot2_partition_table.table.ptTable.entryCnt * 0x24 + 0x1c58);
}



int hal_boot2_partition_bus_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  anon_struct_conflict1ae139 *paVar4;
  uint uVar5;
  uint uVar6;
  anon_struct_conflict1ae139 *paVar7;
  
  if (boot2_partition_table.table.ptTable.magicCode != 0x54504642) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -5;
  }
  paVar7 = &boot2_partition_table;
  paVar4 = &boot2_partition_table;
  uVar1 = 0;
  while ((int)uVar1 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
    iVar3 = strcmp((char *)(paVar4->table).ptEntries[0].name,name);
    paVar4 = (anon_struct_conflict1ae139 *)((paVar4->table).ptEntries[0].Address + 1);
    if (iVar3 == 0) break;
    uVar1 = uVar1 + 1;
  }
  iVar3 = -2;
  if (uVar1 != boot2_partition_table.table.ptTable.entryCnt) {
    iVar3 = uVar1 * 0x24;
    uVar6 = *(uint *)(boot2_partition_table.pad + iVar3 + 0x1f);
    uVar5 = *(uint *)(boot2_partition_table.pad + iVar3 + 0x23);
    *active = (uint)boot2_partition_table.pad[iVar3 + 0x15];
    *size0 = *(uint32_t *)(boot2_partition_table.pad + iVar3 + 0x27);
    uVar2 = 0;
    *size1 = *(uint32_t *)(boot2_partition_table.pad + uVar1 * 0x24 + 0x2b);
    while ((int)uVar2 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar3 = strcmp((char *)(paVar7->table).ptEntries[0].name,"FW");
      paVar7 = (anon_struct_conflict1ae139 *)((paVar7->table).ptEntries[0].Address + 1);
      if (iVar3 == 0) break;
      uVar2 = uVar2 + 1;
    }
    iVar3 = -0x8c;
    if (uVar2 != boot2_partition_table.table.ptTable.entryCnt) {
      if (uVar6 != 0) {
        if (uVar6 < *(uint *)(boot2_partition_table.pad + uVar2 * 0x24 + 0x1f)) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x16;
        }
        if (uVar6 < *(uint *)(boot2_partition_table.pad + uVar2 * 0x24 + 0x23)) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x16;
        }
      }
      if (uVar5 != 0) {
        if (uVar5 < *(uint *)(boot2_partition_table.pad + uVar2 * 0x24 + 0x1f)) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x16;
        }
        if (uVar5 < *(uint *)(boot2_partition_table.pad + uVar2 * 0x24 + 0x23)) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x16;
        }
      }
      iVar3 = -0xe;
      if (boot2_partition_table.pad[uVar2 * 0x24 + 0x15] < 2) {
        iVar3 = 0;
        *addr0 = (uVar6 + 0x22fff000) -
                 *(int *)(boot2_partition_table.pad +
                         ((uint)boot2_partition_table.pad[uVar2 * 0x24 + 0x15] + uVar2 * 9) * 4 +
                         0x1f);
        *addr1 = (uVar5 + 0x22fff000) -
                 *(int *)(boot2_partition_table.pad +
                         (uVar2 * 9 + (uint)boot2_partition_table.pad[uVar2 * 0x24 + 0x15]) * 4 +
                         0x1f);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int hal_boot2_partition_bus_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int hal_boot2_partition_bus_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_bus_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int hal_boot2_partition_addr
              (char *name,uint32_t *addr0,uint32_t *addr1,uint32_t *size0,uint32_t *size1,
              int *active)

{
  uint uVar1;
  anon_struct_conflict1ae139 *paVar2;
  int iVar3;
  int iVar4;
  
  if (boot2_partition_table.table.ptTable.magicCode == 0x54504642) {
    paVar2 = &boot2_partition_table;
    uVar1 = 0;
    while ((int)uVar1 < (int)(uint)boot2_partition_table.table.ptTable.entryCnt) {
      iVar3 = strcmp((char *)(paVar2->table).ptEntries[0].name,name);
      paVar2 = (anon_struct_conflict1ae139 *)((paVar2->table).ptEntries[0].Address + 1);
      if (iVar3 == 0) break;
      uVar1 = uVar1 + 1;
    }
    iVar3 = -2;
    if (uVar1 != boot2_partition_table.table.ptTable.entryCnt) {
      iVar4 = uVar1 * 0x24;
      *addr0 = *(uint32_t *)(boot2_partition_table.pad + iVar4 + 0x1f);
      *addr1 = *(uint32_t *)(boot2_partition_table.pad + iVar4 + 0x23);
      *size0 = *(uint32_t *)(boot2_partition_table.pad + iVar4 + 0x27);
      *size1 = *(uint32_t *)(boot2_partition_table.pad + uVar1 * 0x24 + 0x2b);
      iVar3 = 0;
      *active = (uint)boot2_partition_table.pad[iVar4 + 0x15];
    }
  }
  else {
    iVar3 = -5;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int hal_boot2_partition_addr_active(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      uStack36 = addr0;
    }
    *addr = uStack36;
    if (size1 != 0) {
      addr1 = size0;
    }
    *size = addr1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int hal_boot2_partition_addr_inactive(char *name,uint32_t *addr,uint32_t *size)

{
  int iVar1;
  uint32_t uStack36;
  uint32_t addr0;
  uint32_t addr1;
  uint32_t size0;
  uint32_t size1;
  int active;
  
  iVar1 = hal_boot2_partition_addr(name,&uStack36,&addr0,&addr1,&size0,(int *)&size1);
  if (iVar1 == 0) {
    if (size1 != 0) {
      addr0 = uStack36;
    }
    *addr = addr0;
    if (size1 != 0) {
      size0 = addr1;
    }
    *size = size0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



uint8_t hal_boot2_get_active_partition(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return boot2_partition_table.partition_active_idx;
}



int hal_boot2_get_active_entries(int type,HALPartition_Entry_Config *ptEntry_hal)

{
  PtTable_Error_Type PVar1;
  undefined3 extraout_var;
  
  PVar1 = PtTable_Get_Active_Entries
                    (&boot2_partition_table.table,(PtTable_Entry_Type)type,
                     (PtTable_Entry_Config *)ptEntry_hal);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(CONCAT31(extraout_var,PVar1) != 0);
}



int hal_boot2_dump(void)

{
  _dump_partition();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int hal_boot2_init(void)

{
  TickType_t TVar1;
  
  boot2_partition_table.partition_active_idx = ram_heap[7232];
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_boot2 < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [HAL] [BOOT2] Active Partition[%u] consumed %d Bytes\r\n",TVar1,
              &DAT_2307f16c,"hal_boot2.c",0x114,(uint)boot2_partition_table.partition_active_idx,
              0x254);
  }
  _dump_partition();
  bl_flash_config_update();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int hal_reboot(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_sys_reset(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void hal_poweroff(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hal_sys_capcode_update(uint8_t capin,uint8_t capout)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_00002029,capin) != 0xff) &&
     (CONCAT31(in_register_0000202d,capout) != 0xff)) {
    (*_DAT_2101081c)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    hal_sys_capcode_update::capin_static = capin;
    hal_sys_capcode_update::capout_static = capout;
    return;
  }
                    // WARNING: Could not recover jumptable at 0x230370ea. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101081c)(hal_sys_capcode_update::capin_static,hal_sys_capcode_update::capout_static);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint8_t hal_sys_capcode_get(void)

{
  uint8_t uVar1;
  
  uVar1 = AON_Get_Xtal_CapCode();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint32_t fdt32_to_cpu(fdt32_t x)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (x >> 0x10 & 0xff) << 8 | x << 0x18 | x >> 0x18 | (x >> 8 & 0xff) << 0x10;
}



uint32_t hal_board_get_factory_addr(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return factory_addr;
}



// WARNING: Could not reconcile some variable overlaps

int hal_board_cfg(uint8_t board_code)

{
  char cVar1;
  byte bVar2;
  int iVar3;
  uint32_t uVar4;
  int iVar5;
  TickType_t TVar6;
  int iVar7;
  int iVar8;
  char *pcVar9;
  size_t sVar10;
  uint32_t uVar11;
  uint32_t uVar12;
  void *pvVar13;
  uint32_t uVar14;
  fdt32_t *pfVar15;
  fdt32_t fVar16;
  int iVar17;
  int iVar18;
  char *pcVar19;
  uint8_t chan;
  undefined4 uVar20;
  int *piVar21;
  size_t *psVar22;
  size_t *psVar23;
  byte *pbVar24;
  uint8_t uVar25;
  uint8_t uVar26;
  fdt32_t *pfVar27;
  int iStack220;
  byte local_c4 [4];
  char pwr_mode [3];
  uint32_t size;
  int lentmp;
  int lentmp_2;
  int lentmp_1;
  char xtal_mode [3];
  size_t local_a0;
  uint16_t channel_cnt_table [14];
  undefined4 local_80;
  uint32_t channel_div_table [15];
  
  iVar5 = hal_boot2_partition_addr_active("factory",&factory_addr,(uint32_t *)pwr_mode);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] addr from partition is %08x, ret is %d\r\n"
              ,TVar6,&DAT_2307f16c,"hal_board.c",0x376,factory_addr,iVar5);
  }
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [FLASH] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar6,&DAT_23072bcc,"hal_board.c",0x378);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  iVar5 = hal_boot2_partition_bus_addr_active("factory",&factory_addr,(uint32_t *)pwr_mode);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] addr from partition is %08x, ret is %d\r\n",
              TVar6,&DAT_2307f16c,"hal_board.c",0x37e,factory_addr,iVar5);
  }
  uVar4 = factory_addr;
  if (factory_addr == 0) {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk(
                "[%10u][%s: %s:%4d] [MAIN] [BOARD] [XIP] Dead loop. Reason: NO valid Param Parition found\r\n"
                ,TVar6,&DAT_23072bcc,"hal_board.c",0x380);
    }
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  size = 0;
  iVar5 = fdt_subnode_offset((void *)factory_addr,0,"wifi");
  if (((iVar5 < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] wifi NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c",0x242);
  }
  iVar7 = fdt_subnode_offset((void *)uVar4,iVar5,"brd_rf");
  if (0 < iVar7) {
    local_a0 = 0;
    iVar8 = fdt_stringlist_count((void *)uVar4,iVar7,"xtal_mode");
    if (iVar8 == 1) {
      pcVar9 = fdt_stringlist_get((void *)uVar4,iVar7,"xtal_mode",0,(int *)&local_a0);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] xtal_mode length %d\r\n",TVar6,&DAT_2307f16c,"hal_board.c",
                  0x141,local_a0);
      }
      if ((int)local_a0 < 3) {
        memcpy(&lentmp_1,pcVar9,local_a0);
        lentmp_1 = lentmp_1 & 0xff00ffff;
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar6 = xTaskGetTickCount();
          }
          else {
            TVar6 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] xtal_mode is %s\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x145
                    ,&lentmp_1);
        }
        sVar10 = strlen((char *)&lentmp_1);
        iVar8 = 0;
        while (iVar8 < (int)sVar10) {
          if (xtal_mode[iVar8 + -4] == 'F') {
            local_80 = 0;
            pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar7,"xtal",&local_80);
            if (local_80 == 0x14) {
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                uVar14 = fdt32_to_cpu(*pfVar15);
                uVar11 = fdt32_to_cpu(pfVar15[1]);
                uVar12 = fdt32_to_cpu(pfVar15[2]);
                fdt32_to_cpu(pfVar15[3]);
                fdt32_to_cpu(pfVar15[4]);
                bl_printk("[%10u][%s: %s:%4d] xtal dtb in DEC :%u %u %u %u %u\r\n",TVar6,
                          &DAT_2307f16c,"hal_board.c",0xf9,uVar14 & 0xff,uVar11 & 0xff,uVar12 & 0xff
                         );
              }
              uVar14 = fdt32_to_cpu(*pfVar15);
              uVar25 = (uint8_t)uVar14;
              uVar14 = fdt32_to_cpu(pfVar15[1]);
              local_80._0_1_ = (byte)uVar14;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from F ready\r\n",TVar6,"DEBUG ",
                          "hal_board.c",0x114);
              }
              goto LAB_23037596;
            }
            if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
              if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] xtal dtb NULL.",TVar6,&DAT_23072bcc,"hal_board.c",
                          0x100);
              }
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                uVar20 = 0x117;
                pcVar9 = "[%10u][%s: %s:%4d] get xtal from F failed\r\n";
                goto LAB_23037900;
              }
            }
          }
          else {
            if (xtal_mode[iVar8 + -4] != 'M') {
              if (TrapNetCounter == 0) {
                TVar6 = xTaskGetTickCount();
              }
              else {
                TVar6 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar6,&UNK_2307c064,"hal_board.c",
                        0x128,"hal_board.c",0x128);
              do {
                    // WARNING: Do nothing block with infinite loop
              } while( true );
            }
            local_80 = local_80 & 0xffffff00;
            iVar17 = bl_efuse_read_capcode((uint8_t *)&local_80);
            if (iVar17 == 0) {
              uVar25 = (byte)local_80;
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                 (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] get xtal from M ready\r\n",TVar6,"DEBUG ",
                          "hal_board.c",0x11f);
              }
              goto LAB_23037596;
            }
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
               (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar6 = xTaskGetTickCount();
              }
              else {
                TVar6 = xTaskGetTickCountFromISR();
              }
              uVar20 = 0x122;
              pcVar9 = "[%10u][%s: %s:%4d] get xtal from M failed\r\n";
LAB_23037900:
              bl_printk(pcVar9,TVar6,"DEBUG ","hal_board.c",uVar20);
            }
          }
          iVar8 = iVar8 + 1;
          if (iVar8 == 2) break;
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar6 = xTaskGetTickCount();
          }
          else {
            TVar6 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default xtal\r\n",TVar6,&DAT_2307f16c,"hal_board.c",
                    0x12e);
        }
        local_80._0_1_ = '2';
        uVar25 = '2';
LAB_23037596:
        hal_sys_capcode_update(uVar25,(byte)local_80);
      }
    }
    pvVar13 = fdt_getprop((void *)uVar4,iVar7,"channel_div_table",(int *)&size);
    if (size == 0x3c) {
      iVar8 = 0;
      do {
        uVar14 = fdt32_to_cpu(*(fdt32_t *)((int)pvVar13 + iVar8));
        *(uint32_t *)((int)channel_div_table + iVar8 + -4) = uVar14;
        iVar8 = iVar8 + 4;
      } while (iVar8 != 0x3c);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table :\r\n",TVar6,&DAT_2307f16c,"hal_board.c",600
                 );
      }
      log_buf_out("hal_board.c",0x259,&local_80,0x3c,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_div_table NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c"
                  ,0x25b);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar7,"channel_cnt_table",(int *)&size);
    if (size == 0x38) {
      pfVar27 = pfVar15 + 0xe;
      psVar22 = &local_a0;
      do {
        fVar16 = *pfVar15;
        pfVar15 = pfVar15 + 1;
        uVar14 = fdt32_to_cpu(fVar16);
        *(short *)psVar22 = (short)uVar14;
        psVar22 = (size_t *)((int)psVar22 + 2);
      } while (pfVar27 != pfVar15);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table :\r\n",TVar6,&DAT_2307f16c,"hal_board.c",
                  0x263);
      }
      log_buf_out("hal_board.c",0x264,&local_a0,0x38,LOG_BUF_OUT_DATA_TYPE_HEX);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] channel_cnt_table NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c"
                  ,0x266);
      }
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar7,"lo_fcal_div",(int *)&size);
    if (size == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        fVar16 = *pfVar15;
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar14 = fdt32_to_cpu(fVar16);
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div : %d\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x26c,
                  uVar14 & 0xffff);
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] lo_fcal_div NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c",0x26e
                 );
      }
    }
  }
  iVar7 = fdt_subnode_offset((void *)uVar4,iVar5,"mac");
  if (0 < iVar7) {
    lentmp_2 = 0;
    iVar8 = fdt_stringlist_count((void *)uVar4,iVar7,"mode");
    if (iVar8 == 1) {
      pcVar9 = fdt_stringlist_get((void *)uVar4,iVar7,"mode",0,&lentmp_2);
      bl_printk("MAC address mode length %d\r\n",lentmp_2);
      if (lentmp_2 < 4) {
        memcpy(&lentmp_1,pcVar9,lentmp_2);
        lentmp_1 = lentmp_1 & 0xffffff;
        bl_printk("MAC address mode is %s\r\n",&lentmp_1);
        sVar10 = strlen((char *)&lentmp_1);
        iVar8 = 0;
        do {
          if ((int)sVar10 <= iVar8) break;
          cVar1 = xtal_mode[iVar8 + -4];
          if (cVar1 == 'F') {
            pvVar13 = fdt_getprop((void *)uVar4,iVar7,"sta_mac_addr",(int *)&local_a0);
            if (local_a0 == 6) {
              memcpy(&local_80,pvVar13,6);
              bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
              pvVar13 = fdt_getprop((void *)uVar4,iVar7,"ap_mac_addr",(int *)&local_a0);
              if (local_a0 == 6) {
                memcpy(&local_80,pvVar13,6);
                bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                  if (TrapNetCounter == 0) {
                    TVar6 = xTaskGetTickCount();
                  }
                  else {
                    TVar6 = xTaskGetTickCountFromISR();
                  }
                  uVar20 = 0x9b;
                  pcVar9 = "[%10u][%s: %s:%4d] get MAC from F ready\r\n";
                  goto LAB_23037b56;
                }
                goto LAB_23037b64;
              }
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar6 = xTaskGetTickCount();
                  }
                  else {
                    TVar6 = xTaskGetTickCountFromISR();
                  }
                  uVar20 = 0x54;
                  pcVar9 = "[%10u][%s: %s:%4d] ap_mac_addr NULL.\r\n";
                  goto LAB_23038094;
                }
                goto LAB_23038098;
              }
            }
            else {
              if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
                if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
                  if (TrapNetCounter == 0) {
                    TVar6 = xTaskGetTickCount();
                  }
                  else {
                    TVar6 = xTaskGetTickCountFromISR();
                  }
                  uVar20 = 0x47;
                  pcVar9 = "[%10u][%s: %s:%4d] sta_mac_addr NULL.\r\n";
LAB_23038094:
                  bl_printk(pcVar9,TVar6,&DAT_23072bcc,"hal_board.c",uVar20);
                }
LAB_23038098:
                if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
                   (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
                  if (TrapNetCounter == 0) {
                    TVar6 = xTaskGetTickCount();
                  }
                  else {
                    TVar6 = xTaskGetTickCountFromISR();
                  }
                  uVar20 = 0x9e;
                  pcVar9 = "[%10u][%s: %s:%4d] get MAC from F failed\r\n";
                  goto LAB_2303786a;
                }
              }
            }
          }
          else {
            if (cVar1 == 'M') {
              iVar17 = bl_efuse_read_mac_factory((uint8_t *)&local_80);
              if (iVar17 == 0) {
                if (((byte)(channel_div_table[0]._1_1_ |
                           (byte)channel_div_table[0] |
                           local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0)
                   && (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ &
                        (byte)channel_div_table[0] & channel_div_table[0]._1_1_) != 1)) {
                  if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                  if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO) {
                    if (TrapNetCounter == 0) {
                      TVar6 = xTaskGetTickCount();
                    }
                    else {
                      TVar6 = xTaskGetTickCountFromISR();
                    }
                    uVar20 = 0xa6;
                    pcVar9 = "[%10u][%s: %s:%4d] get MAC from M ready\r\n";
                    goto LAB_23037b56;
                  }
                  goto LAB_23037b64;
                }
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_2303786e;
              if (TrapNetCounter == 0) {
                TVar6 = xTaskGetTickCount();
              }
              else {
                TVar6 = xTaskGetTickCountFromISR();
              }
              uVar20 = 0xa9;
              pcVar9 = "[%10u][%s: %s:%4d] get MAC from M failed\r\n";
            }
            else {
              if (cVar1 != 'B') {
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar6,&UNK_2307c064,"hal_board.c",
                          0xaf,"hal_board.c",0xaf);
                do {
                    // WARNING: Do nothing block with infinite loop
                } while( true );
              }
              bl_efuse_read_mac((uint8_t *)&local_80);
              if (((byte)(channel_div_table[0]._1_1_ |
                         (byte)channel_div_table[0] |
                         local_80._3_1_ | local_80._2_1_ | (byte)local_80 | local_80._1_1_) != 0) &&
                 (((byte)local_80 & local_80._1_1_ & local_80._2_1_ & local_80._3_1_ &
                   (byte)channel_div_table[0] & channel_div_table[0]._1_1_) != 1)) {
                if (BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) goto LAB_23037b5a;
                if (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board) goto LAB_23037b64;
                if (TrapNetCounter == 0) {
                  TVar6 = xTaskGetTickCount();
                }
                else {
                  TVar6 = xTaskGetTickCountFromISR();
                }
                uVar20 = 0x90;
                pcVar9 = "[%10u][%s: %s:%4d] get MAC from B ready\r\n";
LAB_23037b56:
                bl_printk(pcVar9,TVar6,"DEBUG ","hal_board.c",uVar20);
                goto LAB_23037b5a;
              }
              if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
                 (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_2303786e;
              if (TrapNetCounter == 0) {
                TVar6 = xTaskGetTickCount();
              }
              else {
                TVar6 = xTaskGetTickCountFromISR();
              }
              uVar20 = 0x93;
              pcVar9 = "[%10u][%s: %s:%4d] get MAC from B failed\r\n";
            }
LAB_2303786a:
            bl_printk(pcVar9,TVar6,"DEBUG ","hal_board.c",uVar20);
          }
LAB_2303786e:
          iVar8 = iVar8 + 1;
        } while (iVar8 != 3);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar6 = xTaskGetTickCount();
          }
          else {
            TVar6 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] Using Default MAC address\r\n",TVar6,&DAT_2307f16c,
                    "hal_board.c",0xb5);
        }
        memcpy(&local_80,&mac_default_3782,6);
LAB_23037b5a:
        if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
LAB_23037b64:
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
            if (TrapNetCounter == 0) {
              TVar6 = xTaskGetTickCount();
            }
            else {
              TVar6 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Set MAC addrress %02X:%02X:%02X:%02X:%02X:%02X\r\n",TVar6,
                      &DAT_2307f16c,"hal_board.c",0xc0,local_80 & 0xff,local_80 >> 8 & 0xff,
                      local_80 >> 0x10 & 0xff);
          }
        }
        bl_wifi_ap_mac_addr_set((uint8_t *)&local_80);
        bl_wifi_sta_mac_addr_set((uint8_t *)&local_80);
      }
    }
  }
  iVar7 = fdt_subnode_offset((void *)uVar4,iVar5,"region");
  if (0 < iVar7) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar7,"country_code",(int *)&size);
    if (size == 4) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar14 = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] country_code : %d\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x27f
                  ,uVar14 & 0xff);
      }
      uVar14 = fdt32_to_cpu(*pfVar15);
      bl_wifi_country_code_set((uint8_t)uVar14);
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] country_code NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c",
                  0x283);
      }
    }
  }
  iVar7 = fdt_subnode_offset((void *)uVar4,iVar5,"brd_rf");
  if (iVar7 < 1) goto LAB_23038860;
  pvVar13 = fdt_getprop((void *)uVar4,iVar7,"pwr_table_11b",(int *)&size);
  if (size == 0x10) {
    iVar8 = 0;
    do {
      uVar14 = fdt32_to_cpu(*(fdt32_t *)(iVar8 * 4 + (int)pvVar13));
      *(char *)((int)channel_div_table + iVar8 + -4) = (char)uVar14;
      iVar8 = iVar8 + 1;
    } while (iVar8 != 4);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b :%u %u %u %u\r\n",TVar6,&DAT_2307f16c,
                "hal_board.c",0x298,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11b((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11b NULL. lentmp = %d\r\n",TVar6,&DAT_23072bcc,
                "hal_board.c",0x29b,size);
    }
  }
  pvVar13 = fdt_getprop((void *)uVar4,iVar7,"pwr_table_11g",(int *)&size);
  if (size == 0x20) {
    iVar8 = 0;
    do {
      uVar14 = fdt32_to_cpu(*(fdt32_t *)(iVar8 * 4 + (int)pvVar13));
      *(char *)((int)channel_div_table + iVar8 + -4) = (char)uVar14;
      iVar8 = iVar8 + 1;
    } while (iVar8 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g :%u %u %u %u %u %u %u %u\r\n",TVar6,&DAT_2307f16c,
                "hal_board.c",0x2ac,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11g((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11g NULL. lentmp = %d\r\n",TVar6,&DAT_23072bcc,
                "hal_board.c",0x2af,size);
    }
  }
  pvVar13 = fdt_getprop((void *)uVar4,iVar7,"pwr_table_11n",(int *)&size);
  if (size == 0x20) {
    iVar8 = 0;
    do {
      uVar14 = fdt32_to_cpu(*(fdt32_t *)(iVar8 * 4 + (int)pvVar13));
      *(char *)((int)channel_div_table + iVar8 + -4) = (char)uVar14;
      iVar8 = iVar8 + 1;
    } while (iVar8 != 8);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n :%u %u %u %u %u %u %u %u\r\n",TVar6,&DAT_2307f16c,
                "hal_board.c",0x2c0,local_80 & 0xff,local_80 >> 8 & 0xff,local_80 >> 0x10 & 0xff);
    }
    bl_tpc_update_power_rate_11n((int8_t *)&local_80);
  }
  else {
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] pwr_table_11n NULL. lentmp = %d\r\n",TVar6,&DAT_23072bcc,
                "hal_board.c",0x2c3,size);
    }
  }
  lentmp = 0;
  iVar8 = fdt_stringlist_count((void *)uVar4,iVar7,"pwr_mode");
  if (iVar8 != 1) goto LAB_23038860;
  pcVar9 = fdt_stringlist_get((void *)uVar4,iVar7,"pwr_mode",0,&lentmp);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode length %d\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x1c1,
              lentmp);
  }
  if (2 < lentmp) goto LAB_23038860;
  memcpy(local_c4,pcVar9,lentmp);
  local_c4[2] = 0;
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] pwr_mode is %s\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x1c5,
              local_c4);
  }
  memset(&lentmp_1,0,0xe);
  memset(&local_a0,0,0xe);
  sVar10 = strlen((char *)local_c4);
  pbVar24 = local_c4;
  iStack220 = 0;
  iVar17 = 0;
  do {
    if ((int)sVar10 <= iVar17) break;
    bVar2 = *pbVar24;
    if (bVar2 == 0x46) {
LAB_230383fa:
      lentmp_2 = 0;
      pvVar13 = fdt_getprop((void *)uVar4,iVar7,"pwr_offset",&lentmp_2);
      if (lentmp_2 != 0x38) {
        if (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) {
          if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT) {
            if (TrapNetCounter == 0) {
              TVar6 = xTaskGetTickCount();
            }
            else {
              TVar6 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] pwr_offset NULL. lentmp = %d\r\n",TVar6,&DAT_23072bcc,
                      "hal_board.c",0x15f,lentmp_2);
          }
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
             (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar6 = xTaskGetTickCount();
            }
            else {
              TVar6 = xTaskGetTickCountFromISR();
            }
            uVar20 = 0x1a0;
            pcVar9 = "[%10u][%s: %s:%4d] get pwr offset from F(f) failed\r\n";
            goto LAB_23038748;
          }
        }
        goto LAB_230386be;
      }
      iVar7 = 0;
      do {
        uVar14 = fdt32_to_cpu(*(fdt32_t *)(iVar7 * 4 + (int)pvVar13));
        *(char *)((int)channel_cnt_table + iVar7 + -4) = (char)uVar14;
        iVar7 = iVar7 + 1;
      } while (iVar7 != 0xe);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb:\r\n",TVar6,&DAT_2307f16c,"hal_board.c",
                  0x156);
      }
      log_buf_out("hal_board.c",0x157,&local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_HEX);
      psVar22 = &local_a0;
      do {
        psVar23 = (size_t *)((int)psVar22 + 1);
        *(char *)psVar22 = *(char *)psVar22 + -10;
        psVar22 = psVar23;
      } while ((size_t *)(channel_cnt_table + 5) != psVar23);
      if (_fsymc_level_hal_drv < BLOG_LEVEL_WARN) {
        if (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN) {
          if (TrapNetCounter == 0) {
            TVar6 = xTaskGetTickCount();
          }
          else {
            TVar6 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] pwr_offset from dtb (rebase on %d):\r\n",TVar6,&DAT_2307f16c
                    ,"hal_board.c",0x15b,10);
        }
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
           (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
          if (TrapNetCounter == 0) {
            TVar6 = xTaskGetTickCount();
          }
          else {
            TVar6 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] get pwr offset from F(f) ready\r\n",TVar6,"DEBUG ",
                    "hal_board.c",399);
        }
      }
      if (*pbVar24 == 0x42) {
        iVar7 = 0;
        do {
          xtal_mode[iVar7 + -4] = *(char *)((int)channel_cnt_table + iVar7 + -4);
          iVar7 = iVar7 + 1;
        } while (iVar7 != 0xe);
        if ((BLOG_LEVEL_DEBUG < _fsymc_level_hal_drv) ||
           (BLOG_LEVEL_DEBUG < _fsymf_level_hal_drvhal_board)) goto LAB_23038844;
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar20 = 0x195;
        pcVar19 = "DEBUG ";
        pcVar9 = "[%10u][%s: %s:%4d] Use pwr offset from F only\r\n";
        goto LAB_23038656;
      }
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] Use pwr offset from f in incremental mode\r\n",TVar6,"DEBUG ",
                  "hal_board.c",0x199);
      }
      iVar7 = 0;
      piVar21 = &lentmp_1;
      do {
        iVar8 = iVar7 + -4;
        iVar7 = iVar7 + 1;
        *(char *)piVar21 = *(char *)((int)channel_cnt_table + iVar8) + *(char *)piVar21;
        piVar21 = (int *)((int)piVar21 + 1);
      } while (iVar7 != 0xe);
      goto LAB_23038844;
    }
    if (bVar2 < 0x47) {
      if (bVar2 != 0x42) {
LAB_23037f9e:
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar6,&UNK_2307c064,"hal_board.c",0x1a6,
                  "hal_board.c",0x1a6);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if (bVar2 != 0x62) {
        if (bVar2 != 0x66) goto LAB_23037f9e;
        goto LAB_230383fa;
      }
    }
    iVar18 = bl_efuse_read_pwroft((int8_t *)&local_a0);
    if (iVar18 != 0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar20 = 0x186;
        pcVar9 = "[%10u][%s: %s:%4d] get pwr offset from B(b) failed\r\n";
LAB_23038748:
        bl_printk(pcVar9,TVar6,"DEBUG ","hal_board.c",uVar20);
      }
      goto LAB_230386be;
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] get pwr offset from B(b) ready\r\n",TVar6,&DAT_2307f16c,
                "hal_board.c",0x175);
    }
    log_buf_out("hal_board.c",0x176,&local_a0,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
    if (*pbVar24 == 0x42) goto LAB_23038602;
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] Use pwr offset from b in incremental mode\r\n",TVar6,"DEBUG ",
                "hal_board.c",0x180);
    }
    piVar21 = &lentmp_1;
    do {
      iVar3 = iVar18 + -4;
      iVar18 = iVar18 + 1;
      *(char *)piVar21 = *(char *)((int)channel_cnt_table + iVar3) + *(char *)piVar21;
      piVar21 = (int *)((int)piVar21 + 1);
      iStack220 = iVar8;
    } while (iVar18 != 0xe);
LAB_230386be:
    iVar17 = iVar17 + 1;
    pbVar24 = pbVar24 + 1;
  } while (iVar17 != 2);
  if (((iStack220 == 0) && (_fsymc_level_hal_drv < BLOG_LEVEL_WARN)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    uVar20 = 0x1ac;
    pcVar19 = "\x1b[32mINFO  \x1b[0m";
    pcVar9 = "[%10u][%s: %s:%4d] Using Default pwr offset\r\n";
    goto LAB_23038656;
  }
LAB_23038844:
  log_buf_out("hal_board.c",0x1ae,&lentmp_1,0xe,LOG_BUF_OUT_DATA_TYPE_INT8);
  phy_powroffset_set((int8_t *)&lentmp_1);
LAB_23038860:
  lentmp_1 = 0;
  iVar7 = fdt_subnode_offset((void *)uVar4,iVar5,"ap");
  if (0 < iVar7) {
    iVar8 = fdt_stringlist_count((void *)uVar4,iVar7,"ssid");
    if ((iVar8 == 1) &&
       (pcVar9 = fdt_stringlist_get((void *)uVar4,iVar7,"ssid",0,&lentmp_1), lentmp_1 - 1U < 0x1f))
    {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar6,
                  &DAT_2307f16c,"hal_board.c",0x213,0,pcVar9,lentmp_1);
      }
      memcpy(&local_a0,pcVar9,lentmp_1);
      *(undefined *)((int)channel_cnt_table + lentmp_1 + -4) = 0;
      uVar25 = (uint8_t)lentmp_1;
    }
    else {
      uVar25 = '\0';
    }
    iVar8 = fdt_stringlist_count((void *)uVar4,iVar7,"pwd");
    if ((iVar8 == 1) &&
       (pcVar9 = fdt_stringlist_get((void *)uVar4,iVar7,"pwd",0,&lentmp_1), lentmp_1 - 1U < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar6,
                  &DAT_2307f16c,"hal_board.c",0x21e,0,pcVar9,lentmp_1);
      }
      memcpy(&local_80,pcVar9,lentmp_1);
      *(undefined *)((int)channel_div_table + lentmp_1 + -4) = 0;
      uVar26 = (uint8_t)lentmp_1;
    }
    else {
      uVar26 = '\0';
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar7,"ap_channel",&lentmp_1);
    if (pfVar15 == (fdt32_t *)0x0) {
      chan = '\0';
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT) &&
         (chan = '\0', _fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] ap_channel NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c",0x22b)
        ;
        chan = '\0';
      }
    }
    else {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar14 = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] ap_channel = %ld\r\n",TVar6,&DAT_2307f16c,"hal_board.c",0x227,
                  uVar14);
      }
      uVar14 = fdt32_to_cpu(*pfVar15);
      chan = (uint8_t)uVar14;
    }
    bl_wifi_ap_info_set((uint8_t *)&local_a0,uVar25,(uint8_t *)&local_80,uVar26,chan);
  }
  lentmp_1 = 0;
  iVar5 = fdt_subnode_offset((void *)uVar4,iVar5,"sta");
  if (0 < iVar5) {
    iVar7 = fdt_stringlist_count((void *)uVar4,iVar5,"ssid");
    if ((iVar7 == 1) &&
       (pcVar9 = fdt_stringlist_get((void *)uVar4,iVar5,"ssid",0,&lentmp_1), lentmp_1 - 1U < 0x1f))
    {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_ssid string[%d] = %s, ap_ssid_len = %d\r\n",TVar6,
                  &DAT_2307f16c,"hal_board.c",0x1df,0,pcVar9,lentmp_1);
      }
      memcpy(&local_a0,pcVar9,lentmp_1);
      *(undefined *)((int)channel_cnt_table + lentmp_1 + -4) = 0;
      uVar25 = (uint8_t)lentmp_1;
    }
    else {
      uVar25 = '\0';
    }
    iVar7 = fdt_stringlist_count((void *)uVar4,iVar5,"pwd");
    if ((iVar7 == 1) &&
       (pcVar9 = fdt_stringlist_get((void *)uVar4,iVar5,"pwd",0,&lentmp_1), lentmp_1 - 1U < 0x1f)) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] [STA] ap_psk string[%d] = %s, ap_psk_len = %d\r\n",TVar6,
                  &DAT_2307f16c,"hal_board.c",0x1ea,0,pcVar9,lentmp_1);
      }
      memcpy(&local_80,pcVar9,lentmp_1);
      *(undefined *)((int)channel_div_table + lentmp_1 + -4) = 0;
      uVar26 = (uint8_t)lentmp_1;
    }
    else {
      uVar26 = '\0';
    }
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar5,"auto_connect_enable",&lentmp_1);
    uVar14 = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar6 = xTaskGetTickCount();
        }
        else {
          TVar6 = xTaskGetTickCountFromISR();
        }
        uVar14 = fdt32_to_cpu(*pfVar15);
        bl_printk("[%10u][%s: %s:%4d] auto_connect_enable = %ld\r\n",TVar6,&DAT_2307f16c,
                  "hal_board.c",0x1f2,uVar14);
      }
      uVar14 = fdt32_to_cpu(*pfVar15);
    }
    bl_wifi_sta_info_set((uint8_t *)&local_a0,uVar25,(uint8_t *)&local_80,uVar26,uVar14);
  }
  iVar5 = fdt_subnode_offset((void *)uVar4,0,"bluetooth");
  if (((iVar5 < 1) && (_fsymc_level_hal_drv < BLOG_LEVEL_ASSERT)) &&
     (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_ASSERT)) {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] bt NULL.\r\n",TVar6,&DAT_23072bcc,"hal_board.c",0x2cd);
  }
  iVar5 = fdt_subnode_offset((void *)uVar4,iVar5,"brd_rf");
  if (0 < iVar5) {
    pfVar15 = (fdt32_t *)fdt_getprop((void *)uVar4,iVar5,"pwr_table_ble",(int *)&size);
    uVar4 = 0;
    if (pfVar15 != (fdt32_t *)0x0) {
      uVar4 = fdt32_to_cpu(*pfVar15);
    }
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
       (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_WARN)) {
      if (TrapNetCounter == 0) {
        TVar6 = xTaskGetTickCount();
      }
      else {
        TVar6 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] set pwr_table_ble = %ld in dts\r\n",TVar6,&DAT_2307f16c,
                "hal_board.c",0x2d9,uVar4);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
LAB_23038602:
  do {
    xtal_mode[iVar18 + -4] = *(char *)((int)channel_cnt_table + iVar18 + -4);
    iVar18 = iVar18 + 1;
  } while (iVar18 != 0xe);
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_INFO) && (_fsymf_level_hal_drvhal_board < BLOG_LEVEL_INFO))
  {
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    uVar20 = 0x17c;
    pcVar19 = "DEBUG ";
    pcVar9 = "[%10u][%s: %s:%4d] Use pwr offset from B only\r\n";
LAB_23038656:
    bl_printk(pcVar9,TVar6,pcVar19,"hal_board.c",uVar20);
  }
  goto LAB_23038844;
}



int bl_tsen_adc_get(int16_t *temp,uint8_t log_flag)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  TickType_t TVar2;
  float a;
  undefined3 in_register_0000202d;
  uint16_t uVar3;
  BaseType_t BVar4;
  DFtype DVar5;
  ADC_FIFO_Cfg_Type aAStack68 [2];
  ADC_FIFO_Cfg_Type adcFifoCfg;
  ADC_CFG_Type adcCfg;
  
  uVar3 = 0xffff;
  TVar2 = CONCAT31(in_register_0000202d,log_flag);
  if (bl_tsen_adc_get::tsen_offset == 0xffff) {
    bl_tsen_adc_get::tsen_offset = 0;
    memcpy(&adcFifoCfg,&DAT_2308591c,0xe);
    aAStack68[0] = (ADC_FIFO_Cfg_Type)0x0;
    GLB_Set_ADC_CLK('\x01',GLB_ADC_CLK_96M,'\a');
    ADC_Disable();
    ADC_Enable();
    ADC_Reset();
    ADC_Init((ADC_CFG_Type *)&adcFifoCfg);
    ADC_Channel_Config(ADC_CHAN_TSEN_P,ADC_CHAN_GND,DISABLE);
    ADC_Tsen_Init(ADC_TSEN_MOD_INTERNAL_DIODE);
    ADC_FIFO_Cfg(aAStack68);
    BVar1 = ADC_Trim_TSEN(&bl_tsen_adc_get::tsen_offset);
    if (CONCAT31(extraout_var,BVar1) == 1) {
      if (TrapNetCounter == 0) {
        BVar4 = TrapNetCounter;
        TVar2 = xTaskGetTickCount();
        uVar3 = (uint16_t)BVar4;
      }
      else {
        BVar4 = TrapNetCounter;
        TVar2 = xTaskGetTickCountFromISR();
        uVar3 = (uint16_t)BVar4;
      }
      bl_printk("[%10u][%s: %s:%4d] read efuse data failed\r\n",TVar2,&DAT_23072bcc,"bl_adc.c",0x10b
               );
    }
    else {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = bl_tsen_adc_get::tsen_offset;
      bl_printk("[%10u][%s: %s:%4d] offset = %d\r\n",TVar2,&DAT_2307f16c,"bl_adc.c",0x10d);
    }
  }
  a = TSEN_Get_Temp((uint)bl_tsen_adc_get::tsen_offset);
  if (CONCAT31(in_register_0000202d,log_flag) != 0) {
    DVar5 = __extendsfdf2((SFtype)a);
    printf("temperature = %f Celsius\r\n",a,TVar2,SUB84(DVar5,0));
  }
  if (temp != (int16_t *)0x0) {
    *temp = uVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



uint64_t bl_rtc_get_counter(void)

{
  uint64_t in_fa0;
  uint32_t uStack24;
  uint32_t valLow;
  uint32_t valHigh;
  
  HBN_Get_RTC_Timer_Val(&uStack24,&valLow);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



uint64_t bl_rtc_get_timestamp_ms(void)

{
  uint64_t uVar1;
  
  uVar1 = bl_rtc_get_counter();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int hal_wifi_start_firmware_task(void)

{
  xTaskCreateStatic(wifi_main,"fw",0x600,(void *)0x0,0x1e,
                    hal_wifi_start_firmware_task::wifi_fw_stack,
                    &hal_wifi_start_firmware_task::wifi_fw_task);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_sys_reset_por(void)

{
  GLB_SW_POR_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



void bl_sys_reset_system(void)

{
  GLB_SW_System_Reset();
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



int bl_sys_isxipaddr(uint32_t addr)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(((addr & 0xff000000) + 0xdd000000 & 0xdf000000) == 0);
}



PtTable_Error_Type
PtTable_Update_Entry
          (SPI_Flash_Cfg_Type *pFlashCfg,PtTable_ID_Type targetTableID,PtTable_Stuff_Config *ptStuff
          ,PtTable_Entry_Config *ptEntry)

{
  uint uVar1;
  PtTable_Error_Type PVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  undefined3 in_register_0000202d;
  PtTable_Entry_Config *__dest;
  PtTable_Entry_Config *dataIn;
  uint32_t addr;
  
  if ((ptEntry == (PtTable_Entry_Config *)0x0) || (ptStuff == (PtTable_Stuff_Config *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return PT_ERROR_PARAMETER;
  }
  dataIn = ptStuff->ptEntries;
  PVar2 = PT_ERROR_TABLE_NOT_VALID;
  if (CONCAT31(in_register_0000202d,targetTableID) != 2) {
    addr = 0xe000;
    if (CONCAT31(in_register_0000202d,targetTableID) != 0) {
      addr = 0xf000;
    }
    uVar1 = 0;
    __dest = dataIn;
    while (uVar1 < (ptStuff->ptTable).entryCnt) {
      if (__dest->type == ptEntry->type) {
        memcpy(__dest,ptEntry,0x24);
        break;
      }
      uVar1 = uVar1 + 1;
      __dest = __dest + 1;
    }
    if ((ptStuff->ptTable).entryCnt == uVar1) {
      if (0xf < uVar1) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return PT_ERROR_ENTRY_UPDATE_FAIL;
      }
      memcpy(dataIn + uVar1,ptEntry,0x24);
      (ptStuff->ptTable).entryCnt = (ptStuff->ptTable).entryCnt + 1;
    }
    (ptStuff->ptTable).age = (ptStuff->ptTable).age + 1;
    uVar3 = BFLB_Soft_CRC32(ptStuff,0xc);
    uVar1 = (uint)(ptStuff->ptTable).entryCnt;
    (ptStuff->ptTable).crc32 = uVar3;
    uVar3 = uVar1 * 0x24;
    uVar4 = BFLB_Soft_CRC32(dataIn,uVar3);
    *(uint32_t *)(dataIn + uVar1) = uVar4;
    uVar1 = bl_flash_erase(addr,uVar3 + 0x14);
    if ((uVar1 & 0xff) == 0) {
      uVar1 = bl_flash_write(addr,(uint8_t *)ptStuff,0x254);
      if ((uVar1 & 0xff) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return (PtTable_Error_Type)(uVar1 & 0xff);
      }
    }
    PVar2 = PT_ERROR_FALSH_WRITE;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return PVar2;
}



PtTable_Error_Type
PtTable_Get_Active_Entries
          (PtTable_Stuff_Config *ptStuff,PtTable_Entry_Type type,PtTable_Entry_Config *ptEntry)

{
  undefined3 in_register_0000202d;
  PtTable_Entry_Config *pPVar1;
  uint uVar2;
  
  if (ptStuff == (PtTable_Stuff_Config *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return PT_ERROR_PARAMETER;
  }
  if (ptEntry != (PtTable_Entry_Config *)0x0) {
    uVar2 = 0;
    pPVar1 = ptStuff->ptEntries;
    while( true ) {
      if ((ptStuff->ptTable).entryCnt <= uVar2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return PT_ERROR_ENTRY_NOT_FOUND;
      }
      if ((uint)pPVar1->type == CONCAT31(in_register_0000202d,type)) break;
      uVar2 = uVar2 + 1;
      pPVar1 = pPVar1 + 1;
    }
    memcpy(ptEntry,ptStuff->ptEntries + uVar2,0x24);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return PT_ERROR_SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return PT_ERROR_PARAMETER;
}



int bl_gpio_enable_output(uint8_t pin,uint8_t pullup,uint8_t pulldown)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  undefined auStack24 [4];
  GLB_GPIO_Cfg_Type cfg;
  
  cfg._0_2_ = 0x100;
  auStack24[1] = '\v';
  auStack24[2] = '\x01';
  if (CONCAT31(in_register_0000202d,pullup) == 0) {
    auStack24[3] = '\x02';
  }
  else {
    auStack24[3] = '\0';
  }
  if (CONCAT31(in_register_00002031,pulldown) != 0) {
    auStack24[3] = '\x01';
  }
  auStack24[0] = pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)auStack24);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_gpio_enable_input(uint8_t pin,uint8_t pullup,uint8_t pulldown)

{
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  undefined auStack24 [4];
  GLB_GPIO_Cfg_Type cfg;
  
  cfg._0_2_ = 0x100;
  auStack24[1] = '\v';
  auStack24[2] = '\0';
  if (CONCAT31(in_register_0000202d,pullup) == 0) {
    auStack24[3] = '\x02';
  }
  else {
    auStack24[3] = '\0';
  }
  if (CONCAT31(in_register_00002031,pulldown) != 0) {
    auStack24[3] = '\x01';
  }
  auStack24[0] = pin;
  GLB_GPIO_Init((GLB_GPIO_Cfg_Type *)auStack24);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_gpio_output_set(uint8_t pin,uint8_t value)

{
  undefined3 in_register_0000202d;
  
  GLB_GPIO_Write(pin,(uint)(CONCAT31(in_register_0000202d,value) != 0));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_gpio_input_get(uint8_t pin,uint8_t *value)

{
  uint32_t uVar1;
  
  uVar1 = GLB_GPIO_Read(pin);
  *value = (uint8_t)uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_erase(uint32_t addr,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010ab0)(0x4200dc24,addr,len,_DAT_21010ab0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_write(uint32_t addr,uint8_t *src,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aac)(0x4200dc24,addr,src,len,_DAT_21010aac);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int bl_flash_read(uint32_t addr,uint8_t *dst,int len)

{
  if (boot2_flashCfg.flashCfg.mid != '\0') {
    (*_DAT_21010aa8)(0x4200dc24,addr,dst,len,_DAT_21010aa8);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int bl_flash_config_update(void)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN))
  {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ======= FlashCfg magiccode @%p, code 0x%08lX =======\r\n",TVar1,
              &DAT_2307f16c,"bl_flash.c",0x60,ram_heap + 0x1c58,boot2_flashCfg.magic);
    if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) && (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)
       ) {
      if (TrapNetCounter == 0) {
        TVar1 = xTaskGetTickCount();
      }
      else {
        TVar1 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] mid \t\t0x%X\r\n",TVar1,&DAT_2307f16c,"bl_flash.c",0x61,
                (uint)boot2_flashCfg.flashCfg.mid);
      if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
         (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
        if (TrapNetCounter == 0) {
          TVar1 = xTaskGetTickCount();
        }
        else {
          TVar1 = xTaskGetTickCountFromISR();
        }
        bl_printk("[%10u][%s: %s:%4d] clkDelay \t0x%X\r\n",TVar1,&DAT_2307f16c,"bl_flash.c",0x62,
                  (uint)boot2_flashCfg.flashCfg.clkDelay);
        if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
           (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar1 = xTaskGetTickCount();
          }
          else {
            TVar1 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] clkInvert \t0x%X\r\n",TVar1,&DAT_2307f16c,"bl_flash.c",99,
                    (uint)boot2_flashCfg.flashCfg.clkInvert);
          if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
             (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
            if (TrapNetCounter == 0) {
              TVar1 = xTaskGetTickCount();
            }
            else {
              TVar1 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] sector size\t%uKBytes\r\n",TVar1,&DAT_2307f16c,
                      "bl_flash.c",100,(uint)boot2_flashCfg.flashCfg.sectorSize);
            if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
               (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
              if (TrapNetCounter == 0) {
                TVar1 = xTaskGetTickCount();
              }
              else {
                TVar1 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] page size\t%uBytes\r\n",TVar1,&DAT_2307f16c,"bl_flash.c"
                        ,0x65,(uint)boot2_flashCfg.flashCfg.pageSize);
              if ((_fsymc_level_hal_drv < BLOG_LEVEL_WARN) &&
                 (_fsymf_level_hal_drvbl_flash < BLOG_LEVEL_WARN)) {
                if (TrapNetCounter == 0) {
                  TVar1 = xTaskGetTickCount();
                }
                else {
                  TVar1 = xTaskGetTickCountFromISR();
                }
                bl_printk(
                          "[%10u][%s: %s:%4d] ---------------------------------------------------------------\r\n"
                          ,TVar1,&DAT_2307f16c,"bl_flash.c",0x66);
              }
            }
          }
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_wdt_feed(void)

{
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void bl_wdt_disable(void)

{
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



int bl_wdt_init(int ms)

{
  if (ms < 0xfff) {
    WDT_Disable();
    WDT_Set_Clock(TIMER_CLKSRC_32K,'\x01');
    WDT_SetCompValue((uint16_t)((uint)(ms << 0x14) >> 0x10));
    WDT_ResetCounterValue();
    WDT_IntMask(WDT_INT,MASK);
    WDT_Enable();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



err_t httpc_tcp_sent(void *arg,altcp_pcb *pcb,u16_t len)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t httpc_get_internal_addr(httpc_state_t *req,ip_addr_t *ipaddr)

{
  err_t eVar1;
  
  if (&req->remote_addr != ipaddr) {
    (req->remote_addr).addr = ipaddr->addr;
  }
  eVar1 = altcp_connect(req->pcb,&req->remote_addr,req->remote_port,httpc_tcp_connected);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t httpc_free_state(httpc_state_t *req)

{
  altcp_pcb *conn;
  err_t eVar1;
  undefined3 extraout_var;
  
  if (req->request != (pbuf *)0x0) {
    pbuf_free(req->request);
    req->request = (pbuf *)0x0;
  }
  if (req->rx_hdrs != (pbuf *)0x0) {
    pbuf_free(req->rx_hdrs);
    req->rx_hdrs = (pbuf *)0x0;
  }
  conn = req->pcb;
  mem_free(req);
  if (conn != (altcp_pcb *)0x0) {
    altcp_arg(conn,(void *)0x0);
    altcp_recv(conn,(altcp_recv_fn *)0x0);
    altcp_err(conn,(altcp_err_fn *)0x0);
    altcp_poll(conn,(altcp_poll_fn *)0x0,'\0');
    altcp_sent(conn,(altcp_sent_fn *)0x0);
    eVar1 = altcp_close(conn);
    if (CONCAT31(extraout_var,eVar1) != 0) {
      altcp_abort(conn);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0xd;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t httpc_close(httpc_state_t *req,httpc_result_t result,u32_t server_response,err_t err)

{
  err_t eVar1;
  httpc_result_fn *phVar2;
  
  if (req != (httpc_state_t *)0x0) {
    if ((req->conn_settings != (httpc_connection_t_conflict *)0x0) &&
       (phVar2 = req->conn_settings->result_fn, phVar2 != (httpc_result_fn *)0x0)) {
      (*phVar2)(req->callback_arg,result,req->rx_content_len,server_response,err);
    }
    eVar1 = httpc_free_state(req);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t httpc_tcp_recv(void *arg,altcp_pcb *pcb,pbuf *p,err_t r)

{
  ushort uVar1;
  uint uVar2;
  err_t eVar3;
  u8_t uVar4;
  byte bVar5;
  u16_t uVar6;
  u16_t uVar7;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_04;
  undefined2 extraout_var_05;
  undefined2 extraout_var_06;
  undefined2 extraout_var_07;
  undefined2 extraout_var_08;
  undefined2 extraout_var_09;
  httpc_result_t result;
  u16_t start_offset;
  undefined3 in_register_00002035;
  int iVar8;
  code *pcVar9;
  pbuf *ppVar10;
  char acStack64 [4];
  char status_num [10];
  
  *(undefined4 *)((int)arg + 0xc) = 0x1e;
  if (p == (pbuf *)0x0) {
    result = HTTPC_RESULT_ERR_CLOSED;
    if (*(char *)((int)arg + 0x30) == '\x02') {
      result = HTTPC_RESULT_OK;
      if ((*(int *)((int)arg + 0x2c) != -1) &&
         (*(int *)((int)arg + 0x2c) != *(int *)((int)arg + 0x28))) {
        result = HTTPC_RESULT_ERR_CONTENT_LEN;
      }
    }
    uVar1 = *(ushort *)((int)arg + 0x1a);
    iVar8 = 0;
LAB_2303957c:
    eVar3 = httpc_close((httpc_state_t *)arg,result,(uint)uVar1,(err_t)iVar8);
    goto LAB_23039582;
  }
  if (*(char *)((int)arg + 0x30) == '\x02') {
LAB_230395a8:
    *(uint *)((int)arg + 0x28) = *(int *)((int)arg + 0x28) + (uint)p->tot_len;
    if (*(code **)((int)arg + 0x1c) != (code *)0x0) {
      eVar3 = (**(code **)((int)arg + 0x1c))
                        (*(undefined4 *)((int)arg + 0x24),pcb,p,CONCAT31(in_register_00002035,r));
      goto LAB_23039582;
    }
    altcp_recved(pcb,p->tot_len);
    pbuf_free(p);
  }
  else {
    if (*(pbuf **)((int)arg + 0x14) == (pbuf *)0x0) {
      *(pbuf **)((int)arg + 0x14) = p;
    }
    else {
      pbuf_cat(*(pbuf **)((int)arg + 0x14),p);
    }
    if (*(char *)((int)arg + 0x30) == '\0') {
      ppVar10 = *(pbuf **)((int)arg + 0x14);
      uVar6 = pbuf_memfind(ppVar10,"\r\n",2,0);
      if (CONCAT22(extraout_var_01,uVar6) == 0xffff) goto LAB_23039782;
      uVar7 = pbuf_memfind(ppVar10," ",1,0);
      iVar8 = CONCAT22(extraout_var_02,uVar7);
      if (((iVar8 == 0xffff) ||
          (uVar7 = pbuf_memcmp(ppVar10,0,&DAT_23085d2c,5), CONCAT22(extraout_var_03,uVar7) != 0)) ||
         (uVar4 = pbuf_get_at(ppVar10,6), CONCAT31(extraout_var,uVar4) != 0x2e)) goto LAB_23039782;
      bVar5 = pbuf_get_at(ppVar10,5);
      uVar4 = pbuf_get_at(ppVar10,7);
      *(ushort *)((int)arg + 0x18) =
           (short)CONCAT31(extraout_var_00,uVar4) - 0x30U | (ushort)((bVar5 - 0x30 & 0xffff) << 8);
      start_offset = (u16_t)((uint)((iVar8 + 1) * 0x10000) >> 0x10);
      uVar7 = pbuf_memfind(ppVar10," ",1,start_offset);
      if (CONCAT22(extraout_var_04,uVar7) == 0xffff) {
        iVar8 = CONCAT22(extraout_var_01,uVar6) - iVar8;
      }
      else {
        iVar8 = CONCAT22(extraout_var_04,uVar7) - iVar8;
      }
      memset(acStack64,0,10);
      uVar6 = pbuf_copy_partial(ppVar10,acStack64,(u16_t)((uint)((iVar8 + -1) * 0x10000) >> 0x10),
                                start_offset);
      if ((iVar8 + -1 != CONCAT22(extraout_var_05,uVar6)) ||
         (iVar8 = atoi(acStack64), 0xfffe < iVar8 - 1U)) goto LAB_23039782;
      *(short *)((int)arg + 0x1a) = (short)iVar8;
      *(undefined *)((int)arg + 0x30) = 1;
LAB_230396b8:
      ppVar10 = *(pbuf **)((int)arg + 0x14);
      uVar6 = pbuf_memfind(ppVar10,&DAT_2307b07c,4,0);
      if (0xfffc < CONCAT22(extraout_var_06,uVar6)) goto LAB_2303978c;
      *(undefined4 *)((int)arg + 0x2c) = 0xffffffff;
      uVar7 = pbuf_memfind(ppVar10,"Content-Length: ",0x10,0);
      iVar8 = CONCAT22(extraout_var_07,uVar7);
      if (iVar8 != 0xffff) {
        uVar7 = pbuf_memfind(ppVar10,"\r\n",2,uVar7);
        if (CONCAT22(extraout_var_08,uVar7) != 0xffff) {
          memset(acStack64,0,0x10);
          uVar2 = (CONCAT22(extraout_var_08,uVar7) - iVar8) - 0x10;
          uVar7 = pbuf_copy_partial(ppVar10,acStack64,(u16_t)(uVar2 * 0x10000 >> 0x10),
                                    (u16_t)((uint)((iVar8 + 0x10) * 0x10000) >> 0x10));
          if (((uVar2 & 0xffff) == CONCAT22(extraout_var_09,uVar7)) &&
             (iVar8 = atoi(acStack64), -1 < iVar8)) {
            *(int *)((int)arg + 0x2c) = iVar8;
          }
        }
      }
      uVar2 = CONCAT22(extraout_var_06,uVar6) + 4;
      uVar6 = (u16_t)(uVar2 * 0x10000 >> 0x10);
      altcp_recved(pcb,uVar6);
      if (((*(int *)((int)arg + 0x20) != 0) &&
          (pcVar9 = *(code **)(*(int *)((int)arg + 0x20) + 0x18), pcVar9 != (code *)0x0)) &&
         (iVar8 = (*pcVar9)(arg,*(undefined4 *)((int)arg + 0x24),*(undefined4 *)((int)arg + 0x14),
                            uVar2 & 0xffff,*(undefined4 *)((int)arg + 0x2c)), iVar8 != 0)) {
        uVar1 = *(ushort *)((int)arg + 0x1a);
        result = HTTPC_RESULT_LOCAL_ABORT;
        goto LAB_2303957c;
      }
      p = pbuf_free_header(*(pbuf **)((int)arg + 0x14),uVar6);
      *(undefined4 *)((int)arg + 0x14) = 0;
      *(undefined *)((int)arg + 0x30) = 2;
      if (p != (pbuf *)0x0) goto LAB_230395a8;
    }
    else {
LAB_23039782:
      if (*(char *)((int)arg + 0x30) == '\x01') goto LAB_230396b8;
LAB_2303978c:
      if (*(char *)((int)arg + 0x30) == '\x02') goto LAB_230395a8;
    }
  }
  eVar3 = '\0';
LAB_23039582:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar3;
}



void httpc_dns_found(char *hostname,ip_addr_t *ipaddr,void *arg)

{
  err_t eVar1;
  undefined3 extraout_var;
  httpc_result_t result;
  int iVar2;
  
  if (ipaddr == (ip_addr_t *)0x0) {
    result = HTTPC_RESULT_ERR_HOSTNAME;
    iVar2 = -0x10;
  }
  else {
    eVar1 = httpc_get_internal_addr((httpc_state_t *)arg,ipaddr);
    iVar2 = CONCAT31(extraout_var,eVar1);
    result = HTTPC_RESULT_ERR_CONNECT;
    if (iVar2 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  httpc_close((httpc_state_t *)arg,result,0,(err_t)iVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t httpc_tcp_poll(void *arg,altcp_pcb *pcb)

{
  err_t eVar1;
  int iVar2;
  
  if ((arg != (void *)0x0) &&
     ((*(int *)((int)arg + 0xc) == 0 ||
      (iVar2 = *(int *)((int)arg + 0xc) + -1, *(int *)((int)arg + 0xc) = iVar2, iVar2 == 0)))) {
    eVar1 = httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_TIMEOUT,0,'\0');
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void httpc_tcp_err(void *arg,err_t err)

{
  if (arg != (void *)0x0) {
    *(undefined4 *)arg = 0;
    httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_CLOSED,0,err);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t httpc_tcp_connected(void *arg,altcp_pcb *pcb,err_t err)

{
  err_t eVar1;
  undefined3 extraout_var;
  
                    // WARNING: Load size is inaccurate
  eVar1 = altcp_write(*arg,*(void **)(*(int *)((int)arg + 0x10) + 4),
                      *(short *)(*(int *)((int)arg + 0x10) + 10) - 1,'\x01');
  if (CONCAT31(extraout_var,eVar1) != 0) {
    eVar1 = httpc_close((httpc_state_t *)arg,HTTPC_RESULT_ERR_MEM,0,eVar1);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  pbuf_free(*(pbuf **)((int)arg + 0x10));
                    // WARNING: Load size is inaccurate
  *(undefined4 *)((int)arg + 0x10) = 0;
  altcp_output(*arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



int httpc_create_request_string
              (httpc_connection_t_conflict *settings,char *server_name,int server_port,char *uri,
              char *buffer,size_t buffer_size)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  
  if (settings->use_proxy == '\0') {
    if (settings->req_type == '\x01') {
      pcVar3 = (char *)0x0;
      if (settings->content_type < 4) {
        pcVar3 = g_cont_type[settings->content_type];
      }
      sVar2 = strlen((char *)settings->data);
      iVar1 = snprintf(buffer,buffer_size,
                                              
                       "POST %s HTTP/1.1\r\nContent-Type: %s\r\nContent-Length: %d\r\nUser-Agent: %s\r\nHost: %s\r\nAccept: */*\r\nConnection: Close\r\n\r\n%s"
                       ,uri,pcVar3,sVar2,&UNK_23085ba4,server_name);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    iVar1 = snprintf(buffer,buffer_size,
                                          
                     "GET %s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                     ,&UNK_23085ba4,server_name);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (server_port != 0x50) {
    iVar1 = snprintf(buffer,buffer_size,
                                          
                     "GET http://%s:%d%s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                     ,server_name,server_port,uri,&UNK_23085ba4);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  iVar1 = snprintf(buffer,buffer_size,
                                      
                   "GET http://%s%s HTTP/1.1\r\nUser-Agent: %s\r\nAccept: */*\r\nHost: %s\r\nConnection: Close\r\n\r\n"
                   ,server_name,uri,&UNK_23085ba4,server_name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



err_t httpc_init_connection_common
                (httpc_state_t **connection,httpc_connection_t_conflict *settings,char *server_name,
                u16_t server_port,char *uri,altcp_recv_fn *recv_fn,void *callback_arg)

{
  uint uVar1;
  httpc_state_t *req;
  pbuf *ppVar2;
  altcp_pcb *conn;
  uint uVar3;
  undefined2 in_register_00002036;
  err_t eVar4;
  uint uVar5;
  
  uVar3 = CONCAT22(in_register_00002036,server_port);
  uVar1 = httpc_create_request_string(settings,server_name,uVar3,uri,(char *)0x0,0);
  if (uVar1 < 0xffff) {
    req = (httpc_state_t *)mem_malloc(0x34);
    if (req == (httpc_state_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    memset(req,0,0x34);
    req->timeout_ticks = 0x1e;
    ppVar2 = pbuf_alloc(PBUF_RAW,(u16_t)((uVar1 + 1) * 0x10000 >> 0x10),PBUF_RAM);
    req->request = ppVar2;
    if ((ppVar2 != (pbuf *)0x0) && (ppVar2->next == (pbuf *)0x0)) {
      req->hdr_content_len = 0xffffffff;
      conn = altcp_new(settings->altcp_allocator);
      req->pcb = conn;
      if (conn != (altcp_pcb *)0x0) {
        uVar5 = uVar3;
        if (settings->use_proxy != '\0') {
          uVar5 = (uint)settings->proxy_port;
        }
        req->remote_port = (u16_t)uVar5;
        altcp_arg(conn,req);
        altcp_recv(req->pcb,httpc_tcp_recv);
        altcp_err(req->pcb,httpc_tcp_err);
        altcp_poll(req->pcb,httpc_tcp_poll,'\x01');
        altcp_sent(req->pcb,httpc_tcp_sent);
        uVar3 = httpc_create_request_string
                          (settings,server_name,uVar3,uri,(char *)req->request->payload,uVar1 + 1);
        if (uVar1 == uVar3) {
          req->recv_fn = recv_fn;
          req->conn_settings = settings;
          req->callback_arg = callback_arg;
          *connection = req;
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return '\0';
        }
        httpc_free_state(req);
        goto LAB_23039a74;
      }
    }
    httpc_free_state(req);
    eVar4 = -1;
  }
  else {
LAB_23039a74:
    eVar4 = -6;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar4;
}



err_t httpc_get_file_dns(char *server_name,u16_t port,char *uri,
                        httpc_connection_t_conflict *settings,altcp_recv_fn *recv_fn,
                        void *callback_arg,httpc_state_t **connection)

{
  httpc_state_t *req_00;
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar3;
  httpc_state_t *phStack36;
  httpc_state_t *req;
  undefined3 extraout_var_01;
  
  iVar1 = -0x10;
  if (((server_name == (char *)0x0) || (uri == (char *)0x0)) || (recv_fn == (altcp_recv_fn *)0x0))
  goto LAB_23039ad8;
  eVar2 = httpc_init_connection_common
                    (&phStack36,settings,server_name,port,uri,recv_fn,callback_arg);
  req_00 = phStack36;
  iVar1 = CONCAT31(extraout_var,eVar2);
  if (iVar1 != 0) goto LAB_23039ad8;
  if (settings->use_proxy == '\0') {
    settings = (httpc_connection_t_conflict *)&phStack36->remote_addr;
    eVar2 = dns_gethostbyname(server_name,(ip_addr_t *)settings,httpc_dns_found,phStack36);
    iVar3 = CONCAT31(extraout_var_01,eVar2);
    if (iVar3 == 0) goto LAB_23039ac4;
    if (iVar3 == -5) goto LAB_23039b0a;
  }
  else {
LAB_23039ac4:
    eVar2 = httpc_get_internal_addr(req_00,(ip_addr_t *)settings);
    iVar3 = CONCAT31(extraout_var_00,eVar2);
    if (CONCAT31(extraout_var_00,eVar2) == 0) {
LAB_23039b0a:
      if (connection != (httpc_state_t **)0x0) {
        *connection = phStack36;
      }
      goto LAB_23039ad8;
    }
  }
  iVar1 = iVar3;
  httpc_free_state(phStack36);
LAB_23039ad8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



void proc_entry_looprt(void *pvParameters)

{
  bloop_run(&looprt);
  do {
    puts("--->>> Error terminated looprt\r\n");
    vTaskDelay(1000);
  } while( true );
}



void looprt_evt_notify_async(uint task,uint32_t evt_map)

{
  bloop_evt_set_async(&looprt,task,evt_map);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void looprt_evt_status_dump(void)

{
  bloop_status_dump(&looprt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void looprt_evt_schedule(int task,uint32_t evt_map,int delay_ms)

{
  loop_timer *timer;
  
  timer = (loop_timer *)pvPortMalloc(0x24);
  if (timer != (loop_timer *)0x0) {
    bloop_timer_init(timer,1);
    bloop_timer_configure
              (timer,delay_ms,(anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr *)0x0,(void *)0x0
               ,task,evt_map);
    bloop_timer_register(&looprt,timer);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int looprt_start(StackType_t *proc_stack_looprt,int stack_count,StaticTask_t *proc_task_looprt)

{
  bloop_init(&looprt);
  bloop_handler_register(&looprt,&bloop_handler_sys,0x1f);
  looprt_evt_status_dump();
  xTaskCreateStatic(proc_entry_looprt,"bloop_rt",stack_count,(void *)0x0,0x1a,proc_stack_looprt,
                    proc_task_looprt);
  bloop_wait_startup(&looprt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int looprt_start_auto(void)

{
  bloop_init(&looprt);
  bloop_handler_register(&looprt,&bloop_handler_sys,0x1f);
  looprt_evt_status_dump();
  xTaskCreate(proc_entry_looprt,"bloop_rt",0x1000,(void *)0x0,0x1a,(TaskHandle_t *)0x0);
  bloop_wait_startup(&looprt);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int looprt_handler_register(loop_evt_handler *handler,int priority)

{
  int iVar1;
  
  if (looprt.looper != (TaskHandle_t)0x0) {
    iVar1 = bloop_handler_register(&looprt,handler,priority);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int looprt_timer_register(loop_timer *timer)

{
  bloop_timer_register(&looprt,timer);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cmd_looprt_test(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt test ======\r\n");
  printf("struct loop_ctx size is %d\r\n",0x4a0);
  printf("MSG size is %d\r\n",0x18);
  looprt_start_auto();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_looprt_test_status(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt test status ======\r\n");
  looprt_evt_status_dump();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_looprt_test_evt(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt EVT ======\r\n");
  looprt_evt_notify_async(0x1f,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_looprt_test_evt_dump(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt EVT status ======\r\n");
  looprt_evt_notify_async(0x1f,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_looprt_test_schedule_evt1(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt Schedule EVT1 ======\r\n");
  looprt_evt_schedule(0x1f,1,20000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_looprt_test_schedule_evt2(char *buf,int len,int argc,char **argv)

{
  puts("====== looprt Schedule EVT2 ======\r\n");
  looprt_evt_schedule(0x1f,1,10000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int looprt_test_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void _cb_led_trigger(loop_ctx *loop,loop_timer *timer,void *arg)

{
  TickType_t TVar1;
  undefined *puVar2;
  
  bl_gpio_output_set(*(uint8_t *)((int)arg + 0x30),*(int *)((int)arg + 0x38) != 0);
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    if (*(int *)((int)arg + 0x38) == 0) {
      puVar2 = &DAT_23084b74;
    }
    else {
      puVar2 = &DAT_23084b70;
    }
    bl_printk("[%10u][%s: %s:%4d] [LED] [CB] Set pin %d to %s\r\n",TVar1,"DEBUG ","loopset_led.c",
              0x95,*(undefined4 *)((int)arg + 0x30),puVar2);
  }
  *(uint *)((int)arg + 0x38) = (uint)(*(int *)((int)arg + 0x38) == 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int _led_bloop_msg(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  TickType_t TVar1;
  
  if ((_fsymc_level_loopset < BLOG_LEVEL_INFO) &&
     (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_INFO)) {
    if (TrapNetCounter == 0) {
      TVar1 = xTaskGetTickCount();
    }
    else {
      TVar1 = xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] [LED] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
              ,TVar1,"DEBUG ","loopset_led.c",0x78,(uint)*(byte *)&msg->u,
              (uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int _led_bloop_evt(loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,
                  uint32_t *evt_type_map)

{
  char **ppcVar1;
  uint uVar2;
  TickType_t TVar3;
  char *pcVar4;
  undefined *puVar5;
  char *pcVar6;
  char **ppcVar7;
  char **ppcVar8;
  
  uVar2 = *evt_type_map;
  do {
    if ((uVar2 & 1) == 0) {
      if ((uVar2 & 2) == 0) {
        if (uVar2 != 0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","loopset_led.c",0x5e);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        break;
      }
      pcVar6 = handler[1].name;
      ppcVar7 = (char **)0x0;
      ppcVar1 = *(char ***)(pcVar6 + 0xc);
      if (ppcVar1 != (char **)0x0) {
        ppcVar7 = (char **)ppcVar1[1];
      }
      while (ppcVar8 = ppcVar7, ppcVar1 != (char **)(pcVar6 + 8)) {
        if ((_fsymc_level_loopset < BLOG_LEVEL_WARN) &&
           (_fsymf_level_loopsetloopset_led < BLOG_LEVEL_WARN)) {
          if (TrapNetCounter == 0) {
            TVar3 = xTaskGetTickCount();
          }
          else {
            TVar3 = xTaskGetTickCountFromISR();
          }
          puVar5 = &DAT_23084b70;
          if (ppcVar1[0xd] == (char *)0x0) {
            puVar5 = &DAT_23084b74;
          }
          pcVar4 = "Hearbeat";
          if (ppcVar1[0xb] == (char *)0x0) {
            pcVar4 = "Blink";
          }
          bl_printk("[%10u][%s: %s:%4d] [LED] New Trigger: PIN %d, active level %s, type %s\r\n",
                    TVar3,&DAT_2307f16c,"loopset_led.c",0x4b,ppcVar1[0xc],puVar5,pcVar4);
        }
        looprt_timer_register((loop_timer *)(ppcVar1 + 2));
        ppcVar7 = (char **)ppcVar1[1];
        pcVar4 = *ppcVar1;
        *(char ***)(pcVar4 + 4) = ppcVar7;
        *ppcVar7 = pcVar4;
        ppcVar7 = *(char ***)(pcVar6 + 4);
        *ppcVar1 = pcVar6;
        ppcVar1[1] = (char *)ppcVar7;
        *(char ***)(pcVar6 + 4) = ppcVar1;
        *ppcVar7 = (char *)ppcVar1;
        ppcVar1 = ppcVar8;
        ppcVar7 = (char **)0x0;
        if (ppcVar8 != (char **)0x0) {
          ppcVar7 = (char **)ppcVar8[1];
        }
      }
      uVar2 = uVar2 & 0xfffffffd;
    }
    else {
      uVar2 = uVar2 & 0xfffffffe;
    }
  } while (uVar2 != 0);
  *evt_type_map = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int loopset_led_hook_on_looprt(void)

{
  int iVar1;
  
  led_ctx.trigger_queue.next = &led_ctx;
  led_ctx.trigger_queue.prev = &led_ctx;
  led_ctx.waiting_queue.next = (utils_dlist_s *)&led_ctx.waiting_queue;
  led_ctx.waiting_queue.prev = (utils_dlist_s *)&led_ctx.waiting_queue;
  iVar1 = looprt_handler_register
                    ((loop_evt_handler *)&loopset_led_hook_on_looprt::_led_bloop_handler_holder,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void loopset_led_trigger(int pin,uint timeon_ms)

{
  utils_dlist_s **ppuVar1;
  loop_timer *timer;
  utils_dlist_s *__s;
  TickType_t TVar2;
  
  __s = (utils_dlist_s *)pvPortMalloc(0x3c);
  if (__s == (utils_dlist_s *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] ASSERT: %s:%d\r\n",TVar2,&UNK_2307c064,"loopset_led.c",0x9e,
              "loopset_led.c",0x9e);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  memset(__s,0,0x3c);
  timer = (loop_timer *)(__s + 1);
  __s[6].prev = (utils_dlist_s *)pin;
  bloop_timer_init(timer,0);
  bloop_timer_repeat_enable(timer);
  bloop_timer_configure(timer,timeon_ms,_cb_led_trigger,__s,1,1);
  bl_gpio_enable_output((uint8_t)pin,'\0','\0');
  vTaskEnterCritical();
  __s->prev = (utils_dlist_s *)0x420148f0;
  __s->next = led_ctx.waiting_queue.next;
  ppuVar1 = &(led_ctx.waiting_queue.next)->prev;
  led_ctx.waiting_queue.next = __s;
  *ppuVar1 = __s;
  vTaskExitCritical();
  looprt_evt_notify_async(1,2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t sys_mbox_new(sys_mbox_t *mbox,int size)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueGenericCreate(0x32,4,'\0');
  *mbox = (sys_mbox_t)pQVar1;
  lwip_stats.sys.mbox.used = lwip_stats.sys.mbox.used + 1;
  if (lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used) {
    lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)-(*mbox == (sys_mbox_t)0x0);
}



void sys_mbox_free(sys_mbox_t *mbox)

{
  UBaseType_t UVar1;
  
  UVar1 = uxQueueMessagesWaiting((QueueHandle_t)*mbox);
  if (UVar1 != 0) {
    lwip_stats.sys.mbox.err = lwip_stats.sys.mbox.err + 1;
  }
  vQueueDelete((QueueHandle_t)*mbox);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  lwip_stats.sys.mbox.used = lwip_stats.sys.mbox.used - 1;
  return;
}



void sys_mbox_post(sys_mbox_t *mbox,void *data)

{
  BaseType_t BVar1;
  void *apvStack20 [2];
  
  apvStack20[0] = data;
  do {
    BVar1 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0xffffffff,0);
  } while (BVar1 != 1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t sys_mbox_trypost(sys_mbox_t *mbox,void *msg)

{
  err_t eVar1;
  BaseType_t BVar2;
  void *apvStack20 [4];
  
  apvStack20[0] = msg;
  BVar2 = xQueueGenericSend((QueueHandle_t)*mbox,apvStack20,0,0);
  if (BVar2 == 1) {
    eVar1 = '\0';
  }
  else {
    eVar1 = -1;
    lwip_stats.sys.mbox.err = lwip_stats.sys.mbox.err + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox,void **msg,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  u32_t uVar4;
  void *local_24;
  void *dummyptr;
  
  TVar1 = xTaskGetTickCount();
  if (msg == (void **)0x0) {
    msg = &local_24;
  }
  if (timeout == 0) {
    do {
      BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueReceive((QueueHandle_t)*mbox,msg,timeout);
    if (BVar2 != 1) {
      *msg = (void *)0x0;
      uVar4 = 0xffffffff;
      goto LAB_2303a1d0;
    }
  }
  TVar3 = xTaskGetTickCount();
  uVar4 = TVar3 - TVar1;
LAB_2303a1d0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar4;
}



u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox,void **msg)

{
  BaseType_t BVar1;
  void *pvStack20;
  void *dummyptr;
  
  if (msg == (void **)0x0) {
    msg = &pvStack20;
  }
  BVar1 = xQueueReceive((QueueHandle_t)*mbox,msg,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(BVar1 != 1);
}



bool sys_mbox_valid(int *param_1)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return *param_1 != 0;
}



void sys_mbox_set_invalid(undefined4 *param_1)

{
  *param_1 = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t sys_sem_new(sys_sem_t *sem,u8_t count)

{
  err_t eVar1;
  QueueHandle_t xQueue;
  undefined3 in_register_0000202d;
  
  xQueue = xQueueGenericCreate(1,0,'\x03');
  *sem = (sys_sem_t)xQueue;
  if (xQueue != (QueueHandle_t)0x0) {
    xQueueGenericSend(xQueue,(void *)0x0,0,0);
  }
  if ((QueueHandle_t)*sem == (QueueHandle_t)0x0) {
    lwip_stats.sys.sem.err = lwip_stats.sys.sem.err + 1;
    eVar1 = -1;
  }
  else {
    if (CONCAT31(in_register_0000202d,count) == 0) {
      xQueueSemaphoreTake((QueueHandle_t)*sem,1);
    }
    lwip_stats.sys.sem.used = lwip_stats.sys.sem.used + 1;
    eVar1 = '\0';
    if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
      eVar1 = '\0';
      lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u32_t sys_arch_sem_wait(sys_sem_t *sem,u32_t timeout)

{
  TickType_t TVar1;
  BaseType_t BVar2;
  TickType_t TVar3;
  u32_t uVar4;
  
  TVar1 = xTaskGetTickCount();
  if (timeout == 0) {
    do {
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,0xffffffff);
    } while (BVar2 != 1);
  }
  else {
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)*sem,timeout);
    uVar4 = 0xffffffff;
    if (BVar2 != 1) goto LAB_2303a2ba;
  }
  TVar3 = xTaskGetTickCount();
  uVar4 = TVar3 - TVar1;
LAB_2303a2ba:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar4;
}



void sys_sem_free(sys_sem_t *sem)

{
  lwip_stats.sys.sem.used = lwip_stats.sys.sem.used - 1;
  vQueueDelete((QueueHandle_t)*sem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int sys_sem_valid(sys_sem_t *sem)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(*sem != (sys_sem_t)0x0);
}



void sys_sem_set_invalid(sys_sem_t *sem)

{
  *sem = (sys_sem_t)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  s_nextthread = 0;
  return;
}



err_t sys_mutex_new(sys_mutex_t *mutex)

{
  err_t eVar1;
  QueueHandle_t pQVar2;
  
  pQVar2 = xQueueCreateMutex('\x01');
  *mutex = (sys_mutex_t)pQVar2;
  if (pQVar2 == (QueueHandle_t)0x0) {
    lwip_stats.sys.mutex.err = lwip_stats.sys.mutex.err + 1;
    eVar1 = -1;
  }
  else {
    lwip_stats.sys.mutex.used = lwip_stats.sys.mutex.used + 1;
    eVar1 = '\0';
    if (lwip_stats.sys.mutex.max < lwip_stats.sys.mutex.used) {
      eVar1 = '\0';
      lwip_stats.sys.mutex.max = lwip_stats.sys.mutex.used;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void sys_mutex_lock(sys_mutex_t *mutex)

{
  sys_arch_sem_wait((sys_sem_t *)mutex,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_mutex_unlock(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_sem_signal(sys_mutex_t *mutex)

{
  xQueueGenericSend((QueueHandle_t)*mutex,(void *)0x0,0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



sys_thread_t sys_thread_new(char *name,lwip_thread_fn *thread,void *arg,int stacksize,int prio)

{
  BaseType_t BVar1;
  sys_thread_t ptStack20;
  TaskHandle_t CreatedTask;
  
  if (s_nextthread < 6) {
    BVar1 = xTaskCreate((TaskFunction_t *)thread,name,(uint16_t)stacksize,arg,prio,
                        (TaskHandle_t *)&ptStack20);
    if (BVar1 != 1) {
      ptStack20 = (sys_thread_t)0x0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ptStack20;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (sys_thread_t)0x0;
}



sys_prot_t sys_arch_protect(void)

{
  vTaskEnterCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



void sys_arch_unprotect(void)

{
  if ((xSchedulerRunning != 0) && (pxCurrentTCB->uxCriticalNesting != 0)) {
    vTaskExitCritical();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



TickType_t sys_now(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return xTickCount;
}



// WARNING: Variable defined which should be unmapped: addr

hostent * lwip_gethostbyname(char *name)

{
  err_t eVar1;
  undefined3 extraout_var;
  hostent *phVar2;
  ip_addr_t iStack20;
  ip_addr_t addr;
  
  eVar1 = netconn_gethostbyname(name,&iStack20);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    lwip_gethostbyname::s_hostent_addr = iStack20;
    lwip_gethostbyname::s_phostent_addr[0] = &lwip_gethostbyname::s_hostent_addr;
    lwip_gethostbyname::s_phostent_addr[1] = (ip_addr_t *)0x0;
    strncpy(lwip_gethostbyname::s_hostname,name,0x100);
    lwip_gethostbyname::s_aliases = (char *)0x0;
    lwip_gethostbyname::s_hostent.h_aliases = &lwip_gethostbyname::s_aliases;
    lwip_gethostbyname::s_hostent.h_addrtype = 2;
    lwip_gethostbyname::s_hostname[256] = '\0';
    lwip_gethostbyname::s_hostent.h_name = lwip_gethostbyname::s_hostname;
    lwip_gethostbyname::s_hostent.h_length = 4;
    lwip_gethostbyname::s_hostent.h_addr_list = lwip_gethostbyname::s_phostent_addr;
    phVar2 = &lwip_gethostbyname::s_hostent;
  }
  else {
    h_errno = 0xd2;
    phVar2 = (hostent *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return phVar2;
}



void lwip_freeaddrinfo(addrinfo *ai)

{
  addrinfo *paVar1;
  
  if (ai != (addrinfo *)0x0) {
    do {
      paVar1 = ai->ai_next;
      memp_free(MEMP_NETDB,ai);
      ai = paVar1;
    } while (paVar1 != (addrinfo *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: addr
// WARNING: Type propagation algorithm not settling

int lwip_getaddrinfo(char *nodename,char *servname,addrinfo *hints,addrinfo **res)

{
  err_t eVar1;
  u16_t uVar2;
  uint uVar3;
  size_t __n;
  undefined3 extraout_var;
  addrinfo *__s;
  size_t __n_00;
  int iVar4;
  ip4_addr_t iStack36;
  ip_addr_t addr;
  
  if (res == (addrinfo **)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xca;
  }
  *res = (addrinfo *)0x0;
  if (nodename == (char *)0x0) {
    if (servname == (char *)0x0) {
LAB_2303a492:
      iVar4 = 200;
      goto LAB_2303a510;
    }
    if (hints != (addrinfo *)0x0) goto LAB_2303a49a;
LAB_2303a4ac:
    uVar3 = atoi(servname);
    iVar4 = 0xc9;
    if (0xfffe < uVar3 - 1) goto LAB_2303a510;
    if (nodename == (char *)0x0) goto LAB_2303a52a;
    if (hints == (addrinfo *)0x0) {
LAB_2303a502:
      uVar2 = (u16_t)uVar3;
      eVar1 = netconn_gethostbyname(nodename,(ip_addr_t *)&iStack36);
      if (CONCAT31(extraout_var,eVar1) == 0) goto LAB_2303a4da;
    }
    else {
LAB_2303a4ca:
      uVar2 = (u16_t)uVar3;
      if ((hints->ai_flags & 4U) == 0) goto LAB_2303a502;
      iVar4 = ip4addr_aton(nodename,&iStack36);
      if (iVar4 == 0) goto LAB_2303a492;
LAB_2303a4da:
      __n = strlen(nodename);
      __n_00 = __n + 0x31;
      if (__n < 0x101) goto LAB_2303a53c;
    }
    iVar4 = 0xca;
  }
  else {
    if (hints == (addrinfo *)0x0) {
      uVar3 = 0;
      if (servname != (char *)0x0) goto LAB_2303a4ac;
      goto LAB_2303a502;
    }
LAB_2303a49a:
    iVar4 = 0xcc;
    uVar3 = hints->ai_family & 0xfffffffd;
    if (uVar3 != 0) goto LAB_2303a510;
    if (servname != (char *)0x0) goto LAB_2303a4ac;
    if (nodename != (char *)0x0) goto LAB_2303a4ca;
LAB_2303a52a:
    uVar2 = (u16_t)uVar3;
    if ((hints == (addrinfo *)0x0) || ((hints->ai_flags & 1U) == 0)) {
      iStack36 = 0x100007f;
    }
    else {
      iStack36 = 0;
    }
    __n = 0;
    __n_00 = 0x30;
LAB_2303a53c:
    __s = (addrinfo *)memp_malloc(MEMP_NETDB);
    iVar4 = 0xcb;
    if (__s != (addrinfo *)0x0) {
      memset(__s,0,__n_00);
      ((ip4_addr_t *)&__s[1].ai_family)->addr = iStack36;
      *(undefined2 *)&__s[1].ai_flags = 0x210;
      uVar2 = lwip_htons(uVar2);
      *(u16_t *)((int)&__s[1].ai_flags + 2) = uVar2;
      __s->ai_family = 2;
      if (hints != (addrinfo *)0x0) {
        __s->ai_socktype = hints->ai_socktype;
        __s->ai_protocol = hints->ai_protocol;
      }
      if (nodename != (char *)0x0) {
        __s->ai_canonname = (char *)&__s[1].ai_addrlen;
        memcpy(&__s[1].ai_addrlen,nodename,__n);
        __s->ai_canonname[__n] = '\0';
      }
      __s->ai_addrlen = 0x10;
      __s->ai_addr = (sockaddr *)(__s + 1);
      *res = __s;
      iVar4 = 0;
    }
  }
LAB_2303a510:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



err_t netifapi_do_netif_add(tcpip_api_call_data *m)

{
  err_t eVar1;
  netif *pnVar2;
  
  pnVar2 = netif_add(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                     (ip4_addr_t *)m[2].sem,*(void **)(m + 3),(netif_init_fn_conflict *)m[3].sem,
                     *(netif_input_fn **)(m + 4));
  if (pnVar2 == (netif *)0x0) {
    eVar1 = -0xc;
  }
  else {
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netifapi_do_netif_set_addr(tcpip_api_call_data *m)

{
  netif_set_addr(*(netif **)(m + 1),(ip4_addr_t *)m[1].sem,*(ip4_addr_t **)(m + 2),
                 (ip4_addr_t *)m[2].sem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t netifapi_do_netif_common(tcpip_api_call_data *m)

{
  err_t eVar1;
  
  if (*(code **)(m + 2) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303a5f4. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)(m + 2))();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  (*(code *)m[1].sem)(*(undefined4 *)(m + 1),m[1].sem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t netifapi_netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,
                        void *state,netif_init_fn init,netif_input_fn *input)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  msg.msg._8_4_ = state;
  msg.msg._12_4_ = init;
  msg.msg._16_4_ = input;
  eVar1 = tcpip_api_call(netifapi_do_netif_add,(tcpip_api_call_data *)auStack52);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netifapi_netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)ipaddr;
  msg.msg._0_4_ = netmask;
  msg.msg._4_4_ = gw;
  eVar1 = tcpip_api_call(netifapi_do_netif_set_addr,(tcpip_api_call_data *)auStack52);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netifapi_netif_common(netif *netif,netifapi_void_fn voidfunc,netifapi_errt_fn errtfunc)

{
  err_t eVar1;
  undefined auStack52 [4];
  netifapi_msg msg;
  
  msg.call.sem = (sys_sem_t)netif;
  msg.netif = (netif *)voidfunc;
  msg.msg._0_4_ = errtfunc;
  eVar1 = tcpip_api_call(netifapi_do_netif_common,(tcpip_api_call_data *)auStack52);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



int alloc_socket(netconn *newconn,int accepted)

{
  int iVar1;
  u16_t uVar2;
  lwip_sock *plVar3;
  
  uVar2 = (u16_t)accepted;
  plVar3 = sockets;
  iVar1 = 0;
  do {
    sys_arch_protect();
    if (plVar3->conn == (netconn *)0x0) {
      sockets[iVar1].conn = newconn;
      sys_arch_unprotect();
      sockets[iVar1].lastdata = 0;
      sockets[iVar1].rcvevent = 0;
      if ((newconn->type & 0xf0) != NETCONN_TCP) {
        uVar2 = 1;
      }
      sockets[iVar1].sendevent = uVar2;
      sockets[iVar1].errevent = 0;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    iVar1 = iVar1 + 1;
    sys_arch_unprotect();
    plVar3 = plVar3 + 1;
  } while (iVar1 != 0x15);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void lwip_link_select_cb(lwip_select_cb *select_cb)

{
  sys_arch_protect();
  select_cb->next = select_cb_list;
  if (select_cb_list != (lwip_select_cb *)0x0) {
    select_cb_list->prev = select_cb;
  }
  select_cb_ctr = select_cb_ctr + 1;
  select_cb_list = select_cb;
  sys_arch_unprotect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_unlink_select_cb(lwip_select_cb *select_cb)

{
  lwip_select_cb **pplVar1;
  
  sys_arch_protect();
  if (select_cb->next != (lwip_select_cb *)0x0) {
    select_cb->next->prev = select_cb->prev;
  }
  pplVar1 = &select_cb_list;
  if (select_cb_list != select_cb) {
    pplVar1 = (lwip_select_cb **)select_cb->prev;
  }
  *pplVar1 = select_cb->next;
  select_cb_ctr = select_cb_ctr + 1;
  sys_arch_unprotect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int lwip_selscan(int maxfdp1,_types_fd_set *readset_in,_types_fd_set *writeset_in,
                _types_fd_set *exceptset_in,_types_fd_set *readset_out,_types_fd_set *writeset_out,
                _types_fd_set *exceptset_out)

{
  short sVar1;
  u16_t uVar2;
  u16_t uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  lwip_sock *plVar8;
  s16_t rcvevent;
  uint local_58;
  _types_fd_set lreadset;
  _types_fd_set lwriteset;
  _types_fd_set lexceptset;
  
  iVar6 = 0;
  do {
    *(undefined *)((int)&local_58 + iVar6) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  iVar6 = 0;
  do {
    *(undefined *)((int)lreadset.fds_bits + iVar6 + 4) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  iVar6 = 0;
  do {
    *(undefined *)((int)lwriteset.fds_bits + iVar6 + 4) = 0;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 8);
  plVar8 = sockets;
  iVar6 = 0;
  uVar4 = 0;
  do {
    if (maxfdp1 <= (int)uVar4) {
      readset_out->fds_bits[0] = local_58;
      readset_out->fds_bits[1] = lreadset.fds_bits[0];
      writeset_out->fds_bits[0] = lreadset.fds_bits[1];
      writeset_out->fds_bits[1] = lwriteset.fds_bits[0];
      exceptset_out->fds_bits[0] = lwriteset.fds_bits[1];
      exceptset_out->fds_bits[1] = lexceptset.fds_bits[0];
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar6;
    }
    if ((((readset_in != (_types_fd_set *)0x0) &&
         ((1 << (uVar4 & 0x1f) & readset_in->fds_bits[uVar4 >> 5]) != 0)) ||
        ((writeset_in != (_types_fd_set *)0x0 &&
         ((1 << (uVar4 & 0x1f) & writeset_in->fds_bits[uVar4 >> 5]) != 0)))) ||
       ((exceptset_in != (_types_fd_set *)0x0 &&
        ((1 << (uVar4 & 0x1f) & exceptset_in->fds_bits[uVar4 >> 5]) != 0)))) {
      sys_arch_protect();
      if (0x14 < uVar4) {
        sys_arch_unprotect();
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -1;
      }
      uVar2 = plVar8->sendevent;
      uVar3 = plVar8->errevent;
      iVar7 = plVar8->lastdata;
      sVar1 = plVar8->rcvevent;
      sys_arch_unprotect();
      if (((readset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (readset_in->fds_bits[0] & uVar5) != 0)) &&
         ((iVar7 != 0 || (0 < sVar1)))) {
        iVar6 = iVar6 + 1;
        local_58 = local_58 | uVar5;
      }
      if (((writeset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (writeset_in->fds_bits[0] & uVar5) != 0)) && (uVar2 != 0)) {
        iVar6 = iVar6 + 1;
        lreadset.fds_bits[1] = lreadset.fds_bits[1] | uVar5;
      }
      if (((exceptset_in != (_types_fd_set *)0x0) &&
          (uVar5 = 1 << (uVar4 & 0x1f), (exceptset_in->fds_bits[0] & uVar5) != 0)) && (uVar3 != 0))
      {
        iVar6 = iVar6 + 1;
        lwriteset.fds_bits[1] = lwriteset.fds_bits[1] | uVar5;
      }
    }
    uVar4 = uVar4 + 1;
    plVar8 = plVar8 + 1;
  } while( true );
}



ssize_t lwip_recv_tcp(lwip_sock *sock,void *mem,size_t len,int flags)

{
  size_t len_00;
  err_t err;
  pbuf *ppVar1;
  undefined3 extraout_var;
  int iVar2;
  void *dataptr;
  u8_t apiflags;
  uint uVar3;
  pbuf *ppStack52;
  pbuf *p;
  
  if ((int)len < 0) {
    len = 0x7fffffff;
  }
  apiflags = '\b';
  if ((flags & 8U) != 0) {
    apiflags = '\f';
  }
  len_00 = 0;
  do {
    ppVar1 = (pbuf *)sock->lastdata;
    if ((pbuf *)sock->lastdata == (pbuf *)0x0) {
      err = netconn_recv_tcp_pbuf_flags(sock->conn,&ppStack52,apiflags);
      if (CONCAT31(extraout_var,err) != 0) {
        if (len_00 == 0) {
          iVar2 = err_to_errno(err);
          if (iVar2 != 0) {
            errno = iVar2;
          }
          len_00 = -(uint)(CONCAT31(extraout_var,err) != -0xf);
        }
        else {
          if ((flags & 1U) == 0) goto LAB_2303a9bc;
        }
        goto LAB_2303a9e0;
      }
      sock->lastdata = ppStack52;
      ppVar1 = ppStack52;
    }
    ppStack52 = ppVar1;
    uVar3 = (uint)ppStack52->tot_len;
    if ((int)len <= (int)uVar3) {
      uVar3 = len & 0xffff;
    }
    dataptr = (void *)((int)mem + len_00);
    len_00 = uVar3 + len_00;
    pbuf_copy_partial(ppStack52,dataptr,(u16_t)uVar3,0);
    if ((flags & 1U) != 0) {
      if (len_00 != 0) goto LAB_2303a9e0;
      goto LAB_2303aa2c;
    }
    if ((int)(ppStack52->tot_len - uVar3) < 1) {
      sock->lastdata = 0;
      pbuf_free(ppStack52);
    }
    else {
      ppVar1 = pbuf_free_header(ppStack52,(u16_t)uVar3);
      sock->lastdata = ppVar1;
    }
    len = len - uVar3;
    apiflags = '\x1c';
  } while (0 < (int)len);
  if (len_00 == 0) {
LAB_2303aa2c:
    len_00 = 0;
  }
  else {
LAB_2303a9bc:
    netconn_tcp_recvd(sock->conn,len_00);
  }
LAB_2303a9e0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return len_00;
}



// WARNING: Could not reconcile some variable overlaps

int lwip_sock_make_addr(u16_t port,sockaddr *from,socklen_t *fromlen)

{
  int iVar1;
  undefined2 in_register_0000202a;
  size_t *in_a3;
  uint uVar2;
  undefined2 uStack32;
  u16_t uStack30;
  sockaddr_aligned saddr;
  
  uStack32 = 0x210;
  uStack30 = lwip_htons((u16_t)from);
  saddr._0_4_ = *(undefined4 *)CONCAT22(in_register_0000202a,port);
  memset((void *)&saddr.field_0x4,0,8);
  uVar2 = (uint)(byte)uStack32;
  iVar1 = 1;
  if ((uVar2 <= *in_a3) && (iVar1 = 0, uVar2 < *in_a3)) {
    *in_a3 = uVar2;
  }
  memcpy(fromlen,&uStack32,*in_a3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void free_socket(lwip_sock *sock,int is_tcp)

{
  netbuf *buf;
  netconn *conn;
  
  sys_arch_protect();
  buf = (netbuf *)sock->lastdata;
  conn = sock->conn;
  sock->lastdata = 0;
  sock->conn = (netconn *)0x0;
  sys_arch_unprotect();
  if (buf != (netbuf *)0x0) {
    if (is_tcp == 0) {
      netbuf_delete(buf);
    }
    else {
      pbuf_free((pbuf *)buf);
    }
  }
  if (conn != (netconn *)0x0) {
    netconn_delete(conn);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t lwip_recvfrom_udp_raw(lwip_sock *sock,int flags,msghdr *msg,u16_t *datagram_len)

{
  ushort uVar1;
  uint uVar2;
  err_t eVar3;
  int iVar4;
  undefined3 extraout_var;
  uint uVar5;
  uint uVar6;
  netbuf *pnStack52;
  netbuf *buf;
  
  if ((msg->msg_iov != (iovec *)0x0) || (iVar4 = -0x10, msg->msg_iovlen < 1)) {
    pnStack52 = (netbuf *)sock->lastdata;
    if (pnStack52 == (netbuf *)0x0) {
      eVar3 = netconn_recv_udp_raw_netbuf_flags(sock->conn,&pnStack52,((flags & 8U) != 0) << 2);
      iVar4 = CONCAT31(extraout_var,eVar3);
      if (iVar4 != 0) goto LAB_2303ab7e;
      sock->lastdata = pnStack52;
    }
    iVar4 = 0;
    uVar2 = 0;
    uVar1 = pnStack52->p->tot_len;
    while ((iVar4 < msg->msg_iovlen && (uVar2 < uVar1))) {
      uVar5 = msg->msg_iov[iVar4].iov_len;
      uVar6 = uVar1 - uVar2 & 0xffff;
      if (uVar5 <= uVar6) {
        uVar6 = uVar5 & 0xffff;
      }
      pbuf_copy_partial(pnStack52->p,msg->msg_iov[iVar4].iov_base,(u16_t)uVar6,(u16_t)uVar2);
      uVar2 = uVar2 + uVar6 & 0xffff;
      iVar4 = iVar4 + 1;
    }
    if (((socklen_t *)msg->msg_name != (socklen_t *)0x0) && (msg->msg_namelen != 0)) {
      lwip_sock_make_addr((short)pnStack52 + 8,(sockaddr *)(uint)pnStack52->port,
                          (socklen_t *)msg->msg_name);
    }
    msg->msg_flags = 0;
    if (msg->msg_control != (void *)0x0) {
      msg->msg_controllen = 0;
    }
    if ((flags & 1U) == 0) {
      sock->lastdata = 0;
      netbuf_delete(pnStack52);
    }
    *datagram_len = uVar1;
    iVar4 = 0;
  }
LAB_2303ab7e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar4;
}



lwip_sock * get_socket(int fd)

{
  lwip_sock *plVar1;
  
  if ((0x14 < (uint)fd) || (plVar1 = sockets + fd, plVar1->conn == (netconn *)0x0)) {
    errno = 9;
    plVar1 = (lwip_sock *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return plVar1;
}



// WARNING: Type propagation algorithm not settling

void lwip_setsockopt_callback(void *arg)

{
  ip4_addr_t iVar1;
  err_t eVar2;
  ip4_addr_t *name;
  sys_mutex_t mutex;
  lwip_sock *plVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  netif *netif;
  netconn *pnVar4;
  int iVar5;
  lwip_socket_multicast_pair *plVar6;
  uint uVar7;
  byte bVar8;
  netconn_type nVar9;
  int iVar10;
  u32_t uVar11;
  uint fd;
  ip4_addr_t iStack40;
  ip4_addr_t if_addr;
  ip4_addr_t multi_addr;
  
                    // WARNING: Load size is inaccurate
  fd = *arg;
  iVar1 = (ip4_addr_t)((ip4_addr_t *)((int)arg + 4))->addr;
  iVar10 = *(int *)((int)arg + 8);
  uVar7 = *(uint *)((int)arg + 0x10);
  name = *(ip4_addr_t **)((int)arg + 0xc);
  if ((0x14 < fd) || (pnVar4 = sockets[fd].conn, pnVar4 == (netconn *)0x0)) {
    iVar1 = (ip4_addr_t)0x9;
    goto LAB_2303ac7e;
  }
  if (iVar1 == (ip4_addr_t)0x6) {
    iVar1 = (ip4_addr_t)0x16;
    if ((((uVar7 < 4) || (iVar5 = pnVar4->pcb, iVar5 == 0)) ||
        (iVar1 = (ip4_addr_t)0x5c, (pnVar4->type & 0xf0) != NETCONN_TCP)) ||
       ((iVar1 = (ip4_addr_t)0x16, *(char *)(iVar5 + 0x14) == '\x01' ||
        (iVar1 = (ip4_addr_t)0x5c, 4 < iVar10 - 1U)))) goto LAB_2303ac7e;
    iVar1 = (ip4_addr_t)name->addr;
    switch(iVar10) {
    case 1:
      if (iVar1 == (ip4_addr_t)0x0) {
        *(ushort *)(iVar5 + 0x1a) = *(ushort *)(iVar5 + 0x1a) & 0xffbf;
        goto LAB_2303ac7e;
      }
      *(ushort *)(iVar5 + 0x1a) = *(ushort *)(iVar5 + 0x1a) | 0x40;
      break;
    case 3:
      iVar1 = (ip4_addr_t)((int)iVar1 * 1000);
    case 2:
      ((ip4_addr_t *)(iVar5 + 0x94))->addr = (u32_t)iVar1;
      break;
    case 4:
      *(int *)(iVar5 + 0x98) = (int)iVar1 * 1000;
      break;
    case 5:
      ((ip4_addr_t *)(iVar5 + 0x9c))->addr = (u32_t)iVar1;
    }
LAB_2303acfa:
    iVar1 = (ip4_addr_t)0x0;
    goto LAB_2303ac7e;
  }
  if (iVar1 == (ip4_addr_t)0xfff) {
    if (iVar10 == 0x1005) {
      iVar1 = (ip4_addr_t)0x16;
      if ((uVar7 < 0x10) || (iVar10 = name->addr * 1000 + *(int *)(name + 2) / 1000, iVar10 < 0))
      goto LAB_2303ac7e;
      pnVar4->send_timeout = iVar10;
    }
    else {
      if (iVar10 < 0x1006) {
        if (((iVar10 != 8) && (iVar10 != 0x20)) && (iVar10 != 4)) goto switchD_2303add6_caseD_7;
        if (iVar10 == 0x20) {
          iVar1 = (ip4_addr_t)0x5c;
          if ((pnVar4->type & 0xf0) != NETCONN_UDP) goto LAB_2303ac7e;
        }
        else {
          if ((iVar10 != 4) && (iVar10 != 8)) {
            iVar10 = 0;
          }
        }
        iVar1 = (ip4_addr_t)0x16;
        if ((uVar7 < 4) || (iVar5 = pnVar4->pcb, iVar1 = (ip4_addr_t)0x16, iVar5 == 0))
        goto LAB_2303ac7e;
        iVar1 = (ip4_addr_t)name->addr;
        if (iVar1 == (ip4_addr_t)0x0) {
          *(byte *)(iVar5 + 9) = *(byte *)(iVar5 + 9) & ~(byte)iVar10;
          goto LAB_2303ac7e;
        }
        *(byte *)(iVar5 + 9) = *(byte *)(iVar5 + 9) | (byte)iVar10;
      }
      else {
        if (iVar10 == 0x100a) {
          iVar1 = (ip4_addr_t)0x16;
          if (((uVar7 < 4) || (iVar10 = pnVar4->pcb, iVar10 == 0)) ||
             (iVar1 = (ip4_addr_t)0x5c, (pnVar4->type & 0xf0) != NETCONN_UDP)) goto LAB_2303ac7e;
          iVar1 = (ip4_addr_t)name->addr;
          if (iVar1 == (ip4_addr_t)0x0) {
            bVar8 = *(byte *)(iVar10 + 0x10) & 0xfe;
            goto LAB_2303ad60;
          }
          *(byte *)(iVar10 + 0x10) = *(byte *)(iVar10 + 0x10) | 1;
        }
        else {
          if (iVar10 == 0x100b) {
            iVar1 = (ip4_addr_t)0x16;
            if (uVar7 < 6) goto LAB_2303ac7e;
            netif = (netif *)0x0;
            if (*(char *)&name->addr != '\0') {
              netif = netif_find((char *)name);
              iVar1 = (ip4_addr_t)0x13;
              if (netif == (netif *)0x0) goto LAB_2303ac7e;
            }
            pnVar4 = sockets[fd].conn;
            nVar9 = pnVar4->type & 0xf0;
            if (nVar9 == NETCONN_UDP) {
              udp_bind_netif((udp_pcb *)pnVar4->pcb,netif);
            }
            else {
              if (nVar9 != NETCONN_RAW) {
                iVar1 = (ip4_addr_t)0x0;
                if (nVar9 == NETCONN_TCP) {
                  tcp_bind_netif((tcp_pcb *)pnVar4->pcb,netif);
                }
                goto LAB_2303ac7e;
              }
              raw_bind_netif((raw_pcb *)pnVar4->pcb,netif);
            }
          }
          else {
            if (iVar10 != 0x1006) goto switchD_2303add6_caseD_7;
            iVar1 = (ip4_addr_t)0x16;
            if ((uVar7 < 0x10) ||
               (uVar11 = name->addr * 1000 + *(int *)(name + 2) / 1000, (int)uVar11 < 0))
            goto LAB_2303ac7e;
            pnVar4->recv_timeout = uVar11;
          }
        }
      }
    }
    goto LAB_2303acfa;
  }
  if (iVar1 != (ip4_addr_t)0x0) goto switchD_2303add6_caseD_7;
  switch(iVar10) {
  case 1:
    if ((3 < uVar7) && (pnVar4->pcb != 0)) {
      *(char *)(pnVar4->pcb + 10) = (char)name->addr;
      goto LAB_2303ac7e;
    }
    goto LAB_2303afd4;
  case 2:
    if ((3 < uVar7) && (pnVar4->pcb != 0)) {
      *(char *)(pnVar4->pcb + 0xb) = (char)name->addr;
      goto LAB_2303ac7e;
    }
LAB_2303afd4:
    iVar1 = (ip4_addr_t)0x16;
    goto LAB_2303ac7e;
  case 3:
  case 4:
    if ((uVar7 < 8) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      iStack40 = name[1].addr;
      if_addr = name->addr;
      if (iVar10 == 3) {
        plVar3 = get_socket(fd);
        if (plVar3 != (lwip_sock *)0x0) {
          plVar6 = socket_ipv4_multicast_memberships;
          iVar10 = 0;
          do {
            if (plVar6->sock == (lwip_sock *)0x0) {
              socket_ipv4_multicast_memberships[iVar10].sock = plVar3;
              socket_ipv4_multicast_memberships[iVar10].if_addr.addr = iStack40;
              socket_ipv4_multicast_memberships[iVar10].multi_addr.addr = if_addr;
              eVar2 = igmp_joingroup(&iStack40,&if_addr);
              iVar10 = CONCAT31(extraout_var,eVar2);
              goto LAB_2303aed6;
            }
            iVar10 = iVar10 + 1;
            plVar6 = plVar6 + 1;
          } while (iVar10 != 0x15);
        }
        iVar1 = (ip4_addr_t)0xc;
      }
      else {
        eVar2 = igmp_leavegroup(&iStack40,&if_addr);
        iVar10 = CONCAT31(extraout_var_00,eVar2);
        plVar3 = get_socket(fd);
        if (plVar3 != (lwip_sock *)0x0) {
          plVar6 = socket_ipv4_multicast_memberships;
          iVar5 = 0;
          do {
            if (((plVar3 == plVar6->sock) && ((plVar6->if_addr).addr == iStack40)) &&
               ((plVar6->multi_addr).addr == if_addr)) {
              socket_ipv4_multicast_memberships[iVar5].sock = (lwip_sock *)0x0;
              socket_ipv4_multicast_memberships[iVar5].if_addr.addr = 0;
              socket_ipv4_multicast_memberships[iVar5].multi_addr.addr = 0;
              break;
            }
            iVar5 = iVar5 + 1;
            plVar6 = plVar6 + 1;
          } while (iVar5 != 0x15);
        }
LAB_2303aed6:
        if (iVar10 != 0) {
          iVar1 = (ip4_addr_t)0x63;
        }
      }
      goto LAB_2303ac7e;
    }
    break;
  case 5:
    if ((uVar7 == 0) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      *(undefined *)(pnVar4->pcb + 0x1d) = *(undefined *)&name->addr;
      goto LAB_2303ac7e;
    }
    break;
  case 6:
    if ((uVar7 < 4) || (pnVar4->pcb == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      ((ip4_addr_t *)(pnVar4->pcb + 0x18))->addr = name->addr;
      goto LAB_2303ac7e;
    }
    break;
  case 7:
    if ((uVar7 == 0) || (iVar10 = pnVar4->pcb, iVar10 == 0)) goto LAB_2303afd4;
    if ((pnVar4->type & 0xf0) == NETCONN_UDP) {
      if (*(char *)&name->addr == '\0') {
        bVar8 = *(byte *)(iVar10 + 0x10) & 0xf7;
      }
      else {
        bVar8 = *(byte *)(iVar10 + 0x10) | 8;
      }
LAB_2303ad60:
      *(byte *)(iVar10 + 0x10) = bVar8;
      goto LAB_2303ac7e;
    }
  }
switchD_2303add6_caseD_7:
  iVar1 = (ip4_addr_t)0x5c;
LAB_2303ac7e:
  mutex = *(sys_mutex_t *)((int)arg + 0x18);
  ((ip4_addr_t *)((int)arg + 0x14))->addr = (u32_t)iVar1;
  sys_sem_signal((sys_mutex_t *)mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void event_callback(netconn *conn,netconn_evt evt,u16_t len)

{
  short sVar1;
  u16_t uVar2;
  u16_t uVar3;
  bool bVar4;
  lwip_select_cb *plVar5;
  lwip_select_cb *plVar6;
  uint fd;
  lwip_sock *plVar7;
  undefined3 in_register_0000202d;
  nfds_t nVar8;
  int iVar9;
  ushort *puVar10;
  uint uVar11;
  uint uVar12;
  
  if (conn == (netconn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  fd = conn->socket;
  if ((int)fd < 0) {
    sys_arch_protect();
    fd = conn->socket;
    if ((int)fd < 0) {
      if (CONCAT31(in_register_0000202d,evt) == 0) {
        conn->socket = fd - 1;
      }
      goto LAB_2303b018;
    }
    sys_arch_unprotect();
  }
  plVar7 = get_socket(fd);
  if (plVar7 == (lwip_sock *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  sys_arch_protect();
  bVar4 = true;
  switch(CONCAT31(in_register_0000202d,evt)) {
  case 0:
    iVar9 = ((ushort)plVar7->rcvevent + 1) * 0x10000;
    plVar7->rcvevent = (s16_t)((uint)iVar9 >> 0x10);
    bVar4 = iVar9 >> 0x10 < 2;
    break;
  case 1:
    plVar7->rcvevent = plVar7->rcvevent + -1;
    goto LAB_2303b0cc;
  case 2:
    uVar2 = plVar7->sendevent;
    plVar7->sendevent = 1;
    bVar4 = uVar2 == 0;
    break;
  case 3:
    plVar7->sendevent = 0;
LAB_2303b0cc:
    bVar4 = false;
    break;
  case 4:
    bVar4 = true;
    plVar7->errevent = 1;
  }
  if ((plVar7->select_waiting != '\0') && (bVar4)) {
    sVar1 = plVar7->rcvevent;
    uVar2 = plVar7->sendevent;
    uVar3 = plVar7->errevent;
    sys_arch_unprotect();
    sys_arch_protect();
    uVar11 = fd >> 5;
    uVar12 = 1 << (fd & 0x1f);
    plVar5 = select_cb_list;
    while (plVar6 = plVar5, iVar9 = select_cb_ctr, plVar6 != (lwip_select_cb *)0x0) {
      if (plVar6->sem_signalled == 0) {
        if (plVar6->poll_fds == (pollfd *)0x0) {
          if (((((0 < sVar1) && (plVar6->readset != (_types_fd_set *)0x0)) &&
               ((uVar12 & plVar6->readset->fds_bits[uVar11]) != 0)) ||
              (((uVar2 != 0 && (plVar6->writeset != (_types_fd_set *)0x0)) &&
               ((uVar12 & plVar6->writeset->fds_bits[uVar11]) != 0)))) ||
             (((uVar3 != 0 && (plVar6->exceptset != (_types_fd_set *)0x0)) &&
              ((uVar12 & plVar6->exceptset->fds_bits[uVar11]) != 0)))) {
LAB_2303b17c:
            plVar6->sem_signalled = 1;
            sys_sem_signal((sys_mutex_t *)&plVar6->sem);
          }
        }
        else {
          puVar10 = (ushort *)&plVar6->poll_fds->events;
          nVar8 = 0;
          while (nVar8 != plVar6->poll_nfds) {
            if ((fd == *(uint *)(puVar10 + -2)) &&
               ((((0 < sVar1 && ((*puVar10 & 1) != 0)) || ((uVar2 != 0 && ((*puVar10 & 2) != 0))))
                || (uVar3 != 0)))) goto LAB_2303b17c;
            nVar8 = nVar8 + 1;
            puVar10 = puVar10 + 4;
          }
        }
      }
      sys_arch_unprotect();
      sys_arch_protect();
      plVar5 = select_cb_list;
      if (select_cb_ctr == iVar9) {
        plVar5 = plVar6->next;
      }
    }
  }
LAB_2303b018:
  sys_arch_unprotect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int lwip_accept(int s,sockaddr *addr,socklen_t *addrlen)

{
  int iVar1;
  err_t eVar2;
  lwip_sock *plVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar4;
  u16_t uStack58;
  u16_t port;
  netconn *pnStack56;
  netconn *newconn;
  ip_addr_t naddr;
  sockaddr_aligned tempaddr;
  
  uStack58 = 0;
  plVar3 = get_socket(s);
  if (plVar3 != (lwip_sock *)0x0) {
    eVar2 = netconn_accept(plVar3->conn,(netconn **)&stack0xffffffc8);
    iVar4 = CONCAT31(extraout_var,eVar2);
    if (iVar4 == 0) {
      iVar1 = alloc_socket(pnStack56,1);
      if (iVar1 == -1) {
        netconn_delete(pnStack56);
        errno = 0x17;
        goto LAB_2303b1ca;
      }
      sys_arch_protect();
      iVar4 = pnStack56->socket;
      pnStack56->socket = iVar1;
      sys_arch_unprotect();
      if (pnStack56->callback != (netconn_callback *)0x0) {
        iVar4 = (int)(short)~(ushort)iVar4;
        while (0 < iVar4) {
          iVar4 = iVar4 + -1;
          (*pnStack56->callback)(pnStack56,NETCONN_EVT_RCVPLUS,0);
        }
      }
      if ((addr == (sockaddr *)0x0) || (addrlen == (socklen_t *)0x0)) goto LAB_2303b1ca;
      eVar2 = netconn_getaddr(pnStack56,(ip_addr_t *)&newconn,&uStack58,'\0');
      iVar4 = CONCAT31(extraout_var_00,eVar2);
      if (iVar4 == 0) {
        naddr.addr._0_2_ = 0x210;
        naddr.addr._2_2_ = lwip_htons(uStack58);
        tempaddr._0_4_ = (ip_addr_t)newconn;
        memset((void *)&tempaddr.field_0x4,0,8);
        if ((uint)(byte)naddr.addr < *addrlen) {
          *addrlen = (uint)(byte)naddr.addr;
        }
        memcpy(addr,&naddr,*addrlen);
        goto LAB_2303b1ca;
      }
      netconn_delete(pnStack56);
      free_socket(sockets + iVar1,1);
LAB_2303b27e:
      iVar4 = err_to_errno((err_t)iVar4);
      if (iVar4 != 0) {
        errno = iVar4;
      }
    }
    else {
      if ((plVar3->conn->type & 0xf0) == NETCONN_TCP) {
        if (iVar4 != -0xf) goto LAB_2303b27e;
        errno = 0x16;
      }
      else {
        errno = 0x5f;
      }
    }
  }
  iVar1 = -1;
LAB_2303b1ca:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Type propagation algorithm not settling

int lwip_bind(int s,sockaddr *name,socklen_t namelen)

{
  err_t eVar1;
  u16_t port;
  lwip_sock *plVar2;
  int iVar3;
  undefined3 extraout_var;
  ip_addr_t iStack20;
  ip_addr_t local_addr;
  
  plVar2 = get_socket(s);
  if (plVar2 != (lwip_sock *)0x0) {
    if (((namelen == 0x10) && (name->sa_family == '\x02')) && (((uint)name & 3) == 0)) {
      iStack20 = ((ip_addr_t *)(name->sa_data + 2))->addr;
      port = lwip_htons(*(u16_t *)name->sa_data);
      eVar1 = netconn_bind(plVar2->conn,&iStack20,port);
      iVar3 = CONCAT31(extraout_var,eVar1);
      if (iVar3 == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    else {
      iVar3 = -0x10;
    }
    iVar3 = err_to_errno((err_t)iVar3);
    if (iVar3 != 0) {
      errno = iVar3;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Type propagation algorithm not settling

int lwip_close(int s)

{
  lwip_socket_multicast_pair *plVar1;
  uint is_tcp;
  err_t err;
  lwip_sock *sock;
  netconn *pnVar2;
  undefined3 extraout_var;
  int iVar3;
  ip_addr_t iStack40;
  ip_addr_t multi_addr;
  ip_addr_t if_addr;
  
  sock = get_socket(s);
  if (sock != (lwip_sock *)0x0) {
    is_tcp = 0;
    if (sock->conn != (netconn *)0x0) {
      is_tcp = (uint)((sock->conn->type & 0xf0) == NETCONN_TCP);
    }
    pnVar2 = (netconn *)get_socket(s);
    if (pnVar2 != (netconn *)0x0) {
      plVar1 = socket_ipv4_multicast_memberships;
      do {
        if (pnVar2 == ((lwip_sock *)plVar1)->conn) {
          iStack40 = ((ip_addr_t *)&((lwip_sock *)plVar1)->rcvevent)->addr;
          ((lwip_sock *)plVar1)->conn = (netconn *)0x0;
          *(undefined4 *)&((lwip_sock *)plVar1)->rcvevent = 0;
          multi_addr = ((ip_addr_t *)&((lwip_sock *)plVar1)->lastdata)->addr;
          ((lwip_sock *)plVar1)->lastdata = 0;
          netconn_join_leave_group(*(netconn **)&pnVar2->type,&iStack40,&multi_addr,NETCONN_LEAVE);
        }
        plVar1 = (lwip_socket_multicast_pair *)((int)plVar1 + 0xc);
      } while ((lwip_sock *)plVar1 != sockets);
    }
    err = netconn_prepare_delete(sock->conn);
    if (CONCAT31(extraout_var,err) == 0) {
      free_socket(sock,is_tcp);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar3 = err_to_errno(err);
    if (iVar3 != 0) {
      errno = iVar3;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Type propagation algorithm not settling

int lwip_connect(int s,sockaddr *name,socklen_t namelen)

{
  err_t eVar1;
  u16_t port;
  lwip_sock *plVar2;
  undefined3 extraout_var;
  int iVar3;
  undefined3 extraout_var_00;
  ip_addr_t iStack20;
  ip_addr_t remote_addr;
  
  plVar2 = get_socket(s);
  if (plVar2 == (lwip_sock *)0x0) goto LAB_2303b40a;
  if (name->sa_family == '\0') {
    eVar1 = netconn_disconnect(plVar2->conn);
    iVar3 = CONCAT31(extraout_var,eVar1);
LAB_2303b41c:
    if (iVar3 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  else {
    if (((namelen == 0x10) && (name->sa_family == '\x02')) && (((uint)name & 3) == 0)) {
      iStack20 = ((ip_addr_t *)(name->sa_data + 2))->addr;
      port = lwip_htons(*(u16_t *)name->sa_data);
      eVar1 = netconn_connect(plVar2->conn,&iStack20,port);
      iVar3 = CONCAT31(extraout_var_00,eVar1);
      goto LAB_2303b41c;
    }
    iVar3 = -0x10;
  }
  iVar3 = err_to_errno((err_t)iVar3);
  if (iVar3 != 0) {
    errno = iVar3;
  }
LAB_2303b40a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int lwip_listen(int s,int backlog)

{
  err_t err;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  int iVar2;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if (backlog < 0) {
      backlog = 0;
    }
    if (0xff < backlog) {
      backlog = 0xff;
    }
    err = netconn_listen_with_backlog(plVar1->conn,(u8_t)backlog);
    if (CONCAT31(extraout_var,err) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if ((plVar1->conn->type & 0xf0) == NETCONN_TCP) {
      iVar2 = err_to_errno(err);
      if (iVar2 != 0) {
        errno = iVar2;
      }
    }
    else {
      errno = 0x5f;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Could not reconcile some variable overlaps

ssize_t lwip_recvfrom(int s,void *mem,size_t len,int flags,sockaddr *from,socklen_t *fromlen)

{
  err_t err;
  lwip_sock *sock;
  uint uVar1;
  undefined3 extraout_var;
  int iVar2;
  socklen_t sVar3;
  ushort uStack70;
  u16_t datagram_len;
  void *pvStack68;
  iovec vec;
  msghdr msg;
  
  sock = get_socket(s);
  if (sock != (lwip_sock *)0x0) {
    if ((sock->conn->type & 0xf0) == NETCONN_TCP) {
      uVar1 = lwip_recv_tcp(sock,mem,len,flags);
      if (from == (sockaddr *)0x0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar1;
      }
      if (fromlen == (socklen_t *)0x0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar1;
      }
      netconn_getaddr(sock->conn,(ip_addr_t *)&vec.iov_len,(u16_t *)&stack0xffffffbc,'\0');
      lwip_sock_make_addr((short)register0x00002008 - 0x3c,(sockaddr *)((uint)pvStack68 & 0xffff),
                          (socklen_t *)from);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar1;
    }
    uStack70 = 0;
    sVar3 = 0;
    if (fromlen != (socklen_t *)0x0) {
      sVar3 = *fromlen;
    }
    pvStack68 = mem;
    vec.iov_base = (void *)len;
    vec.iov_len = (size_t)from;
    err = lwip_recvfrom_udp_raw(sock,flags,(msghdr *)&vec.iov_len,&uStack70);
    if (CONCAT31(extraout_var,err) == 0) {
      uVar1 = (uint)uStack70;
      if (len < uStack70) {
        uVar1 = len;
      }
      if (fromlen == (socklen_t *)0x0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar1;
      }
      *fromlen = sVar3;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar1;
    }
    iVar2 = err_to_errno(err);
    if (iVar2 != 0) {
      errno = iVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xffffffff;
}



ssize_t lwip_read(int s,void *mem,size_t len)

{
  ssize_t sVar1;
  
  sVar1 = lwip_recvfrom(s,mem,len,0,(sockaddr *)0x0,(socklen_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



ssize_t lwip_recv(int s,void *mem,size_t len,int flags)

{
  ssize_t sVar1;
  
  sVar1 = lwip_recvfrom(s,mem,len,flags,(sockaddr *)0x0,(socklen_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



ssize_t lwip_sendto(int s,void *data,size_t size,int flags,sockaddr *to,socklen_t tolen)

{
  err_t eVar1;
  lwip_sock *plVar2;
  int iVar3;
  void *pvVar4;
  undefined3 extraout_var;
  int iVar5;
  undefined auStack52 [4];
  netbuf buf;
  
  plVar2 = get_socket(s);
  if (plVar2 != (lwip_sock *)0x0) {
    if ((plVar2->conn->type & 0xf0) == NETCONN_TCP) {
      size = lwip_send(s,data,size,flags);
      goto LAB_2303b5ec;
    }
    if (0xffff < size) {
      errno = 0x5a;
      goto LAB_2303b5ce;
    }
    if (to == (sockaddr *)0x0) {
LAB_2303b61a:
      if (tolen == 0) {
        buf.p = (pbuf *)0x0;
        auStack52 = (pbuf *)0x0;
        buf.addr.addr._2_1_ = '\0';
        if (to == (sockaddr *)0x0) {
          buf.ptr = (pbuf *)0x0;
          buf.addr.addr._0_2_ = 0;
        }
        else {
          buf.ptr = *(pbuf **)(to->sa_data + 2);
          buf.addr.addr._0_2_ = lwip_htons(*(u16_t *)to->sa_data);
        }
        pvVar4 = netbuf_alloc((netbuf *)auStack52,(u16_t)size);
        iVar3 = -1;
        if (pvVar4 != (void *)0x0) {
          if ((plVar2->conn->type & 0xf0) == NETCONN_RAW) {
            memcpy(auStack52->payload,data,size);
          }
          else {
            buf.port = lwip_chksum_copy(auStack52->payload,data,(u16_t)size);
            buf.addr.addr._2_1_ = '\x02';
          }
          eVar1 = netconn_send(plVar2->conn,(netbuf *)auStack52);
          iVar3 = CONCAT31(extraout_var,eVar1);
        }
        netbuf_free((netbuf *)auStack52);
        iVar5 = err_to_errno((err_t)iVar3);
        if (iVar5 != 0) {
          errno = iVar5;
        }
        if (iVar3 == 0) goto LAB_2303b5ec;
        goto LAB_2303b5ce;
      }
    }
    else {
      if ((tolen == 0x10) && (to->sa_family == '\x02')) {
        tolen = (uint)to & 3;
        goto LAB_2303b61a;
      }
    }
    iVar3 = err_to_errno(-0x10);
    if (iVar3 != 0) {
      errno = iVar3;
    }
  }
LAB_2303b5ce:
  size = 0xffffffff;
LAB_2303b5ec:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return size;
}



ssize_t lwip_send(int s,void *data,size_t size,int flags)

{
  err_t err;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  int iVar2;
  byte bVar3;
  size_t sStack20;
  size_t written;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if ((plVar1->conn->type & 0xf0) != NETCONN_TCP) {
      sStack20 = lwip_sendto(s,data,size,flags,(sockaddr *)0x0,0);
      goto LAB_2303b6e4;
    }
    bVar3 = 3;
    if ((flags & 0x10U) == 0) {
      bVar3 = 1;
    }
    sStack20 = 0;
    err = netconn_write_partly(plVar1->conn,data,size,bVar3 | (byte)(flags >> 1) & 4,&sStack20);
    iVar2 = err_to_errno(err);
    if (iVar2 != 0) {
      errno = iVar2;
    }
    if (CONCAT31(extraout_var,err) == 0) goto LAB_2303b6e4;
  }
  sStack20 = 0xffffffff;
LAB_2303b6e4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sStack20;
}



int lwip_socket(int domain,int type,int protocol)

{
  netconn_type t;
  netconn *newconn;
  int iVar1;
  u8_t proto;
  
  if (type == 2) {
    t = NETCONN_UDPLITE;
    if (protocol != 0x88) {
      t = NETCONN_UDP;
    }
    proto = '\0';
  }
  else {
    if (type == 3) {
      proto = (u8_t)protocol;
      t = NETCONN_RAW;
    }
    else {
      if (type != 1) {
        errno = 0x16;
        goto LAB_2303b7a8;
      }
      proto = '\0';
      t = NETCONN_TCP;
    }
  }
  newconn = netconn_new_with_proto_and_callback(t,proto,event_callback);
  if (newconn != (netconn *)0x0) {
    iVar1 = alloc_socket(newconn,0);
    if (iVar1 == -1) {
      netconn_delete(newconn);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      errno = 0x17;
      return -1;
    }
    newconn->socket = iVar1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  errno = 0x69;
LAB_2303b7a8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



ssize_t lwip_write(int s,void *data,size_t size)

{
  ssize_t sVar1;
  
  sVar1 = lwip_send(s,data,size,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



int lwip_select(int maxfdp1,_types_fd_set *readset,_types_fd_set *writeset,_types_fd_set *exceptset,
               timeval *timeout)

{
  uint uVar1;
  err_t eVar2;
  uint uVar3;
  undefined3 extraout_var;
  u8_t uVar4;
  u32_t uVar5;
  lwip_sock *plVar6;
  uint uVar7;
  lwip_sock *plVar8;
  undefined local_7c [4];
  _types_fd_set lreadset;
  _types_fd_set lwriteset;
  _types_fd_set lexceptset;
  lwip_select_cb select_cb;
  
  if ((uint)maxfdp1 < 0x41) {
    uVar3 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)local_7c,
                         (_types_fd_set *)(lreadset.fds_bits + 1),
                         (_types_fd_set *)(lwriteset.fds_bits + 1));
    if ((int)uVar3 < 0) {
      errno = 9;
    }
    else {
      uVar7 = uVar3;
      if ((uVar3 != 0) ||
         (((timeout != (timeval *)0x0 &&
           ((*(uint *)&timeout->tv_sec | *(uint *)((int)&timeout->tv_sec + 4)) == 0)) &&
          (uVar7 = timeout->tv_usec, uVar7 == 0)))) {
LAB_2303b9b6:
        if (readset != (_types_fd_set *)0x0) {
          readset->fds_bits[0] = local_7c;
          readset->fds_bits[1] = lreadset.fds_bits[0];
        }
        if (writeset != (_types_fd_set *)0x0) {
          writeset->fds_bits[0] = lreadset.fds_bits[1];
          writeset->fds_bits[1] = lwriteset.fds_bits[0];
        }
        if (exceptset != (_types_fd_set *)0x0) {
          exceptset->fds_bits[0] = lwriteset.fds_bits[1];
          exceptset->fds_bits[1] = lexceptset.fds_bits[0];
        }
        goto LAB_2303b814;
      }
      memset(lexceptset.fds_bits + 1,0,0x24);
      select_cb.prev = (lwip_select_cb *)readset;
      select_cb.readset = writeset;
      select_cb.writeset = exceptset;
      eVar2 = sys_sem_new((sys_sem_t *)&select_cb.sem_signalled,'\0');
      if (CONCAT31(extraout_var,eVar2) == 0) {
        plVar6 = sockets;
        plVar8 = sockets;
        lwip_link_select_cb((lwip_select_cb *)(lexceptset.fds_bits + 1));
        uVar1 = 0;
        while (uVar1 != maxfdp1) {
          if ((((readset != (_types_fd_set *)0x0) &&
               ((1 << (uVar1 & 0x1f) & readset->fds_bits[uVar1 >> 5]) != 0)) ||
              ((writeset != (_types_fd_set *)0x0 &&
               ((1 << (uVar1 & 0x1f) & writeset->fds_bits[uVar1 >> 5]) != 0)))) ||
             ((exceptset != (_types_fd_set *)0x0 &&
              ((1 << (uVar1 & 0x1f) & exceptset->fds_bits[uVar1 >> 5]) != 0)))) {
            sys_arch_protect();
            if ((int)uVar1 < 0x15) {
              uVar4 = plVar8->select_waiting + '\x01';
              plVar8->select_waiting = uVar4;
              if (uVar4 != '\0') {
                sys_arch_unprotect();
                goto LAB_2303b9ec;
              }
              sockets[uVar1].select_waiting = -1;
              sys_arch_unprotect();
              errno = 0x10;
            }
            else {
              sys_arch_unprotect();
              errno = 9;
            }
            uVar7 = 0xffffffff;
            uVar5 = 0;
            goto LAB_2303b986;
          }
LAB_2303b9ec:
          uVar1 = uVar1 + 1;
          plVar8 = plVar8 + 1;
        }
        uVar7 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)local_7c,
                             (_types_fd_set *)(lreadset.fds_bits + 1),
                             (_types_fd_set *)(lwriteset.fds_bits + 1));
        uVar5 = 0;
        if (uVar7 == 0) {
          uVar5 = 0;
          if ((timeout != (timeval *)0x0) &&
             (uVar5 = *(int *)&timeout->tv_sec * 1000 + (timeout->tv_usec + 500) / 1000,
             (int)uVar5 < 1)) {
            uVar5 = 1;
          }
          uVar5 = sys_arch_sem_wait((sys_sem_t *)&select_cb.sem_signalled,uVar5);
          uVar1 = maxfdp1;
        }
LAB_2303b986:
        while (uVar3 != uVar1) {
          if ((((readset != (_types_fd_set *)0x0) &&
               ((1 << (uVar3 & 0x1f) & readset->fds_bits[uVar3 >> 5]) != 0)) ||
              ((writeset != (_types_fd_set *)0x0 &&
               ((1 << (uVar3 & 0x1f) & writeset->fds_bits[uVar3 >> 5]) != 0)))) ||
             ((exceptset != (_types_fd_set *)0x0 &&
              ((1 << (uVar3 & 0x1f) & exceptset->fds_bits[uVar3 >> 5]) != 0)))) {
            sys_arch_protect();
            if ((int)uVar3 < 0x15) {
              if (plVar6->select_waiting != '\0') {
                plVar6->select_waiting = plVar6->select_waiting + -1;
              }
              sys_arch_unprotect();
            }
            else {
              sys_arch_unprotect();
              uVar7 = 0xffffffff;
              errno = 9;
            }
          }
          uVar3 = uVar3 + 1;
          plVar6 = plVar6 + 1;
        }
        lwip_unlink_select_cb((lwip_select_cb *)(lexceptset.fds_bits + 1));
        sys_sem_free((sys_sem_t *)&select_cb.sem_signalled);
        if (-1 < (int)uVar7) {
          if (uVar5 != 0xffffffff) {
            uVar7 = lwip_selscan(maxfdp1,readset,writeset,exceptset,(_types_fd_set *)local_7c,
                                 (_types_fd_set *)(lreadset.fds_bits + 1),
                                 (_types_fd_set *)(lwriteset.fds_bits + 1));
          }
          goto LAB_2303b9b6;
        }
      }
      else {
        errno = 0xc;
      }
    }
  }
  else {
    errno = 0x16;
  }
  uVar7 = 0xffffffff;
LAB_2303b814:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar7;
}



int lwip_shutdown(int s,int how)

{
  err_t err;
  lwip_sock *plVar1;
  netconn *conn;
  int iVar2;
  undefined3 extraout_var;
  u8_t shut_tx;
  u8_t shut_rx;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    conn = plVar1->conn;
    if (conn == (netconn *)0x0) {
      errno = 0x6b;
    }
    else {
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        if (how == 0) {
          shut_tx = '\0';
          shut_rx = '\x01';
        }
        else {
          shut_rx = '\x01';
          if (how == 1) {
            shut_tx = '\x01';
            shut_rx = '\0';
          }
          else {
            shut_tx = '\x01';
            if (how != 2) {
              errno = 0x16;
              goto LAB_2303ba9e;
            }
          }
        }
        err = netconn_shutdown(conn,shut_rx,shut_tx);
        iVar2 = err_to_errno(err);
        if (iVar2 != 0) {
          errno = iVar2;
        }
        iVar2 = -(uint)(CONCAT31(extraout_var,err) != 0);
        goto LAB_2303bae6;
      }
      errno = 0x5f;
    }
  }
LAB_2303ba9e:
  iVar2 = -1;
LAB_2303bae6:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int lwip_setsockopt(int s,int level,int optname,void *optval,socklen_t optlen)

{
  err_t err;
  lwip_sock *plVar1;
  undefined3 extraout_var;
  int iStack44;
  lwip_setgetsockopt_data data;
  
  plVar1 = get_socket(s);
  if (plVar1 != (lwip_sock *)0x0) {
    if (optval == (void *)0x0) {
      errno = 0xe;
    }
    else {
      data.optlen = 0;
      data.err = (int)&plVar1->conn->op_completed;
      iStack44 = s;
      data.s = level;
      data.level = optname;
      data.optname = (int)optval;
      data.optval = optlen;
      err = tcpip_callback(lwip_setsockopt_callback,&iStack44);
      if (CONCAT31(extraout_var,err) == 0) {
        sys_arch_sem_wait((sys_sem_t *)data.err,0);
        if (data.optlen == 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
      }
      else {
        data.optlen = err_to_errno(err);
        if (data.optlen == 0) goto LAB_2303bb12;
      }
      errno = data.optlen;
    }
  }
LAB_2303bb12:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int lwip_fcntl(int s,int cmd,int val)

{
  ushort uVar1;
  uint uVar2;
  lwip_sock *plVar3;
  byte bVar4;
  int iVar5;
  
  plVar3 = get_socket(s);
  if (plVar3 != (lwip_sock *)0x0) {
    if (cmd == 3) {
      uVar2 = 6;
      bVar4 = plVar3->conn->flags;
      if ((plVar3->conn->type & 0xf0) == NETCONN_TCP) {
        sys_arch_protect();
        uVar2 = 0;
        iVar5 = plVar3->conn->pcb;
        if ((iVar5 != 0) &&
           (uVar1 = *(ushort *)(iVar5 + 0x1a), uVar2 = (uint)((uVar1 & 0x10) == 0) << 1,
           (uVar1 & 0x20) == 0)) {
          uVar2 = uVar2 | 4;
        }
        sys_arch_unprotect();
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar2 | (int)(uint)bVar4 >> 1 & 1U;
    }
    if ((cmd == 4) && ((val & 0xfffffff8U) == 0)) {
      bVar4 = plVar3->conn->flags;
      if ((val & 1U) == 0) {
        bVar4 = bVar4 & 0xfd;
      }
      else {
        bVar4 = bVar4 | 2;
      }
      plVar3->conn->flags = bVar4;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    errno = 0x26;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xffffffff;
}



void tcpip_thread(void *arg)

{
  byte *mem;
  undefined uVar1;
  memp_t type;
  u32_t uVar2;
  int iVar3;
  undefined *puVar4;
  byte *pbStack36;
  tcpip_msg *msg;
  
  if (tcpip_init_done != (tcpip_init_done_fn)0x0) {
    (*tcpip_init_done)(tcpip_init_done_arg);
  }
switchD_2303bc70_caseD_5:
  do {
    while (uVar2 = sys_timeouts_sleeptime(), uVar2 != 0xffffffff) {
      if ((uVar2 != 0) &&
         (uVar2 = sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,uVar2), uVar2 != 0xffffffff))
      goto LAB_2303bc5e;
      sys_check_timeouts();
    }
    sys_arch_mbox_fetch(&tcpip_mbox,&pbStack36,0);
LAB_2303bc5e:
    mem = pbStack36;
  } while (pbStack36 == (byte *)0x0);
  switch(*pbStack36) {
  case 0:
  case 4:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    goto switchD_2303bc70_caseD_5;
  case 1:
    puVar4 = *(undefined **)(pbStack36 + 8);
    uVar1 = (**(code **)(pbStack36 + 4))(puVar4,*(code **)(pbStack36 + 4));
    *puVar4 = uVar1;
    sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)(mem + 0xc));
    goto switchD_2303bc70_caseD_5;
  case 2:
    iVar3 = (**(code **)(pbStack36 + 0xc))
                      (*(undefined4 *)(pbStack36 + 4),*(undefined4 *)(pbStack36 + 8),
                       *(code **)(pbStack36 + 0xc));
    if (iVar3 != 0) {
      pbuf_free(*(pbuf **)(mem + 4));
    }
    type = MEMP_TCPIP_MSG_INPKT;
    break;
  case 3:
    (**(code **)(pbStack36 + 4))(*(undefined4 *)(pbStack36 + 8),*(code **)(pbStack36 + 4));
    type = MEMP_TCPIP_MSG_API;
    break;
  default:
    goto switchD_2303bc70_caseD_5;
  }
  memp_free(type,mem);
  goto switchD_2303bc70_caseD_5;
}



err_t tcpip_inpkt(pbuf *p,netif *inp,netif_input_fn *input_fn)

{
  err_t eVar1;
  undefined *msg;
  int iVar2;
  undefined3 extraout_var;
  
  sys_mbox_valid((int *)&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == (undefined *)0x0) {
    printf("[LWIP] NO TCP MSG\r\n");
  }
  else {
    *(netif **)(msg + 8) = inp;
    *msg = 2;
    *(pbuf **)(msg + 4) = p;
    *(netif_input_fn **)(msg + 0xc) = input_fn;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    iVar2 = CONCAT31(extraout_var,eVar1);
    if (iVar2 == 0) goto LAB_2303bd04;
    printf("[LWIP] NO MBOX\r\n");
    memp_free(MEMP_TCPIP_MSG_INPKT,msg);
  }
  iVar2 = -1;
LAB_2303bd04:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



err_t tcpip_input(pbuf *p,netif *inp)

{
  err_t eVar1;
  code *input_fn;
  
  if ((inp->flags & 0x18) == 0) {
    input_fn = ip4_input;
  }
  else {
    input_fn = ethernet_input;
  }
  eVar1 = tcpip_inpkt(p,inp,input_fn);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t tcpip_callback(tcpip_callback_fn function,void *ctx)

{
  err_t eVar1;
  undefined *data;
  
  sys_mbox_valid((int *)&tcpip_mbox);
  data = (undefined *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (data == (undefined *)0x0) {
    eVar1 = -1;
  }
  else {
    *data = 3;
    *(void **)(data + 8) = ctx;
    *(tcpip_callback_fn *)(data + 4) = function;
    sys_mbox_post(&tcpip_mbox,data);
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t tcpip_try_callback(tcpip_callback_fn function,void *ctx)

{
  err_t eVar1;
  undefined *msg;
  undefined3 extraout_var;
  int iVar2;
  
  sys_mbox_valid((int *)&tcpip_mbox);
  msg = (undefined *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (msg != (undefined *)0x0) {
    *(void **)(msg + 8) = ctx;
    *msg = 3;
    *(tcpip_callback_fn *)(msg + 4) = function;
    eVar1 = sys_mbox_trypost(&tcpip_mbox,msg);
    iVar2 = CONCAT31(extraout_var,eVar1);
    if (iVar2 == 0) goto LAB_2303bdee;
    memp_free(MEMP_TCPIP_MSG_API,msg);
  }
  iVar2 = -1;
LAB_2303bdee:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



// WARNING: Could not reconcile some variable overlaps

err_t tcpip_send_msg_wait_sem(tcpip_callback_fn fn,void *apimsg,sys_sem_t *sem)

{
  undefined auStack32 [4];
  tcpip_msg msg;
  
  sys_sem_valid(sem);
  sys_mbox_valid((int *)&tcpip_mbox);
  auStack32[0] = 0;
  msg._0_4_ = fn;
  msg.msg._0_4_ = apimsg;
  sys_mbox_post(&tcpip_mbox,auStack32);
  sys_arch_sem_wait(sem,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



// WARNING: Could not reconcile some variable overlaps

err_t tcpip_api_call(tcpip_api_call_fn *fn,tcpip_api_call_data *call)

{
  sys_sem_t *sem;
  err_t eVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined local_30 [4];
  tcpip_msg msg;
  
  sem = &call->sem;
  eVar1 = sys_sem_new(sem,'\0');
  iVar2 = CONCAT31(extraout_var,eVar1);
  if (iVar2 == 0) {
    sys_mbox_valid((int *)&tcpip_mbox);
    local_30[0] = 1;
    msg._0_4_ = fn;
    msg.msg._0_4_ = call;
    msg.msg._4_4_ = sem;
    sys_mbox_post(&tcpip_mbox,local_30);
    sys_arch_sem_wait(msg.msg._4_4_,0);
    sys_sem_free(sem);
    iVar2 = (int)call->err;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



void tcpip_init(tcpip_init_done_fn initfunc,void *arg)

{
  lwip_init();
  tcpip_init_done = initfunc;
  tcpip_init_done_arg = arg;
  sys_mbox_new(&tcpip_mbox,0x32);
  sys_thread_new("TCP/IP",tcpip_thread,(void *)0x0,4000,0x1e);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



altcp_pcb * altcp_alloc(void)

{
  altcp_pcb *__s;
  
  __s = (altcp_pcb *)memp_malloc(MEMP_ALTCP_PCB);
  if (__s != (altcp_pcb *)0x0) {
    memset(__s,0,0x2c);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



void altcp_free(altcp_pcb *conn)

{
  altcp_dealloc_fn paVar1;
  
  if (conn == (altcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((conn->fns != (altcp_functions *)0x0) &&
     (paVar1 = conn->fns->dealloc, paVar1 != (altcp_dealloc_fn)0x0)) {
    (*paVar1)(conn);
  }
  memp_free(MEMP_ALTCP_PCB,conn);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

altcp_pcb * altcp_new_ip_type(altcp_allocator_t *allocator,u8_t ip_type)

{
  altcp_pcb *paVar1;
  
  if (allocator == (altcp_allocator_t *)0x0) {
    paVar1 = altcp_tcp_new_ip_type(ip_type);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return paVar1;
  }
  if (allocator->alloc != (altcp_new_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2303bf52. Too many branches
                    // WARNING: Treating indirect jump as call
    paVar1 = (*allocator->alloc)(allocator->arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return paVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (altcp_pcb *)0x0;
}



altcp_pcb * altcp_new(altcp_allocator_t *allocator)

{
  altcp_pcb *paVar1;
  
  paVar1 = altcp_new_ip_type(allocator,'\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return paVar1;
}



void altcp_arg(altcp_pcb *conn,void *arg)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->arg = arg;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void altcp_recv(altcp_pcb *conn,altcp_recv_fn *recv)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->recv = recv;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void altcp_sent(altcp_pcb *conn,altcp_sent_fn *sent)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->sent = sent;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_poll(altcp_pcb *conn,altcp_poll_fn *poll,u8_t interval)

{
  altcp_set_poll_fn UNRECOVERED_JUMPTABLE;
  undefined3 in_register_00002031;
  
  if (conn != (altcp_pcb *)0x0) {
    conn->poll = poll;
    conn->pollinterval = interval;
    if ((conn->fns != (altcp_functions *)0x0) &&
       (UNRECOVERED_JUMPTABLE = conn->fns->set_poll, UNRECOVERED_JUMPTABLE != (altcp_set_poll_fn)0x0
       )) {
                    // WARNING: Could not recover jumptable at 0x2303bf86. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)((altcp_pcb *)CONCAT31(in_register_00002031,interval));
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void altcp_err(altcp_pcb *conn,altcp_err_fn *err)

{
  if (conn != (altcp_pcb *)0x0) {
    conn->err = err;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_recved(altcp_pcb *conn,u16_t len)

{
  altcp_recved_fn *UNRECOVERED_JUMPTABLE;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->recved, UNRECOVERED_JUMPTABLE != (altcp_recved_fn *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bf9e. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_connect(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port,altcp_connected_fn connected)

{
  altcp_connect_fn *UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->connect, UNRECOVERED_JUMPTABLE != (altcp_connect_fn *)0x0))
  {
                    // WARNING: Could not recover jumptable at 0x2303bfb0. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

void altcp_abort(altcp_pcb *conn)

{
  altcp_abort_fn UNRECOVERED_JUMPTABLE;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->abort, UNRECOVERED_JUMPTABLE != (altcp_abort_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfc4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_close(altcp_pcb *conn)

{
  altcp_close_fn UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->close, UNRECOVERED_JUMPTABLE != (altcp_close_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfd6. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_write(altcp_pcb *conn,void *dataptr,u16_t len,u8_t apiflags)

{
  altcp_write_fn *UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->write, UNRECOVERED_JUMPTABLE != (altcp_write_fn *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bfea. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



// WARNING: Exceeded maximum restarts with more pending

err_t altcp_output(altcp_pcb *conn)

{
  altcp_output_fn UNRECOVERED_JUMPTABLE;
  err_t eVar1;
  
  if (((conn != (altcp_pcb *)0x0) && (conn->fns != (altcp_functions *)0x0)) &&
     (UNRECOVERED_JUMPTABLE = conn->fns->output, UNRECOVERED_JUMPTABLE != (altcp_output_fn)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303bffe. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (*UNRECOVERED_JUMPTABLE)();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t altcp_tcp_connected(void *arg,tcp_pcb *tpcb,err_t err)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x14) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c012. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x14))(*(undefined4 *)((int)arg + 8),arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t altcp_tcp_sent(void *arg,tcp_pcb *tpcb,u16_t len)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x1c) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c026. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x1c))(*(undefined4 *)((int)arg + 8),arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t altcp_tcp_poll(void *arg,tcp_pcb *tpcb)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x20) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c03a. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x20))(*(undefined4 *)((int)arg + 8),arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



u16_t altcp_tcp_mss(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(u16_t *)((int)conn->state + 0x32);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



u16_t altcp_tcp_sndbuf(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(u16_t *)((int)conn->state + 100);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



u16_t altcp_tcp_sndqueuelen(altcp_pcb *conn)

{
  if (conn != (altcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(u16_t *)((int)conn->state + 0x66);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void altcp_tcp_nagle_disable(altcp_pcb *conn)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    *(ushort *)((int)pvVar1 + 0x1a) = *(ushort *)((int)pvVar1 + 0x1a) | 0x40;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void altcp_tcp_nagle_enable(altcp_pcb *conn)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    *(ushort *)((int)pvVar1 + 0x1a) = *(ushort *)((int)pvVar1 + 0x1a) & 0xffbf;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int altcp_tcp_nagle_disabled(altcp_pcb *conn)

{
  if ((conn != (altcp_pcb *)0x0) && (conn->state != (void *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(ushort *)((int)conn->state + 0x1a) >> 6 & 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void altcp_tcp_dealloc(altcp_pcb *conn)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



ip_addr_t * altcp_tcp_get_ip(altcp_pcb *conn,int local)

{
  if (((conn != (altcp_pcb *)0x0) && (conn = (altcp_pcb *)conn->state, conn != (altcp_pcb *)0x0)) &&
     (local == 0)) {
    conn = (altcp_pcb *)&conn->inner_conn;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (ip_addr_t *)conn;
}



u16_t altcp_tcp_get_port(altcp_pcb *conn,int local)

{
  void *pvVar1;
  
  if ((conn != (altcp_pcb *)0x0) && (pvVar1 = conn->state, pvVar1 != (void *)0x0)) {
    if (local == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return *(u16_t *)((int)pvVar1 + 0x18);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(u16_t *)((int)pvVar1 + 0x16);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void altcp_tcp_setup_callbacks(altcp_pcb *conn,tcp_pcb *tpcb)

{
  tcp_arg(tpcb,conn);
  tcp_recv(tpcb,altcp_tcp_recv);
  tcp_sent(tpcb,altcp_tcp_sent);
  tcp_err(tpcb,altcp_tcp_err);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void altcp_tcp_err(void *arg,err_t err)

{
  if (arg != (void *)0x0) {
    *(undefined4 *)((int)arg + 0xc) = 0;
    if (*(code **)((int)arg + 0x24) != (code *)0x0) {
      (**(code **)((int)arg + 0x24))(*(undefined4 *)((int)arg + 8));
    }
    altcp_free((altcp_pcb *)arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t altcp_tcp_get_tcp_addrinfo(altcp_pcb *conn,int local,ip_addr_t *addr,u16_t *port)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_tcp_get_tcp_addrinfo((tcp_pcb *)conn->state,local,addr,port);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



void altcp_tcp_setprio(altcp_pcb *conn,u8_t prio)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_setprio((tcp_pcb *)conn->state,prio);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t altcp_tcp_output(altcp_pcb *conn)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_output((tcp_pcb *)conn->state);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t altcp_tcp_write(altcp_pcb *conn,void *dataptr,u16_t len,u8_t apiflags)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_write((tcp_pcb *)conn->state,dataptr,len,apiflags);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t altcp_tcp_shutdown(altcp_pcb *conn,int shut_rx,int shut_tx)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_shutdown((tcp_pcb *)conn->state,shut_rx,shut_tx);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t altcp_tcp_close(altcp_pcb *conn)

{
  tcp_pcb *pcb;
  err_t eVar1;
  undefined3 extraout_var;
  int iVar2;
  tcp_poll_fn *poll;
  
  iVar2 = -6;
  if (conn != (altcp_pcb *)0x0) {
    pcb = (tcp_pcb *)conn->state;
    if (pcb != (tcp_pcb *)0x0) {
      poll = pcb->poll;
      tcp_arg(pcb,(void *)0x0);
      tcp_recv(pcb,(tcp_recv_fn *)0x0);
      tcp_sent(pcb,(tcp_sent_fn *)0x0);
      tcp_err(pcb,(tcp_err_fn *)0x0);
      tcp_poll(pcb,(tcp_poll_fn *)0x0,pcb->pollinterval);
      eVar1 = tcp_close(pcb);
      iVar2 = CONCAT31(extraout_var,eVar1);
      if (iVar2 != 0) {
        altcp_tcp_setup_callbacks(conn,pcb);
        tcp_poll(pcb,poll,pcb->pollinterval);
        goto LAB_2303c1d2;
      }
      conn->state = (void *)0x0;
    }
    altcp_free(conn);
    iVar2 = 0;
  }
LAB_2303c1d2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



void altcp_tcp_abort(altcp_pcb *conn)

{
  if ((conn != (altcp_pcb *)0x0) && ((tcp_pcb *)conn->state != (tcp_pcb *)0x0)) {
    tcp_abort((tcp_pcb *)conn->state);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



altcp_pcb * altcp_tcp_listen(altcp_pcb *conn,u8_t backlog,err_t *err)

{
  tcp_pcb *pcb;
  
  if ((conn == (altcp_pcb *)0x0) ||
     (pcb = tcp_listen_with_backlog_and_err((tcp_pcb *)conn->state,backlog,err),
     pcb == (tcp_pcb *)0x0)) {
    conn = (altcp_pcb *)0x0;
  }
  else {
    conn->state = pcb;
    tcp_accept(pcb,altcp_tcp_accept);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return conn;
}



err_t altcp_tcp_connect(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port,altcp_connected_fn connected)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    conn->connected = connected;
    eVar1 = tcp_connect((tcp_pcb *)conn->state,ipaddr,port,altcp_tcp_connected);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t altcp_tcp_bind(altcp_pcb *conn,ip_addr_t *ipaddr,u16_t port)

{
  err_t eVar1;
  
  if (conn != (altcp_pcb *)0x0) {
    eVar1 = tcp_bind((tcp_pcb *)conn->state,ipaddr,port);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



void altcp_tcp_recved(altcp_pcb *conn,u16_t len)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_recved((tcp_pcb *)conn->state,len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t altcp_tcp_recv(void *arg,tcp_pcb *tpcb,pbuf *p,err_t err)

{
  err_t eVar1;
  
  if ((arg != (void *)0x0) && (*(code **)((int)arg + 0x18) != (code *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x2303c266. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar1 = (**(code **)((int)arg + 0x18))(*(undefined4 *)((int)arg + 8));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  if (p != (pbuf *)0x0) {
    pbuf_free(p);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void altcp_tcp_set_poll(altcp_pcb *conn,u8_t interval)

{
  if (conn != (altcp_pcb *)0x0) {
    tcp_poll((tcp_pcb *)conn->state,altcp_tcp_poll,interval);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t altcp_tcp_accept(void *arg,tcp_pcb *new_tpcb,err_t err)

{
  err_t eVar1;
  altcp_pcb *conn;
  undefined3 in_register_00002031;
  
  if ((arg != (void *)0x0) && (*(int *)((int)arg + 0x10) != 0)) {
    conn = altcp_alloc();
    if (conn != (altcp_pcb *)0x0) {
      altcp_tcp_setup_callbacks(conn,new_tpcb);
      conn->state = new_tpcb;
      conn->fns = &altcp_tcp_functions;
                    // WARNING: Could not recover jumptable at 0x2303c2dc. Too many branches
                    // WARNING: Treating indirect jump as call
      eVar1 = (**(code **)((int)arg + 0x10))
                        (*(undefined4 *)((int)arg + 8),conn,CONCAT31(in_register_00002031,err));
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



altcp_pcb * altcp_tcp_new_ip_type(u8_t ip_type)

{
  altcp_pcb *conn;
  tcp_pcb *pcb;
  
  pcb = tcp_new_ip_type(ip_type);
  conn = (altcp_pcb *)0x0;
  if (pcb != (tcp_pcb *)0x0) {
    conn = altcp_alloc();
    if (conn == (altcp_pcb *)0x0) {
      tcp_close(pcb);
    }
    else {
      altcp_tcp_setup_callbacks(conn,pcb);
      conn->state = pcb;
      conn->fns = &altcp_tcp_functions;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return conn;
}



u16_t lwip_htons(u16_t n)

{
  undefined2 in_register_0000202a;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)((ushort)(CONCAT22(in_register_0000202a,n) >> 8) | n << 8);
}



u32_t lwip_htonl(u32_t n)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return n >> 8 & 0xff00 | n << 0x18 | n >> 0x18 | (n & 0xff00) << 8;
}



int lwip_strnicmp(char *str1,char *str2,size_t len)

{
  byte bVar1;
  int iVar2;
  
  iVar2 = 0;
  while( true ) {
    bVar1 = str1[iVar2];
    if ((bVar1 != str2[iVar2]) &&
       ((0x19 < (byte)((bVar1 | 0x20) + 0x9f) ||
        ((byte)(bVar1 | 0x20) != (byte)(str2[iVar2] | 0x20U))))) break;
    if ((len - 1 == iVar2) || (iVar2 = iVar2 + 1, bVar1 == 0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



void dns_call_found(u8_t idx,ip_addr_t *addr)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,idx);
  if (dns_requests[iVar1].found != (dns_found_callback *)0x0) {
    (*dns_requests[iVar1].found)(dns_table[iVar1].name,addr,dns_requests[iVar1].arg);
  }
  dns_requests[iVar1].found = (dns_found_callback *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: hdr

err_t dns_send(u8_t idx)

{
  u8_t *dataptr;
  u8_t *puVar1;
  err_t eVar2;
  undefined3 in_register_00002029;
  int iVar3;
  size_t sVar4;
  pbuf *buf;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 local_40;
  dns_query qry;
  dns_hdr hdr;
  
  iVar3 = CONCAT31(in_register_00002029,idx);
  if (dns_servers[dns_table[iVar3].server_idx].addr == 0) {
    dns_call_found(idx,(ip_addr_t *)0x0);
    eVar2 = '\0';
    dns_table[iVar3].state = '\0';
  }
  else {
    sVar4 = strlen(dns_table[iVar3].name);
    buf = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((sVar4 + 0x12) * 0x10000 >> 0x10),PBUF_RAM);
    eVar2 = -1;
    if (buf != (pbuf *)0x0) {
      memset(&qry,0,0xc);
      qry.type = lwip_htons(dns_table[iVar3].txid);
      qry.cls._0_1_ = 1;
      puVar1 = &dns_table[iVar3].seqno;
      pbuf_take(buf,&qry,0xc);
      uVar6 = 0xc;
      do {
        dataptr = puVar1 + 1;
        uVar5 = 0;
        puVar1 = dataptr;
        while ((*puVar1 != '.' && (*puVar1 != '\0'))) {
          uVar5 = uVar5 + 1 & 0xff;
          puVar1 = puVar1 + 1;
        }
        if (0xfffe < uVar6 + uVar5) {
          pbuf_free(buf);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -6;
        }
        pbuf_put_at(buf,(u16_t)uVar6,(u8_t)uVar5);
        pbuf_take_at(buf,dataptr,(u16_t)((uint)((int)(puVar1 + -(int)dataptr) * 0x10000) >> 0x10),
                     (u16_t)((uVar6 + 1) * 0x10000 >> 0x10));
        uVar7 = uVar6 + uVar5 & 0xffff;
        uVar5 = uVar7 + 1;
        uVar6 = uVar5 & 0xffff;
      } while (*puVar1 != '\0');
      pbuf_put_at(buf,(u16_t)(uVar5 * 0x10000 >> 0x10),'\0');
      local_40 = 0x1000100;
      pbuf_take_at(buf,&local_40,4,(u16_t)((uVar7 + 2) * 0x10000 >> 0x10));
      eVar2 = udp_sendto(dns_pcbs,buf,dns_servers + dns_table[iVar3].server_idx,0x35);
      pbuf_free(buf);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



void dns_check_entry(u8_t i)

{
  undefined3 in_register_00002029;
  int iVar1;
  u8_t uVar2;
  u16_t uVar3;
  u32_t uVar4;
  dns_table_entry_conflict *pdVar5;
  
  iVar1 = CONCAT31(in_register_00002029,i);
  uVar2 = dns_table[iVar1].state;
  if (uVar2 == '\x02') {
    uVar2 = dns_table[iVar1].tmr + -1;
    dns_table[iVar1].tmr = uVar2;
    if (uVar2 != '\0') goto LAB_2303c660;
    uVar2 = dns_table[iVar1].retries + '\x01';
    dns_table[iVar1].retries = uVar2;
    if (uVar2 != '\x04') {
      dns_table[iVar1].tmr = uVar2;
LAB_2303c5fe:
      dns_send(i);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((dns_table[iVar1].server_idx == '\0') && (dns_servers[1] != 0)) {
      dns_table[iVar1].server_idx = '\x01';
      *(undefined2 *)&dns_table[iVar1].tmr = 1;
      goto LAB_2303c5fe;
    }
    dns_call_found(i,(ip_addr_t *)0x0);
  }
  else {
    if (uVar2 != '\x03') {
      if (uVar2 == '\x01') {
        do {
          uVar3 = dns_txid + 1;
          pdVar5 = dns_table;
          while ((dns_txid = uVar3, pdVar5->state != '\x02' || (pdVar5->txid != uVar3))) {
            pdVar5 = pdVar5 + 1;
            if (pdVar5 == (dns_table_entry_conflict *)arp_table) {
              *(undefined2 *)&dns_table[iVar1].state = 2;
              dns_table[iVar1].txid = uVar3;
              *(undefined2 *)&dns_table[iVar1].tmr = 1;
              goto LAB_2303c5fe;
            }
          }
        } while( true );
      }
      goto LAB_2303c660;
    }
    uVar4 = dns_table[iVar1].ttl;
    if ((uVar4 != 0) && (uVar4 = uVar4 - 1, dns_table[iVar1].ttl = uVar4, uVar4 != 0))
    goto LAB_2303c660;
  }
  dns_table[iVar1].state = '\0';
LAB_2303c660:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void dns_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u8_t i;
  uint uVar1;
  u16_t uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  uint uVar4;
  int iVar5;
  undefined2 extraout_var_03;
  uint uVar6;
  undefined2 extraout_var_04;
  undefined2 extraout_var_05;
  u32_t uVar7;
  undefined2 extraout_var_06;
  dns_table_entry_conflict *pdVar8;
  byte *pbVar9;
  int iVar10;
  uint uVar11;
  byte *pbVar12;
  short sStack96;
  short sStack94;
  dns_query qry;
  ip4_addr_t ip4addr;
  dns_hdr hdr;
  dns_answer ans;
  
  if (0xf < p->tot_len) {
    uVar2 = pbuf_copy_partial(p,&ip4addr,0xc,0);
    uVar1 = CONCAT22(extraout_var,uVar2);
    if (uVar1 == 0xc) {
      iVar10 = 0;
      uVar2 = lwip_htons((u16_t)ip4addr.addr);
      pdVar8 = dns_table;
      do {
        i = (u8_t)iVar10;
        if ((pdVar8->state == '\x02') && ((uint)pdVar8->txid == CONCAT22(extraout_var_00,uVar2))) {
          uVar2 = lwip_htons(hdr.id);
          uVar3 = lwip_htons(hdr._2_2_);
          uVar11 = CONCAT22(extraout_var_02,uVar3);
          if ((ip4addr.addr._2_1_ < '\0') &&
             ((CONCAT22(extraout_var_01,uVar2) == 1 &&
              (addr->addr == dns_servers[dns_table[iVar10].server_idx].addr)))) {
            pbVar12 = (byte *)dns_table[iVar10].name;
            goto LAB_2303c752;
          }
          break;
        }
        iVar10 = iVar10 + 1;
        pdVar8 = pdVar8 + 1;
      } while (iVar10 != 4);
    }
  }
  goto ignore_packet;
  while( true ) {
    pbVar9 = pbVar12 + uVar4;
    while( true ) {
      uVar1 = uVar1 + 1 & 0xffff;
      if (pbVar12 == pbVar9) break;
      uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
      if ((int)uVar4 < 0) goto ignore_packet;
      uVar6 = (uint)*pbVar12;
      if ((_ctype_[uVar6 + 1] & 3) == 1) {
        uVar6 = uVar6 + 0x20;
      }
      uVar4 = uVar4 & 0xff;
      if ((_ctype_[uVar4 + 1] & 3) == 1) {
        uVar4 = uVar4 + 0x20;
      }
      if ((uVar6 != uVar4) || (uVar1 == 0xffff)) goto ignore_packet;
      pbVar12 = pbVar12 + 1;
    }
    pbVar12 = pbVar12 + 1;
    iVar5 = pbuf_try_get_at(p,(u16_t)uVar1);
    if (iVar5 < 0) goto ignore_packet;
    if (iVar5 == 0) break;
LAB_2303c752:
    uVar4 = pbuf_try_get_at(p,(u16_t)uVar1);
    if ((((int)uVar4 < 0) || (uVar1 == 0xffff)) || ((uVar4 & 0xc0) == 0xc0)) goto ignore_packet;
  }
  if (uVar1 != 0xffff) {
    uVar4 = uVar1 + 1 & 0xffff;
    if (((uVar4 != 0xffff) &&
        (uVar2 = pbuf_copy_partial(p,&sStack96,4,(u16_t)((uVar1 + 1) * 0x10000 >> 0x10)),
        CONCAT22(extraout_var_03,uVar2) == 4)) &&
       ((sStack94 == 0x100 && ((sStack96 == 0x100 && (uVar4 < 0xfffc)))))) {
      if ((ip4addr.addr._3_1_ & 0xf) == 0) {
        uVar1 = uVar1 + 5;
        while ((uVar1 = uVar1 & 0xffff, uVar11 != 0 && (uVar1 < p->tot_len))) {
          do {
            uVar4 = uVar1 + 1 & 0xffff;
            uVar6 = pbuf_try_get_at(p,(u16_t)uVar1);
            if (((int)uVar6 < 0) || (uVar4 == 0)) goto ignore_packet;
            if ((uVar6 & 0xc0) == 0xc0) break;
            uVar6 = uVar6 + uVar4;
            if ((int)(uint)p->tot_len <= (int)uVar6) goto ignore_packet;
            uVar1 = uVar6 & 0xffff;
            iVar5 = pbuf_try_get_at(p,(u16_t)(uVar6 * 0x10000 >> 0x10));
            if (iVar5 < 0) goto ignore_packet;
            uVar4 = uVar1;
          } while (iVar5 != 0);
          if (uVar4 == 0xffff) goto ignore_packet;
          uVar1 = uVar4 + 1 & 0xffff;
          if (((uVar1 == 0xffff) ||
              (uVar2 = pbuf_copy_partial(p,&hdr.numauthrr,10,(u16_t)((uVar4 + 1) * 0x10000 >> 0x10))
              , CONCAT22(extraout_var_04,uVar2) != 10)) || (0xfff5 < uVar1)) goto ignore_packet;
          uVar1 = uVar4 + 0xb & 0xffff;
          if (((hdr.numextrarr == 0x100) && (hdr.numauthrr == 0x100)) && ((u16_t)ans.ttl == 0x400))
          {
            uVar2 = pbuf_copy_partial(p,&qry,4,(u16_t)((uVar4 + 0xb) * 0x10000 >> 0x10));
            if (CONCAT22(extraout_var_05,uVar2) != 4) goto ignore_packet;
            *(dns_query *)&dns_table[iVar10].ipaddr = qry;
            pbuf_free(p);
            uVar7 = lwip_htonl(ans._0_4_);
            dns_table[iVar10].state = '\x03';
            if (uVar7 < 0x93a81) {
              dns_table[iVar10].ttl = uVar7;
            }
            else {
              dns_table[iVar10].ttl = 0x93a80;
            }
            dns_call_found(i,&dns_table[iVar10].ipaddr);
            if ((dns_table[iVar10].ttl == 0) && (dns_table[iVar10].state == '\x03')) {
              dns_table[iVar10].state = '\0';
            }
            goto LAB_2303c988;
          }
          uVar2 = lwip_htons((u16_t)ans.ttl);
          if (0xffff < (int)(CONCAT22(extraout_var_06,uVar2) + uVar1)) goto ignore_packet;
          uVar2 = lwip_htons((u16_t)ans.ttl);
          uVar1 = uVar2 + uVar1;
          uVar11 = uVar11 - 1 & 0xffff;
        }
      }
      else {
        if ((dns_table[iVar10].server_idx == '\0') && (dns_servers[1] != 0)) {
          *(undefined2 *)&dns_table[iVar10].tmr = 0x301;
          dns_check_entry(i);
          goto ignore_packet;
        }
      }
      pbuf_free(p);
      dns_call_found(i,(ip_addr_t *)0x0);
      dns_table[iVar10].state = '\0';
      goto LAB_2303c988;
    }
  }
ignore_packet:
  pbuf_free(p);
LAB_2303c988:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dns_init(void)

{
  if (dns_pcbs == (udp_pcb *)0x0) {
    dns_pcbs = udp_new_ip_type();
    udp_bind(dns_pcbs,&ip_addr_any,0);
    udp_recv(dns_pcbs,dns_recv,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dns_setserver(u8_t numdns,ip_addr_t *dnsserver)

{
  undefined3 in_register_00002029;
  u32_t uVar1;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    if (dnsserver == (ip_addr_t *)0x0) {
      uVar1 = 0;
    }
    else {
      uVar1 = dnsserver->addr;
    }
    dns_servers[CONCAT31(in_register_00002029,numdns)].addr = uVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



ip_addr_t * dns_getserver(u8_t numdns)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,numdns) < 2) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return dns_servers + CONCAT31(in_register_00002029,numdns);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return &ip_addr_any;
}



void dns_tmr(void)

{
  dns_check_entry('\0');
  dns_check_entry('\x01');
  dns_check_entry('\x02');
  dns_check_entry('\x03');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dns_gethostbyname_addrtype
                (char *hostname,ip_addr_t *addr,dns_found_callback *found,void *callback_arg,
                u8_t dns_addrtype)

{
  u8_t uVar1;
  uint uVar2;
  size_t __n;
  int iVar3;
  int iVar4;
  uint uVar5;
  byte bVar6;
  err_t eVar7;
  byte bVar8;
  uint uVar9;
  dns_table_entry_conflict *pdVar10;
  dns_table_entry_conflict *pdVar11;
  
  if (addr == (ip_addr_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if ((((hostname == (char *)0x0) || (*hostname == '\0')) || (dns_pcbs == (udp_pcb *)0x0)) ||
     (__n = strlen(hostname), 0xff < __n)) {
    eVar7 = -0x10;
  }
  else {
    iVar3 = ip4addr_aton(hostname,(ip4_addr_t *)addr);
    eVar7 = '\0';
    if (iVar3 == 0) {
      pdVar10 = dns_table;
      pdVar11 = dns_table;
      iVar3 = 0;
      do {
        if ((pdVar11->state == '\x03') &&
           (iVar4 = lwip_strnicmp(hostname,pdVar11->name,0x100), iVar4 == 0)) {
          eVar7 = '\0';
          addr->addr = dns_table[iVar3].ipaddr.addr;
          goto LAB_2303cab2;
        }
        uVar1 = dns_seqno;
        iVar3 = iVar3 + 1;
        pdVar11 = pdVar11 + 1;
      } while (iVar3 != 4);
      eVar7 = -6;
      if (dns_servers[0] != 0) {
        uVar9 = 0;
        uVar2 = 4;
        bVar6 = 0;
        do {
          uVar5 = uVar9 & 0xff;
          if (pdVar10->state == '\0') goto LAB_2303cba6;
          if ((pdVar10->state == '\x03') && (bVar8 = dns_seqno - pdVar10->seqno, bVar6 < bVar8)) {
            uVar2 = uVar5;
            bVar6 = bVar8;
          }
          uVar9 = uVar9 + 1;
          pdVar10 = pdVar10 + 1;
        } while (uVar9 != 4);
        eVar7 = -1;
        if ((uVar2 != 4) &&
           (eVar7 = -1, uVar5 = uVar2, uVar9 = uVar2, dns_table[uVar2].state == '\x03')) {
LAB_2303cba6:
          iVar3 = uVar9 * 0x110;
          dns_table[0].name[iVar3 + -5] = '\x01';
          dns_table[0].name[iVar3 + -1] = uVar1;
          dns_requests[uVar5].found = found;
          dns_requests[uVar5].arg = callback_arg;
          memcpy(dns_table[0].name + iVar3,hostname,__n);
          dns_table[0].name[iVar3 + __n] = '\0';
          dns_seqno = dns_seqno + '\x01';
          dns_check_entry((u8_t)uVar5);
          eVar7 = -5;
        }
      }
    }
  }
LAB_2303cab2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar7;
}



err_t dns_gethostbyname(char *hostname,ip_addr_t *addr,dns_found_callback *found,void *callback_arg)

{
  err_t eVar1;
  
  eVar1 = dns_gethostbyname_addrtype(hostname,addr,found,callback_arg,'\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u16_t lwip_standard_chksum(void *dataptr,int len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  u16_t t;
  ushort uStack2;
  
  uStack2 = 0;
  uVar3 = (uint)dataptr & 1;
  if ((uVar3 != 0) && (0 < len)) {
                    // WARNING: Load size is inaccurate
    bVar1 = *dataptr;
    len = len + -1;
    dataptr = (void *)((int)dataptr + 1);
    uStack2 = (ushort)bVar1 << 8;
  }
  uVar5 = (uint)dataptr & 3;
  if ((uVar5 != 0) && (uVar5 = 0, 1 < len)) {
                    // WARNING: Load size is inaccurate
    uVar5 = (uint)*dataptr;
    len = len + -2;
    dataptr = (void *)((int)dataptr + 2);
  }
  while (7 < len) {
                    // WARNING: Load size is inaccurate
    uVar4 = *dataptr + uVar5;
    if (uVar4 < uVar5) {
      uVar4 = uVar4 + 1;
    }
    uVar5 = *(int *)((int)dataptr + 4) + uVar4;
    if (uVar5 < uVar4) {
      uVar5 = uVar5 + 1;
    }
    len = len + -8;
    dataptr = (int *)((int)dataptr + 8);
  }
  iVar6 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  while (1 < len) {
                    // WARNING: Load size is inaccurate
    len = len + -2;
    iVar6 = iVar6 + (uint)*dataptr;
    dataptr = (int *)((int)dataptr + 2);
  }
  if (len == 1) {
                    // WARNING: Load size is inaccurate
    uStack2 = uStack2 | *dataptr;
  }
  uVar5 = ((uint)uStack2 + iVar6 >> 0x10) + ((uint)uStack2 + iVar6 & 0xffff);
  iVar6 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  uVar2 = (ushort)iVar6;
  if (uVar3 != 0) {
    uVar2 = (ushort)((uint)iVar6 >> 8) & 0xff | uVar2 * 0x100;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)uVar2;
}



u16_t inet_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo(pbuf *p,u8_t proto,u16_t proto_len,ip4_addr_t *src,ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  
  uVar5 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  uVar5 = (uVar5 >> 0x10) + (uVar5 & 0xffff);
  bVar1 = false;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar5 = uVar5 + CONCAT22(extraout_var_01,uVar3);
    uVar5 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar5 = uVar5 >> 8 & 0xff | uVar5 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar5 = uVar5 >> 8 & 0xff | (uVar5 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar5 = uVar5 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar5 & 0xffff) + (uVar5 >> 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  undefined2 in_register_00002036;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t ip_chksum_pseudo_partial
                (pbuf *p,u8_t proto,u16_t proto_len,u16_t chksum_len,ip4_addr_t *src,
                ip4_addr_t *dest)

{
  bool bVar1;
  int iVar2;
  u16_t uVar3;
  u16_t uVar4;
  undefined2 extraout_var;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  undefined3 in_register_0000202d;
  uint uVar5;
  undefined2 in_register_00002036;
  uint uVar6;
  uint uVar7;
  
  uVar5 = CONCAT22(in_register_00002036,chksum_len);
  uVar6 = (src->addr >> 0x10) + (dest->addr & 0xffff) + (dest->addr >> 0x10) + (src->addr & 0xffff);
  uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  uVar6 = (uVar6 >> 0x10) + (uVar6 & 0xffff);
  bVar1 = false;
  while ((p != (pbuf *)0x0 && (uVar5 != 0))) {
    uVar7 = (uint)p->len;
    if (uVar5 < p->len) {
      uVar7 = uVar5;
    }
    uVar3 = lwip_standard_chksum(p->payload,uVar7 & 0xffff);
    uVar6 = uVar6 + CONCAT22(extraout_var_01,uVar3);
    uVar6 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
    uVar5 = uVar5 - (uVar7 & 0xffff) & 0xffff;
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar6 = uVar6 >> 8 & 0xff | uVar6 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar6 = uVar6 >> 8 & 0xff | (uVar6 & 0xff) << 8;
  }
  uVar3 = lwip_htons((u16_t)CONCAT31(in_register_0000202d,proto));
  uVar4 = lwip_htons(proto_len);
  uVar6 = uVar6 + CONCAT22(extraout_var_00,uVar4) + CONCAT22(extraout_var,uVar3);
  iVar2 = (uVar6 & 0xffff) + (uVar6 >> 0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)~((short)iVar2 + (short)((uint)iVar2 >> 0x10));
}



u16_t inet_chksum(void *dataptr,u16_t len)

{
  u16_t uVar1;
  undefined2 in_register_0000202e;
  
  uVar1 = lwip_standard_chksum(dataptr,CONCAT22(in_register_0000202e,len));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ~uVar1;
}



u16_t inet_chksum_pbuf(pbuf *p)

{
  bool bVar1;
  uint uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  
  bVar1 = false;
  uVar2 = 0;
  while (p != (pbuf *)0x0) {
    uVar3 = lwip_standard_chksum(p->payload,(uint)p->len);
    uVar2 = uVar2 + CONCAT22(extraout_var,uVar3);
    uVar2 = (uVar2 & 0xffff) + (uVar2 >> 0x10);
    if ((p->len & 1) != 0) {
      bVar1 = (bool)(bVar1 ^ 1);
      uVar2 = uVar2 >> 8 & 0xff | uVar2 * 0x100 & 0xffff;
    }
    p = p->next;
  }
  if (bVar1) {
    uVar2 = uVar2 >> 8 & 0xff | (uVar2 & 0xff) << 8;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)~(ushort)uVar2;
}



u16_t lwip_chksum_copy(void *dst,void *src,u16_t len)

{
  u16_t uVar1;
  undefined2 in_register_00002032;
  
  memcpy(dst,src,CONCAT22(in_register_00002032,len));
  uVar1 = lwip_standard_chksum(dst,CONCAT22(in_register_00002032,len));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void lwip_init(void)

{
  stats_init();
  sys_init();
  mem_init();
  memp_init();
  netif_init();
  udp_init();
  tcp_init();
  igmp_init();
  dns_init();
  sys_timeouts_init();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dhcp_set_state(dhcp *dhcp,u8_t new_state)

{
  undefined3 in_register_0000202d;
  
  if ((uint)dhcp->state != CONCAT31(in_register_0000202d,new_state)) {
    dhcp->state = new_state;
    dhcp->tries = '\0';
    dhcp->request_timeout = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u16_t dhcp_option_short(u16_t options_out_len,u8_t *options,u16_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 8);
  options[iVar1 + 1U & 0xffff] = (u8_t)value;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)((uint)((iVar1 + 2) * 0x10000) >> 0x10);
}



u16_t dhcp_option_long(u16_t options_out_len,u8_t *options,u32_t value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  
  iVar1 = CONCAT22(in_register_0000202a,options_out_len);
  options[iVar1] = (u8_t)(value >> 0x18);
  options[iVar1 + 1U & 0xffff] = (u8_t)(value >> 0x10);
  options[iVar1 + 2U & 0xffff] = (u8_t)(value >> 8);
  options[iVar1 + 3U & 0xffff] = (u8_t)value;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)((uint)((iVar1 + 4) * 0x10000) >> 0x10);
}



pbuf * dhcp_create_msg(netif *netif,dhcp *dhcp,u8_t message_type,u16_t *options_out_len)

{
  u8_t uVar1;
  undefined *__s;
  u32_t uVar2;
  undefined3 in_register_00002031;
  int iVar3;
  u8_t *puVar4;
  u8_t *puVar5;
  pbuf *ppVar6;
  
  iVar3 = CONCAT31(in_register_00002031,message_type);
  if (((netif == (netif *)0x0) || (dhcp == (dhcp *)0x0)) ||
     (ppVar6 = pbuf_alloc(PBUF_TRANSPORT,0x134,PBUF_RAM), ppVar6 == (pbuf *)0x0)) {
    ppVar6 = (pbuf *)0x0;
  }
  else {
    if ((iVar3 != 3) || (dhcp->state == '\x03')) {
      if (dhcp->tries == '\0') {
        dhcp_create_msg::xid = bl_rand();
      }
      dhcp->xid = dhcp_create_msg::xid;
    }
    __s = (undefined *)ppVar6->payload;
    memset(__s,0,0x134);
    *__s = 1;
    __s[1] = 1;
    __s[2] = netif->hwaddr_len;
    uVar2 = lwip_htonl(dhcp->xid);
    __s[4] = (char)uVar2;
    __s[5] = (char)(uVar2 >> 8);
    __s[6] = (char)(uVar2 >> 0x10);
    __s[7] = (char)(uVar2 >> 0x18);
    if (((iVar3 == 4) || ((iVar3 - 7U & 0xff) < 2)) ||
       ((iVar3 == 3 && ((byte)(dhcp->state - 4) < 2)))) {
      uVar2 = (netif->ip_addr).addr;
      __s[0xc] = (char)uVar2;
      __s[0xd] = (char)(uVar2 >> 8);
      __s[0xe] = (char)(uVar2 >> 0x10);
      __s[0xf] = (char)(uVar2 >> 0x18);
    }
    puVar5 = netif->hwaddr;
    puVar4 = __s + 0x1c;
    do {
      uVar1 = *puVar5;
      puVar5 = puVar5 + 1;
      *puVar4 = uVar1;
      puVar4 = puVar4 + 1;
    } while (puVar5 != &netif->hwaddr_len);
    __s[0xec] = 99;
    __s[0xef] = 99;
    __s[0xed] = 0x82;
    __s[0xf0] = 0x35;
    __s[0xf1] = 1;
    __s[0xee] = 0x53;
    __s[0xf2] = message_type;
    *options_out_len = 3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar6;
}



void dhcp_option_trailer(u16_t options_out_len,u8_t *options,pbuf *p_out)

{
  undefined2 in_register_0000202a;
  u8_t *puVar1;
  uint uVar2;
  
  uVar2 = CONCAT22(in_register_0000202a,options_out_len) + 1U & 0xffff;
  options[CONCAT22(in_register_0000202a,options_out_len)] = -1;
  puVar1 = options + uVar2;
  while (uVar2 < 0x44) {
    *puVar1 = '\0';
    uVar2 = uVar2 + 1 & 0xffff;
    puVar1 = puVar1 + 1;
  }
  pbuf_realloc(p_out,(u16_t)((uVar2 + 0xf0) * 0x10000 >> 0x10));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dhcp_discover(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar1;
  int iVar2;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  (dhcp->offered_ip_addr).addr = 0;
  dhcp_set_state(dhcp,'\x06');
  p_out = dhcp_create_msg(netif,dhcp,'\x01',auStack34);
  if (p_out != (pbuf *)0x0) {
    uVar1 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar1] = '9';
    options[uVar1 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar2 = 0;
    do {
      options[auStack34[0]] = "\x01\x03\x1c\x06"[iVar2];
      auStack34[0] = (u16_t)((auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar2 = iVar2 + 1;
    } while (iVar2 != 4);
    dhcp_option_trailer(auStack34[0],options,p_out);
    udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 6) {
    uVar1 = (uint)((1 << (dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
  }
  else {
    uVar1 = 60000;
  }
  dhcp->request_timeout = (u16_t)((uVar1 + 499) / 500);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void dhcp_check(netif *netif)

{
  dhcp *dhcp;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\b');
  etharp_query(netif,&dhcp->offered_ip_addr,(pbuf *)0x0);
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  dhcp->request_timeout = 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void dhcp_bind(netif *netif)

{
  byte bVar1;
  dhcp *dhcp;
  u16_t uVar2;
  uint uVar3;
  int iVar4;
  ip4_addr_t iStack24;
  ip4_addr_t sn_mask;
  ip4_addr_t gw_addr;
  
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  dhcp = (dhcp *)netif->client_data[0];
  if (dhcp == (dhcp *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  dhcp->lease_used = 0;
  if (dhcp->offered_t0_lease != 0xffffffff) {
    uVar3 = dhcp->offered_t0_lease + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 == 0) {
        dhcp->t0_timeout = 1;
        goto LAB_2303d354;
      }
    }
    else {
      uVar2 = 0xffff;
    }
    dhcp->t0_timeout = uVar2;
  }
LAB_2303d354:
  if (dhcp->offered_t1_renew != 0xffffffff) {
    uVar3 = dhcp->offered_t1_renew + 0x1e;
    if (uVar3 < 0x3c0000) {
      uVar3 = uVar3 / 0x3c;
      uVar2 = (u16_t)uVar3;
      if (uVar3 != 0) goto LAB_2303d376;
      dhcp->t1_timeout = 1;
    }
    else {
      uVar2 = 0xffff;
LAB_2303d376:
      dhcp->t1_timeout = uVar2;
    }
    dhcp->t1_renew_time = dhcp->t1_timeout;
  }
  if (dhcp->offered_t2_rebind == 0xffffffff) goto LAB_2303d3b0;
  uVar3 = dhcp->offered_t2_rebind + 0x1e;
  if (uVar3 < 0x3c0000) {
    uVar3 = uVar3 / 0x3c;
    uVar2 = (u16_t)uVar3;
    if (uVar3 != 0) goto LAB_2303d3a4;
    dhcp->t2_timeout = 1;
  }
  else {
    uVar2 = 0xffff;
LAB_2303d3a4:
    dhcp->t2_timeout = uVar2;
  }
  dhcp->t2_rebind_time = dhcp->t2_timeout;
LAB_2303d3b0:
  if ((dhcp->t2_timeout <= dhcp->t1_timeout) && (dhcp->t2_timeout != 0)) {
    dhcp->t1_timeout = 0;
  }
  if (dhcp->subnet_mask_given == '\0') {
    bVar1 = *(byte *)&(dhcp->offered_ip_addr).addr;
    if ((char)bVar1 < '\0') {
      if (bVar1 < 0xc0) {
        iVar4 = 0x10000;
      }
      else {
        iVar4 = 0x1000000;
      }
      iStack24 = iVar4 - 1;
    }
    else {
      iStack24 = 0xff;
    }
  }
  else {
    iStack24 = (dhcp->offered_sn_mask).addr;
  }
  sn_mask = (dhcp->offered_gw_addr).addr;
  if ((ip4_addr_t)sn_mask == (ip4_addr_t)0x0) {
    sn_mask = (dhcp->offered_ip_addr).addr & iStack24 | 0x1000000;
  }
  dhcp_set_state(dhcp,'\n');
  netif_set_addr(netif,&dhcp->offered_ip_addr,&iStack24,&sn_mask);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dhcp_inc_pcb_refcount(void)

{
  udp_pcb *pcb;
  
  if (dhcp_pcb_refcount == '\0') {
    pcb = udp_new();
    if (pcb == (udp_pcb *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      dhcp_pcb = pcb;
      return -1;
    }
    dhcp_pcb = pcb;
    pcb->so_options = pcb->so_options | 0x20;
    udp_bind(pcb,&ip_addr_any,0x44);
    udp_connect(dhcp_pcb,&ip_addr_any,0x43);
    udp_recv(dhcp_pcb,dhcp_recv,(void *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  dhcp_pcb_refcount = dhcp_pcb_refcount + '\x01';
  return '\0';
}



u16_t dhcp_option_hostname(u16_t options_out_len,u8_t *options)

{
  uint uVar1;
  undefined2 in_register_0000202a;
  size_t sVar2;
  u8_t **in_a2;
  u8_t *puVar3;
  u8_t *puVar4;
  uint uVar5;
  uint uVar6;
  
  uVar1 = CONCAT22(in_register_0000202a,options_out_len);
  if ((*in_a2 != (u8_t *)0x0) && (sVar2 = strlen((char *)*in_a2), sVar2 != 0)) {
    puVar3 = *in_a2;
    uVar6 = 0x41 - uVar1;
    if (sVar2 < 0x41 - uVar1) {
      uVar6 = sVar2;
    }
    options[uVar1] = '\f';
    uVar5 = uVar1 + 2 & 0xffff;
    options[uVar1 + 1 & 0xffff] = (u8_t)uVar6;
    puVar4 = puVar3;
    uVar1 = uVar5;
    while (puVar4 != puVar3 + uVar6) {
      options[uVar1] = *puVar4;
      uVar1 = uVar1 + 1 & 0xffff;
      puVar4 = puVar4 + 1;
    }
    uVar1 = uVar5 + uVar6 & 0xffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)uVar1;
}



err_t dhcp_reboot(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t uVar2;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t value;
  undefined2 extraout_var_00;
  uint uVar3;
  int iVar4;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x03');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar3 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar3] = '9';
    options[uVar3 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar3 + 2) * 0x10000 >> 0x10);
    uVar2 = dhcp_option_short(auStack34[0],options,0x240);
    iVar4 = CONCAT22(extraout_var,uVar2);
    options[iVar4] = '2';
    options[iVar4 + 1U & 0xffff] = '\x04';
    uVar2 = (u16_t)((uint)((iVar4 + 2) * 0x10000) >> 0x10);
    auStack34[0] = uVar2;
    value = lwip_htonl((dhcp->offered_ip_addr).addr);
    auStack34[0] = dhcp_option_long(uVar2,options,value);
    options[CONCAT22(extraout_var_00,auStack34[0])] = '7';
    options[CONCAT22(extraout_var_00,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar4 = 0;
    do {
      options[auStack34[0]] = "\x01\x03\x1c\x06"[iVar4];
      auStack34[0] = (u16_t)((auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar4 = iVar4 + 1;
    } while (iVar4 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar3 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
  }
  else {
    uVar3 = 10000;
  }
  dhcp->request_timeout = (u16_t)((uVar3 + 499) / 500);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t dhcp_select(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  u16_t uVar2;
  pbuf *p_out;
  undefined2 extraout_var;
  u32_t uVar3;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar4;
  int iVar5;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  eVar1 = -0x10;
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    eVar1 = -6;
    if (dhcp != (dhcp *)0x0) {
      dhcp_set_state(dhcp,'\x01');
      p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
      eVar1 = -1;
      if (p_out != (pbuf *)0x0) {
        uVar4 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar4] = '9';
        options[uVar4 + 1 & 0xffff] = '\x02';
        auStack34[0] = (u16_t)((uVar4 + 2) * 0x10000 >> 0x10);
        uVar2 = dhcp_option_short(auStack34[0],options,netif->mtu);
        iVar5 = CONCAT22(extraout_var,uVar2);
        options[iVar5] = '2';
        options[iVar5 + 1U & 0xffff] = '\x04';
        uVar2 = (u16_t)((uint)((iVar5 + 2) * 0x10000) >> 0x10);
        auStack34[0] = uVar2;
        uVar3 = lwip_htonl((dhcp->offered_ip_addr).addr);
        uVar2 = dhcp_option_long(uVar2,options,uVar3);
        iVar5 = CONCAT22(extraout_var_00,uVar2);
        options[iVar5] = '6';
        options[iVar5 + 1U & 0xffff] = '\x04';
        uVar2 = (u16_t)((uint)((iVar5 + 2) * 0x10000) >> 0x10);
        auStack34[0] = uVar2;
        uVar3 = lwip_htonl((dhcp->server_ip_addr).addr);
        auStack34[0] = dhcp_option_long(uVar2,options,uVar3);
        options[CONCAT22(extraout_var_01,auStack34[0])] = '7';
        options[CONCAT22(extraout_var_01,auStack34[0]) + 1U & 0xffff] = '\x04';
        auStack34[0] = auStack34[0] + 2;
        iVar5 = 0;
        do {
          options[auStack34[0]] = "\x01\x03\x1c\x06"[iVar5];
          auStack34[0] = (u16_t)((auStack34[0] + 1) * 0x10000 >> 0x10);
          iVar5 = iVar5 + 1;
        } while (iVar5 != 4);
        auStack34[0] = dhcp_option_hostname(auStack34[0],options);
        dhcp_option_trailer(auStack34[0],options,p_out);
        eVar1 = udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      if (dhcp->tries < 6) {
        uVar4 = (uint)((1 << (dhcp->tries & 0x1f)) * 0x3e80000) >> 0x10;
      }
      else {
        uVar4 = 60000;
      }
      dhcp->request_timeout = (u16_t)((uVar4 + 499) / 500);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void dhcp_dec_pcb_refcount(void)

{
  dhcp_pcb_refcount = dhcp_pcb_refcount + -1;
  if (dhcp_pcb_refcount == '\0') {
    udp_remove(dhcp_pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    dhcp_pcb = (udp_pcb *)0x0;
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dhcp_handle_ack(dhcp_msg *msg_in)

{
  u8_t uVar1;
  u32_t uVar2;
  int in_a1;
  uint uVar3;
  ip_addr_t iStack20;
  ip_addr_t dns_addr;
  
  uVar1 = dhcp_rx_options_given[3];
  *(undefined4 *)(msg_in->chaddr + 4) = 0;
  *(undefined4 *)(msg_in->chaddr + 8) = 0;
  if (uVar1 != '\0') {
    *(u32_t *)(msg_in->chaddr + 0xc) = dhcp_rx_options_val[3];
  }
  uVar3 = dhcp_rx_options_val[4];
  if (dhcp_rx_options_given[4] == '\0') {
    uVar3 = *(uint *)(msg_in->chaddr + 0xc) >> 1;
  }
  *(uint *)msg_in->sname = uVar3;
  uVar3 = dhcp_rx_options_val[5];
  if (dhcp_rx_options_given[5] == '\0') {
    uVar3 = (uint)(*(int *)(msg_in->chaddr + 0xc) * 7) >> 3;
  }
  *(uint *)(msg_in->sname + 4) = uVar3;
  *(undefined4 *)msg_in->chaddr = *(undefined4 *)(in_a1 + 0x10);
  if (dhcp_rx_options_given[6] == '\0') {
    *(undefined *)((int)&msg_in->xid + 3) = 0;
  }
  else {
    uVar2 = lwip_htonl(dhcp_rx_options_val[6]);
    *(u32_t *)(msg_in->chaddr + 4) = uVar2;
    *(undefined *)((int)&msg_in->xid + 3) = 1;
  }
  if (dhcp_rx_options_given[7] != '\0') {
    uVar2 = lwip_htonl(dhcp_rx_options_val[7]);
    *(u32_t *)(msg_in->chaddr + 8) = uVar2;
  }
  if (dhcp_rx_options_given[8] != '\0') {
    iStack20 = lwip_htonl(dhcp_rx_options_val[8]);
    dns_setserver('\0',&iStack20);
    if (dhcp_rx_options_given[9] != '\0') {
      iStack20 = lwip_htonl(dhcp_rx_options_val[9]);
      dns_setserver('\x01',&iStack20);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dhcp_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  pbuf **pppVar4;
  netif *netif;
  uint uVar5;
  void *pvVar6;
  u16_t uVar7;
  u32_t uVar8;
  undefined2 extraout_var;
  void *pvVar9;
  uint uVar10;
  char *pcVar11;
  uint uVar12;
  u8_t *puVar13;
  u32_t *puVar14;
  pbuf *buf;
  uint uVar15;
  uint uVar16;
  int iVar17;
  uint uVar18;
  void *pvStack96;
  u32_t uStack68;
  u32_t value;
  
  netif = ip_data.current_input_netif;
  puVar14 = (u32_t *)(ip_data.current_input_netif)->client_data[0];
  if ((((puVar14 != (u32_t *)0x0) && (*(char *)(puVar14 + 1) != '\0')) && (0x2b < p->len)) &&
     (pcVar11 = (char *)p->payload, *pcVar11 == '\x02')) {
    uVar16 = 0;
    do {
      if (((uint)(ip_data.current_input_netif)->hwaddr_len <= (uVar16 & 0xff)) || (uVar16 == 6)) {
        uVar8 = lwip_htonl(*(u32_t *)(pcVar11 + 4));
        if ((uVar8 == *puVar14) && (memset(dhcp_rx_options_given,0,10), 0x2b < p->len)) {
          uVar16 = (uint)p->tot_len;
          bVar3 = false;
          uVar18 = 0xf0;
          buf = p;
          goto LAB_2303da8a;
        }
        break;
      }
      puVar13 = (ip_data.current_input_netif)->hwaddr + uVar16;
      iVar17 = uVar16 + 0x1c;
      uVar16 = uVar16 + 1;
    } while (pcVar11[iVar17] == *puVar13);
  }
free_pbuf_and_return:
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
LAB_2303da8a:
  do {
    uVar12 = (uint)buf->len;
    if (uVar18 < uVar12) {
      pvStack96 = buf->payload;
      uVar12 = uVar18;
LAB_2303dccc:
      if (uVar16 <= uVar12) goto LAB_2303dce2;
      bVar2 = *(byte *)((int)pvStack96 + uVar12);
      if (bVar2 == 0xff) goto LAB_2303dce2;
      uVar15 = uVar12 + 2 & 0xffff;
      if (uVar15 < uVar12) break;
      if (uVar12 + 1 < (uint)buf->len) {
        bVar1 = ((byte *)((int)pvStack96 + uVar12))[1];
LAB_2303db20:
        uVar10 = (uint)bVar1;
        if (bVar2 == 0x33) {
          if (uVar10 != 4) break;
          uVar5 = 4;
          iVar17 = 3;
        }
        else {
          if (bVar2 < 0x34) {
            if (bVar2 == 1) {
              if (uVar10 == 4) {
                uVar5 = 4;
                iVar17 = 6;
                goto LAB_2303dba6;
              }
              break;
            }
            if (bVar2 == 0) goto LAB_2303dc92;
            if (bVar2 != 3) goto LAB_2303db3e;
            if (uVar10 < 4) break;
            iVar17 = 7;
            uVar5 = 4;
          }
          else {
            if (bVar2 == 0x36) {
LAB_2303dc78:
              if (uVar10 != 4) break;
              uVar5 = 4;
              iVar17 = 2;
            }
            else {
              if (bVar2 < 0x37) {
                if (bVar2 == 0x34) goto LAB_2303dc62;
LAB_2303db70:
                if (bVar2 == 0x35) {
                  if (uVar10 != 1) break;
                  uVar5 = 1;
                  iVar17 = 1;
                }
                else {
LAB_2303db42:
                  iVar17 = -1;
                  uVar5 = 0;
                }
              }
              else {
                if (bVar2 == 0x3a) goto LAB_2303dc86;
LAB_2303db8c:
                if (bVar2 != 0x3b) goto LAB_2303db42;
                if (uVar10 != 4) break;
                uVar5 = 4;
                iVar17 = 5;
              }
            }
          }
        }
      }
      else {
        if (buf->next != (pbuf *)0x0) {
                    // WARNING: Load size is inaccurate
          bVar1 = *buf->next->payload;
          goto LAB_2303db20;
        }
        if (bVar2 == 0x33) break;
        if (bVar2 < 0x34) {
          if (bVar2 == 1) break;
          if (bVar2 != 0) {
            if (bVar2 != 3) {
              uVar10 = 0;
LAB_2303db3e:
              if (bVar2 != 6) goto LAB_2303db42;
              if ((uVar10 & 3) == 0) {
                uVar5 = uVar10;
                if (8 < uVar10) {
                  uVar5 = 8;
                }
                if (uVar5 <= uVar10) {
                  iVar17 = 8;
                  goto LAB_2303dba6;
                }
              }
            }
            break;
          }
LAB_2303dc92:
          uVar12 = uVar12 + 1 & 0xffff;
          goto LAB_2303dc9a;
        }
        if (bVar2 == 0x36) {
          uVar10 = 0;
          goto LAB_2303dc78;
        }
        if (bVar2 < 0x37) {
          if (bVar2 != 0x34) {
            uVar10 = 0;
            goto LAB_2303db70;
          }
          uVar10 = 0;
LAB_2303dc62:
          if ((uVar10 != 1) || (uVar18 != 0xf0)) break;
          uVar5 = 1;
          iVar17 = 0;
        }
        else {
          if (bVar2 != 0x3a) {
            uVar10 = 0;
            goto LAB_2303db8c;
          }
          uVar10 = 0;
LAB_2303dc86:
          if (uVar10 != 4) break;
          uVar5 = 4;
          iVar17 = 4;
        }
      }
LAB_2303dba6:
      if (0xfffd < uVar10 + uVar12) break;
      uVar12 = uVar10 + uVar15 & 0xffff;
      if (uVar5 != 0) {
        uStack68 = 0;
        puVar13 = dhcp_rx_options_given + iVar17;
        while (*puVar13 == '\0') {
          uVar10 = uVar5;
          if (4 < uVar5) {
            uVar10 = 4;
          }
          uVar7 = pbuf_copy_partial(buf,&uStack68,(u16_t)uVar10,(u16_t)uVar15);
          if (uVar10 != CONCAT22(extraout_var,uVar7)) goto free_pbuf_and_return;
          if (uVar5 < 5) {
            if (uVar5 == 4) {
              uStack68 = lwip_htonl(uStack68);
            }
            else {
              if (uVar5 != 1) goto free_pbuf_and_return;
              uStack68 = uStack68 & 0xff;
            }
            dhcp_rx_options_given[iVar17] = '\x01';
            dhcp_rx_options_val[iVar17] = uStack68;
            break;
          }
          if ((uVar5 & 3) != 0) goto free_pbuf_and_return;
          *puVar13 = '\x01';
          uVar8 = lwip_htonl(uStack68);
          dhcp_rx_options_val[iVar17] = uVar8;
          uVar10 = uVar15 + 4 & 0xffff;
          uVar5 = uVar5 - 4 & 0xff;
          puVar13 = puVar13 + 1;
          if (uVar10 < uVar15) goto free_pbuf_and_return;
          iVar17 = iVar17 + 1;
          uVar15 = uVar10;
        }
      }
LAB_2303dc9a:
      uVar15 = (uint)buf->len;
      if (uVar15 <= uVar12) {
        uVar12 = uVar12 - uVar15 & 0xffff;
        uVar16 = uVar16 - uVar15 & 0xffff;
        if ((uVar16 <= uVar12) || (buf = buf->next, buf == (pbuf *)0x0)) break;
        pvStack96 = buf->payload;
      }
      goto LAB_2303dccc;
    }
    pppVar4 = &buf->next;
    uVar18 = uVar18 - uVar12 & 0xffff;
    uVar16 = uVar16 - uVar12 & 0xffff;
    buf = *pppVar4;
  } while (*pppVar4 != (pbuf *)0x0);
  goto free_pbuf_and_return;
LAB_2303dce2:
  if (dhcp_rx_options_given[0] != '\0') {
    dhcp_rx_options_given[0] = '\0';
    if (dhcp_rx_options_val[0] == 1) {
LAB_2303dd96:
      uVar16 = 0xec;
      uVar18 = 0x6c;
      buf = p;
      goto LAB_2303da8a;
    }
    if (dhcp_rx_options_val[0] == 2) goto LAB_2303dd80;
    if (dhcp_rx_options_val[0] == 3) {
      bVar3 = true;
      goto LAB_2303dd96;
    }
  }
  if (!bVar3) {
    if (dhcp_rx_options_given[1] == '\0') goto free_pbuf_and_return;
    pvVar9 = p->payload;
    if ((char)dhcp_rx_options_val[1] != '\x05') {
      if ((char)dhcp_rx_options_val[1] == '\x06') {
        if (((byte)(*(char *)((int)puVar14 + 5) - 3U) < 3) ||
           (*(char *)((int)puVar14 + 5) == '\x01')) {
          dhcp_set_state((dhcp *)netif->client_data[0],'\f');
          netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                         (ip4_addr_t *)&ip_addr_any);
          dhcp_discover(netif);
        }
      }
      else {
        if ((((char)dhcp_rx_options_val[1] == '\x02') && (*(char *)((int)puVar14 + 5) == '\x06')) &&
           (dhcp_rx_options_given[2] != '\0')) {
          pvVar6 = netif->client_data[0];
          *(undefined2 *)((int)pvVar6 + 8) = 0;
          uVar8 = lwip_htonl(dhcp_rx_options_val[2]);
          *(u32_t *)((int)pvVar6 + 0x18) = uVar8;
          *(undefined4 *)((int)pvVar6 + 0x1c) = *(undefined4 *)((int)pvVar9 + 0x10);
          dhcp_select(netif);
        }
      }
      goto free_pbuf_and_return;
    }
    if (*(char *)((int)puVar14 + 5) == '\x01') {
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
      if ((netif->flags & 8) != 0) {
        dhcp_check(netif);
        goto free_pbuf_and_return;
      }
    }
    else {
      if (2 < (byte)(*(char *)((int)puVar14 + 5) - 3U)) goto free_pbuf_and_return;
      dhcp_handle_ack((dhcp_msg *)netif->client_data[0]);
    }
    dhcp_bind(netif);
    goto free_pbuf_and_return;
  }
LAB_2303dd80:
  bVar3 = false;
  uVar16 = 0x6c;
  uVar18 = 0x2c;
  buf = p;
  goto LAB_2303da8a;
}



void dhcp_network_changed(netif *netif)

{
  byte bVar1;
  void *pvVar2;
  
  pvVar2 = netif->client_data[0];
  if (pvVar2 == (void *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  bVar1 = *(byte *)((int)pvVar2 + 5);
  if (bVar1 < 6) {
    if (2 < bVar1) {
LAB_2303dec6:
      *(undefined *)((int)pvVar2 + 6) = 0;
      dhcp_reboot(netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (bVar1 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  else {
    if (bVar1 == 10) goto LAB_2303dec6;
  }
  *(undefined *)((int)pvVar2 + 6) = 0;
  dhcp_discover(netif);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dhcp_arp_reply(netif *netif,ip4_addr_t *addr)

{
  dhcp *dhcp;
  u8_t *options;
  pbuf *p_out;
  u32_t value;
  uint uVar1;
  u16_t options_out_len_00;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  if (netif != (netif *)0x0) {
    dhcp = (dhcp *)netif->client_data[0];
    if (((dhcp != (dhcp *)0x0) && (dhcp->state == '\b')) &&
       (addr->addr == (dhcp->offered_ip_addr).addr)) {
      dhcp_set_state(dhcp,'\f');
      p_out = dhcp_create_msg(netif,dhcp,'\x04',auStack34);
      if (p_out != (pbuf *)0x0) {
        uVar1 = (uint)auStack34[0];
        options = (u8_t *)((int)p_out->payload + 0xf0);
        options[uVar1] = '2';
        options[uVar1 + 1 & 0xffff] = '\x04';
        options_out_len_00 = (u16_t)((uVar1 + 2) * 0x10000 >> 0x10);
        auStack34[0] = options_out_len_00;
        value = lwip_htonl((dhcp->offered_ip_addr).addr);
        auStack34[0] = dhcp_option_long(options_out_len_00,options,value);
        dhcp_option_trailer(auStack34[0],options,p_out);
        udp_sendto_if_src(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif,&ip_addr_any);
        pbuf_free(p_out);
      }
      if (dhcp->tries != -1) {
        dhcp->tries = dhcp->tries + '\x01';
      }
      dhcp->request_timeout = 0x14;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dhcp_renew(netif *netif)

{
  u8_t *options;
  dhcp *dhcp;
  err_t eVar1;
  pbuf *p_out;
  undefined2 extraout_var;
  uint uVar2;
  int iVar3;
  u16_t auStack34 [2];
  u16_t options_out_len;
  
  dhcp = (dhcp *)netif->client_data[0];
  dhcp_set_state(dhcp,'\x05');
  p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack34);
  eVar1 = -1;
  if (p_out != (pbuf *)0x0) {
    uVar2 = (uint)auStack34[0];
    options = (u8_t *)((int)p_out->payload + 0xf0);
    options[uVar2] = '9';
    options[uVar2 + 1 & 0xffff] = '\x02';
    auStack34[0] = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
    auStack34[0] = dhcp_option_short(auStack34[0],options,netif->mtu);
    options[CONCAT22(extraout_var,auStack34[0])] = '7';
    options[CONCAT22(extraout_var,auStack34[0]) + 1U & 0xffff] = '\x04';
    auStack34[0] = auStack34[0] + 2;
    iVar3 = 0;
    do {
      options[auStack34[0]] = "\x01\x03\x1c\x06"[iVar3];
      auStack34[0] = (u16_t)((auStack34[0] + 1) * 0x10000 >> 0x10);
      iVar3 = iVar3 + 1;
    } while (iVar3 != 4);
    auStack34[0] = dhcp_option_hostname(auStack34[0],options);
    dhcp_option_trailer(auStack34[0],options,p_out);
    eVar1 = udp_sendto_if(dhcp_pcb,p_out,&dhcp->server_ip_addr,0x43,netif);
    pbuf_free(p_out);
  }
  if (dhcp->tries != -1) {
    dhcp->tries = dhcp->tries + '\x01';
  }
  if (dhcp->tries < 10) {
    uVar2 = (uint)dhcp->tries * 0x7d00000 >> 0x10;
  }
  else {
    uVar2 = 20000;
  }
  dhcp->request_timeout = (u16_t)((uVar2 + 499) / 500);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u8_t dhcp_supplied_address(netif *netif)

{
  bool bVar1;
  uint uVar2;
  
  if ((netif != (netif *)0x0) && (netif->client_data[0] != (void *)0x0)) {
    uVar2 = (uint)*(byte *)((int)netif->client_data[0] + 5);
    bVar1 = true;
    if (uVar2 != 10) {
      bVar1 = uVar2 - 4 < 2;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (u8_t)bVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



// WARNING: Type propagation algorithm not settling

void dhcp_release_and_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len_00;
  u16_t uStack38;
  u16_t options_out_len;
  ip_addr_t iStack36;
  ip_addr_t server_ip_addr;
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    iStack36 = (ip_addr_t)(dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len_00 = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len_00;
      value = lwip_htonl((u32_t)iStack36);
      uStack38 = dhcp_option_long(options_out_len_00,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,(ip_addr_t *)&stack0xffffffdc,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dhcp_start(netif *netif)

{
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  dhcp *dhcp;
  
  iVar1 = -0x10;
  if ((netif == (netif *)0x0) || (iVar1 = -0x10, (netif->flags & 1) == 0)) goto LAB_2303e28c;
  dhcp = (dhcp *)netif->client_data[0];
  if (0x23f < netif->mtu) {
    if (dhcp == (dhcp *)0x0) {
      dhcp = (dhcp *)mem_malloc(0x34);
      if (dhcp == (dhcp *)0x0) goto LAB_2303e24a;
      netif->client_data[0] = dhcp;
    }
    else {
      if (dhcp->pcb_allocated != '\0') {
        dhcp_dec_pcb_refcount();
      }
    }
    memset(dhcp,0,0x34);
    eVar2 = dhcp_inc_pcb_refcount();
    iVar1 = CONCAT31(extraout_var,eVar2);
    if (iVar1 == 0) {
      dhcp->pcb_allocated = '\x01';
      if ((netif->flags & 4) == 0) {
        dhcp_set_state(dhcp,'\x02');
        goto LAB_2303e28c;
      }
      eVar2 = dhcp_discover(netif);
      iVar1 = CONCAT31(extraout_var_00,eVar2);
      if (iVar1 == 0) goto LAB_2303e28c;
      dhcp_release_and_stop(netif);
    }
  }
LAB_2303e24a:
  iVar1 = -1;
LAB_2303e28c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



void dhcp_coarse_tmr(void)

{
  netif *netif;
  dhcp *dhcp;
  pbuf *p_out;
  undefined2 extraout_var;
  short sVar1;
  void *pvVar2;
  uint uVar3;
  int iVar4;
  u8_t *options;
  u16_t auStack50 [2];
  u16_t options_out_len;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    pvVar2 = netif->client_data[0];
    if ((pvVar2 != (void *)0x0) && (*(char *)((int)pvVar2 + 5) != '\0')) {
      if ((*(short *)((int)pvVar2 + 0x14) == 0) ||
         (sVar1 = *(short *)((int)pvVar2 + 0x12) + 1, *(short *)((int)pvVar2 + 0x12) = sVar1,
         *(short *)((int)pvVar2 + 0x14) != sVar1)) {
        sVar1 = *(short *)((int)pvVar2 + 0x10);
        if ((sVar1 == 0) || (*(short *)((int)pvVar2 + 0x10) = sVar1 + -1, sVar1 != 1)) {
          sVar1 = *(short *)((int)pvVar2 + 0xe);
          if ((sVar1 != 0) && (*(short *)((int)pvVar2 + 0xe) = sVar1 + -1, sVar1 == 1)) {
            pvVar2 = netif->client_data[0];
            if (((*(byte *)((int)pvVar2 + 5) & 0xfb) == 1) || (*(byte *)((int)pvVar2 + 5) == 10)) {
              dhcp_renew(netif);
              iVar4 = (uint)*(ushort *)((int)pvVar2 + 0xc) - (uint)*(ushort *)((int)pvVar2 + 0x12);
              if (1 < iVar4) {
                *(short *)((int)pvVar2 + 0xe) = (short)(iVar4 >> 1);
              }
            }
          }
        }
        else {
          dhcp = (dhcp *)netif->client_data[0];
          if ((dhcp->state < 0xb) && ((0x432U >> (dhcp->state & 0x1f) & 1) != 0)) {
            dhcp_set_state(dhcp,'\x04');
            p_out = dhcp_create_msg(netif,dhcp,'\x03',auStack50);
            if (p_out != (pbuf *)0x0) {
              uVar3 = (uint)auStack50[0];
              options = (u8_t *)((int)p_out->payload + 0xf0);
              options[uVar3] = '9';
              options[uVar3 + 1 & 0xffff] = '\x02';
              auStack50[0] = (u16_t)((uVar3 + 2) * 0x10000 >> 0x10);
              auStack50[0] = dhcp_option_short(auStack50[0],options,netif->mtu);
              options[CONCAT22(extraout_var,auStack50[0])] = '7';
              options[CONCAT22(extraout_var,auStack50[0]) + 1U & 0xffff] = '\x04';
              auStack50[0] = auStack50[0] + 2;
              iVar4 = 0;
              do {
                options[auStack50[0]] = "\x01\x03\x1c\x06"[iVar4];
                auStack50[0] = (u16_t)((auStack50[0] + 1) * 0x10000 >> 0x10);
                iVar4 = iVar4 + 1;
              } while (iVar4 != 4);
              auStack50[0] = dhcp_option_hostname(auStack50[0],options);
              dhcp_option_trailer(auStack50[0],options,p_out);
              udp_sendto_if(dhcp_pcb,p_out,&ip_addr_broadcast,0x43,netif);
              pbuf_free(p_out);
            }
            if (dhcp->tries != -1) {
              dhcp->tries = dhcp->tries + '\x01';
            }
            uVar3 = 10000;
            if (dhcp->tries < 10) {
              uVar3 = (uint)dhcp->tries * 0x3e80000 >> 0x10;
            }
            dhcp->request_timeout = (u16_t)((uVar3 + 499) / 500);
            iVar4 = (uint)dhcp->t0_timeout - (uint)dhcp->lease_used;
            if (1 < iVar4) {
              dhcp->t2_rebind_time = (u16_t)(iVar4 >> 1);
            }
          }
        }
      }
      else {
        dhcp_release_and_stop(netif);
        dhcp_start(netif);
      }
    }
    netif = netif->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void dhcp_fine_tmr(void)

{
  char cVar1;
  ushort uVar2;
  netif *netif;
  void *pvVar3;
  
  netif = netif_list;
  do {
    if (netif == (netif *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    pvVar3 = netif->client_data[0];
    if (pvVar3 != (void *)0x0) {
      uVar2 = *(ushort *)((int)pvVar3 + 8);
      if (uVar2 < 2) {
        if (uVar2 == 1) {
          *(undefined2 *)((int)pvVar3 + 8) = 0;
          pvVar3 = netif->client_data[0];
          cVar1 = *(char *)((int)pvVar3 + 5);
          if ((cVar1 == '\f') || (cVar1 == '\x06')) {
LAB_2303e534:
            dhcp_discover(netif);
          }
          else {
            if (cVar1 == '\x01') {
              if (*(byte *)((int)pvVar3 + 6) < 6) {
                dhcp_select(netif);
              }
              else {
                dhcp_release_and_stop(netif);
                dhcp_start(netif);
              }
            }
            else {
              if (cVar1 == '\b') {
                if (*(byte *)((int)pvVar3 + 6) < 2) {
                  dhcp_check(netif);
                }
                else {
                  dhcp_bind(netif);
                }
              }
              else {
                if (cVar1 == '\x03') {
                  if (1 < *(byte *)((int)pvVar3 + 6)) goto LAB_2303e534;
                  dhcp_reboot(netif);
                }
              }
            }
          }
        }
      }
      else {
        *(ushort *)((int)pvVar3 + 8) = uVar2 - 1;
      }
    }
    netif = netif->next;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

void dhcp_stop(netif *netif)

{
  dhcp *dhcp;
  u8_t uVar1;
  undefined3 extraout_var;
  pbuf *p_out;
  u32_t value;
  uint uVar2;
  u8_t *options;
  u16_t options_out_len;
  u16_t uStack38;
  ip_addr_t aiStack36 [3];
  
  dhcp = (dhcp *)netif->client_data[0];
  if ((dhcp != (dhcp *)0x0) && (dhcp->state != '\0')) {
    aiStack36[0] = (dhcp->server_ip_addr).addr;
    (dhcp->offered_ip_addr).addr = 0;
    (dhcp->server_ip_addr).addr = 0;
    (dhcp->offered_sn_mask).addr = 0;
    (dhcp->offered_gw_addr).addr = 0;
    dhcp->offered_t2_rebind = 0;
    dhcp->offered_t1_renew = 0;
    dhcp->offered_t0_lease = 0;
    dhcp->t1_renew_time = 0;
    *(undefined4 *)&dhcp->t2_rebind_time = 0;
    dhcp->t0_timeout = 0;
    uVar1 = dhcp_supplied_address(netif);
    if ((CONCAT31(extraout_var,uVar1) != 0) &&
       (p_out = dhcp_create_msg(netif,dhcp,'\a',&uStack38), p_out != (pbuf *)0x0)) {
      uVar2 = (uint)uStack38;
      options = (u8_t *)((int)p_out->payload + 0xf0);
      options[uVar2] = '6';
      options[uVar2 + 1 & 0xffff] = '\x04';
      options_out_len = (u16_t)((uVar2 + 2) * 0x10000 >> 0x10);
      uStack38 = options_out_len;
      value = lwip_htonl(aiStack36[0]);
      uStack38 = dhcp_option_long(options_out_len,options,value);
      dhcp_option_trailer(uStack38,options,p_out);
      udp_sendto_if(dhcp_pcb,p_out,aiStack36,0x43,netif);
      pbuf_free(p_out);
    }
    netif_set_addr(netif,(ip4_addr_t *)&ip_addr_any,(ip4_addr_t *)&ip_addr_any,
                   (ip4_addr_t *)&ip_addr_any);
    dhcp_set_state(dhcp,'\0');
    if (dhcp->pcb_allocated != '\0') {
      dhcp_dec_pcb_refcount();
      dhcp->pcb_allocated = '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void etharp_free_entry(int i)

{
  pbuf *p;
  
  p = arp_table[i].q;
  if (p != (pbuf *)0x0) {
    pbuf_free(p);
    arp_table[i].q = (pbuf *)0x0;
  }
  arp_table[i].state = '\0';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



s16_t etharp_find_entry(ip4_addr_t *ipaddr,u8_t flags,netif *netif)

{
  ushort uVar1;
  ushort uVar2;
  int iVar3;
  int iVar4;
  int i;
  undefined3 in_register_0000202d;
  etharp_entry *peVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  ushort uVar10;
  ushort uVar11;
  
  peVar5 = arp_table;
  uVar2 = 0;
  uVar11 = 0;
  uVar10 = 0;
  iVar3 = 10;
  iVar7 = 0;
  iVar9 = 10;
  iVar4 = 10;
  iVar6 = 10;
  do {
    i = iVar6;
    if (iVar6 == 10) {
      i = iVar7;
    }
    if (peVar5->state != '\0') {
      if (((ipaddr != (ip4_addr_t *)0x0) && (ipaddr->addr == (peVar5->ipaddr).addr)) &&
         ((netif == (netif *)0x0 || (peVar5->netif == netif)))) goto LAB_2303e6a0;
      uVar1 = peVar5->ctime;
      if (peVar5->state == '\x01') {
        if (peVar5->q == (pbuf *)0x0) {
          i = iVar6;
          if (uVar11 <= uVar1) {
            iVar4 = iVar7;
            uVar11 = uVar1;
          }
        }
        else {
          i = iVar6;
          if (uVar10 <= uVar1) {
            iVar3 = iVar7;
            uVar10 = uVar1;
          }
        }
      }
      else {
        i = iVar6;
        if (uVar2 <= uVar1) {
          iVar9 = iVar7;
          uVar2 = uVar1;
        }
      }
    }
    uVar8 = iVar7 + 1U & 0xffff;
    peVar5 = peVar5 + 1;
    iVar7 = (int)(short)uVar8;
    iVar6 = i;
  } while (uVar8 != 10);
  iVar7 = -1;
  if (CONCAT31(in_register_0000202d,flags) == 1) {
    if (i == 10) {
      i = iVar9;
      if (((iVar9 == 10) && (i = iVar4, iVar4 == 10)) && (i = iVar3, iVar3 == 10))
      goto LAB_2303e6a0;
      etharp_free_entry(i);
    }
    if (ipaddr != (ip4_addr_t *)0x0) {
      arp_table[i].ipaddr.addr = ipaddr->addr;
    }
    arp_table[i].ctime = 0;
    arp_table[i].netif = netif;
    iVar7 = i;
  }
LAB_2303e6a0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (s16_t)iVar7;
}



err_t etharp_raw(netif *netif,eth_addr *ethsrc_addr,eth_addr *ethdst_addr,eth_addr *hwsrc_addr,
                ip4_addr_t *ipsrc_addr,eth_addr *hwdst_addr,ip4_addr_t *ipdst_addr,u16_t opcode)

{
  undefined *puVar1;
  err_t eVar2;
  u16_t uVar3;
  pbuf *p;
  
  p = pbuf_alloc(PBUF_LINK,0x1c,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    eVar2 = -1;
    lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
  }
  else {
    puVar1 = (undefined *)p->payload;
    uVar3 = lwip_htons(opcode);
    puVar1[6] = (char)uVar3;
    puVar1[7] = (char)(uVar3 >> 8);
    memcpy(puVar1 + 8,hwsrc_addr,6);
    memcpy(puVar1 + 0x12,hwdst_addr,6);
    memcpy(puVar1 + 0xe,ipsrc_addr,4);
    memcpy(puVar1 + 0x18,ipdst_addr,4);
    puVar1[1] = 1;
    puVar1[2] = 8;
    puVar1[4] = 6;
    puVar1[5] = 4;
    *puVar1 = 0;
    puVar1[3] = 0;
    ethernet_output(netif,p,ethsrc_addr,ethdst_addr,0x806);
    lwip_stats.etharp.xmit = lwip_stats.etharp.xmit + 1;
    pbuf_free(p);
    eVar2 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



void etharp_cleanup_netif(netif *netif)

{
  etharp_entry *peVar1;
  int i;
  
  peVar1 = arp_table;
  i = 0;
  do {
    if ((peVar1->state != '\0') && (peVar1->netif == netif)) {
      etharp_free_entry(i);
    }
    i = i + 1;
    peVar1 = peVar1 + 1;
  } while (i != 10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void etharp_input(pbuf *p,netif *netif)

{
  bool bVar1;
  short *psVar2;
  u8_t uVar3;
  s16_t sVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  ip4_addr_t iVar6;
  eth_addr *dst;
  u8_t flags;
  pbuf *p_00;
  ip4_addr_t iStack56;
  ip4_addr_t sipaddr;
  ip4_addr_t dipaddr;
  int iVar5;
  
  if (netif != (netif *)0x0) {
    psVar2 = (short *)p->payload;
    if ((((*psVar2 == 0x100) && (*(char *)(psVar2 + 2) == '\x06')) &&
        (*(char *)((int)psVar2 + 5) == '\x04')) && (psVar2[1] == 8)) {
      lwip_stats.etharp.recv = lwip_stats.etharp.recv + 1;
      memcpy(&iStack56,psVar2 + 7,4);
      memcpy(&sipaddr,psVar2 + 0xc,4);
      iVar6 = (ip4_addr_t)(netif->ip_addr).addr;
      dst = (eth_addr *)(psVar2 + 4);
      if ((iVar6 == (ip4_addr_t)0x0) || (iVar6 != (ip4_addr_t)sipaddr)) {
        bVar1 = false;
        flags = '\x02';
      }
      else {
        bVar1 = true;
        flags = '\x01';
      }
      if ((((ip4_addr_t)iStack56 != (ip4_addr_t)0x0) &&
          (uVar3 = ip4_addr_isbroadcast_u32(iStack56,netif), CONCAT31(extraout_var,uVar3) == 0)) &&
         ((iStack56 & 0xf0) != 0xe0)) {
        sVar4 = etharp_find_entry(&iStack56,flags,netif);
        iVar5 = CONCAT22(extraout_var_00,sVar4);
        if (-1 < extraout_var_00) {
          arp_table[iVar5].state = '\x02';
          arp_table[iVar5].netif = netif;
          memcpy(&arp_table[iVar5].ethaddr,dst,6);
          p_00 = arp_table[iVar5].q;
          arp_table[iVar5].ctime = 0;
          if (p_00 != (pbuf *)0x0) {
            arp_table[iVar5].q = (pbuf *)0x0;
            ethernet_output(netif,p_00,(eth_addr *)netif->hwaddr,dst,0x800);
            pbuf_free(p_00);
          }
        }
      }
      if (psVar2[3] == 0x100) {
        if (bVar1) {
          etharp_raw(netif,(eth_addr *)netif->hwaddr,dst,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,dst,&iStack56,2);
        }
      }
      else {
        if (psVar2[3] == 0x200) {
          dhcp_arp_reply(netif,&iStack56);
        }
        else {
          lwip_stats.etharp.err = lwip_stats.etharp.err + 1;
        }
      }
    }
    else {
      lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
      lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
    }
    pbuf_free(p);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t etharp_request(netif *netif,ip4_addr_t *ipaddr)

{
  err_t eVar1;
  
  eVar1 = etharp_raw(netif,(eth_addr *)netif->hwaddr,&ethbroadcast,(eth_addr *)netif->hwaddr,
                     (ip4_addr_t *)&netif->ip_addr,&ethzero,ipaddr,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void etharp_tmr(void)

{
  u8_t uVar1;
  etharp_entry *peVar2;
  int i;
  ushort uVar3;
  
  peVar2 = arp_table;
  i = 0;
  do {
    uVar1 = peVar2->state;
    if (uVar1 != '\0') {
      uVar3 = peVar2->ctime + 1;
      peVar2->ctime = uVar3;
      if (uVar3 < 300) {
        if (uVar1 == '\x01') {
          if (4 < uVar3) goto LAB_2303ea08;
          etharp_request(peVar2->netif,&peVar2->ipaddr);
        }
        else {
          if (uVar1 == '\x03') {
            peVar2->state = '\x04';
          }
          else {
            if (uVar1 == '\x04') {
              peVar2->state = '\x02';
            }
          }
        }
      }
      else {
LAB_2303ea08:
        etharp_free_entry(i);
      }
    }
    i = i + 1;
    peVar2 = peVar2 + 1;
    if (i == 10) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  } while( true );
}



err_t etharp_output_to_arp_index(netif *netif,pbuf *q,netif_addr_idx_t arp_idx)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 in_register_00002031;
  int iVar3;
  eth_addr *ethsrc_addr;
  int iVar2;
  
  iVar3 = CONCAT31(in_register_00002031,arp_idx);
  ethsrc_addr = (eth_addr *)netif->hwaddr;
  if (arp_table[iVar3].state == '\x02') {
    if (arp_table[iVar3].ctime < 0x11d) {
      if (arp_table[iVar3].ctime < 0x10e) goto LAB_2303eaa0;
      eVar1 = etharp_raw(netif,ethsrc_addr,&arp_table[iVar3].ethaddr,ethsrc_addr,
                         (ip4_addr_t *)&netif->ip_addr,&ethzero,&arp_table[iVar3].ipaddr,1);
      iVar2 = CONCAT31(extraout_var_00,eVar1);
    }
    else {
      eVar1 = etharp_request(netif,&arp_table[iVar3].ipaddr);
      iVar2 = CONCAT31(extraout_var,eVar1);
    }
    if (iVar2 == 0) {
      arp_table[iVar3].state = '\x03';
    }
  }
LAB_2303eaa0:
  eVar1 = ethernet_output(netif,q,ethsrc_addr,&arp_table[iVar3].ethaddr,0x800);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t etharp_query(netif *netif,ip4_addr_t *ipaddr,pbuf *q)

{
  pbuf **pppVar1;
  u8_t uVar2;
  err_t eVar3;
  ushort uVar4;
  undefined3 extraout_var;
  short extraout_var_00;
  pbuf *ppVar5;
  uint uVar6;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  if (((CONCAT31(extraout_var,uVar2) != 0) || ((ipaddr->addr & 0xf0) == 0xe0)) ||
     (ipaddr->addr == 0)) {
    eVar3 = -0x10;
    goto LAB_2303eb42;
  }
  uVar4 = etharp_find_entry(ipaddr,'\x01',netif);
  if (extraout_var_00 < 0) {
    if (q != (pbuf *)0x0) {
      lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
    }
    eVar3 = (err_t)uVar4;
    goto LAB_2303eb42;
  }
  uVar6 = uVar4 & 0xff;
  if (arp_table[uVar6].state == '\0') {
    arp_table[uVar6].state = '\x01';
    arp_table[uVar6].netif = netif;
LAB_2303eb74:
    eVar3 = etharp_request(netif,ipaddr);
    if (q == (pbuf *)0x0) goto LAB_2303eb42;
  }
  else {
    eVar3 = -1;
    if (q == (pbuf *)0x0) goto LAB_2303eb74;
  }
  if (1 < arp_table[uVar6].state) {
    etharp_cached_entry = (netif_addr_idx_t)uVar6;
    eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,&arp_table[uVar6].ethaddr,0x800);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar3;
  }
  ppVar5 = q;
  if (arp_table[uVar6].state == 1) {
    do {
      if ((ppVar5->type_internal & 0x40) != 0) {
        q = pbuf_clone(PBUF_LINK,PBUF_RAM,q);
        if (q != (pbuf *)0x0) goto LAB_2303ebe4;
        eVar3 = -1;
        lwip_stats.etharp.memerr = lwip_stats.etharp.memerr + 1;
        goto LAB_2303eb42;
      }
      pppVar1 = &ppVar5->next;
      ppVar5 = *pppVar1;
    } while (*pppVar1 != (pbuf *)0x0);
    pbuf_ref(q);
LAB_2303ebe4:
    if (arp_table[uVar6].q != (pbuf *)0x0) {
      pbuf_free(arp_table[uVar6].q);
    }
    arp_table[uVar6].q = q;
    eVar3 = '\0';
  }
LAB_2303eb42:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar3;
}



// WARNING: Variable defined which should be unmapped: mcastaddr

err_t etharp_output(netif *netif,pbuf *q,ip4_addr_t *ipaddr)

{
  netif_addr_idx_t nVar1;
  u8_t uVar2;
  err_t eVar3;
  undefined3 extraout_var;
  eth_addr *dst;
  uint uVar4;
  uint uVar5;
  etharp_entry *peVar6;
  undefined2 uStack24;
  u8_t uStack22;
  byte bStack21;
  eth_addr mcastaddr;
  
  uVar2 = ip4_addr_isbroadcast_u32(ipaddr->addr,netif);
  uVar4 = CONCAT31(extraout_var,uVar2);
  if (uVar4 == 0) {
    uVar5 = ipaddr->addr;
    if ((uVar5 & 0xf0) != 0xe0) {
      if (((((netif->ip_addr).addr ^ uVar5) & (netif->netmask).addr) != 0) &&
         ((uVar5 & 0xffff) != 0xfea9)) {
        eVar3 = -4;
        if ((netif->gw).addr == 0) goto LAB_2303ed0e;
        ipaddr = (ip4_addr_t *)&netif->gw;
      }
      uVar5 = (uint)etharp_cached_entry;
      peVar6 = arp_table;
      if (((arp_table[uVar5].state < 2) || (arp_table[uVar5].netif != netif)) ||
         (ipaddr->addr != arp_table[uVar5].ipaddr.addr)) {
        do {
          if (((1 < peVar6->state) && (peVar6->netif == netif)) &&
             (nVar1 = (netif_addr_idx_t)uVar4, ipaddr->addr == (peVar6->ipaddr).addr))
          goto LAB_2303ed06;
          uVar4 = uVar4 + 1 & 0xff;
          peVar6 = peVar6 + 1;
        } while (uVar4 != 10);
        eVar3 = etharp_query(netif,ipaddr,q);
      }
      else {
        lwip_stats.etharp.cachehit = lwip_stats.etharp.cachehit + 1;
        nVar1 = etharp_cached_entry;
LAB_2303ed06:
        etharp_cached_entry = nVar1;
        eVar3 = etharp_output_to_arp_index(netif,q,etharp_cached_entry);
      }
      goto LAB_2303ed0e;
    }
    uStack24 = 1;
    uStack22 = '^';
    dst = (eth_addr *)&uStack24;
    bStack21 = *(byte *)((int)&ipaddr->addr + 1) & 0x7f;
    mcastaddr.addr[0] = *(u8_t *)((int)&ipaddr->addr + 2);
    mcastaddr.addr[1] = *(u8_t *)((int)&ipaddr->addr + 3);
  }
  else {
    dst = &ethbroadcast;
  }
  eVar3 = ethernet_output(netif,q,(eth_addr *)netif->hwaddr,dst,0x800);
LAB_2303ed0e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar3;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void igmp_send(netif *netif,igmp_group *group,u8_t type)

{
  u8_t *dataptr;
  u16_t uVar1;
  pbuf *p;
  undefined3 in_register_00002031;
  ip4_addr_t *dest;
  u8_t uVar2;
  u8_t uVar3;
  u8_t uVar4;
  u32_t uVar5;
  ip4_addr_t iStack40;
  ip4_addr_t src;
  u16_t ra [2];
  
  iStack40 = 0;
  p = pbuf_alloc(PBUF_TRANSPORT,8,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    lwip_stats.igmp.memerr = lwip_stats.igmp.memerr + 1;
  }
  else {
    iStack40 = (netif->ip_addr).addr;
    uVar5 = (group->group_address).addr;
    dataptr = (u8_t *)p->payload;
    uVar4 = (u8_t)(uVar5 >> 0x18);
    uVar2 = (u8_t)(uVar5 >> 8);
    uVar3 = (u8_t)(uVar5 >> 0x10);
    if (CONCAT31(in_register_00002031,type) == 0x16) {
      dataptr[7] = uVar4;
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dest = &group->group_address;
      group->last_reporter_flag = '\x01';
    }
    else {
      dataptr[4] = (u8_t)uVar5;
      dataptr[5] = uVar2;
      dataptr[6] = uVar3;
      dataptr[7] = uVar4;
      dest = &allrouters;
    }
    *dataptr = type;
    dataptr[1] = '\0';
    dataptr[2] = '\0';
    dataptr[3] = '\0';
    uVar1 = inet_chksum(dataptr,8);
    dataptr[2] = (u8_t)uVar1;
    dataptr[3] = (u8_t)(uVar1 >> 8);
    src = 0x494;
    lwip_stats.igmp.xmit = lwip_stats.igmp.xmit + 1;
    ip4_output_if_opt(p,&iStack40,dest,'\x01','\0','\x02',netif,&src,_DAT_00000010);
    pbuf_free(p);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void igmp_delaying_member(igmp_group *group,u8_t maxresp)

{
  uint uVar1;
  undefined3 in_register_0000202d;
  uint uVar2;
  
  uVar2 = CONCAT31(in_register_0000202d,maxresp);
  if ((group->group_state != '\x02') &&
     ((group->group_state != '\x01' || ((group->timer != 0 && (group->timer <= uVar2)))))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (2 < uVar2) {
    uVar1 = bl_rand();
    group->timer = (u16_t)(uVar1 % uVar2);
    if (uVar1 % uVar2 != 0) goto LAB_2303ee92;
  }
  group->timer = 1;
LAB_2303ee92:
  group->group_state = '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void igmp_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  allrouters = 0x20000e0;
  allsystems = 0x10000e0;
  return;
}



err_t igmp_stop(netif *netif)

{
  void **mem;
  void *pvVar1;
  
  mem = (void **)netif->client_data[1];
  netif->client_data[1] = (void *)0x0;
  while (mem != (void **)0x0) {
    pvVar1 = *mem;
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,(ip4_addr_t *)(mem + 1),NETIF_DEL_MAC_FILTER);
    }
    memp_free(MEMP_IGMP_GROUP,mem);
    mem = (void **)pvVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



// WARNING: Type propagation algorithm not settling

void igmp_report_groups(netif *netif)

{
  igmp_group *group;
  
  if ((igmp_group *)netif->client_data[1] != (igmp_group *)0x0) {
    group = ((igmp_group *)netif->client_data[1])->next;
    while (group != (igmp_group *)0x0) {
      igmp_delaying_member(group,'\x05');
      group = group->next;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



igmp_group * igmp_lookfor_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  
  piVar1 = (igmp_group *)ifp->client_data[1];
  while ((piVar1 != (igmp_group *)0x0 && ((piVar1->group_address).addr != addr->addr))) {
    piVar1 = piVar1->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return piVar1;
}



// WARNING: Type propagation algorithm not settling

igmp_group * igmp_lookup_group(netif *ifp,ip4_addr_t *addr)

{
  igmp_group *piVar1;
  igmp_group *piVar2;
  u32_t uVar3;
  
  piVar2 = igmp_lookfor_group(ifp,addr);
  if (piVar2 == (igmp_group *)0x0) {
    piVar1 = (igmp_group *)ifp->client_data[1];
    piVar2 = (igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
    if (piVar2 != (igmp_group *)0x0) {
      uVar3 = 0;
      if (addr != (ip4_addr_t *)0x0) {
        uVar3 = addr->addr;
      }
      (piVar2->group_address).addr = uVar3;
      *(undefined4 *)&piVar2->last_reporter_flag = 0;
      piVar2->use = '\0';
      if (piVar1 == (igmp_group *)0x0) {
        piVar2->next = (igmp_group *)0x0;
        ifp->client_data[1] = piVar2;
      }
      else {
        piVar2->next = piVar1->next;
        piVar1->next = piVar2;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return piVar2;
}



err_t igmp_start(netif *netif)

{
  err_t eVar1;
  igmp_group *piVar2;
  
  piVar2 = igmp_lookup_group(netif,&allsystems);
  if (piVar2 == (igmp_group *)0x0) {
    eVar1 = -1;
  }
  else {
    piVar2->group_state = '\x02';
    piVar2->use = piVar2->use + '\x01';
    eVar1 = '\0';
    if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
      (*netif->igmp_mac_filter)(netif,&allsystems,NETIF_ADD_MAC_FILTER);
      eVar1 = '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



// WARNING: Type propagation algorithm not settling

void igmp_input(pbuf *p,netif *inp,ip4_addr_t *dest)

{
  ip4_addr_t iVar1;
  char *dataptr;
  u16_t uVar2;
  undefined2 extraout_var;
  igmp_group *piVar3;
  ip4_addr_t iStack36;
  ip4_addr_t groupaddr;
  
  lwip_stats.igmp.recv = lwip_stats.igmp.recv + 1;
  if (p->len < 8) {
    pbuf_free(p);
    lwip_stats.igmp.lenerr = lwip_stats.igmp.lenerr + 1;
    goto LAB_2303f01e;
  }
  dataptr = (char *)p->payload;
  uVar2 = inet_chksum(dataptr,p->len);
  if (CONCAT22(extraout_var,uVar2) != 0) {
    pbuf_free(p);
    lwip_stats.igmp.chkerr = lwip_stats.igmp.chkerr + 1;
    goto LAB_2303f01e;
  }
  piVar3 = igmp_lookfor_group(inp,dest);
  if (piVar3 == (igmp_group *)0x0) {
    pbuf_free(p);
    lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
    goto LAB_2303f01e;
  }
  if (*dataptr == '\x11') {
    iVar1 = (ip4_addr_t)((ip4_addr_t *)(dataptr + 4))->addr;
    if (dest->addr == allsystems) {
      if (iVar1 == (ip4_addr_t)0x0) {
        if (dataptr[1] == '\0') {
          lwip_stats.igmp.rx_v1 = lwip_stats.igmp.rx_v1 + 1;
          dataptr[1] = '\n';
        }
        else {
          lwip_stats.igmp.rx_general = lwip_stats.igmp.rx_general + 1;
        }
        if ((igmp_group *)inp->client_data[1] != (igmp_group *)0x0) {
          piVar3 = ((igmp_group *)inp->client_data[1])->next;
          while (piVar3 != (igmp_group *)0x0) {
            igmp_delaying_member(piVar3,dataptr[1]);
            piVar3 = piVar3->next;
          }
        }
      }
      else {
        iStack36 = (u32_t)iVar1;
        piVar3 = igmp_lookfor_group(inp,&iStack36);
        if (piVar3 != (igmp_group *)0x0) goto LAB_2303f108;
        lwip_stats.igmp.drop = lwip_stats.igmp.drop + 1;
      }
    }
    else {
      if (iVar1 == (ip4_addr_t)0x0) goto LAB_2303f07c;
LAB_2303f108:
      lwip_stats.igmp.rx_group = lwip_stats.igmp.rx_group + 1;
      igmp_delaying_member(piVar3,dataptr[1]);
    }
  }
  else {
    if (*dataptr == '\x16') {
      lwip_stats.igmp.rx_report = lwip_stats.igmp.rx_report + 1;
      if (piVar3->group_state == '\x01') {
        *(undefined4 *)&piVar3->last_reporter_flag = 0x200;
      }
    }
    else {
LAB_2303f07c:
      lwip_stats.igmp.proterr = lwip_stats.igmp.proterr + 1;
    }
  }
  pbuf_free(p);
LAB_2303f01e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t igmp_joingroup_netif(netif *netif,ip4_addr_t *groupaddr)

{
  u16_t uVar1;
  igmp_group *group;
  uint uVar2;
  err_t eVar3;
  
  if (((groupaddr->addr & 0xf0) == 0xe0) && (eVar3 = -6, groupaddr->addr != allsystems)) {
    if ((netif->flags & 0x20) != 0) {
      group = igmp_lookup_group(netif,groupaddr);
      eVar3 = -1;
      if (group != (igmp_group *)0x0) {
        if (group->group_state == '\0') {
          if ((group->use == '\0') && (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0)) {
            (*netif->igmp_mac_filter)(netif,groupaddr,NETIF_ADD_MAC_FILTER);
          }
          lwip_stats.igmp.tx_join = lwip_stats.igmp.tx_join + 1;
          igmp_send(netif,group,'\x16');
          uVar2 = bl_rand();
          uVar1 = (u16_t)(uVar2 % 5);
          if (uVar2 % 5 == 0) {
            uVar1 = 1;
          }
          group->timer = uVar1;
          group->group_state = '\x01';
        }
        group->use = group->use + '\x01';
        eVar3 = '\0';
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t igmp_joingroup(ip4_addr_t *ifaddr,ip4_addr_t *groupaddr)

{
  netif *netif;
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  
  if ((groupaddr->addr & 0xf0) != 0xe0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -6;
  }
  iVar2 = -6;
  netif = netif_list;
  if (groupaddr->addr != allsystems) {
    while (netif != (netif *)0x0) {
      if (((netif->flags & 0x20) != 0) &&
         (((ifaddr == (ip4_addr_t *)0x0 || (ifaddr->addr == 0)) ||
          (ifaddr->addr == (netif->ip_addr).addr)))) {
        eVar1 = igmp_joingroup_netif(netif,groupaddr);
        iVar2 = CONCAT31(extraout_var,eVar1);
        if (iVar2 != 0) break;
      }
      netif = netif->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



err_t igmp_leavegroup_netif(netif *netif,ip4_addr_t *groupaddr)

{
  igmp_group *piVar1;
  igmp_group *group;
  err_t eVar2;
  igmp_group *piVar3;
  
  if (((groupaddr->addr & 0xf0) != 0xe0) || (eVar2 = -6, groupaddr->addr == allsystems)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -6;
  }
  if ((netif->flags & 0x20) != 0) {
    group = igmp_lookfor_group(netif,groupaddr);
    eVar2 = -6;
    if (group != (igmp_group *)0x0) {
      if (group->use < 2) {
        piVar1 = (igmp_group *)netif->client_data[1];
        do {
          piVar3 = piVar1;
          if (piVar3 == (igmp_group *)0x0) goto LAB_2303f2b0;
          piVar1 = piVar3->next;
        } while (group != piVar3->next);
        piVar3->next = group->next;
LAB_2303f2b0:
        if (group->last_reporter_flag != '\0') {
          lwip_stats.igmp.tx_leave = lwip_stats.igmp.tx_leave + 1;
          igmp_send(netif,group,'\x17');
        }
        if (netif->igmp_mac_filter != (netif_igmp_mac_filter_fn *)0x0) {
          (*netif->igmp_mac_filter)(netif,groupaddr,NETIF_DEL_MAC_FILTER);
        }
        memp_free(MEMP_IGMP_GROUP,group);
      }
      else {
        group->use = group->use - 1;
      }
      eVar2 = '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



err_t igmp_leavegroup(ip4_addr_t *ifaddr,ip4_addr_t *groupaddr)

{
  netif *netif;
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  
  iVar1 = -6;
  if (((groupaddr->addr & 0xf0) == 0xe0) &&
     (iVar1 = -6, netif = netif_list, groupaddr->addr != allsystems)) {
    while (netif != (netif *)0x0) {
      if (((netif->flags & 0x20) != 0) &&
         (((ifaddr == (ip4_addr_t *)0x0 || (ifaddr->addr == 0)) ||
          (ifaddr->addr == (netif->ip_addr).addr)))) {
        eVar2 = igmp_leavegroup_netif(netif,groupaddr);
        if (iVar1 != 0) {
          iVar1 = CONCAT31(extraout_var,eVar2);
        }
      }
      netif = netif->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



void igmp_tmr(void)

{
  igmp_group *group;
  netif *netif;
  u16_t uVar1;
  
  netif = netif_list;
  while (netif != (netif *)0x0) {
    group = (igmp_group *)netif->client_data[1];
    while (group != (igmp_group *)0x0) {
      if ((((group->timer != 0) && (uVar1 = group->timer - 1, group->timer = uVar1, uVar1 == 0)) &&
          (group->group_state == '\x01')) && ((group->group_address).addr != allsystems)) {
        group->group_state = '\x02';
        lwip_stats.igmp.tx_report = lwip_stats.igmp.tx_report + 1;
        igmp_send(netif,group,'\x16');
      }
      group = group->next;
    }
    netif = netif->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ip4_input_accept(netif *netif)

{
  u8_t uVar1;
  uint uVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  
  if ((netif->flags & 1) == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uVar3 = (netif->ip_addr).addr;
  uVar2 = 0;
  if (uVar3 != 0) {
    uVar2 = 1;
    if (uVar3 != ip_data.current_iphdr_dest) {
      uVar1 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (uint)(CONCAT31(extraout_var,uVar1) != 0);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



netif * ip4_route(ip4_addr_t *dest)

{
  byte bVar1;
  netif *pnVar2;
  netif *pnVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = dest->addr;
  pnVar2 = netif_list;
  if (((uVar5 & 0xf0) != 0xe0) ||
     (pnVar3 = ip4_default_multicast_netif, ip4_default_multicast_netif == (netif *)0x0)) {
    while (pnVar3 = pnVar2, pnVar3 != (netif *)0x0) {
      bVar1 = pnVar3->flags;
      if (((((bVar1 & 1) != 0) && ((bVar1 >> 2 & 1) != 0)) &&
          (uVar4 = (pnVar3->ip_addr).addr, uVar4 != 0)) &&
         ((((uVar4 ^ uVar5) & (pnVar3->netmask).addr) == 0 ||
          (((bVar1 & 2) == 0 && (uVar5 == (pnVar3->gw).addr)))))) goto LAB_2303f4be;
      pnVar2 = pnVar3->next;
    }
    if (((netif_default == (netif *)0x0) || ((netif_default->flags & 5) != 5)) ||
       (((netif_default->ip_addr).addr == 0 || (pnVar3 = netif_default, (uVar5 & 0xff) == 0x7f)))) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      lwip_stats.ip.rterr = lwip_stats.ip.rterr + 1;
      return (netif *)0x0;
    }
  }
LAB_2303f4be:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pnVar3;
}



err_t ip4_input(pbuf *p,netif *inp)

{
  byte bVar1;
  uint uVar2;
  u8_t uVar3;
  raw_input_state_t rVar4;
  u16_t uVar5;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  igmp_group *piVar6;
  undefined3 extraout_var;
  int iVar7;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  ip_hdr *dataptr;
  netif *pnVar8;
  uint uVar9;
  
  lwip_stats.ip.recv = lwip_stats.ip.recv + 1;
  dataptr = (ip_hdr *)p->payload;
  bVar1 = dataptr->_v_hl;
  if (bVar1 >> 4 != 4) {
    pbuf_free(p);
    lwip_stats.ip.err = lwip_stats.ip.err + 1;
    lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
    goto LAB_2303f512;
  }
  uVar5 = lwip_htons(dataptr->_len);
  uVar9 = bVar1 & 0xf;
  uVar2 = (uVar9 << 0x12) >> 0x10;
  if (CONCAT22(extraout_var_02,uVar5) < (uint)p->tot_len) {
    pbuf_realloc(p,uVar5);
  }
  if (((p->len < uVar2) || ((uint)p->tot_len < CONCAT22(extraout_var_02,uVar5))) || (uVar2 < 0x14))
  {
    pbuf_free(p);
    lwip_stats.ip.lenerr = lwip_stats.ip.lenerr + 1;
  }
  else {
    uVar5 = inet_chksum(dataptr,(u16_t)((uVar9 << 0x12) >> 0x10));
    if (CONCAT22(extraout_var_03,uVar5) == 0) {
      ip_data.current_iphdr_dest = (dataptr->dest).addr;
      ip_data.current_iphdr_src = (dataptr->src).addr;
      pnVar8 = inp;
      if ((ip_data.current_iphdr_dest & 0xf0) == 0xe0) {
        if (((inp->flags & 0x20) == 0) ||
           (piVar6 = igmp_lookfor_group(inp,(ip4_addr_t *)&ip_data.current_iphdr_dest),
           piVar6 == (igmp_group *)0x0)) goto LAB_2303f60e;
        if ((ip_data.current_iphdr_dest != 0x10000e0) || (ip_data.current_iphdr_src != 0))
        goto LAB_2303f63e;
      }
      else {
        iVar7 = ip4_input_accept(inp);
        if (iVar7 == 0) {
          pnVar8 = netif_list;
          if ((char)ip_data.current_iphdr_dest.addr != '\x7f') {
            while (pnVar8 != (netif *)0x0) {
              if ((pnVar8 != inp) && (iVar7 = ip4_input_accept(pnVar8), iVar7 != 0))
              goto LAB_2303f63e;
              pnVar8 = pnVar8->next;
            }
          }
        }
        else {
          if (inp != (netif *)0x0) goto LAB_2303f63e;
        }
LAB_2303f60e:
        if ((dataptr->_proto != '\x11') || (pnVar8 = inp, (&dataptr->_len)[uVar9 * 2] != 0x4400)) {
          pnVar8 = (netif *)0x0;
LAB_2303f63e:
          if ((ip_data.current_iphdr_src != 0) &&
             ((uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_src,inp),
              CONCAT31(extraout_var,uVar3) != 0 || ((ip_data.current_iphdr_src & 0xf0) == 0xe0)))) {
            pbuf_free(p);
            goto LAB_2303f588;
          }
        }
        if (pnVar8 == (netif *)0x0) {
          lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
          pbuf_free(p);
          goto LAB_2303f512;
        }
      }
      if ((*(byte *)&dataptr->_offset & 0x3f | (uint)*(byte *)((int)&dataptr->_offset + 1) << 8) ==
          0) {
        ip_data.current_ip_header_tot_len = (u16_t)((dataptr->_v_hl & 0xf) << 2);
        ip_data.current_netif = pnVar8;
        ip_data.current_input_netif = inp;
        ip_data.current_ip4_header = dataptr;
        rVar4 = raw_input(p,inp);
        if (CONCAT31(extraout_var_00,rVar4) != 1) {
          pbuf_remove_header(p,uVar9 * 4);
          bVar1 = dataptr->_proto;
          if (bVar1 == 2) {
            igmp_input(p,inp,(ip4_addr_t *)&ip_data.current_iphdr_dest);
          }
          else {
            if (bVar1 < 3) {
              if (bVar1 == 1) {
                icmp_input(p,inp);
              }
              else {
LAB_2303f734:
                if (CONCAT31(extraout_var_00,rVar4) != 2) {
                  uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,pnVar8);
                  if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
                     ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
                    pbuf_header_force(p,(s16_t)(uVar9 * 4));
                    icmp_dest_unreach(p,ICMP_DUR_PROTO);
                  }
                  lwip_stats.ip.proterr = lwip_stats.ip.proterr + 1;
                  lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
                }
                pbuf_free(p);
              }
            }
            else {
              if (bVar1 == 6) {
                tcp_input(p,inp);
              }
              else {
                if (bVar1 != 0x11) goto LAB_2303f734;
                udp_input(p,inp);
              }
            }
          }
        }
        ip_data.current_netif = (netif *)0x0;
        ip_data.current_input_netif = (netif *)0x0;
        ip_data.current_ip4_header = (ip_hdr *)0x0;
        ip_data.current_ip_header_tot_len = 0;
        ip_data.current_iphdr_src = 0;
        ip_data.current_iphdr_dest = 0;
        goto LAB_2303f512;
      }
      pbuf_free(p);
      lwip_stats.ip.opterr = lwip_stats.ip.opterr + 1;
    }
    else {
      pbuf_free(p);
      lwip_stats.ip.chkerr = lwip_stats.ip.chkerr + 1;
    }
  }
LAB_2303f588:
  lwip_stats.ip.drop = lwip_stats.ip.drop + 1;
LAB_2303f512:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



// WARNING: Type propagation algorithm not settling

err_t ip4_output_if_opt_src
                (pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,netif *netif,
                void *ip_options,u16_t optlen)

{
  uint uVar1;
  undefined *puVar2;
  uint uVar3;
  u8_t uVar4;
  err_t eVar5;
  u16_t uVar6;
  u16_t uVar7;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  int iVar8;
  undefined3 in_register_0000203d;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  ushort in_stack_00000000;
  ip4_addr_t iStack52;
  ip4_addr_t dest_addr;
  
  uVar11 = (uint)in_stack_00000000;
  if (dest == (ip4_addr_t *)0x0) {
    if (0x13 < p->len) {
      dest = &iStack52;
      iStack52 = ((ip4_addr_t *)((int)p->payload + 0x10))->addr;
      goto LAB_2303f9c0;
    }
  }
  else {
    if (uVar11 == 0) {
      uVar3 = 0x14;
      iVar12 = 0;
    }
    else {
      if (0x28 < uVar11) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        lwip_stats.ip.err = lwip_stats.ip.err + 1;
        return -6;
      }
      uVar1 = uVar11 + 3 & 0xfffc;
      uVar4 = pbuf_add_header(p,uVar1);
      uVar3 = uVar1 + 0x14 & 0xffff;
      if (CONCAT31(extraout_var,uVar4) != 0) goto LAB_2303f856;
      memcpy(p->payload,ip_options,uVar11);
      if (uVar11 < uVar1) {
        memset((void *)((int)p->payload + uVar11),0,uVar1 - uVar11);
      }
      iVar9 = 0;
      iVar12 = 0;
      do {
        iVar8 = iVar9 * 2;
        iVar9 = iVar9 + 1;
        iVar12 = iVar12 + (uint)*(ushort *)(iVar8 + (int)p->payload);
      } while (iVar9 < (int)(uVar1 >> 1));
    }
    uVar4 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var_00,uVar4) == 0) {
      puVar2 = (undefined *)p->payload;
      puVar2[8] = ttl;
      puVar2[9] = proto;
      uVar1 = dest->addr;
      uVar10 = CONCAT31(in_register_00002035,ttl) << 8 | CONCAT31(in_register_0000203d,proto);
      puVar2[0x10] = (char)uVar1;
      puVar2[0x11] = (char)(uVar1 >> 8);
      puVar2[0x12] = (char)(uVar1 >> 0x10);
      uVar11 = uVar3 >> 2 & 0xff | 0x40;
      *puVar2 = (char)uVar11;
      uVar11 = uVar11 << 8 | CONCAT31(in_register_00002039,tos);
      puVar2[0x13] = (char)(uVar1 >> 0x18);
      puVar2[1] = tos;
      uVar6 = lwip_htons(p->tot_len);
      puVar2[2] = (char)uVar6;
      uVar7 = ip_id;
      puVar2[3] = (char)(uVar6 >> 8);
      puVar2[6] = 0;
      puVar2[7] = 0;
      uVar7 = lwip_htons(uVar7);
      puVar2[5] = (char)(uVar7 >> 8);
      puVar2[4] = (char)uVar7;
      ip_id = ip_id + 1;
      if (src == (ip4_addr_t *)0x0) {
        uVar3 = 0;
      }
      else {
        uVar3 = src->addr;
      }
      puVar2[0xf] = (char)(uVar3 >> 0x18);
      puVar2[0xc] = (char)uVar3;
      puVar2[0xd] = (char)(uVar3 >> 8);
      uVar11 = (uVar3 & 0xffff) +
               CONCAT22(extraout_var_02,uVar7) +
               (((int)uVar11 >> 8 | uVar11 << 8) & 0xffff) +
               ((uVar10 << 8 | (int)uVar10 >> 8) & 0xffff) + (uVar1 & 0xffff) + (uVar1 >> 0x10) +
               iVar12 + CONCAT22(extraout_var_01,uVar6) + (uVar3 >> 0x10);
      puVar2[0xe] = (char)(uVar3 >> 0x10);
      uVar11 = (uVar11 & 0xffff) + (uVar11 >> 0x10);
      uVar11 = ~((uVar11 >> 0x10) + uVar11);
      puVar2[10] = (char)uVar11;
      puVar2[0xb] = (char)(uVar11 >> 8);
LAB_2303f9c0:
      lwip_stats.ip.xmit = lwip_stats.ip.xmit + 1;
      eVar5 = (*netif->output)(netif,p,dest);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eVar5;
    }
  }
LAB_2303f856:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  lwip_stats.ip.err = lwip_stats.ip.err + 1;
  return -2;
}



err_t ip4_output_if_opt(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif,void *ip_options,u16_t optlen)

{
  err_t eVar1;
  
  if ((dest != (ip4_addr_t *)0x0) && ((src == (ip4_addr_t *)0x0 || (src->addr == 0)))) {
    src = (ip4_addr_t *)&netif->ip_addr;
  }
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,ip_options,optlen);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                   netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

err_t ip4_output_if_src(pbuf *p,ip4_addr_t *src,ip4_addr_t *dest,u8_t ttl,u8_t tos,u8_t proto,
                       netif *netif)

{
  err_t eVar1;
  
  eVar1 = ip4_output_if_opt_src(p,src,dest,ttl,tos,proto,netif,(void *)0x0,_DAT_00000010);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u8_t ip4_addr_isbroadcast_u32(u32_t addr,netif *netif)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  
  if (addr - 1 < 0xfffffffe) {
    bVar1 = netif->flags & 2;
    if ((netif->flags & 2) != 0) {
      uVar3 = (netif->ip_addr).addr;
      bVar1 = 0;
      if ((uVar3 != addr) && (uVar2 = (netif->netmask).addr, ((uVar3 ^ addr) & uVar2) == 0)) {
        uVar2 = ~uVar2;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return (u8_t)((uVar2 & addr) == uVar2);
      }
    }
  }
  else {
    bVar1 = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u8_t)bVar1;
}



int ip4addr_aton(char *cp,ip4_addr_t *addr)

{
  byte bVar1;
  int iVar2;
  u32_t uVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uStack32;
  u32_t parts [4];
  
  bVar1 = *cp;
  puVar4 = &uStack32;
LAB_2303fabc:
  uVar6 = (uint)bVar1;
  if ((_ctype_[uVar6 + 1] & 4) != 0) {
    iVar7 = 10;
    if (uVar6 == 0x30) {
      uVar6 = (uint)(byte)cp[1];
      if ((uVar6 & 0xdf) == 0x58) {
        uVar6 = (uint)(byte)cp[2];
        iVar7 = 0x10;
        cp = cp + 2;
      }
      else {
        cp = cp + 1;
        iVar7 = 8;
      }
    }
    uVar3 = 0;
    do {
      bVar1 = _ctype_[uVar6 + 1];
      if ((bVar1 & 4) == 0) {
        if ((iVar7 != 0x10) || ((bVar1 & 0x44) == 0)) goto LAB_2303fb36;
        iVar2 = 0x61;
        if ((bVar1 & 3) != 2) {
          iVar2 = 0x41;
        }
        uVar3 = uVar3 << 4 | (uVar6 + 10) - iVar2;
      }
      else {
        uVar3 = (iVar7 * uVar3 + uVar6) - 0x30;
      }
      uVar6 = (uint)(byte)cp[1];
      cp = cp + 1;
    } while( true );
  }
LAB_2303fb78:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
LAB_2303fb36:
  if (uVar6 == 0x2e) {
    if (puVar4 == parts + 2) goto LAB_2303fb78;
    *puVar4 = uVar3;
    bVar1 = cp[1];
    cp = cp + 1;
    puVar4 = puVar4 + 1;
    goto LAB_2303fabc;
  }
  if ((uVar6 != 0) && ((bVar1 & 8) == 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  iVar7 = (int)((int)puVar4 - (int)&uStack32) >> 2;
  iVar2 = iVar7 + 1;
  if (iVar2 == 2) {
    if (0xffffff < uVar3) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (0xff < uStack32) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    uVar6 = uStack32 << 0x18;
  }
  else {
    if (iVar2 < 3) {
      if (iVar7 == -1) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      goto LAB_2303fb6a;
    }
    if (iVar2 == 3) {
      if (0xffff < uVar3) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      if (0xff < uStack32) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      if (0xff < parts[0]) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      uVar6 = uStack32 << 0x18;
      uVar5 = parts[0] << 0x10;
    }
    else {
      if (iVar2 != 4) goto LAB_2303fb6a;
      if (0xff < uVar3) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      if (0xff < uStack32) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      if (0xff < parts[0]) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      if (0xff < parts[1]) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      uVar6 = uStack32 << 0x18 | parts[0] << 0x10;
      uVar5 = parts[1] << 8;
    }
    uVar6 = uVar6 | uVar5;
  }
  uVar3 = uVar3 | uVar6;
LAB_2303fb6a:
  if (addr == (ip4_addr_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  uVar3 = lwip_htonl(uVar3);
  addr->addr = uVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



u32_t ipaddr_addr(char *cp)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t val;
  
  iVar1 = ip4addr_aton(cp,&iStack20);
  if (iVar1 == 0) {
    iStack20 = 0xffffffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iStack20;
}



// WARNING: Could not reconcile some variable overlaps

char * ip4addr_ntoa_r(ip4_addr_t *addr,char *buf,int buflen)

{
  bool bVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  byte *pbVar5;
  uint uVar6;
  char *pcVar7;
  uint uVar8;
  uint uVar9;
  char *pcVar10;
  u32_t s_addr;
  char local_8 [4];
  char inv [3];
  
  _inv = addr->addr;
  iVar3 = 0;
  pbVar5 = (byte *)inv;
  pcVar10 = buf;
  while( true ) {
    uVar2 = 0;
    uVar9 = (uint)*pbVar5;
    do {
      uVar8 = uVar2;
      uVar6 = uVar9 / 10;
      local_8[uVar8] = (char)(uVar9 % 10) + '0';
      bVar1 = 9 < uVar9;
      uVar2 = uVar8 + 1 & 0xff;
      uVar9 = uVar6;
    } while (bVar1);
    *pbVar5 = (byte)uVar6;
    iVar4 = iVar3;
    pcVar7 = pcVar10;
    while (iVar3 = iVar4 + 1, uVar8 != 0xff) {
      if (buflen <= iVar4) goto LAB_2303fca2;
      *pcVar7 = local_8[uVar8];
      iVar4 = iVar3;
      pcVar7 = pcVar7 + 1;
      uVar8 = uVar8 - 1 & 0xff;
    }
    if (buflen <= iVar4) break;
    *pcVar7 = '.';
    pbVar5 = pbVar5 + 1;
    pcVar10 = pcVar7 + 1;
    if (pbVar5 == (byte *)register0x00002008) {
      *pcVar7 = '\0';
LAB_2303fc76:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return buf;
    }
  }
LAB_2303fca2:
  buf = (char *)0x0;
  goto LAB_2303fc76;
}



char * ip4addr_ntoa(ip4_addr_t *addr)

{
  char *pcVar1;
  
  pcVar1 = ip4addr_ntoa_r(addr,ip4addr_ntoa::str,0x10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar1;
}



void mem_init(void)

{
  ram = ram_heap;
  ram_heap._0_4_ = 0x2000;
  ram_heap[4] = '\0';
  ram_end = (mem *)(ram_heap + 0x2000);
  ram_heap._8192_4_ = 0x20002000;
  ram_heap[8196] = '\x01';
  lfree = (mem *)ram_heap;
  lwip_stats.mem.avail = 0x2000;
  sys_mutex_new(&mem_mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mem_free(void *rmem)

{
  ushort uVar1;
  short sVar2;
  u8_t *puVar3;
  mem *pmVar4;
  mem *pmVar5;
  mem *pmVar6;
  uint uVar7;
  mem *pmVar8;
  uint uVar9;
  
  if (rmem == (void *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (((((uint)rmem & 3) == 0) && (pmVar5 = (mem *)((int)rmem + -8), ram <= pmVar5)) &&
     ((mem *)((int)rmem + 0xc) <= ram_end)) {
    sys_mutex_lock(&mem_mutex);
    pmVar4 = ram_end;
    puVar3 = ram;
    pmVar8 = lfree;
    if (*(char *)((int)rmem + -4) != '\0') {
      uVar1 = *(ushort *)((int)rmem + -8);
      if ((uVar1 < 0x2001) && (uVar9 = (uint)*(ushort *)((int)rmem + -6), uVar9 < 0x2001)) {
        pmVar6 = (mem *)((int)pmVar5 - (int)ram);
        uVar7 = (uint)pmVar6 & 0xffff;
        if ((uVar7 == uVar9) || (*(ushort *)(ram + uVar9) == uVar7)) {
          if (((mem *)(ram + uVar1) == ram_end) || (((mem *)(ram + uVar1))->prev == uVar7)) {
            *(undefined *)((int)rmem + -4) = 0;
            if (pmVar5 < pmVar8) {
              lfree = pmVar5;
            }
            sVar2 = (short)((uint)((int)pmVar6 * 0x10000) >> 0x10);
            lwip_stats.mem.used = (lwip_stats.mem.used - uVar1) + sVar2;
            pmVar8 = (mem *)(puVar3 + *(ushort *)((int)rmem + -8));
            if (((pmVar5 != pmVar8) && (pmVar8->used == '\0')) && (pmVar4 != pmVar8)) {
              if (pmVar8 == lfree) {
                lfree = pmVar5;
              }
              *(mem_size_t *)((int)rmem + -8) = pmVar8->next;
              if (pmVar8->next != 0x2000) {
                *(short *)(puVar3 + pmVar8->next + 2) = sVar2;
              }
            }
            uVar1 = *(ushort *)((int)rmem + -6);
            pmVar8 = (mem *)(puVar3 + uVar1);
            if ((pmVar5 != pmVar8) && (pmVar8->used == '\0')) {
              if (pmVar5 == lfree) {
                lfree = pmVar8;
              }
              pmVar8->next = *(mem_size_t *)((int)rmem + -8);
              if (*(ushort *)((int)rmem + -8) != 0x2000) {
                *(ushort *)(puVar3 + *(ushort *)((int)rmem + -8) + 2) = uVar1;
              }
            }
            sys_mutex_unlock(&mem_mutex);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return;
          }
        }
      }
    }
    sys_mutex_unlock(&mem_mutex);
  }
  sys_arch_protect();
  lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
  sys_arch_unprotect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * mem_trim(void *rmem,mem_size_t new_size)

{
  mem_size_t mVar1;
  short sVar2;
  u8_t *puVar3;
  uint uVar4;
  mem_size_t mVar5;
  uint uVar6;
  uint uVar7;
  undefined2 in_register_0000202e;
  mem *pmVar8;
  mem *pmVar9;
  undefined2 uVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  
  uVar4 = CONCAT22(in_register_0000202e,new_size) + 3 & 0xfffc;
  if (uVar4 < 0xc) {
    uVar4 = 0xc;
  }
  else {
    if (0x2000 < uVar4) goto LAB_2303fed8;
  }
  if (uVar4 < CONCAT22(in_register_0000202e,new_size)) {
LAB_2303fed8:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (void *)0x0;
  }
  if ((rmem < ram) || (ram_end <= rmem)) {
    sys_arch_protect();
    lwip_stats.mem.illegal = lwip_stats.mem.illegal + 1;
    sys_arch_unprotect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return rmem;
  }
  uVar6 = (int)rmem + (-8 - (int)ram);
  uVar11 = *(ushort *)((int)rmem + -8) - 8;
  uVar7 = uVar6 & 0xffff;
  uVar12 = uVar11 & 0xffff;
  uVar13 = uVar12 - uVar7 & 0xffff;
  if (uVar13 < uVar4) goto LAB_2303fed8;
  if (uVar13 == uVar4) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return rmem;
  }
  sys_mutex_lock(&mem_mutex);
  puVar3 = ram;
  pmVar8 = (mem *)(ram + *(ushort *)((int)rmem + -8));
  mVar5 = (mem_size_t)uVar7;
  if (pmVar8->used == '\0') {
    uVar6 = uVar7 + 8 + uVar4;
    mVar1 = pmVar8->next;
    pmVar9 = (mem *)(ram + (uVar6 & 0xffff));
    if (lfree == pmVar8) {
      lfree = pmVar9;
    }
    pmVar9->used = '\0';
    pmVar9->next = mVar1;
    pmVar9->prev = mVar5;
    uVar10 = (undefined2)(uVar6 * 0x10000 >> 0x10);
    *(undefined2 *)((int)rmem + -8) = uVar10;
    if (pmVar9->next != 0x2000) {
      *(undefined2 *)(puVar3 + pmVar9->next + 2) = uVar10;
    }
    sVar2 = (mVar5 - (short)uVar12) + lwip_stats.mem.used;
  }
  else {
    if (uVar13 < uVar4 + 0x14) goto LAB_2303ff8e;
    uVar7 = uVar7 + 8 + uVar4;
    pmVar8 = (mem *)(ram + (uVar7 & 0xffff));
    if (pmVar8 < lfree) {
      lfree = pmVar8;
    }
    pmVar8->used = '\0';
    mVar1 = *(mem_size_t *)((int)rmem + -8);
    pmVar8->prev = mVar5;
    pmVar8->next = mVar1;
    uVar10 = (undefined2)(uVar7 * 0x10000 >> 0x10);
    *(undefined2 *)((int)rmem + -8) = uVar10;
    if (pmVar8->next != 0x2000) {
      *(undefined2 *)(puVar3 + pmVar8->next + 2) = uVar10;
    }
    sVar2 = ((short)(uVar6 * 0x10000 >> 0x10) - (short)(uVar11 * 0x10000 >> 0x10)) +
            lwip_stats.mem.used;
  }
  lwip_stats.mem.used = (short)uVar4 + sVar2;
LAB_2303ff8e:
  sys_mutex_unlock(&mem_mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return rmem;
}



void * mem_malloc(mem_size_t size_in)

{
  ushort uVar1;
  u8_t *puVar2;
  mem_size_t *pmVar3;
  mem *pmVar4;
  uint uVar5;
  undefined2 in_register_0000202a;
  uint uVar6;
  ushort *puVar7;
  mem_size_t mVar8;
  uint uVar9;
  uint uVar10;
  mem *pmVar11;
  
  uVar9 = CONCAT22(in_register_0000202a,size_in);
  if (uVar9 == 0) {
LAB_23040080:
    pmVar3 = (mem_size_t *)0x0;
  }
  else {
    uVar5 = uVar9 + 3 & 0xfffc;
    if (uVar5 < 0xc) {
      uVar5 = 0xc;
    }
    else {
      pmVar3 = (mem_size_t *)0x0;
      if (0x2000 < uVar5) goto LAB_2304001a;
    }
    pmVar3 = (mem_size_t *)0x0;
    if (uVar9 <= uVar5) {
      sys_mutex_lock(&mem_mutex);
      puVar2 = ram;
      pmVar11 = lfree;
      uVar9 = (uint)((int)lfree - (int)ram) & 0xffff;
      do {
        uVar10 = uVar9;
        if (0x2000 - uVar5 <= uVar10) {
          lwip_stats.mem.err = lwip_stats.mem.err + 1;
          sys_mutex_unlock(&mem_mutex);
          goto LAB_23040080;
        }
        pmVar4 = (mem *)(ram + uVar10);
        uVar9 = (uint)pmVar4->next;
      } while ((pmVar4->used != '\0') || (uVar6 = (-8 - uVar10) + uVar9, uVar6 < uVar5));
      if (uVar6 < uVar5 + 0x14) {
        pmVar4->used = '\x01';
        uVar10 = (uVar9 + lwip_stats.mem.used) - uVar10;
        lwip_stats.mem.used = (mem_size_t)(uVar10 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar10 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      else {
        uVar9 = uVar5 + 8 + uVar10;
        puVar7 = (ushort *)(ram + (uVar9 & 0xffff));
        *(undefined *)(puVar7 + 2) = 0;
        uVar1 = pmVar4->next;
        puVar7[1] = (ushort)uVar10;
        *puVar7 = uVar1;
        mVar8 = (mem_size_t)(uVar9 * 0x10000 >> 0x10);
        pmVar4->next = mVar8;
        pmVar4->used = '\x01';
        if (*puVar7 != 0x2000) {
          *(mem_size_t *)(puVar2 + *puVar7 + 2) = mVar8;
        }
        uVar5 = uVar5 + lwip_stats.mem.used + 8;
        lwip_stats.mem.used = (mem_size_t)(uVar5 * 0x10000 >> 0x10);
        if ((uint)lwip_stats.mem.max < (uVar5 & 0xffff)) {
          lwip_stats.mem.max = lwip_stats.mem.used;
        }
      }
      if (pmVar11 == pmVar4) {
        while ((lfree = pmVar11, pmVar11->used != '\0' && (ram_end != pmVar11))) {
          pmVar11 = (mem *)(puVar2 + pmVar11->next);
        }
      }
      sys_mutex_unlock(&mem_mutex);
      pmVar3 = &pmVar4[1].prev;
    }
  }
LAB_2304001a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar3;
}



// WARNING: Type propagation algorithm not settling

void * do_memp_malloc_pool(memp_desc *desc)

{
  memp mVar1;
  stats_mem *psVar2;
  
  sys_arch_protect();
  mVar1 = (memp)((memp *)desc->tab)->next;
  if (mVar1 == (memp)0x0) {
    desc->stats->err = desc->stats->err + 1;
  }
  else {
    ((memp *)desc->tab)->next = (memp *)*(memp *)mVar1;
    desc->stats->used = desc->stats->used + 1;
    psVar2 = desc->stats;
    if (psVar2->max < psVar2->used) {
      psVar2->max = psVar2->used;
    }
  }
  sys_arch_unprotect();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (void *)mVar1;
}



// WARNING: Type propagation algorithm not settling

void memp_init_pool(memp_desc *desc)

{
  int iVar1;
  memp mVar2;
  
  iVar1 = 0;
  *desc->tab = (memp *)0x0;
  mVar2 = (memp)((uint)(desc->base + 3) & 0xfffffffc);
  while (iVar1 < (int)(uint)desc->num) {
    iVar1 = iVar1 + 1;
    *(memp **)mVar2 = ((memp *)desc->tab)->next;
    ((memp *)desc->tab)->next = (memp *)mVar2;
    mVar2 = (memp)((int)mVar2 + (uint)desc->size);
  }
  desc->stats->avail = desc->num;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void memp_init(void)

{
  stats_ *psVar1;
  int iVar2;
  memp_desc *desc;
  
  iVar2 = 0;
  psVar1 = &lwip_stats;
  do {
    desc = *(memp_desc **)((int)memp_pools + iVar2);
    iVar2 = iVar2 + 4;
    memp_init_pool(desc);
    psVar1->memp[0] = desc->stats;
    psVar1 = (stats_ *)&(psVar1->link).fw;
  } while (iVar2 != 0x3c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * memp_malloc(memp_t type)

{
  undefined3 in_register_00002029;
  void *pvVar1;
  
  if (CONCAT31(in_register_00002029,type) < 0xf) {
    pvVar1 = do_memp_malloc_pool(memp_pools[CONCAT31(in_register_00002029,type)]);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return pvVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (void *)0x0;
}



void memp_free(memp_t type,void *mem)

{
  memp_desc *pmVar1;
  undefined3 in_register_00002029;
  
  if ((CONCAT31(in_register_00002029,type) < 0xf) && (mem != (void *)0x0)) {
    pmVar1 = memp_pools[CONCAT31(in_register_00002029,type)];
    sys_arch_protect();
    pmVar1->stats->used = pmVar1->stats->used - 1;
    *(memp **)mem = *pmVar1->tab;
    *pmVar1->tab = (memp *)mem;
    sys_arch_unprotect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t netif_null_output_ip4(netif *netif,pbuf *p,ip4_addr_t *ipaddr)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



void netif_issue_reports(netif *netif,u8_t report_type)

{
  if (((netif->flags & 5) != 5) || ((report_type & 1) == 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    if ((netif->flags & 8) != 0) {
      etharp_request(netif,(ip4_addr_t *)&netif->ip_addr);
    }
    if ((netif->flags & 0x20) != 0) {
      igmp_report_groups(netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: new_addr
// WARNING: Type propagation algorithm not settling

int netif_do_set_ipaddr(netif *netif,ip4_addr_t *ipaddr,ip_addr_t *old_addr)

{
  ip_addr_t iVar1;
  ip_addr_t iStack20;
  ip_addr_t new_addr;
  
  iVar1 = (ip_addr_t)(netif->ip_addr).addr;
  iStack20 = ipaddr->addr;
  if ((ip_addr_t)iStack20 != iVar1) {
    old_addr->addr = (u32_t)iVar1;
    tcp_netif_ip_addr_changed(old_addr,&iStack20);
    udp_netif_ip_addr_changed(old_addr,&iStack20);
    raw_netif_ip_addr_changed(old_addr,&iStack20);
    (netif->ip_addr).addr = ipaddr->addr;
    netif_issue_reports(netif,'\x01');
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void netif_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_ipaddr(netif *netif,ip4_addr_t *ipaddr)

{
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (netif != (netif *)0x0) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_netmask(netif *netif,ip4_addr_t *netmask)

{
  if (netif != (netif *)0x0) {
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask->addr != (netif->netmask).addr) {
      (netif->netmask).addr = netmask->addr;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_gw(netif *netif,ip4_addr_t *gw)

{
  if (netif != (netif *)0x0) {
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw->addr != (netif->gw).addr) {
      (netif->gw).addr = gw->addr;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: old_addr

void netif_set_addr(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw)

{
  bool bVar1;
  ip_addr_t iStack20;
  ip_addr_t old_addr;
  
  if (ipaddr == (ip4_addr_t *)0x0) {
    ipaddr = (ip4_addr_t *)&ip_addr_any;
  }
  if (netmask == (ip4_addr_t *)0x0) {
    netmask = (ip4_addr_t *)&ip_addr_any;
  }
  if (gw == (ip4_addr_t *)0x0) {
    gw = (ip4_addr_t *)&ip_addr_any;
  }
  bVar1 = ipaddr->addr == 0;
  if (bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  if (netmask->addr != (netif->netmask).addr) {
    (netif->netmask).addr = netmask->addr;
  }
  if (gw->addr != (netif->gw).addr) {
    (netif->gw).addr = gw->addr;
  }
  if (!bVar1) {
    netif_do_set_ipaddr(netif,ipaddr,&iStack20);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



netif * netif_add(netif *netif,ip4_addr_t *ipaddr,ip4_addr_t *netmask,ip4_addr_t *gw,void *state,
                 netif_init_fn_conflict *init,netif_input_fn *input)

{
  u8_t uVar1;
  err_t eVar2;
  undefined3 extraout_var;
  netif *pnVar3;
  
  if ((netif != (netif *)0x0) && (init != (netif_init_fn_conflict *)0x0)) {
    if (ipaddr == (ip4_addr_t *)0x0) {
      ipaddr = (ip4_addr_t *)&ip_addr_any;
    }
    if (netmask == (ip4_addr_t *)0x0) {
      netmask = (ip4_addr_t *)&ip_addr_any;
    }
    if (gw == (ip4_addr_t *)0x0) {
      gw = (ip4_addr_t *)&ip_addr_any;
    }
    netif->output = netif_null_output_ip4;
    (netif->ip_addr).addr = 0;
    (netif->netmask).addr = 0;
    (netif->gw).addr = 0;
    netif->mtu = 0;
    netif->flags = '\0';
    memset(netif->client_data,0,0xc);
    netif->state = state;
    uVar1 = netif_num;
    netif->input = input;
    netif->num = uVar1;
    netif->status_callback = (netif_status_callback_fn *)0x0;
    netif->link_callback = (netif_status_callback_fn *)0x0;
    netif->igmp_mac_filter = (netif_igmp_mac_filter_fn *)0x0;
    netif_set_addr(netif,ipaddr,netmask,gw);
    eVar2 = (*init)(netif);
    if (CONCAT31(extraout_var,eVar2) == 0) {
      do {
        if (netif->num == -1) {
          netif->num = '\0';
        }
        uVar1 = netif->num;
        pnVar3 = netif_list;
        while( true ) {
          if (pnVar3 == (netif *)0x0) {
            netif_num = '\0';
            if (uVar1 != -2) {
              netif_num = uVar1 + '\x01';
            }
            netif->next = netif_list;
            netif_list = netif;
            if ((netif->flags & 0x20) != 0) {
              igmp_start(netif);
            }
            goto LAB_23040416;
          }
          if (pnVar3->num == uVar1) break;
          pnVar3 = pnVar3->next;
        }
        netif->num = uVar1 + '\x01';
      } while( true );
    }
  }
  netif = (netif *)0x0;
LAB_23040416:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return netif;
}



void netif_set_default(netif *netif)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  netif_default = netif;
  return;
}



void netif_set_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((netif->flags & 1) == 0) {
    netif->flags = netif->flags | 1;
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
      (*netif->status_callback)(netif);
    }
    netif_issue_reports(netif,'\x03');
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_down(netif *netif)

{
  byte bVar1;
  
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  bVar1 = netif->flags;
  if ((bVar1 & 1) != 0) {
    netif->flags = bVar1 & 0xfe;
    if ((bVar1 & 8) != 0) {
      etharp_cleanup_netif(netif);
    }
    if (netif->status_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23040594. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->status_callback)(netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_remove(netif *netif)

{
  netif *pnVar1;
  ip_addr_t *old_addr;
  netif *pnVar2;
  
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((netif->ip_addr).addr != 0) {
    old_addr = &netif->ip_addr;
    tcp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    udp_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
    raw_netif_ip_addr_changed(old_addr,(ip_addr_t *)0x0);
  }
  if ((netif->flags & 0x20) != 0) {
    igmp_stop(netif);
  }
  if ((netif->flags & 1) != 0) {
    netif_set_down(netif);
  }
  if (netif_default == netif) {
    netif_default = (netif *)0x0;
  }
  pnVar1 = netif_list;
  if (netif_list == netif) {
    netif_list = netif->next;
  }
  else {
    do {
      pnVar2 = pnVar1;
      if (pnVar2 == (netif *)0x0) goto LAB_2304060c;
      pnVar1 = pnVar2->next;
    } while (pnVar2->next != netif);
    pnVar2->next = netif->next;
  }
LAB_2304060c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_status_callback(netif *netif,netif_status_callback_fn *status_callback)

{
  if (netif != (netif *)0x0) {
    netif->status_callback = status_callback;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netif_set_link_up(netif *netif)

{
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if ((netif->flags & 4) == 0) {
    netif->flags = netif->flags | 4;
    dhcp_network_changed(netif);
    netif_issue_reports(netif,'\x03');
    if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23040666. Too many branches
                    // WARNING: Treating indirect jump as call
      (*netif->link_callback)(netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

void netif_set_link_down(netif *netif)

{
  if (netif != (netif *)0x0) {
    if ((netif->flags & 4) != 0) {
      netif->flags = netif->flags & 0xfb;
      if (netif->link_callback != (netif_status_callback_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304068c. Too many branches
                    // WARNING: Treating indirect jump as call
        (*netif->link_callback)();
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



netif * netif_get_by_index(u8_t idx)

{
  undefined3 in_register_00002029;
  netif *pnVar1;
  netif *pnVar2;
  
  pnVar1 = netif_list;
  pnVar2 = (netif *)0x0;
  if (CONCAT31(in_register_00002029,idx) != 0) {
    while ((pnVar2 = pnVar1, pnVar1 != (netif *)0x0 &&
           ((pnVar1->num + 1 & 0xff) != CONCAT31(in_register_00002029,idx)))) {
      pnVar1 = pnVar1->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pnVar2;
}



netif * netif_find(char *name)

{
  uint uVar1;
  netif *pnVar2;
  
  if (name == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (netif *)0x0;
  }
  uVar1 = atoi(name + 2);
  pnVar2 = netif_list;
  while( true ) {
    if (pnVar2 == (netif *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (netif *)0x0;
    }
    if ((((uint)pnVar2->num == (uVar1 & 0xff)) && (*name == pnVar2->name[0])) &&
       (name[1] == pnVar2->name[1])) break;
    pnVar2 = pnVar2->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pnVar2;
}



pbuf * pbuf_skip_const(pbuf *in,u16_t in_offset,u16_t *out_offset)

{
  pbuf *ppVar1;
  undefined2 in_register_0000202e;
  
  if ((in != (pbuf *)0x0) && ((uint)in->len <= CONCAT22(in_register_0000202e,in_offset))) {
    ppVar1 = pbuf_skip_const(in->next,(u16_t)((CONCAT22(in_register_0000202e,in_offset) -
                                              (uint)in->len) * 0x10000 >> 0x10),out_offset);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ppVar1;
  }
  if (out_offset != (u16_t *)0x0) {
    *out_offset = in_offset;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in;
}



void pbuf_free_ooseq_callback(void *arg)

{
  tcp_pcb *pcb;
  
  sys_arch_protect();
  pbuf_free_ooseq_pending = '\0';
  sys_arch_unprotect();
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) break;
    pcb = pcb->next;
  }
  tcp_free_ooseq(pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u8_t pbuf_add_header_impl(pbuf *p,size_t header_size_increment,u8_t force)

{
  u8_t uVar1;
  pbuf *ppVar2;
  undefined3 in_register_00002031;
  uint uVar3;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_increment < 0x10000) && (uVar1 = '\0', header_size_increment != 0)) {
      uVar3 = (uint)p->tot_len + (header_size_increment & 0xffff);
      uVar1 = '\x01';
      if ((header_size_increment & 0xffff) <= (uVar3 & 0xffff)) {
        if ((char)p->type_internal < '\0') {
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
          if (ppVar2 < p + 1) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return '\x01';
          }
        }
        else {
          if (CONCAT31(in_register_00002031,force) == 0) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return '\x01';
          }
          ppVar2 = (pbuf *)((int)p->payload - header_size_increment);
        }
        p->payload = ppVar2;
        p->tot_len = (u16_t)(uVar3 * 0x10000 >> 0x10);
        p->len = (short)header_size_increment + p->len;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\0';
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



pbuf * pbuf_alloc_reference(void *payload,u16_t length,pbuf_type type)

{
  pbuf *ppVar1;
  
  ppVar1 = (pbuf *)memp_malloc(MEMP_PBUF);
  if (ppVar1 != (pbuf *)0x0) {
    ppVar1->next = (pbuf *)0x0;
    ppVar1->payload = payload;
    ppVar1->tot_len = length;
    ppVar1->len = length;
    ppVar1->type_internal = (u8_t)type;
    ppVar1->flags = '\0';
    *(undefined2 *)&ppVar1->ref = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar1;
}



pbuf * pbuf_alloced_custom(pbuf_layer l,u16_t length,pbuf_type type,pbuf_custom *p,void *payload_mem
                          ,u16_t payload_mem_len)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined2 in_register_0000202e;
  undefined2 in_register_0000203e;
  
  uVar1 = CONCAT31(in_register_00002029,l) + 3U & 0xfffffffc;
  if (CONCAT22(in_register_0000202e,length) + uVar1 <=
      CONCAT22(in_register_0000203e,payload_mem_len)) {
    if (payload_mem != (void *)0x0) {
      payload_mem = (void *)((int)payload_mem + uVar1);
    }
    (p->pbuf).flags = '\x02';
    (p->pbuf).next = (pbuf *)0x0;
    (p->pbuf).payload = payload_mem;
    (p->pbuf).tot_len = length;
    (p->pbuf).len = length;
    (p->pbuf).type_internal = (u8_t)type;
    *(undefined2 *)&(p->pbuf).ref = 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (pbuf *)p;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (pbuf *)(pbuf_custom *)0x0;
}



u8_t pbuf_add_header(pbuf *p,size_t header_size_increment)

{
  u8_t uVar1;
  
  uVar1 = pbuf_add_header_impl(p,header_size_increment,'\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



u8_t pbuf_remove_header(pbuf *p,size_t header_size_decrement)

{
  u8_t uVar1;
  
  if (p == (pbuf *)0x0) {
    uVar1 = '\x01';
  }
  else {
    uVar1 = '\x01';
    if ((header_size_decrement < 0x10000) && (uVar1 = '\0', header_size_decrement != 0)) {
      uVar1 = '\x01';
      if ((header_size_decrement & 0xffff) <= (uint)p->len) {
        p->len = p->len - (short)header_size_decrement;
        p->payload = (void *)(header_size_decrement + (int)p->payload);
        p->tot_len = p->tot_len - (short)header_size_decrement;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\0';
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



u8_t pbuf_header(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\0');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



u8_t pbuf_header_force(pbuf *p,s16_t header_size_increment)

{
  u8_t uVar1;
  short in_register_0000202e;
  
  if (in_register_0000202e < 0) {
    uVar1 = pbuf_remove_header(p,-CONCAT22(in_register_0000202e,header_size_increment));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return uVar1;
  }
  uVar1 = pbuf_add_header_impl(p,CONCAT22(in_register_0000202e,header_size_increment),'\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



u8_t pbuf_free(pbuf *p)

{
  u8_t uVar1;
  u8_t uVar2;
  pbuf *ppVar3;
  memp_t type;
  byte bVar4;
  
  uVar1 = '\0';
  if (p != (pbuf *)0x0) {
    uVar1 = '\0';
    do {
      sys_arch_protect();
      uVar2 = p->ref + -1;
      p->ref = uVar2;
      sys_arch_unprotect();
      if (uVar2 != '\0') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar1;
      }
      ppVar3 = p->next;
      if ((p->flags & 2) == 0) {
        type = MEMP_PBUF_POOL;
        bVar4 = p->type_internal & 0xf;
        if (bVar4 != 2) {
          if (bVar4 != 1) {
            if ((p->type_internal & 0xf) == 0) {
              mem_free(p);
            }
            goto LAB_230408d6;
          }
          type = MEMP_PBUF;
        }
        memp_free(type,p);
      }
      else {
        (*(code *)p[1].next)(p,p[1].next);
      }
LAB_230408d6:
      uVar1 = uVar1 + '\x01';
      p = ppVar3;
    } while (ppVar3 != (pbuf *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



pbuf * pbuf_alloc(pbuf_layer layer,u16_t length,pbuf_type type)

{
  u8_t uVar1;
  uint uVar2;
  uint uVar3;
  pbuf *ppVar4;
  err_t eVar5;
  undefined3 in_register_00002029;
  uint uVar6;
  pbuf *ppVar7;
  pbuf *ppVar8;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  uint uVar9;
  pbuf *ppVar10;
  
  uVar6 = CONCAT22(in_register_00002032,type);
  uVar3 = CONCAT22(in_register_0000202e,length);
  if (uVar6 == 0x41) {
LAB_230409bc:
    ppVar7 = pbuf_alloc_reference((void *)0x0,length,type);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ppVar7;
  }
  if (uVar6 < 0x42) {
    if (uVar6 == 1) goto LAB_230409bc;
  }
  else {
    uVar2 = CONCAT31(in_register_00002029,layer) & 0xffff;
    if (uVar6 == 0x182) {
      ppVar7 = (pbuf *)0x0;
      ppVar10 = (pbuf *)0x0;
      do {
        ppVar8 = (pbuf *)memp_malloc(MEMP_PBUF_POOL);
        if (ppVar8 == (pbuf *)0x0) {
          sys_arch_protect();
          uVar1 = pbuf_free_ooseq_pending;
          pbuf_free_ooseq_pending = '\x01';
          sys_arch_unprotect();
          if ((uVar1 == '\0') &&
             (eVar5 = tcpip_try_callback(pbuf_free_ooseq_callback,(void *)0x0),
             CONCAT31(extraout_var,eVar5) != 0)) {
            sys_arch_protect();
            pbuf_free_ooseq_pending = '\0';
            sys_arch_unprotect();
          }
          if (ppVar7 != (pbuf *)0x0) {
            pbuf_free(ppVar7);
          }
          goto LAB_23040932;
        }
        uVar6 = 0x2f8 - (uVar2 + 3 & 0xfffffffc);
        if (uVar3 < (uVar6 & 0xffff)) {
          uVar6 = uVar3;
        }
        ppVar8->next = (pbuf *)0x0;
        ppVar8->payload = (void *)((int)&ppVar8[1].next + uVar2 + 3 & 0xfffffffc);
        ppVar8->tot_len = (u16_t)uVar3;
        ppVar8->len = (u16_t)uVar6;
        *(undefined4 *)&ppVar8->type_internal = 0x10082;
        ppVar4 = ppVar8;
        if (ppVar7 != (pbuf *)0x0) {
          ppVar10->next = ppVar8;
          ppVar4 = ppVar7;
        }
        uVar3 = uVar3 - (uVar6 & 0xffff) & 0xffff;
        uVar2 = 0;
        ppVar7 = ppVar4;
        ppVar10 = ppVar8;
      } while (uVar3 != 0);
      goto LAB_23040934;
    }
    if (uVar6 == 0x280) {
      uVar9 = uVar3 + 3 & 0xfffffffc;
      uVar3 = (uVar2 + 3 & 0xfffffffc) + uVar9 & 0xffff;
      uVar6 = uVar3 + 0x10;
      if ((uVar9 <= uVar3) && (uVar9 <= (uVar6 & 0xffff))) {
        ppVar4 = (pbuf *)mem_malloc((mem_size_t)(uVar6 * 0x10000 >> 0x10));
        if (ppVar4 != (pbuf *)0x0) {
          ppVar4->next = (pbuf *)0x0;
          ppVar4->payload =
               (void *)((int)&ppVar4[1].next + CONCAT31(in_register_00002029,layer) + 3 & 0xfffffffc
                       );
          ppVar4->tot_len = length;
          ppVar4->len = length;
          *(undefined4 *)&ppVar4->type_internal = 0x10080;
        }
        goto LAB_23040934;
      }
    }
  }
LAB_23040932:
  ppVar4 = (pbuf *)0x0;
LAB_23040934:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar4;
}



void pbuf_realloc(pbuf *p,u16_t new_len)

{
  ushort uVar1;
  uint uVar2;
  undefined2 in_register_0000202e;
  uint uVar3;
  
  uVar2 = CONCAT22(in_register_0000202e,new_len);
  uVar1 = p->tot_len;
  if (uVar2 < uVar1) {
    while (uVar3 = (uint)p->len, uVar3 < uVar2) {
      p->tot_len = p->tot_len + (new_len - uVar1);
      uVar2 = uVar2 - uVar3 & 0xffff;
      p = p->next;
    }
    if ((((p->type_internal & 0xf) == 0) && (uVar3 != uVar2)) && ((p->flags & 2) == 0)) {
      p = (pbuf *)mem_trim(p,(mem_size_t)(((int)p->payload + (uVar2 - (int)p)) * 0x10000 >> 0x10));
    }
    p->len = (u16_t)uVar2;
    p->tot_len = (u16_t)uVar2;
    if (p->next != (pbuf *)0x0) {
      pbuf_free(p->next);
    }
    p->next = (pbuf *)0x0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



pbuf * pbuf_free_header(pbuf *q,u16_t size)

{
  pbuf *ppVar1;
  undefined2 in_register_0000202e;
  uint header_size_decrement;
  
  header_size_decrement = CONCAT22(in_register_0000202e,size);
  while( true ) {
    if (header_size_decrement == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return q;
    }
    if (q == (pbuf *)0x0) break;
    if (header_size_decrement < q->len) {
      pbuf_remove_header(q,header_size_decrement);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return q;
    }
    ppVar1 = q->next;
    header_size_decrement = header_size_decrement - q->len & 0xffff;
    q->next = (pbuf *)0x0;
    pbuf_free(q);
    q = ppVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (pbuf *)0x0;
}



u16_t pbuf_clen(pbuf *p)

{
  u16_t uVar1;
  
  uVar1 = 0;
  while (p != (pbuf *)0x0) {
    uVar1 = uVar1 + 1;
    p = p->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void pbuf_ref(pbuf *p)

{
  if (p != (pbuf *)0x0) {
    sys_arch_protect();
    p->ref = p->ref + '\x01';
    sys_arch_unprotect();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void pbuf_cat(pbuf *h,pbuf *t)

{
  pbuf *ppVar1;
  
  if (h != (pbuf *)0x0) {
    if (t == (pbuf *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    do {
      ppVar1 = h;
      ppVar1->tot_len = ppVar1->tot_len + t->tot_len;
      h = ppVar1->next;
    } while (ppVar1->next != (pbuf *)0x0);
    ppVar1->next = t;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void pbuf_chain(pbuf *h,pbuf *t)

{
  pbuf_cat(h,t);
  pbuf_ref(t);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t pbuf_copy(pbuf *p_to,pbuf *p_from)

{
  err_t eVar1;
  uint uVar2;
  uint __n;
  uint uVar3;
  uint uVar4;
  
  if (p_to == (pbuf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if ((p_from == (pbuf *)0x0) || (p_to->tot_len < p_from->tot_len)) {
LAB_23040c06:
    eVar1 = -0x10;
  }
  else {
    uVar4 = 0;
    uVar3 = 0;
    do {
      __n = p_to->len - uVar3;
      uVar2 = p_from->len - uVar4;
      if (uVar2 < __n) {
        __n = uVar2;
      }
      memcpy((void *)((int)p_to->payload + uVar3),(void *)((int)p_from->payload + uVar4),__n);
      uVar4 = uVar4 + __n;
      uVar3 = uVar3 + __n;
      if (p_from->len <= uVar4) {
        p_from = p_from->next;
        uVar4 = 0;
      }
      if (uVar3 == p_to->len) {
        p_to = p_to->next;
        if (p_to == (pbuf *)0x0) {
          if (p_from == (pbuf *)0x0) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return '\0';
          }
          goto LAB_23040c06;
        }
        uVar3 = 0;
      }
      if ((((p_from != (pbuf *)0x0) && (p_from->len == p_from->tot_len)) &&
          (p_from->next != (pbuf *)0x0)) ||
         ((p_to->len == p_to->tot_len && (p_to->next != (pbuf *)0x0)))) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -6;
      }
    } while (p_from != (pbuf *)0x0);
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



u16_t pbuf_copy_partial(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  uint uVar4;
  
  uVar4 = CONCAT22(in_register_00002036,offset);
  uVar2 = CONCAT22(in_register_00002032,len);
  uVar1 = 0;
  if ((buf != (pbuf *)0x0) && (uVar1 = 0, dataptr != (void *)0x0)) {
    while ((uVar2 != 0 && (buf != (pbuf *)0x0))) {
      uVar3 = (uint)buf->len;
      if ((uVar4 == 0) || (uVar4 < uVar3)) {
        uVar3 = uVar3 - uVar4 & 0xffff;
        if (uVar2 < uVar3) {
          uVar3 = uVar2;
        }
        uVar3 = uVar3 & 0xffff;
        memcpy((void *)((int)dataptr + uVar1),(void *)((int)buf->payload + uVar4),uVar3);
        uVar1 = uVar1 + uVar3 & 0xffff;
        uVar2 = uVar2 - uVar3 & 0xffff;
        uVar4 = 0;
      }
      else {
        uVar4 = uVar4 - uVar3 & 0xffff;
      }
      buf = buf->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)uVar1;
}



err_t pbuf_take(pbuf *buf,void *dataptr,u16_t len)

{
  uint uVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  uint __n;
  int iVar3;
  
  uVar1 = CONCAT22(in_register_00002032,len);
  if (buf != (pbuf *)0x0) {
    eVar2 = -0x10;
    if (dataptr != (void *)0x0) {
      eVar2 = -1;
      iVar3 = 0;
      if (uVar1 <= buf->tot_len) {
        while (uVar1 != 0) {
          __n = (uint)buf->len;
          if (uVar1 < buf->len) {
            __n = uVar1;
          }
          memcpy(buf->payload,(void *)((int)dataptr + iVar3),__n);
          buf = buf->next;
          uVar1 = uVar1 - __n;
          iVar3 = iVar3 + __n;
        }
        eVar2 = '\0';
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t pbuf_take_at(pbuf *buf,void *dataptr,u16_t len,u16_t offset)

{
  err_t eVar1;
  pbuf *ppVar2;
  undefined2 in_register_00002032;
  size_t sVar3;
  uint uVar4;
  uint uVar5;
  size_t __n;
  ushort auStack34 [2];
  u16_t target_offset;
  
  sVar3 = CONCAT22(in_register_00002032,len);
  ppVar2 = pbuf_skip_const(buf,offset,auStack34);
  if (ppVar2 == (pbuf *)0x0) {
    eVar1 = -1;
  }
  else {
    uVar4 = (uint)auStack34[0];
    eVar1 = -1;
    if ((int)(uVar4 + sVar3) <= (int)(uint)ppVar2->tot_len) {
      uVar5 = ppVar2->len - uVar4;
      __n = sVar3;
      if ((int)uVar5 < (int)sVar3) {
        __n = uVar5 & 0xffff;
      }
      memcpy((void *)((int)ppVar2->payload + uVar4),dataptr,__n);
      eVar1 = '\0';
      if ((sVar3 - __n & 0xffff) != 0) {
        eVar1 = pbuf_take(ppVar2->next,(void *)((int)dataptr + __n),
                          (u16_t)((sVar3 - __n) * 0x10000 >> 0x10));
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



pbuf * pbuf_clone(pbuf_layer layer,pbuf_type type,pbuf *p)

{
  pbuf *p_to;
  
  p_to = pbuf_alloc(layer,p->tot_len,type);
  if (p_to != (pbuf *)0x0) {
    pbuf_copy(p_to,p);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return p_to;
}



int pbuf_try_get_at(pbuf *p,u16_t offset)

{
  pbuf *ppVar1;
  uint uVar2;
  ushort auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  uVar2 = 0xffffffff;
  if (ppVar1 != (pbuf *)0x0) {
    uVar2 = 0xffffffff;
    if ((uint)auStack18[0] < (uint)ppVar1->len) {
      uVar2 = (uint)*(byte *)((int)ppVar1->payload + (uint)auStack18[0]);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



u8_t pbuf_get_at(pbuf *p,u16_t offset)

{
  int iVar1;
  
  iVar1 = pbuf_try_get_at(p,offset);
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u8_t)iVar1;
}



void pbuf_put_at(pbuf *p,u16_t offset,u8_t data)

{
  pbuf *ppVar1;
  ushort auStack18 [2];
  u16_t q_idx;
  
  ppVar1 = pbuf_skip_const(p,offset,auStack18);
  if ((ppVar1 != (pbuf *)0x0) && ((uint)auStack18[0] < (uint)ppVar1->len)) {
    *(u8_t *)((int)ppVar1->payload + (uint)auStack18[0]) = data;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u16_t pbuf_memcmp(pbuf *p,u16_t offset,void *s2,u16_t n)

{
  byte *pbVar1;
  ushort *puVar2;
  uint uVar3;
  u8_t uVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002036;
  uint uVar6;
  uint uVar7;
  
  uVar3 = CONCAT22(in_register_0000202e,offset);
  if ((int)(uint)p->tot_len < (int)(uVar3 + CONCAT22(in_register_00002036,n))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xffff;
  }
  do {
    puVar2 = &p->len;
    if (uVar3 < *puVar2) break;
    p = p->next;
    uVar3 = uVar3 - *puVar2 & 0xffff;
  } while (p != (pbuf *)0x0);
  uVar7 = 0;
  do {
    uVar6 = uVar7 & 0xffff;
    if (CONCAT22(in_register_00002036,n) <= uVar6) {
      uVar5 = 0;
      goto LAB_23040eba;
    }
    uVar4 = pbuf_get_at(p,(u16_t)((uVar6 + uVar3) * 0x10000 >> 0x10));
    pbVar1 = (byte *)((int)s2 + uVar7);
    uVar7 = uVar7 + 1;
  } while ((uint)*pbVar1 == CONCAT31(extraout_var,uVar4));
  if (0xfffe < uVar6) {
    uVar6 = 0xfffffffe;
  }
  uVar5 = (short)uVar6 + 1;
LAB_23040eba:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar5;
}



u16_t pbuf_memfind(pbuf *p,void *mem,u16_t mem_len,u16_t start_offset)

{
  ushort uVar1;
  uint uVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  undefined2 in_register_00002032;
  undefined2 in_register_00002036;
  
  uVar2 = CONCAT22(in_register_00002036,start_offset);
  uVar1 = p->tot_len;
  if ((int)(CONCAT22(in_register_00002032,mem_len) + uVar2) <= (int)(uint)uVar1) {
    while (uVar2 <= ((uint)uVar1 - CONCAT22(in_register_00002032,mem_len) & 0xffff)) {
      uVar3 = pbuf_memcmp(p,(u16_t)uVar2,mem,mem_len);
      if (CONCAT22(extraout_var,uVar3) == 0) goto LAB_23040efa;
      uVar2 = uVar2 + 1 & 0xffff;
    }
  }
  uVar2 = 0xffff;
LAB_23040efa:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)uVar2;
}



raw_input_state_t raw_input(pbuf *p,netif *inp)

{
  u8_t uVar1;
  raw_pcb *prVar2;
  raw_pcb *prVar3;
  u8_t uVar4;
  raw_input_state_t rVar5;
  u8_t uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u32_t uVar7;
  raw_pcb *prVar8;
  
  uVar4 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  uVar1 = *(u8_t *)((int)p->payload + 9);
  rVar5 = RAW_INPUT_NONE;
  prVar2 = raw_pcbs;
  prVar8 = (raw_pcb *)0x0;
  do {
    prVar3 = prVar2;
    if (prVar3 == (raw_pcb *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return rVar5;
    }
    if ((prVar3->protocol == uVar1) &&
       ((prVar3->netif_idx == '\0' ||
        (prVar3->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
      uVar7 = (prVar3->local_ip).addr;
      if (CONCAT31(extraout_var,uVar4) == 0) {
        if ((uVar7 == 0) || (ip_data.current_iphdr_dest == uVar7)) goto LAB_23040f92;
      }
      else {
        if (uVar7 == 0) {
LAB_23040f92:
          if ((((prVar3->flags & 1) == 0) || ((prVar3->remote_ip).addr == ip_data.current_iphdr_src)
              ) && (prVar3->recv != (raw_recv_fn *)0x0)) {
            uVar6 = (*prVar3->recv)(prVar3->recv_arg,prVar3,p,(ip_addr_t *)0x4201fed0);
            if (CONCAT31(extraout_var_00,uVar6) != 0) {
              if (prVar8 == (raw_pcb *)0x0) {
                gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                return RAW_INPUT_EATEN;
              }
              prVar8->next = prVar3->next;
              prVar3->next = raw_pcbs;
              raw_pcbs = prVar3;
              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
              return RAW_INPUT_EATEN;
            }
            rVar5 = RAW_INPUT_DELIVERED;
          }
        }
      }
    }
    prVar2 = prVar3->next;
    prVar8 = prVar3;
  } while( true );
}



err_t raw_bind(raw_pcb *pcb,ip_addr_t *ipaddr)

{
  err_t eVar1;
  
  eVar1 = -6;
  if ((pcb != (raw_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) {
    (pcb->local_ip).addr = ipaddr->addr;
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void raw_bind_netif(raw_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t raw_connect(raw_pcb *pcb,ip_addr_t *ipaddr)

{
  if ((pcb != (raw_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) {
    (pcb->remote_ip).addr = ipaddr->addr;
    pcb->flags = pcb->flags | 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



void raw_recv(raw_pcb *pcb,raw_recv_fn *recv,void *recv_arg)

{
  pcb->recv = recv;
  pcb->recv_arg = recv_arg;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t raw_sendto_if_src(raw_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,netif *netif,ip_addr_t *src_ip)

{
  err_t eVar1;
  u8_t uVar2;
  undefined3 extraout_var;
  pbuf *h;
  undefined3 extraout_var_00;
  
  if ((((pcb != (raw_pcb *)0x0) && (dst_ip != (ip_addr_t *)0x0)) && (netif != (netif *)0x0)) &&
     (src_ip != (ip_addr_t *)0x0)) {
    if ((pcb->flags & 2) == 0) {
      if (p->tot_len < 0xffec) {
        uVar2 = pbuf_add_header(p,0x14);
        if (CONCAT31(extraout_var,uVar2) == 0) {
          uVar2 = pbuf_remove_header(p,0x14);
          h = p;
          if (CONCAT31(extraout_var_00,uVar2) == 0) goto LAB_230410e2;
        }
        else {
          h = pbuf_alloc(PBUF_IP,0,PBUF_RAM);
          if (h != (pbuf *)0x0) {
            if (p->tot_len != 0) {
              pbuf_chain(h,p);
            }
LAB_230410e2:
            if ((pcb->flags & 4) == 0) {
LAB_23041106:
              if ((dst_ip->addr & 0xf0) != 0xe0) goto LAB_2304114a;
              uVar2 = pcb->mcast_ttl;
            }
            else {
              if ((dst_ip->addr & 0xf0) == 0xe0) {
                h->flags = h->flags | 4;
                goto LAB_23041106;
              }
LAB_2304114a:
              uVar2 = pcb->ttl;
            }
            eVar1 = ip4_output_if(h,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip,uVar2,pcb->tos,
                                  pcb->protocol,netif);
            if (p != h) {
              pbuf_free(h);
            }
            goto LAB_2304109e;
          }
        }
      }
      eVar1 = -1;
      goto LAB_2304109e;
    }
    if (0x13 < p->len) {
      eVar1 = ip4_output_if(p,(ip4_addr_t *)src_ip,(ip4_addr_t *)0x0,'\0','\0','\0',netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eVar1;
    }
  }
  eVar1 = -6;
LAB_2304109e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t raw_sendto(raw_pcb *pcb,pbuf *p,ip_addr_t *ipaddr)

{
  err_t eVar1;
  netif *netif;
  raw_pcb *src_ip;
  uint uVar2;
  
  if ((pcb == (raw_pcb *)0x0) || (ipaddr == (ip_addr_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -6;
  }
  if (pcb->netif_idx == '\0') {
    if (((ipaddr->addr & 0xf0) == 0xe0) &&
       (netif = netif_get_by_index(pcb->mcast_ifindex), netif != (netif *)0x0)) goto LAB_230411a2;
    netif = ip4_route((ip4_addr_t *)ipaddr);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -4;
  }
LAB_230411a2:
  uVar2 = (pcb->local_ip).addr;
  if ((uVar2 == 0) || (src_ip = pcb, (uVar2 & 0xf0) == 0xe0)) {
    src_ip = (raw_pcb *)&netif->ip_addr;
  }
  eVar1 = raw_sendto_if_src(pcb,p,ipaddr,netif,(ip_addr_t *)src_ip);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t raw_send(raw_pcb *pcb,pbuf *p)

{
  err_t eVar1;
  
  eVar1 = raw_sendto(pcb,p,&pcb->remote_ip);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void raw_remove(raw_pcb *pcb)

{
  raw_pcb *prVar1;
  raw_pcb *prVar2;
  
  prVar1 = raw_pcbs;
  if (raw_pcbs == pcb) {
    raw_pcbs = pcb->next;
  }
  else {
    do {
      prVar2 = prVar1;
      if ((prVar2 == (raw_pcb *)0x0) || (prVar1 = prVar2->next, prVar1 == (raw_pcb *)0x0))
      goto LAB_230411f0;
    } while (prVar1 != pcb);
    prVar2->next = pcb->next;
  }
LAB_230411f0:
  memp_free(MEMP_RAW_PCB,pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



raw_pcb * raw_new(u8_t proto)

{
  raw_pcb *prVar1;
  raw_pcb *__s;
  
  __s = (raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  if (__s != (raw_pcb *)0x0) {
    memset(__s,0,0x1c);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
    __s->protocol = proto;
    prVar1 = __s;
    __s->next = raw_pcbs;
    raw_pcbs = prVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



raw_pcb * raw_new_ip_type(u8_t type,u8_t proto)

{
  raw_pcb *prVar1;
  
  prVar1 = raw_new(proto);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return prVar1;
}



void raw_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  raw_pcb *prVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (prVar1 = raw_pcbs, new_addr->addr != 0)) {
    while (prVar1 != (raw_pcb *)0x0) {
      if ((prVar1->local_ip).addr == old_addr->addr) {
        (prVar1->local_ip).addr = new_addr->addr;
      }
      prVar1 = prVar1->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



raw_pcb * raw_get_pcbs(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return raw_pcbs;
}



void stats_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: ip_str
// WARNING: Type propagation algorithm not settling

void stats_netstat(void *ctx)

{
  ushort uVar1;
  ip4_addr_t addr;
  int iVar2;
  udp_pcb *addr_00;
  raw_pcb *addr_01;
  char *pcVar3;
  int iVar4;
  tcp_pcb ***ppptStack164;
  tcp_pcb ***_tcp_pcb_list;
  char ip_str [128];
  
  memset(&_tcp_pcb_list,0,0x80);
  ppptStack164 = (tcp_pcb ***)0x0;
  iVar2 = tcp_get_pcbs(&ppptStack164);
  addr_00 = udp_get_pcbs();
  addr_01 = raw_get_pcbs();
  printf("netstat tools\r\n");
  iVar4 = 0;
  while (iVar4 < iVar2) {
    addr = (ip4_addr_t)((ip4_addr_t *)ppptStack164[iVar4])->addr;
    while (addr != (ip4_addr_t)0x0) {
      ip4addr_ntoa_r((ip4_addr_t *)addr,(char *)&_tcp_pcb_list,0x80);
      printf("TCP\t%s:%hu\t",&_tcp_pcb_list,
             (uint)*(ushort *)((int)&((ip4_addr_t *)((int)addr + 0x14))->addr + 2));
      ip4addr_ntoa_r((ip4_addr_t *)((int)addr + 4),(char *)&_tcp_pcb_list,0x80);
      uVar1 = *(ushort *)&((ip4_addr_t *)((int)addr + 0x18))->addr;
      pcVar3 = tcp_debug_state_str(*(tcp_state *)&((ip4_addr_t *)((int)addr + 0x14))->addr);
      printf("%s:%hu\t%s\r\n",&_tcp_pcb_list,(uint)uVar1,pcVar3);
      addr = (ip4_addr_t)((ip4_addr_t *)&((ip4_addr_t *)((int)addr + 0xc))->addr)->addr;
    }
    iVar4 = iVar4 + 1;
  }
  while (addr_00 != (udp_pcb *)0x0) {
    ip4addr_ntoa_r((ip4_addr_t *)addr_00,(char *)&_tcp_pcb_list,0x80);
    printf("UDP\t%s:%hu\t",&_tcp_pcb_list,(uint)addr_00->local_port);
    ip4addr_ntoa_r((ip4_addr_t *)&addr_00->remote_ip,(char *)&_tcp_pcb_list,0x80);
    printf("%s:%hu\r\n",&_tcp_pcb_list,(uint)addr_00->remote_port);
    addr_00 = addr_00->next;
  }
  while (addr_01 != (raw_pcb *)0x0) {
    ip4addr_ntoa_r((ip4_addr_t *)addr_01,(char *)&_tcp_pcb_list,0x80);
    printf("RAW\t%s\t",&_tcp_pcb_list);
    ip4addr_ntoa_r((ip4_addr_t *)&addr_01->remote_ip,(char *)&_tcp_pcb_list,0x80);
    printf("%s\t%d\r\n",&_tcp_pcb_list,(uint)addr_01->protocol);
    addr_01 = addr_01->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u16_t tcp_new_port(void)

{
  short sVar1;
  u32_t uVar2;
  tcp_pcb ***ppptVar3;
  
  sVar1 = 0x4000;
again:
  tcp_port = tcp_port + 1;
  if (tcp_port == 0xffff) {
    tcp_port = 0xc000;
  }
  ppptVar3 = tcp_pcb_lists;
  do {
    uVar2 = (((tcp_pcb *)*ppptVar3)->local_ip).addr;
    while (uVar2 != 0) {
      if (*(u16_t *)(uVar2 + 0x16) == tcp_port) {
        sVar1 = sVar1 + -1;
        if (sVar1 == 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        goto again;
      }
      uVar2 = *(u32_t *)(uVar2 + 0xc);
    }
    ppptVar3 = (tcp_pcb ***)((tcp_pcb **)ppptVar3 + 1);
    if (ppptVar3 == (tcp_pcb ***)tcp_state_str) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return tcp_port;
    }
  } while( true );
}



err_t tcp_close_shutdown_fin(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  tcp_state tVar2;
  int iVar3;
  
  tVar2 = pcb->state;
  if (tVar2 == ESTABLISHED) {
LAB_23041440:
    eVar1 = tcp_send_fin(pcb);
    iVar3 = CONCAT31(extraout_var,eVar1);
    if (iVar3 == 0) {
      tVar2 = FIN_WAIT_1;
      goto LAB_2304144a;
    }
LAB_2304146c:
    if (iVar3 != -1) goto LAB_23041456;
    pcb->flags = pcb->flags | 8;
  }
  else {
    if (tVar2 != CLOSE_WAIT) {
      iVar3 = 0;
      if (tVar2 != SYN_RCVD) goto LAB_23041456;
      goto LAB_23041440;
    }
    eVar1 = tcp_send_fin(pcb);
    iVar3 = CONCAT31(extraout_var_00,eVar1);
    if (iVar3 != 0) goto LAB_2304146c;
    tVar2 = LAST_ACK;
LAB_2304144a:
    pcb->state = tVar2;
    tcp_output(pcb);
  }
  iVar3 = 0;
LAB_23041456:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar3;
}



void tcp_init(void)

{
  uint uVar1;
  
  uVar1 = bl_rand();
  tcp_port = (u16_t)(((uVar1 & 0x3fff) - 0x4000) * 0x10000 >> 0x10);
  printf("-------------------->>>>>>>> LWIP tcp_port %u\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_free(tcp_pcb *pcb)

{
  memp_free(MEMP_TCP_PCB,pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t tcp_bind(tcp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  tcp_pcb *ptVar1;
  err_t eVar2;
  u16_t uVar3;
  undefined2 extraout_var;
  int iVar5;
  undefined2 in_register_00002032;
  tcp_pcb ***ppptVar6;
  u32_t *puVar7;
  uint uVar4;
  
  uVar4 = CONCAT22(in_register_00002032,port);
  if (ipaddr == (ip_addr_t *)0x0) {
    ipaddr = &ip_addr_any;
  }
  eVar2 = -0x10;
  if ((pcb != (tcp_pcb *)0x0) && (eVar2 = -6, pcb->state == CLOSED)) {
    if (uVar4 == 0) {
      uVar3 = tcp_new_port();
      uVar4 = CONCAT22(extraout_var,uVar3);
      if (uVar4 == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -2;
      }
    }
    else {
      ppptVar6 = tcp_pcb_lists;
      iVar5 = 0;
      do {
        puVar7 = (u32_t *)(((tcp_pcb *)*ppptVar6)->local_ip).addr;
        while (puVar7 != (u32_t *)0x0) {
          if (((*(ushort *)((int)puVar7 + 0x16) == uVar4) &&
              (((pcb->so_options & 4) == 0 || ((*(byte *)((int)puVar7 + 9) & 4) == 0)))) &&
             ((*puVar7 == 0 || ((ipaddr->addr == 0 || (*puVar7 == ipaddr->addr)))))) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -8;
          }
          puVar7 = (u32_t *)puVar7[3];
        }
        iVar5 = iVar5 + 1;
        ppptVar6 = (tcp_pcb ***)((tcp_pcb **)ppptVar6 + 1);
      } while (((pcb->so_options & 4) == 0) + 3 != iVar5);
    }
    if (ipaddr->addr != 0) {
      (pcb->local_ip).addr = ipaddr->addr;
    }
    pcb->local_port = (u16_t)uVar4;
    ptVar1 = pcb;
    pcb->next = tcp_bound_pcbs;
    tcp_bound_pcbs = ptVar1;
    tcp_timer_needed();
    eVar2 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



void tcp_bind_netif(tcp_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



tcp_pcb * tcp_listen_with_backlog_and_err(tcp_pcb *pcb,u8_t backlog,err_t *err)

{
  u8_t uVar1;
  tcp_pcb *ptVar2;
  tcp_pcb *ptVar3;
  err_t eVar4;
  tcp_pcb *ptVar5;
  
  if (pcb == (tcp_pcb *)0x0) {
    ptVar3 = (tcp_pcb *)0x0;
    eVar4 = -0x10;
  }
  else {
    if (pcb->state == CLOSED) {
      ptVar3 = tcp_listen_pcbs;
      if ((pcb->so_options & 4) != 0) {
        while (ptVar3 != (tcp_pcb *)0x0) {
          if ((ptVar3->local_port == pcb->local_port) &&
             ((ptVar3->local_ip).addr == (pcb->local_ip).addr)) {
            eVar4 = -8;
            goto LAB_2304166a;
          }
          ptVar3 = ptVar3->next;
        }
      }
      ptVar3 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB_LISTEN);
      eVar4 = -1;
      if (ptVar3 != (tcp_pcb *)0x0) {
        ptVar3->callback_arg = pcb->callback_arg;
        ptVar3->local_port = pcb->local_port;
        ptVar3->state = LISTEN;
        ptVar3->prio = pcb->prio;
        uVar1 = pcb->so_options;
        ptVar3->netif_idx = '\0';
        ptVar3->so_options = uVar1;
        ptVar3->ttl = pcb->ttl;
        ptVar3->tos = pcb->tos;
        (ptVar3->local_ip).addr = (pcb->local_ip).addr;
        if (pcb->local_port != 0) {
          ptVar2 = tcp_bound_pcbs;
          if (tcp_bound_pcbs == pcb) {
            tcp_bound_pcbs = pcb->next;
          }
          else {
            do {
              ptVar5 = ptVar2;
              if (ptVar5 == (tcp_pcb *)0x0) goto LAB_230415fc;
              ptVar2 = ptVar5->next;
            } while (ptVar5->next != pcb);
            ptVar5->next = pcb->next;
          }
LAB_230415fc:
          pcb->next = (tcp_pcb *)0x0;
        }
        tcp_free(pcb);
        *(code **)&ptVar3->remote_port = tcp_accept_null;
        ptVar2 = ptVar3;
        ptVar3->next = tcp_listen_pcbs;
        tcp_listen_pcbs = ptVar2;
        tcp_timer_needed();
        eVar4 = '\0';
      }
    }
    else {
      eVar4 = -0xf;
LAB_2304166a:
      ptVar3 = (tcp_pcb *)0x0;
    }
  }
  if (err != (err_t *)0x0) {
    *err = eVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar3;
}



u32_t tcp_update_rcv_ann_wnd(tcp_pcb *pcb)

{
  u32_t uVar1;
  u32_t uVar2;
  u32_t uVar3;
  uint uVar4;
  
  uVar3 = pcb->rcv_ann_right_edge;
  uVar2 = pcb->rcv_nxt;
  uVar4 = (uint)pcb->mss;
  uVar1 = (pcb->rcv_wnd - uVar3) + uVar2;
  if (0x408 < uVar4) {
    uVar4 = 0x408;
  }
  if (-1 < (int)(uVar1 - uVar4)) {
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return uVar1;
  }
  if ((int)(uVar2 - uVar3) < 1) {
    pcb->rcv_ann_wnd = (short)uVar3 - (short)uVar2;
  }
  else {
    pcb->rcv_ann_wnd = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void tcp_recved(tcp_pcb *pcb,u16_t len)

{
  u32_t uVar1;
  ushort uVar2;
  
  if (pcb == (tcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar2 = len + pcb->rcv_wnd;
  if ((0x810 < uVar2) || (uVar2 < pcb->rcv_wnd)) {
    uVar2 = 0x810;
  }
  pcb->rcv_wnd = uVar2;
  uVar1 = tcp_update_rcv_ann_wnd(pcb);
  if (0x407 < uVar1) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_seg_free(tcp_seg *seg)

{
  if (seg == (tcp_seg *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (seg->p != (pbuf *)0x0) {
    pbuf_free(seg->p);
  }
  memp_free(MEMP_TCP_SEG,seg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_segs_free(tcp_seg *seg)

{
  tcp_seg *ptVar1;
  
  if (seg != (tcp_seg *)0x0) {
    do {
      ptVar1 = seg->next;
      tcp_seg_free(seg);
      seg = ptVar1;
    } while (ptVar1 != (tcp_seg *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_setprio(tcp_pcb *pcb,u8_t prio)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->prio = prio;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



tcp_seg * tcp_seg_copy(tcp_seg *seg)

{
  tcp_seg *__dest;
  
  __dest = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (__dest != (tcp_seg *)0x0) {
    memcpy(__dest,seg,0x14);
    pbuf_ref(__dest->p);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __dest;
}



void tcp_arg(tcp_pcb *pcb,void *arg)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->callback_arg = arg;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_recv(tcp_pcb *pcb,tcp_recv_fn *recv)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->recv = recv;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_sent(tcp_pcb *pcb,tcp_sent_fn *sent)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->sent = sent;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_err(tcp_pcb *pcb,tcp_err_fn *err)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->errf = err;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_accept(tcp_pcb *pcb,tcp_accept_fn accept)

{
  if ((pcb != (tcp_pcb *)0x0) && (pcb->state == LISTEN)) {
    *(tcp_accept_fn *)&pcb->remote_port = accept;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_poll(tcp_pcb *pcb,tcp_poll_fn *poll,u8_t interval)

{
  if (pcb != (tcp_pcb *)0x0) {
    pcb->poll = poll;
    pcb->pollinterval = interval;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u32_t tcp_next_iss(tcp_pcb *pcb)

{
  tcp_next_iss::iss = tcp_next_iss::iss + tcp_ticks;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return tcp_next_iss::iss;
}



u16_t tcp_eff_send_mss_netif(u16_t sendmss,netif *outif,ip_addr_t *dest)

{
  ushort uVar1;
  undefined2 in_register_0000202a;
  uint uVar2;
  uint uVar3;
  
  uVar2 = CONCAT22(in_register_0000202a,sendmss);
  if ((outif != (netif *)0x0) && (uVar1 = outif->mtu, uVar1 != 0)) {
    uVar3 = 0;
    if ((0x28 < uVar1) && (uVar3 = (uint)(ushort)(uVar1 - 0x28), uVar2 < (ushort)(uVar1 - 0x28))) {
      uVar3 = uVar2;
    }
    uVar2 = uVar3 & 0xffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u16_t)uVar2;
}



err_t tcp_connect(tcp_pcb *pcb,ip_addr_t *ipaddr,u16_t port,tcp_connected_fn connected)

{
  u16_t uVar1;
  int iVar2;
  err_t eVar3;
  u16_t uVar4;
  netif *outif;
  undefined2 extraout_var_00;
  u32_t uVar5;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  tcp_pcb *ptVar6;
  tcp_pcb *ptVar7;
  
  iVar2 = -0x10;
  if (((pcb != (tcp_pcb *)0x0) && (ipaddr != (ip_addr_t *)0x0)) &&
     (iVar2 = -10, pcb->state == CLOSED)) {
    (pcb->remote_ip).addr = ipaddr->addr;
    pcb->remote_port = port;
    if (pcb->netif_idx == '\0') {
      outif = ip4_route((ip4_addr_t *)&pcb->remote_ip);
    }
    else {
      outif = netif_get_by_index(pcb->netif_idx);
    }
    iVar2 = -4;
    if (outif != (netif *)0x0) {
      if ((pcb->local_ip).addr == 0) {
        (pcb->local_ip).addr = (outif->ip_addr).addr;
      }
      uVar1 = pcb->local_port;
      if (uVar1 == 0) {
        uVar4 = tcp_new_port();
        pcb->local_port = uVar4;
        iVar2 = -2;
        if (CONCAT22(extraout_var_00,uVar4) == 0) goto LAB_2304185c;
      }
      else {
        ptVar6 = tcp_active_pcbs;
        if ((pcb->so_options & 4) != 0) {
          while (ptVar7 = tcp_tw_pcbs, ptVar6 != (tcp_pcb *)0x0) {
            if (((ptVar6->local_port == uVar1) &&
                ((uint)ptVar6->remote_port == CONCAT22(in_register_00002032,port))) &&
               (((ptVar6->local_ip).addr == (pcb->local_ip).addr &&
                ((ptVar6->remote_ip).addr == ipaddr->addr)))) goto LAB_230418b4;
            ptVar6 = ptVar6->next;
          }
          while (ptVar7 != (tcp_pcb *)0x0) {
            if (((ptVar7->local_port == uVar1) &&
                ((uint)ptVar7->remote_port == CONCAT22(in_register_00002032,port))) &&
               (((ptVar7->local_ip).addr == (pcb->local_ip).addr &&
                ((ptVar7->remote_ip).addr == ipaddr->addr)))) goto LAB_230418b4;
            ptVar7 = ptVar7->next;
          }
        }
      }
      uVar5 = tcp_next_iss(pcb);
      *(undefined4 *)&pcb->rcv_wnd = 0x8100810;
      pcb->snd_nxt = uVar5;
      pcb->snd_wnd = 0x810;
      uVar5 = uVar5 - 1;
      pcb->lastack = uVar5;
      pcb->snd_wl2 = uVar5;
      pcb->snd_lbb = uVar5;
      pcb->mss = 0x218;
      pcb->rcv_nxt = 0;
      pcb->rcv_ann_right_edge = 0;
      uVar4 = tcp_eff_send_mss_netif(0x218,outif,&pcb->remote_ip);
      pcb->mss = uVar4;
      pcb->cwnd = 1;
      pcb->connected = connected;
      eVar3 = tcp_enqueue_flags(pcb,'\x02');
      iVar2 = CONCAT31(extraout_var,eVar3);
      if (iVar2 == 0) {
        pcb->state = SYN_SENT;
        if (uVar1 != 0) {
          ptVar6 = tcp_bound_pcbs;
          if (tcp_bound_pcbs == pcb) {
            tcp_bound_pcbs = pcb->next;
          }
          else {
            do {
              ptVar7 = ptVar6;
              if (ptVar7 == (tcp_pcb *)0x0) goto LAB_2304193a;
              ptVar6 = ptVar7->next;
            } while (ptVar7->next != pcb);
            ptVar7->next = pcb->next;
          }
        }
LAB_2304193a:
        ptVar6 = pcb;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = ptVar6;
        tcp_timer_needed();
        tcp_active_pcbs_changed = '\x01';
        tcp_output(pcb);
      }
    }
  }
LAB_2304185c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
LAB_230418b4:
  iVar2 = -8;
  goto LAB_2304185c;
}



char * tcp_debug_state_str(tcp_state s)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return tcp_state_str[CONCAT31(in_register_00002029,s)];
}



err_t tcp_tcp_get_tcp_addrinfo(tcp_pcb *pcb,int local,ip_addr_t *addr,u16_t *port)

{
  u16_t uVar1;
  
  if (pcb == (tcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -6;
  }
  if (local == 0) {
    if (addr != (ip_addr_t *)0x0) {
      addr->addr = (pcb->remote_ip).addr;
    }
    if (port == (u16_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
    uVar1 = pcb->remote_port;
  }
  else {
    if (addr != (ip_addr_t *)0x0) {
      addr->addr = (pcb->local_ip).addr;
    }
    if (port == (u16_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
    uVar1 = pcb->local_port;
  }
  *port = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void tcp_free_ooseq(tcp_pcb *pcb)

{
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = (tcp_seg *)0x0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_pcb_purge(tcp_pcb *pcb)

{
  if (((pcb != (tcp_pcb *)0x0) && (LISTEN < pcb->state)) && (pcb->state != TIME_WAIT)) {
    if (pcb->refused_data != (pbuf *)0x0) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = (pbuf *)0x0;
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      tcp_free_ooseq(pcb);
    }
    pcb->rtime = -1;
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unsent = (tcp_seg *)0x0;
    pcb->unacked = (tcp_seg *)0x0;
    pcb->unsent_oversize = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_pcb_remove(tcp_pcb **pcblist,tcp_pcb *pcb)

{
  tcp_pcb *ptVar1;
  tcp_pcb *ptVar2;
  
  ptVar1 = *pcblist;
  if (*pcblist == pcb) {
    *pcblist = pcb->next;
  }
  else {
    do {
      ptVar2 = ptVar1;
      if (ptVar2 == (tcp_pcb *)0x0) goto LAB_23041a5a;
      ptVar1 = ptVar2->next;
    } while (ptVar2->next != pcb);
    ptVar2->next = pcb->next;
  }
LAB_23041a5a:
  pcb->next = (tcp_pcb *)0x0;
  tcp_pcb_purge(pcb);
  if (((pcb->state != TIME_WAIT) && (pcb->state != LISTEN)) && ((pcb->flags & 1) != 0)) {
    pcb->flags = pcb->flags | 2;
    tcp_output(pcb);
  }
  pcb->state = CLOSED;
  pcb->local_port = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_abandon(tcp_pcb *pcb,int reset)

{
  tcp_pcb *ptVar1;
  u16_t uVar2;
  tcp_pcb *ptVar3;
  tcp_err_fn *UNRECOVERED_JUMPTABLE;
  void *pvVar4;
  u32_t seqno;
  u32_t ackno;
  
  if (pcb == (tcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs,pcb);
    tcp_free(pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  seqno = pcb->snd_nxt;
  ackno = pcb->rcv_nxt;
  UNRECOVERED_JUMPTABLE = pcb->errf;
  pvVar4 = pcb->callback_arg;
  uVar2 = pcb->local_port;
  if (pcb->state == CLOSED) {
    reset = 0;
    if (uVar2 != 0) {
      ptVar1 = tcp_bound_pcbs;
      if (tcp_bound_pcbs == pcb) {
        tcp_bound_pcbs = pcb->next;
      }
      else {
        do {
          ptVar3 = ptVar1;
          if (ptVar3 == (tcp_pcb *)0x0) goto LAB_23041b20;
          ptVar1 = ptVar3->next;
        } while (ptVar3->next != pcb);
        ptVar3->next = pcb->next;
      }
LAB_23041b20:
      pcb->next = (tcp_pcb *)0x0;
      uVar2 = 0;
      reset = 0;
    }
  }
  else {
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_active_pcbs_changed = '\x01';
  }
  if (pcb->unacked != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unacked);
  }
  if (pcb->unsent != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->unsent);
  }
  if (pcb->ooseq != (tcp_seg *)0x0) {
    tcp_segs_free(pcb->ooseq);
  }
  if (reset != 0) {
    tcp_rst(pcb,seqno,ackno,(ip_addr_t *)pcb,&pcb->remote_ip,uVar2,pcb->remote_port);
  }
  tcp_free(pcb);
  if (UNRECOVERED_JUMPTABLE == (tcp_err_fn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
                    // WARNING: Could not recover jumptable at 0x23041b7c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(pvVar4,-0xd);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_abort(tcp_pcb *pcb)

{
  tcp_abandon(pcb,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t tcp_accept_null(void *arg,tcp_pcb *pcb,err_t err)

{
  tcp_abort(pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xd;
}



void tcp_netif_ip_addr_changed_pcblist(tcp_pcb *pcb_list)

{
  tcp_pcb *in_a1;
  tcp_pcb *pcb;
  
  while (pcb = in_a1, pcb != (tcp_pcb *)0x0) {
    in_a1 = pcb->next;
    if ((pcb->local_ip).addr == (pcb_list->local_ip).addr) {
      tcp_abort(pcb);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  u32_t *puVar1;
  
  if (old_addr == (ip_addr_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (old_addr->addr != 0) {
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    tcp_netif_ip_addr_changed_pcblist((tcp_pcb *)old_addr);
    if ((new_addr != (ip_addr_t *)0x0) && (puVar1 = tcp_listen_pcbs, new_addr->addr != 0)) {
      while (puVar1 != (u32_t *)0x0) {
        if (*puVar1 == old_addr->addr) {
          *puVar1 = new_addr->addr;
        }
        puVar1 = (u32_t *)puVar1[3];
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_kill_state(tcp_state state)

{
  undefined3 in_register_00002029;
  uint uVar1;
  tcp_pcb *pcb;
  uint uVar2;
  tcp_pcb *ptVar3;
  
  uVar1 = 0;
  pcb = (tcp_pcb *)0x0;
  ptVar3 = tcp_active_pcbs;
  while (ptVar3 != (tcp_pcb *)0x0) {
    if (((uint)ptVar3->state == CONCAT31(in_register_00002029,state)) &&
       (uVar2 = tcp_ticks - ptVar3->tmr, uVar1 <= uVar2)) {
      uVar1 = uVar2;
      pcb = ptVar3;
    }
    ptVar3 = ptVar3->next;
  }
  if (pcb != (tcp_pcb *)0x0) {
    tcp_abandon(pcb,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



tcp_pcb * tcp_alloc(u8_t prio)

{
  u32_t uVar1;
  undefined3 in_register_00002029;
  tcp_pcb *ptVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  tcp_pcb *ptVar6;
  int iVar7;
  
  iVar7 = CONCAT31(in_register_00002029,prio);
  ptVar2 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
  ptVar6 = tcp_active_pcbs;
  if (ptVar2 == (tcp_pcb *)0x0) {
    while (ptVar2 = ptVar6, ptVar2 != (tcp_pcb *)0x0) {
      ptVar6 = ptVar2->next;
      if ((ptVar2->flags & 8) != 0) {
        ptVar2->flags = ptVar2->flags & 0xfff7;
        tcp_close_shutdown_fin(ptVar2);
      }
    }
    uVar4 = 0;
    ptVar6 = tcp_tw_pcbs;
    while (ptVar6 != (tcp_pcb *)0x0) {
      uVar5 = tcp_ticks - ptVar6->tmr;
      if (uVar4 <= uVar5) {
        ptVar2 = ptVar6;
        uVar4 = uVar5;
      }
      ptVar6 = ptVar6->next;
    }
    if (ptVar2 != (tcp_pcb *)0x0) {
      tcp_abort(ptVar2);
    }
    ptVar2 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    if (ptVar2 == (tcp_pcb *)0x0) {
      tcp_kill_state(LAST_ACK);
      ptVar2 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
      if (ptVar2 == (tcp_pcb *)0x0) {
        tcp_kill_state(CLOSING);
        ptVar2 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
        if (ptVar2 == (tcp_pcb *)0x0) {
          if ((char)prio < '\0') {
            iVar7 = 0x7f;
LAB_23041e24:
            uVar4 = iVar7 - 1U & 0xff;
            uVar5 = 0;
            ptVar6 = tcp_active_pcbs;
            while (ptVar6 != (tcp_pcb *)0x0) {
              uVar3 = (uint)ptVar6->prio;
              if ((uVar3 < uVar4) || ((uVar3 == uVar4 && (uVar5 <= tcp_ticks - ptVar6->tmr)))) {
                uVar5 = tcp_ticks - ptVar6->tmr;
                ptVar2 = ptVar6;
                uVar4 = uVar3;
              }
              ptVar6 = ptVar6->next;
            }
            if (ptVar2 != (tcp_pcb *)0x0) {
              tcp_abort(ptVar2);
            }
          }
          else {
            if (iVar7 != 0) goto LAB_23041e24;
          }
          ptVar2 = (tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
          if (ptVar2 == (tcp_pcb *)0x0) goto LAB_23041de4;
          lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
        }
        lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
      }
      lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
    }
    lwip_stats.memp[2]->err = lwip_stats.memp[2]->err - 1;
  }
  memset(ptVar2,0,0xa4);
  ptVar2->snd_buf = 0x1580;
  *(undefined4 *)&ptVar2->rcv_wnd = 0x8100810;
  ptVar2->ttl = -1;
  ptVar2->rto = 6;
  ptVar2->sv = 6;
  *(undefined4 *)&ptVar2->rtime = 0x218ffff;
  uVar1 = tcp_ticks;
  ptVar2->prio = prio;
  ptVar2->tmr = uVar1;
  ptVar2->last_timer = tcp_timer_ctr;
  *(undefined4 *)&ptVar2->cwnd = 0x15800001;
  ptVar2->recv = tcp_recv_null;
  ptVar2->keep_idle = 7200000;
  ptVar2->keep_intvl = 75000;
  ptVar2->keep_cnt = 9;
LAB_23041de4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar2;
}



tcp_pcb * tcp_new_ip_type(u8_t type)

{
  tcp_pcb *ptVar1;
  
  ptVar1 = tcp_alloc('@');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ptVar1;
}



err_t tcp_close_shutdown(tcp_pcb *pcb,u8_t rst_on_unacked_data)

{
  tcp_state tVar1;
  err_t eVar2;
  undefined3 in_register_0000202d;
  tcp_pcb *ptVar3;
  tcp_pcb *ptVar4;
  tcp_pcb ***ppptVar5;
  
  tVar1 = pcb->state;
  if (((CONCAT31(in_register_0000202d,rst_on_unacked_data) == 0) ||
      ((tVar1 != ESTABLISHED && (tVar1 != CLOSE_WAIT)))) ||
     ((pcb->refused_data == (pbuf *)0x0 && (pcb->rcv_wnd == 0x810)))) {
    if (tVar1 == LISTEN) {
      ppptVar5 = tcp_pcb_lists;
      do {
        ptVar3 = *ppptVar5[1];
        while (ptVar3 != (tcp_pcb *)0x0) {
          if (pcb == (tcp_pcb *)ptVar3->listener) {
            ptVar3->listener = (tcp_pcb_listen *)0x0;
          }
          ptVar3 = ptVar3->next;
        }
        ppptVar5 = ppptVar5 + 1;
      } while (ppptVar5 != (tcp_pcb ***)0x2308643c);
      tcp_pcb_remove((tcp_pcb **)&tcp_listen_pcbs,pcb);
      memp_free(MEMP_TCP_PCB_LISTEN,pcb);
      goto LAB_23041eea;
    }
    if (tVar1 == CLOSED) {
      if (pcb->local_port != 0) {
        ptVar3 = tcp_bound_pcbs;
        if (tcp_bound_pcbs == pcb) {
          tcp_bound_pcbs = pcb->next;
        }
        else {
          do {
            ptVar4 = ptVar3;
            if (ptVar4 == (tcp_pcb *)0x0) goto LAB_23041f3a;
            ptVar3 = ptVar4->next;
          } while (ptVar4->next != pcb);
          ptVar4->next = pcb->next;
        }
LAB_23041f3a:
        pcb->next = (tcp_pcb *)0x0;
      }
    }
    else {
      if (tVar1 != SYN_SENT) {
        eVar2 = tcp_close_shutdown_fin(pcb);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return eVar2;
      }
      tcp_pcb_remove(&tcp_active_pcbs,pcb);
      tcp_active_pcbs_changed = '\x01';
    }
  }
  else {
    tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
            pcb->remote_port);
    tcp_pcb_purge(pcb);
    ptVar3 = tcp_active_pcbs;
    if (tcp_active_pcbs == pcb) {
      tcp_active_pcbs = pcb->next;
    }
    else {
      do {
        ptVar4 = ptVar3;
        if (ptVar4 == (tcp_pcb *)0x0) goto LAB_23041ecc;
        ptVar3 = ptVar4->next;
      } while (ptVar4->next != pcb);
      ptVar4->next = pcb->next;
    }
LAB_23041ecc:
    ptVar3 = tcp_input_pcb;
    tcp_active_pcbs_changed = '\x01';
    pcb->next = (tcp_pcb *)0x0;
    if (ptVar3 == pcb) {
      tcp_trigger_input_pcb_close();
      goto LAB_23041eea;
    }
  }
  tcp_free(pcb);
LAB_23041eea:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t tcp_close(tcp_pcb *pcb)

{
  err_t eVar1;
  
  if (pcb != (tcp_pcb *)0x0) {
    if (pcb->state != LISTEN) {
      pcb->flags = pcb->flags | 0x10;
    }
    eVar1 = tcp_close_shutdown(pcb,'\x01');
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t tcp_recv_null(void *arg,tcp_pcb *pcb,pbuf *p,err_t err)

{
  err_t eVar1;
  undefined3 in_register_00002035;
  
  if (pcb == (tcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if (p != (pbuf *)0x0) {
    tcp_recved(pcb,p->tot_len);
    pbuf_free(p);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  if (CONCAT31(in_register_00002035,err) == 0) {
    eVar1 = tcp_close(pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t tcp_process_refused_data(tcp_pcb *pcb)

{
  byte bVar1;
  int iVar2;
  err_t eVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  pbuf *p;
  
  iVar2 = -0x10;
  if (pcb == (tcp_pcb *)0x0) goto LAB_2304206a;
  p = pcb->refused_data;
  bVar1 = p->flags;
  pcb->refused_data = (pbuf *)0x0;
  if (pcb->recv == (tcp_recv_fn *)0x0) {
    eVar3 = tcp_recv_null((void *)0x0,pcb,p,'\0');
    iVar2 = CONCAT31(extraout_var_01,eVar3);
  }
  else {
    eVar3 = (*pcb->recv)(pcb->callback_arg,pcb,p,'\0');
    iVar2 = CONCAT31(extraout_var,eVar3);
  }
  if (iVar2 == 0) {
    if ((bVar1 & 0x20) == 0) goto LAB_2304206a;
    if (pcb->rcv_wnd != 0x810) {
      pcb->rcv_wnd = pcb->rcv_wnd + 1;
    }
    if ((pcb->recv == (tcp_recv_fn *)0x0) ||
       (eVar3 = (*pcb->recv)(pcb->callback_arg,pcb,(pbuf *)0x0,'\0'),
       CONCAT31(extraout_var_00,eVar3) != -0xd)) goto LAB_2304206a;
  }
  else {
    if (iVar2 != -0xd) {
      pcb->refused_data = p;
      iVar2 = -5;
      goto LAB_2304206a;
    }
  }
  iVar2 = -0xd;
LAB_2304206a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



void tcp_fasttmr(void)

{
  tcp_pcb *pcb;
  tcp_pcb *ptVar1;
  
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  pcb = tcp_active_pcbs;
  while( true ) {
    if (pcb == (tcp_pcb *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (pcb->last_timer == tcp_timer_ctr) break;
    pcb->last_timer = tcp_timer_ctr;
    if ((pcb->flags & 1) != 0) {
      pcb->flags = pcb->flags | 2;
      tcp_output(pcb);
      pcb->flags = pcb->flags & 0xfffc;
    }
    if ((pcb->flags & 8) != 0) {
      pcb->flags = pcb->flags & 0xfff7;
      tcp_close_shutdown_fin(pcb);
    }
    ptVar1 = pcb->next;
    if (pcb->refused_data == (pbuf *)0x0) goto LAB_23042130;
    tcp_active_pcbs_changed = '\0';
    tcp_process_refused_data(pcb);
    pcb = tcp_active_pcbs;
    if (tcp_active_pcbs_changed == '\0') {
LAB_23042130:
      pcb = ptVar1;
    }
  }
  ptVar1 = pcb->next;
  goto LAB_23042130;
}



err_t tcp_shutdown(tcp_pcb *pcb,int shut_rx,int shut_tx)

{
  err_t eVar1;
  uint uVar2;
  
  if (pcb == (tcp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  uVar2 = (uint)pcb->state;
  if (uVar2 == 1) {
LAB_23042196:
    eVar1 = -0xb;
  }
  else {
    if (shut_rx == 0) {
      if (shut_tx != 0) {
        if ((uVar2 < 8) && ((1 << (uVar2 & 0x1f) & 0x98U) != 0)) goto LAB_23042188;
        goto LAB_23042196;
      }
    }
    else {
      shut_rx = 1;
      pcb->flags = pcb->flags | 0x10;
      if (shut_tx != 0) {
LAB_23042188:
        eVar1 = tcp_close_shutdown(pcb,(u8_t)shut_rx);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return eVar1;
      }
      if (pcb->refused_data != (pbuf *)0x0) {
        pbuf_free(pcb->refused_data);
        pcb->refused_data = (pbuf *)0x0;
      }
    }
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void tcp_slowtmr(void)

{
  tcp_state tVar1;
  short sVar2;
  tcp_pcb *pcb;
  uint uVar3;
  tcp_err_fn *ptVar4;
  err_t eVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  byte bVar7;
  uint uVar8;
  u32_t uVar9;
  byte bVar10;
  int iVar11;
  void *pvVar12;
  tcp_pcb *ptVar13;
  tcp_pcb *ptVar14;
  
  tcp_ticks = tcp_ticks + 1;
  tcp_timer_ctr = tcp_timer_ctr + '\x01';
  do {
    ptVar14 = tcp_active_pcbs;
    ptVar13 = (tcp_pcb *)0x0;
LAB_23042200:
    do {
      while( true ) {
        pcb = ptVar14;
        ptVar14 = tcp_tw_pcbs;
        if (pcb == (tcp_pcb *)0x0) {
          while (ptVar14 != (tcp_pcb *)0x0) {
            if (tcp_ticks - ptVar14->tmr < 0xf1) {
              pcb = ptVar14;
              ptVar14 = ptVar14->next;
            }
            else {
              tcp_pcb_purge(ptVar14);
              ptVar13 = ptVar14->next;
              if (pcb != (tcp_pcb *)0x0) {
                pcb->next = ptVar14->next;
                ptVar13 = tcp_tw_pcbs;
              }
              tcp_tw_pcbs = ptVar13;
              ptVar13 = ptVar14->next;
              tcp_free(ptVar14);
              ptVar14 = ptVar13;
            }
          }
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        if (pcb->last_timer != tcp_timer_ctr) break;
        ptVar14 = pcb->next;
        ptVar13 = pcb;
      }
      pcb->last_timer = tcp_timer_ctr;
      if (pcb->state == SYN_SENT) {
        bVar7 = 5;
      }
      else {
        bVar7 = 0xb;
      }
      uVar3 = 1;
      if (pcb->nrtx <= bVar7) {
        uVar3 = (uint)pcb->persist_backoff;
        if (uVar3 == 0) {
          sVar2 = pcb->rtime;
          if (sVar2 < 0) {
LAB_23042456:
            if (pcb->rtime < pcb->rto) goto LAB_230422b0;
          }
          else {
            if (sVar2 != 0x7fff) {
              pcb->rtime = sVar2 + 1;
              goto LAB_23042456;
            }
          }
          eVar5 = tcp_rexmit_rto_prepare(pcb);
          if ((CONCAT31(extraout_var_02,eVar5) == 0) ||
             ((pcb->unacked == (tcp_seg *)0x0 && (pcb->unsent != (tcp_seg *)0x0)))) {
            if (pcb->state != SYN_SENT) {
              uVar6 = (uint)pcb->nrtx;
              if (0xc < uVar6) {
                uVar6 = 0xc;
              }
              iVar11 = ((int)pcb->sa >> 3) + (int)pcb->sv <<
                       ("\x01\x02\x03\x04\x05\x06\a\a\a\a\a\a\a"[uVar6] & 0x1f);
              if (0x7ffe < iVar11) {
                iVar11 = 0x7fff;
              }
              pcb->rto = (s16_t)iVar11;
            }
            pcb->rtime = 0;
            uVar6 = (uint)pcb->snd_wnd;
            if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
              uVar6 = (uint)pcb->cwnd;
            }
            uVar8 = (uint)pcb->mss << 0x11;
            pcb->ssthresh = (tcpwnd_size_t)(uVar6 >> 1);
            if (uVar6 >> 1 < uVar8 >> 0x10) {
              pcb->ssthresh = (tcpwnd_size_t)(uVar8 >> 0x10);
            }
            pcb->cwnd = pcb->mss;
            pcb->bytes_acked = 0;
            tcp_rexmit_rto_commit(pcb);
            goto LAB_230422b2;
          }
        }
        else {
          if (0xb < pcb->persist_probe) {
            uVar3 = 1;
            goto LAB_230422b2;
          }
          bVar7 = *(byte *)((int)&ip_addr_broadcast.addr + uVar3 + 3);
          if ((bVar7 <= pcb->persist_cnt) ||
             (bVar10 = pcb->persist_cnt + 1, pcb->persist_cnt = bVar10, bVar7 <= bVar10)) {
            if (pcb->snd_wnd == 0) {
              eVar5 = tcp_zero_window_probe(pcb);
              if (CONCAT31(extraout_var_01,eVar5) == 0) goto LAB_230423a0;
            }
            else {
              eVar5 = tcp_split_unsent_seg(pcb,pcb->snd_wnd);
              if ((CONCAT31(extraout_var,eVar5) != 0) ||
                 (eVar5 = tcp_output(pcb), CONCAT31(extraout_var_00,eVar5) != 0)) {
LAB_230423a0:
                pcb->persist_cnt = '\0';
                if (pcb->persist_backoff < 7) {
                  pcb->persist_backoff = pcb->persist_backoff + 1;
                }
              }
            }
          }
        }
LAB_230422b0:
        uVar3 = 0;
      }
LAB_230422b2:
      tVar1 = pcb->state;
      if (((tVar1 == FIN_WAIT_2) && ((pcb->flags & 0x10) != 0)) && (0x28 < tcp_ticks - pcb->tmr)) {
        uVar3 = uVar3 + 1 & 0xff;
      }
      bVar7 = pcb->so_options & 8;
      if (((pcb->so_options & 8) != 0) &&
         ((tVar1 == ESTABLISHED || (bVar7 = 0, tVar1 == CLOSE_WAIT)))) {
        uVar6 = tcp_ticks - pcb->tmr;
        if ((pcb->keep_intvl * pcb->keep_cnt + pcb->keep_idle) / 500 < uVar6) {
          uVar3 = uVar3 + 1 & 0xff;
          bVar7 = 1;
        }
        else {
          bVar7 = 0;
          if ((((uint)pcb->keep_cnt_sent * pcb->keep_intvl + pcb->keep_idle) / 500 < uVar6) &&
             (eVar5 = tcp_keepalive(pcb), bVar7 = 0, CONCAT31(extraout_var_03,eVar5) == 0)) {
            pcb->keep_cnt_sent = pcb->keep_cnt_sent + '\x01';
          }
        }
      }
      if ((pcb->ooseq != (tcp_seg *)0x0) && ((uint)(pcb->rto * 6) <= tcp_ticks - pcb->tmr)) {
        tcp_free_ooseq(pcb);
      }
      tVar1 = pcb->state;
      if (tVar1 == SYN_RCVD) {
        if (0x28 < tcp_ticks - pcb->tmr) {
          uVar3 = uVar3 + 1 & 0xff;
        }
LAB_23042362:
        if (uVar3 == 0) {
          ptVar14 = pcb->next;
          bVar7 = pcb->polltmr + 1;
          pcb->polltmr = bVar7;
          ptVar13 = pcb;
          if (pcb->pollinterval <= bVar7) {
            pcb->polltmr = '\0';
            tcp_active_pcbs_changed = '\0';
            if (pcb->poll != (tcp_poll_fn *)0x0) {
              eVar5 = (*pcb->poll)(pcb->callback_arg,pcb);
              if (tcp_active_pcbs_changed != '\0') break;
              if (CONCAT31(extraout_var_04,eVar5) != 0) goto LAB_23042200;
            }
            tcp_output(pcb);
          }
          goto LAB_23042200;
        }
      }
      else {
        if (tVar1 == LAST_ACK) {
          uVar9 = pcb->tmr;
          uVar6 = 0xf0;
        }
        else {
          if ((tVar1 != FIN_WAIT_1) && (tVar1 != CLOSING)) goto LAB_23042362;
          uVar9 = pcb->tmr;
          uVar6 = 10;
        }
        if (tcp_ticks - uVar9 <= uVar6) goto LAB_23042362;
      }
      ptVar4 = pcb->errf;
      tcp_pcb_purge(pcb);
      ptVar14 = pcb->next;
      if (ptVar13 != (tcp_pcb *)0x0) {
        ptVar13->next = pcb->next;
        ptVar14 = tcp_active_pcbs;
      }
      tcp_active_pcbs = ptVar14;
      if (bVar7 != 0) {
        tcp_rst(pcb,pcb->snd_nxt,pcb->rcv_nxt,(ip_addr_t *)pcb,&pcb->remote_ip,pcb->local_port,
                pcb->remote_port);
      }
      pvVar12 = pcb->callback_arg;
      ptVar14 = pcb->next;
      tcp_free(pcb);
      tcp_active_pcbs_changed = '\0';
    } while ((ptVar4 == (tcp_err_fn *)0x0) ||
            ((*ptVar4)(pvVar12,-0xd), tcp_active_pcbs_changed == '\0'));
  } while( true );
}



void tcp_tmr(void)

{
  tcp_fasttmr();
  tcp_timer = tcp_timer + 1;
  if ((tcp_timer & 1) != 0) {
    tcp_slowtmr();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int tcp_get_pcbs(tcp_pcb ****list)

{
  *list = tcp_pcb_lists;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 4;
}



u8_t tcp_get_next_optbyte(void)

{
  uint uVar1;
  
  uVar1 = (uint)tcp_optidx;
  if ((tcphdr_opt2 != (u8_t *)0x0) && (tcphdr_opt1len <= uVar1)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    tcp_optidx = tcp_optidx + 1;
    return tcphdr_opt2[uVar1 - tcphdr_opt1len & 0xff];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  tcp_optidx = tcp_optidx + 1;
  return *(u8_t *)((int)&tcphdr[1].src + uVar1);
}



void tcp_oos_insert_segment(tcp_seg *cseg,tcp_seg *next)

{
  u32_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t uVar4;
  int iVar5;
  tcp_hdr *ptVar6;
  
  uVar4 = lwip_htons(cseg->tcphdr->_hdrlen_rsvd_flags);
  if ((uVar4 & 1) == 0) {
    do {
      iVar5 = cseg->len + seqno;
      uVar1 = next->tcphdr->seqno;
      if ((int)(iVar5 - (next->len + uVar1)) < 0) {
        if (0 < (int)(iVar5 - uVar1)) {
          uVar4 = (u16_t)((uVar1 - seqno) * 0x10000 >> 0x10);
          cseg->len = uVar4;
          pbuf_realloc(cseg->p,uVar4);
        }
        goto LAB_23042662;
      }
      uVar4 = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags);
      if ((uVar4 & 1) != 0) {
        uVar2 = cseg->tcphdr->_hdrlen_rsvd_flags;
        uVar4 = lwip_htons(1);
        ptVar6 = cseg->tcphdr;
        uVar2 = uVar4 | uVar2;
        *(char *)&ptVar6->_hdrlen_rsvd_flags = (char)uVar2;
        *(char *)((int)&ptVar6->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar2 >> 8);
      }
      ptVar3 = next->next;
      tcp_seg_free(next);
      next = ptVar3;
    } while (ptVar3 != (tcp_seg *)0x0);
  }
  else {
    tcp_segs_free(next);
  }
  next = (tcp_seg *)0x0;
LAB_23042662:
  cseg->next = next;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_parseopt(undefined2 *param_1)

{
  uint uVar1;
  u8_t uVar2;
  byte bVar3;
  undefined2 uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  tcp_optidx = 0;
  while( true ) {
    while( true ) {
      do {
        uVar1 = (uint)tcphdr_optlen;
        if (uVar1 <= tcp_optidx) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        uVar2 = tcp_get_next_optbyte();
      } while (CONCAT31(extraout_var,uVar2) == 1);
      if (uVar2 == '\0') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      if (CONCAT31(extraout_var,uVar2) == 2) break;
      uVar2 = tcp_get_next_optbyte();
      if (CONCAT31(extraout_var_02,uVar2) < 2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      tcp_optidx = (tcp_optidx - 2) + (short)CONCAT31(extraout_var_02,uVar2);
    }
    uVar2 = tcp_get_next_optbyte();
    if (CONCAT31(extraout_var_00,uVar2) != 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (uVar1 <= tcp_optidx + 1) break;
    bVar3 = tcp_get_next_optbyte();
    uVar2 = tcp_get_next_optbyte();
    uVar1 = CONCAT31(extraout_var_01,uVar2) & 0xffff | ((uint)bVar3 << 0x18) >> 0x10;
    uVar4 = (undefined2)uVar1;
    if (0x2af < (uVar1 - 1 & 0xffff)) {
      uVar4 = 0x2b0;
    }
    *param_1 = uVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int tcp_input_delayed_close(tcp_pcb *pcb)

{
  if ((recv_flags & 0x10) != 0) {
    if (((pcb->flags & 0x10) == 0) && (pcb->errf != (tcp_err_fn *)0x0)) {
      (*pcb->errf)(pcb->callback_arg,-0xf);
    }
    tcp_pcb_remove(&tcp_active_pcbs,pcb);
    tcp_free(pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



tcp_seg * tcp_free_acked_segments(tcp_seg *seg_list)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  u16_t uVar3;
  u32_t uVar4;
  tcp_seg *in_a1;
  
  while( true ) {
    if (in_a1 == (tcp_seg *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (tcp_seg *)0x0;
    }
    uVar4 = lwip_htonl(in_a1->tcphdr->seqno);
    uVar1 = in_a1->len;
    uVar3 = lwip_htons(in_a1->tcphdr->_hdrlen_rsvd_flags);
    if (0 < (int)((uVar1 - ackno) + uVar4 + (uint)((uVar3 & 3) != 0))) break;
    ptVar2 = in_a1->next;
    uVar3 = pbuf_clen(in_a1->p);
    *(u16_t *)&seg_list->next = *(short *)&seg_list->next - uVar3;
    recv_acked = in_a1->len + recv_acked;
    tcp_seg_free(in_a1);
    in_a1 = ptVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_a1;
}



void tcp_receive(tcp_pcb *pcb)

{
  ushort uVar1;
  ushort uVar2;
  short sVar3;
  tcp_seg *ptVar4;
  tcp_seg *next;
  u16_t uVar5;
  u16_t uVar6;
  int iVar7;
  u32_t uVar8;
  pbuf *ppVar9;
  u32_t uVar10;
  uint uVar11;
  u32_t uVar12;
  uint uVar13;
  tcp_hdr *ptVar14;
  short sVar15;
  tcpwnd_size_t tVar16;
  tcpflags_t tVar17;
  uint uVar18;
  uint uVar19;
  tcp_seg *ptVar20;
  
  uVar8 = seqno;
  uVar12 = ackno;
  if ((flags & 0x10) != 0) {
    uVar1 = pcb->snd_wnd;
    uVar10 = pcb->snd_wl2;
    if ((((int)(pcb->snd_wl1 - seqno) < 0) ||
        ((pcb->snd_wl1 == seqno && ((int)(uVar10 - ackno) < 0)))) ||
       ((uVar10 == ackno && ((uint)uVar1 < (uint)tcphdr->wnd)))) {
      uVar2 = tcphdr->wnd;
      pcb->snd_wnd = uVar2;
      if (pcb->snd_wnd_max < uVar2) {
        pcb->snd_wnd_max = uVar2;
      }
      pcb->snd_wl1 = uVar8;
      pcb->snd_wl2 = uVar12;
    }
    uVar18 = uVar12 - pcb->lastack;
    if ((int)uVar18 < 1) {
      if ((((tcplen == 0) && ((uint)pcb->snd_wnd + pcb->snd_wl2 == uVar1 + uVar10)) &&
          (-1 < pcb->rtime)) && (pcb->lastack == uVar12)) {
        if (pcb->dupacks != -1) {
          pcb->dupacks = pcb->dupacks + '\x01';
        }
        if (pcb->dupacks < 4) {
          if (pcb->dupacks != 3) goto LAB_2304299c;
        }
        else {
          tVar16 = pcb->mss + pcb->cwnd;
          if (tVar16 < pcb->cwnd) {
            tVar16 = 0xffff;
          }
          pcb->cwnd = tVar16;
        }
        tcp_rexmit_fast(pcb);
      }
      else {
        pcb->dupacks = '\0';
      }
    }
    else {
      if ((int)(uVar12 - pcb->snd_nxt) < 1) {
        if ((pcb->flags & 4) != 0) {
          pcb->flags = pcb->flags & 0xfffb;
          pcb->bytes_acked = 0;
          pcb->cwnd = pcb->ssthresh;
        }
        pcb->lastack = uVar12;
        pcb->rto = (pcb->sa >> 3) + pcb->sv;
        *(undefined2 *)&pcb->nrtx = 0;
        if (SYN_RCVD < pcb->state) {
          uVar11 = (uint)pcb->cwnd;
          uVar18 = uVar18 & 0xffff;
          if (uVar11 < pcb->ssthresh) {
            uVar13 = (((pcb->flags & 0x800) == 0) + 1) * (uint)pcb->mss;
            if (uVar18 < (uVar13 & 0xffff)) {
              uVar13 = uVar18;
            }
          }
          else {
            uVar18 = uVar18 + pcb->bytes_acked;
            uVar13 = uVar18 & 0xffff;
            sVar15 = (short)uVar13;
            if (uVar13 < pcb->bytes_acked) {
              sVar15 = -1;
            }
            else {
              if (uVar13 < uVar11) {
                pcb->bytes_acked = (tcpwnd_size_t)(uVar18 * 0x10000 >> 0x10);
                goto LAB_23042cf8;
              }
            }
            pcb->bytes_acked = sVar15 - pcb->cwnd;
            uVar13 = (uint)pcb->mss;
          }
          uVar18 = uVar11 + uVar13 & 0xffff;
          tVar16 = (tcpwnd_size_t)uVar18;
          if (uVar18 < uVar11) {
            tVar16 = 0xffff;
          }
          pcb->cwnd = tVar16;
        }
LAB_23042cf8:
        ptVar4 = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        pcb->unacked = ptVar4;
        ptVar4 = tcp_free_acked_segments((tcp_seg *)&pcb->snd_queuelen);
        ptVar20 = pcb->unacked;
        pcb->unsent = ptVar4;
        pcb->polltmr = '\0';
        pcb->rtime = -(ushort)(ptVar20 == (tcp_seg *)0x0);
        if (ptVar4 == (tcp_seg *)0x0) {
          pcb->unsent_oversize = 0;
        }
        pcb->snd_buf = pcb->snd_buf + recv_acked;
        if ((int)((uint)pcb->flags << 0x14) < 0) {
          if (ptVar20 == (tcp_seg *)0x0) {
            if (ptVar4 != (tcp_seg *)0x0) {
              uVar12 = pcb->rto_end;
              ptVar14 = ptVar4->tcphdr;
              goto LAB_23042d74;
            }
          }
          else {
            uVar12 = pcb->rto_end;
            ptVar14 = ptVar20->tcphdr;
LAB_23042d74:
            uVar8 = lwip_htonl(ptVar14->seqno);
            if (0 < (int)(uVar12 - uVar8)) goto LAB_2304299c;
          }
          pcb->flags = pcb->flags & 0xf7ff;
        }
      }
      else {
        tcp_send_empty_ack(pcb);
      }
    }
LAB_2304299c:
    if ((pcb->rttest != 0) && ((int)(pcb->rtseq - ackno) < 0)) {
      uVar13 = (uint)(ushort)tcp_ticks;
      uVar11 = pcb->rttest & 0xffff;
      uVar18 = (int)pcb->sa >> 3 & 0xffff;
      uVar19 = (uVar13 - uVar11) - uVar18 & 0xffff;
      iVar7 = (int)(short)uVar19;
      sVar15 = (short)((uVar19 + (int)pcb->sa) * 0x10000 >> 0x10);
      pcb->sa = sVar15;
      if (iVar7 < 0) {
        iVar7 = (int)(((uVar11 - uVar13) + uVar18) * 0x10000) >> 0x10;
      }
      pcb->rttest = 0;
      sVar3 = (short)((uint)((((int)pcb->sv - ((int)pcb->sv >> 2)) + iVar7) * 0x10000) >> 0x10);
      pcb->sv = sVar3;
      pcb->rto = (sVar15 >> 3) + sVar3;
    }
  }
  uVar12 = pcb->rcv_nxt;
  if ((tcplen == 0) || (FIN_WAIT_2 < pcb->state)) {
    if ((-1 < (int)(seqno - uVar12)) && ((int)(((seqno + 1) - uVar12) - (uint)pcb->rcv_wnd) < 1))
    goto LAB_23042fce;
    tVar17 = pcb->flags;
LAB_23042fbc:
    tVar17 = tVar17 | 2;
  }
  else {
    uVar18 = uVar12 - seqno;
    if (((int)(uVar18 - 1) < 0) || (0 < (int)(((1 - seqno) - (uint)tcplen) + uVar12))) {
      if ((int)(seqno - uVar12) < 0) {
        pcb->flags = pcb->flags | 2;
      }
    }
    else {
      uVar11 = uVar18 & 0xffff;
      inseg.len = inseg.len - (short)(uVar18 * 0x10000 >> 0x10);
      iVar7 = (inseg.p)->tot_len - uVar11;
      ppVar9 = inseg.p;
      while (uVar1 = ppVar9->len, uVar1 < uVar11) {
        ppVar9->tot_len = (u16_t)((uint)(iVar7 * 0x10000) >> 0x10);
        ppVar9->len = 0;
        uVar11 = uVar11 - uVar1 & 0xffff;
        ppVar9 = ppVar9->next;
      }
      pbuf_remove_header(ppVar9,uVar11);
      ptVar14 = inseg.tcphdr;
      uVar12 = pcb->rcv_nxt;
      seqno = uVar12;
      *(char *)&(inseg.tcphdr)->seqno = (char)uVar12;
      *(char *)((int)&ptVar14->seqno + 1) = (char)(uVar12 >> 8);
      *(char *)((int)&ptVar14->seqno + 2) = (char)(uVar12 >> 0x10);
      *(char *)((int)&ptVar14->seqno + 3) = (char)(uVar12 >> 0x18);
    }
    uVar6 = inseg.len;
    uVar12 = pcb->rcv_nxt;
    if (((int)(seqno - uVar12) < 0) || (0 < (int)(((seqno + 1) - uVar12) - (uint)pcb->rcv_wnd))) {
LAB_23042ffc:
      tcp_send_empty_ack(pcb);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (seqno != uVar12) {
      ptVar4 = pcb->ooseq;
      ptVar20 = (tcp_seg *)0x0;
      if (pcb->ooseq == (tcp_seg *)0x0) {
        ptVar4 = tcp_seg_copy(&inseg);
        pcb->ooseq = ptVar4;
      }
      else {
        do {
          next = ptVar4;
          uVar12 = next->tcphdr->seqno;
          if (seqno == uVar12) {
            if ((next->len < inseg.len) && (ptVar4 = tcp_seg_copy(&inseg), ptVar4 != (tcp_seg *)0x0)
               ) {
              if (ptVar20 == (tcp_seg *)0x0) {
                pcb->ooseq = ptVar4;
              }
              else {
                ptVar20->next = ptVar4;
              }
LAB_23043062:
              tcp_oos_insert_segment(ptVar4,next);
            }
            goto LAB_23042ffc;
          }
          if (ptVar20 == (tcp_seg *)0x0) {
            if ((int)(seqno - uVar12) < 0) {
              ptVar4 = tcp_seg_copy(&inseg);
              if (ptVar4 != (tcp_seg *)0x0) {
                pcb->ooseq = ptVar4;
                goto LAB_23043062;
              }
              goto LAB_23042ffc;
            }
          }
          else {
            if ((-1 < (int)((seqno - 1) - ptVar20->tcphdr->seqno)) &&
               ((int)((seqno + 1) - uVar12) < 1)) {
              ptVar4 = tcp_seg_copy(&inseg);
              if (ptVar4 != (tcp_seg *)0x0) {
                uVar12 = ptVar20->tcphdr->seqno;
                if (0 < (int)((ptVar20->len + uVar12) - seqno)) {
                  uVar6 = (u16_t)((seqno - uVar12) * 0x10000 >> 0x10);
                  ptVar20->len = uVar6;
                  pbuf_realloc(ptVar20->p,uVar6);
                }
                ptVar20->next = ptVar4;
                goto LAB_23043062;
              }
              goto LAB_23042ffc;
            }
          }
          ptVar4 = next->next;
          ptVar20 = next;
        } while (next->next != (tcp_seg *)0x0);
        if ((0 < (int)(seqno - uVar12)) &&
           (uVar6 = lwip_htons(next->tcphdr->_hdrlen_rsvd_flags), (uVar6 & 1) == 0)) {
          ptVar4 = tcp_seg_copy(&inseg);
          next->next = ptVar4;
          if (ptVar4 != (tcp_seg *)0x0) {
            uVar12 = next->tcphdr->seqno;
            if (0 < (int)((next->len + uVar12) - seqno)) {
              uVar6 = (u16_t)((seqno - uVar12) * 0x10000 >> 0x10);
              next->len = uVar6;
              pbuf_realloc(next->p,uVar6);
            }
            if (0 < (int)(((tcplen + seqno) - pcb->rcv_nxt) - (uint)pcb->rcv_wnd)) {
              uVar6 = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              if ((uVar6 & 1) != 0) {
                uVar1 = next->next->tcphdr->_hdrlen_rsvd_flags;
                uVar6 = lwip_htons(uVar1);
                uVar6 = lwip_htons(uVar6 & 0x3e);
                ptVar14 = next->next->tcphdr;
                uVar18 = uVar1 & 0xffffc0ff | (uint)uVar6;
                *(char *)&ptVar14->_hdrlen_rsvd_flags = (char)uVar18;
                *(char *)((int)&ptVar14->_hdrlen_rsvd_flags + 1) = (char)(uVar18 >> 8);
              }
              next->next->len = (pcb->rcv_wnd - (short)seqno) + (short)pcb->rcv_nxt;
              pbuf_realloc(next->next->p,next->next->len);
              uVar6 = next->next->len;
              uVar5 = lwip_htons(next->next->tcphdr->_hdrlen_rsvd_flags);
              tcplen = uVar6 + ((uVar5 & 3) != 0);
            }
          }
        }
      }
      goto LAB_23042ffc;
    }
    uVar5 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    tcplen = ((uVar5 & 3) != 0) + uVar6;
    if (pcb->rcv_wnd < tcplen) {
      uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((uVar6 & 1) != 0) {
        uVar1 = (inseg.tcphdr)->_hdrlen_rsvd_flags;
        uVar6 = lwip_htons(uVar1);
        uVar6 = lwip_htons(uVar6 & 0x3e);
        ptVar14 = inseg.tcphdr;
        uVar18 = uVar1 & 0xffffc0ff | (uint)uVar6;
        *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)uVar18;
        *(char *)((int)&ptVar14->_hdrlen_rsvd_flags + 1) = (char)(uVar18 >> 8);
      }
      inseg.len = pcb->rcv_wnd;
      uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((uVar6 & 2) != 0) {
        inseg.len = inseg.len - 1;
      }
      pbuf_realloc(inseg.p,inseg.len);
      uVar6 = inseg.len;
      uVar5 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      tcplen = uVar6 + ((uVar5 & 3) != 0);
    }
    if (pcb->ooseq != (tcp_seg *)0x0) {
      uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
      if ((uVar6 & 1) == 0) {
        ptVar4 = pcb->ooseq;
        while (ptVar4 != (tcp_seg *)0x0) {
          uVar12 = ptVar4->tcphdr->seqno;
          if ((int)((tcplen + seqno) - (ptVar4->len + uVar12)) < 0) {
            if (0 < (int)((tcplen + seqno) - uVar12)) {
              inseg.len = (short)uVar12 - (short)seqno;
              uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              if ((uVar6 & 2) != 0) {
                inseg.len = inseg.len - 1;
              }
              pbuf_realloc(inseg.p,inseg.len);
              uVar6 = inseg.len;
              uVar5 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
              tcplen = uVar6 + ((uVar5 & 3) != 0);
            }
            break;
          }
          uVar6 = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
          if (((uVar6 & 1) != 0) &&
             (uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags), (uVar6 & 2) == 0)) {
            uVar1 = (inseg.tcphdr)->_hdrlen_rsvd_flags;
            uVar6 = lwip_htons(1);
            ptVar14 = inseg.tcphdr;
            uVar1 = uVar1 | uVar6;
            *(char *)&(inseg.tcphdr)->_hdrlen_rsvd_flags = (char)uVar1;
            *(char *)((int)&ptVar14->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
            uVar6 = inseg.len;
            uVar5 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
            tcplen = uVar6 + ((uVar5 & 3) != 0);
          }
          ptVar20 = ptVar4->next;
          tcp_seg_free(ptVar4);
          ptVar4 = ptVar20;
        }
        pcb->ooseq = ptVar4;
      }
      else {
        while (ptVar4 = pcb->ooseq, ptVar4 != (tcp_seg *)0x0) {
          pcb->ooseq = ptVar4->next;
          tcp_seg_free(ptVar4);
        }
      }
    }
    tVar16 = pcb->rcv_wnd - tcplen;
    pcb->rcv_nxt = seqno + tcplen;
    pcb->rcv_wnd = tVar16;
    tcp_update_rcv_ann_wnd(pcb);
    if ((inseg.p)->tot_len != 0) {
      recv_data = inseg.p;
      inseg.p = (pbuf *)0x0;
    }
    uVar6 = lwip_htons((inseg.tcphdr)->_hdrlen_rsvd_flags);
    if ((uVar6 & 1) != 0) {
      recv_flags = recv_flags | 0x20;
    }
    while (ptVar4 = pcb->ooseq, ptVar4 != (tcp_seg *)0x0) {
      uVar12 = ptVar4->tcphdr->seqno;
      if (uVar12 != pcb->rcv_nxt) break;
      uVar1 = ptVar4->len;
      seqno = uVar12;
      uVar6 = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_nxt = (uint)((uVar6 & 3) != 0) + (uint)uVar1 + pcb->rcv_nxt;
      lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      uVar6 = ptVar4->len;
      uVar5 = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      pcb->rcv_wnd = pcb->rcv_wnd - (((uVar5 & 3) != 0) + uVar6);
      tcp_update_rcv_ann_wnd(pcb);
      ppVar9 = ptVar4->p;
      if (ppVar9->tot_len != 0) {
        if (recv_data != (pbuf *)0x0) {
          pbuf_cat(recv_data,ppVar9);
          ppVar9 = recv_data;
        }
        recv_data = ppVar9;
        ptVar4->p = (pbuf *)0x0;
      }
      uVar6 = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      if (((uVar6 & 1) != 0) && (recv_flags = recv_flags | 0x20, pcb->state == ESTABLISHED)) {
        pcb->state = CLOSE_WAIT;
      }
      pcb->ooseq = ptVar4->next;
      tcp_seg_free(ptVar4);
    }
    uVar1 = pcb->flags;
    if ((uVar1 & 1) != 0) {
      tVar17 = uVar1 & 0xfffe;
      goto LAB_23042fbc;
    }
    tVar17 = uVar1 | 1;
  }
  pcb->flags = tVar17;
LAB_23042fce:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: ram

void tcp_input(pbuf *p,netif *inp)

{
  bool bVar1;
  ushort uVar2;
  byte bVar3;
  tcp_hdr *ptVar4;
  tcp_hdr *ptVar5;
  tcp_pcb *ptVar6;
  u8_t uVar7;
  err_t eVar8;
  u16_t uVar9;
  undefined3 extraout_var;
  undefined2 extraout_var_08;
  undefined2 extraout_var_09;
  undefined3 extraout_var_00;
  tcp_pcb *ptVar10;
  u32_t uVar11;
  netif *pnVar12;
  undefined3 extraout_var_01;
  undefined2 extraout_var_10;
  tcp_seg *seg;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  uint uVar13;
  u32_t uVar14;
  uint uVar15;
  int iVar16;
  tcp_state tVar17;
  u16_t uVar18;
  tcpflags_t tVar19;
  void *pvVar20;
  tcp_accept_fn paVar21;
  uint uVar22;
  uint uVar23;
  tcp_pcb *ptVar24;
  pbuf *ppVar25;
  u16_t uVar26;
  tcp_pcb *ptVar27;
  tcp_pcb *ptVar28;
  
  lwip_stats.tcp.recv = lwip_stats.tcp.recv + 1;
  tcphdr = (tcp_hdr *)p->payload;
  if (p->len < 0x14) goto LAB_230432a4;
  uVar7 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
  if ((CONCAT31(extraout_var,uVar7) == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
    uVar9 = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                             (ip4_addr_t *)&ip_data.current_iphdr_dest);
    if (CONCAT22(extraout_var_08,uVar9) == 0) {
      uVar9 = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
      uVar13 = CONCAT22(extraout_var_09,uVar9) >> 10 & 0xfc;
      if ((0x13 < uVar13) && (uVar13 <= p->tot_len)) {
        tcphdr_optlen = (u16_t)((uVar13 - 0x14) * 0x10000 >> 0x10);
        tcphdr_opt2 = (u8_t *)0x0;
        if (p->len < uVar13) {
          pbuf_remove_header(p,0x14);
          uVar9 = tcphdr_optlen;
          uVar2 = p->len;
          uVar13 = (uint)tcphdr_optlen;
          tcphdr_opt1len = uVar2;
          pbuf_remove_header(p,(uint)uVar2);
          ppVar25 = p->next;
          uVar13 = uVar13 - uVar2 & 0xffff;
          if (ppVar25->len < uVar13) goto LAB_230432a4;
          tcphdr_opt2 = (u8_t *)ppVar25->payload;
          pbuf_remove_header(ppVar25,uVar13);
          p->tot_len = (uVar2 + p->tot_len) - uVar9;
        }
        else {
          tcphdr_opt1len = tcphdr_optlen;
          pbuf_remove_header(p,uVar13);
        }
        ptVar4 = tcphdr;
        uVar9 = lwip_htons(tcphdr->src);
        *(char *)&ptVar4->src = (char)uVar9;
        *(char *)((int)&ptVar4->src + 1) = (char)(uVar9 >> 8);
        ptVar4 = tcphdr;
        uVar9 = lwip_htons(tcphdr->dest);
        *(char *)&ptVar4->dest = (char)uVar9;
        *(char *)((int)&ptVar4->dest + 1) = (char)(uVar9 >> 8);
        ptVar4 = tcphdr;
        seqno = lwip_htonl(tcphdr->seqno);
        *(char *)((int)&ptVar4->seqno + 1) = (char)(seqno >> 8);
        *(char *)((int)&ptVar4->seqno + 2) = (char)(seqno >> 0x10);
        *(char *)&ptVar4->seqno = (char)seqno;
        *(char *)((int)&ptVar4->seqno + 3) = (char)(seqno >> 0x18);
        ptVar4 = tcphdr;
        ackno = lwip_htonl(tcphdr->ackno);
        *(char *)((int)&ptVar4->ackno + 1) = (char)(ackno >> 8);
        *(char *)((int)&ptVar4->ackno + 2) = (char)(ackno >> 0x10);
        *(char *)&ptVar4->ackno = (char)ackno;
        *(char *)((int)&ptVar4->ackno + 3) = (char)(ackno >> 0x18);
        ptVar4 = tcphdr;
        uVar9 = lwip_htons(tcphdr->wnd);
        ptVar5 = tcphdr;
        *(char *)&ptVar4->wnd = (char)uVar9;
        *(char *)((int)&ptVar4->wnd + 1) = (char)(uVar9 >> 8);
        uVar9 = lwip_htons(ptVar5->_hdrlen_rsvd_flags);
        ptVar24 = tcp_active_pcbs;
        ptVar6 = tcp_listen_pcbs;
        ptVar4 = tcphdr;
        flags = (byte)uVar9 & 0x3f;
        tcplen = p->tot_len;
        if (((uVar9 & 3) == 0) ||
           (uVar26 = tcplen + 1, bVar1 = tcplen <= (ushort)(tcplen + 1), tcplen = uVar26, bVar1)) {
          ptVar10 = tcp_active_pcbs;
          ptVar27 = (tcp_pcb *)0x0;
LAB_230434e6:
          ptVar28 = ptVar10;
          ptVar10 = tcp_tw_pcbs;
          if (ptVar28 == (tcp_pcb *)0x0) goto LAB_2304374c;
          if (((((ptVar28->netif_idx != '\0') &&
                (ptVar28->netif_idx != (u8_t)((ip_data.current_input_netif)->num + '\x01'))) ||
               (ptVar28->remote_port != tcphdr->src)) ||
              ((ptVar28->local_port != tcphdr->dest ||
               ((ptVar28->remote_ip).addr != ip_data.current_iphdr_src)))) ||
             ((ptVar28->local_ip).addr != ip_data.current_iphdr_dest)) goto LAB_23043672;
          if (ptVar27 == (tcp_pcb *)0x0) {
            lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
          }
          else {
            tcp_active_pcbs = ptVar28;
            ptVar27->next = ptVar28->next;
            ptVar28->next = ptVar24;
          }
          inseg.len = p->tot_len;
          recv_data = (pbuf *)0x0;
          recv_flags = '\0';
          recv_acked = 0;
          inseg.next = (tcp_seg *)0x0;
          inseg.tcphdr = ptVar4;
          inseg.p = p;
          if ((uVar9 & 8) != 0) {
            p->flags = p->flags | 1;
          }
          if ((ptVar28->refused_data != (pbuf *)0x0) &&
             ((eVar8 = tcp_process_refused_data(ptVar28), CONCAT31(extraout_var_00,eVar8) == -0xd ||
              ((ptVar28->refused_data != (pbuf *)0x0 && (tcplen != 0)))))) {
            if (ptVar28->rcv_ann_wnd == 0) {
              tcp_send_empty_ack(ptVar28);
            }
            lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
            goto aborted;
          }
          uVar7 = flags;
          tcp_input_pcb = ptVar28;
          if ((flags & 4) != 0) {
            if (ptVar28->state == SYN_SENT) {
              if (ptVar28->snd_nxt != ackno) goto switchD_23043a08_caseD_8;
            }
            else {
              if (ptVar28->rcv_nxt != seqno) {
                iVar16 = seqno - ptVar28->rcv_nxt;
                if ((-1 < iVar16) && ((int)(iVar16 - (uint)ptVar28->rcv_wnd) < 1))
                goto LAB_23043994;
                goto switchD_23043a08_caseD_8;
              }
            }
            recv_flags = recv_flags | 8;
            tVar19 = ptVar28->flags & 0xfffe;
LAB_2304394e:
            ptVar28->flags = tVar19;
            goto switchD_23043a08_caseD_8;
          }
          bVar3 = flags & 2;
          tVar19 = ptVar28->flags;
          if (((flags & 2) != 0) && (1 < (byte)(ptVar28->state + ~LISTEN))) {
LAB_230439b6:
            tVar19 = tVar19 | 2;
            goto LAB_2304394e;
          }
          if ((tVar19 & 0x10) == 0) {
            ptVar28->tmr = tcp_ticks;
          }
          *(undefined2 *)&ptVar28->persist_probe = 0;
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&ptVar28->mss);
          }
          uVar14 = seqno;
          switch(ptVar28->state + ~LISTEN) {
          case CLOSED:
            if (((uVar7 & 0x12) != 0x12) || (uVar11 = ptVar28->lastack + 1, uVar11 != ackno)) {
              if (((uVar7 & 0x10) != 0) &&
                 (tcp_rst(ptVar28,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                          &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src), ptVar28->nrtx < 6))
              {
                ptVar28->rtime = 0;
                tcp_rexmit_rto(ptVar28);
              }
              goto switchD_23043a08_caseD_8;
            }
            ptVar28->lastack = uVar11;
            uVar11 = uVar14 + 1;
            ptVar28->rcv_nxt = uVar11;
            ptVar28->rcv_ann_right_edge = uVar11;
            uVar9 = ptVar28->mss;
            uVar26 = tcphdr->wnd;
            ptVar28->snd_wl1 = uVar14 - 1;
            ptVar28->snd_wnd = uVar26;
            ptVar28->snd_wnd_max = uVar26;
            ptVar28->state = ESTABLISHED;
            pnVar12 = ip4_route((ip4_addr_t *)&ptVar28->remote_ip);
            uVar9 = tcp_eff_send_mss_netif
                              (uVar9,pnVar12,(ip_addr_t *)(ip4_addr_t *)&ptVar28->remote_ip);
            iVar16 = CONCAT22(extraout_var_10,uVar9);
            uVar22 = iVar16 << 1;
            ptVar28->mss = uVar9;
            uVar15 = 0x111c;
            uVar13 = uVar22;
            if (uVar22 < 0x111c) {
              uVar13 = uVar15;
            }
            if ((uint)(iVar16 << 2) < uVar13) {
              uVar15 = iVar16 << 0x12;
LAB_23043a8c:
              uVar15 = uVar15 >> 0x10;
            }
            else {
              if (0x111c < uVar22) {
                uVar15 = iVar16 << 0x11;
                goto LAB_23043a8c;
              }
            }
            ptVar28->cwnd = (tcpwnd_size_t)uVar15;
            seg = ptVar28->unacked;
            ptVar28->snd_queuelen = ptVar28->snd_queuelen - 1;
            if (seg == (tcp_seg *)0x0) {
              seg = ptVar28->unsent;
              ptVar28->unsent = seg->next;
            }
            else {
              ptVar28->unacked = seg->next;
            }
            tcp_seg_free(seg);
            if (ptVar28->unacked == (tcp_seg *)0x0) {
              ptVar28->rtime = -1;
            }
            else {
              ptVar28->rtime = 0;
              ptVar28->nrtx = '\0';
            }
            if ((ptVar28->connected == (tcp_connected_fn)0x0) ||
               (eVar8 = (*ptVar28->connected)(ptVar28->callback_arg,ptVar28,'\0'),
               CONCAT31(extraout_var_02,eVar8) != -0xd)) {
LAB_23043994:
              tVar19 = ptVar28->flags;
              goto LAB_230439b6;
            }
            goto aborted;
          case LISTEN:
            if ((uVar7 & 0x10) == 0) {
              if ((bVar3 != 0) && (ptVar28->rcv_nxt - 1 == seqno)) {
                tcp_rexmit(ptVar28);
              }
              goto switchD_23043a08_caseD_8;
            }
            if (((int)((ackno - 1) - ptVar28->lastack) < 0) || (0 < (int)(ackno - ptVar28->snd_nxt))
               ) {
              tcp_rst(ptVar28,ackno,seqno + tcplen,&ip_data.current_iphdr_dest,
                      &ip_data.current_iphdr_src,tcphdr->dest,tcphdr->src);
              goto switchD_23043a08_caseD_8;
            }
            ptVar28->state = ESTABLISHED;
            if ((ptVar28->listener == (tcp_pcb_listen *)0x0) ||
               (paVar21 = ptVar28->listener->accept, paVar21 == (tcp_accept_fn)0x0))
            goto LAB_23043b68;
            eVar8 = (*paVar21)(ptVar28->callback_arg,ptVar28,'\0');
            if (CONCAT31(extraout_var_03,eVar8) != 0) {
              if (CONCAT31(extraout_var_03,eVar8) == -0xd) goto aborted;
              goto LAB_23043b68;
            }
            tcp_receive(ptVar28);
            if (recv_acked != 0) {
              recv_acked = recv_acked - 1;
            }
            uVar22 = (uint)ptVar28->mss;
            uVar15 = uVar22 << 1;
            uVar23 = 0x111c;
            uVar13 = uVar15;
            if (uVar15 < 0x111c) {
              uVar13 = uVar23;
            }
            if (uVar22 << 2 < uVar13) {
              uVar22 = uVar22 << 0x12;
LAB_23043bba:
              uVar23 = uVar22 >> 0x10;
            }
            else {
              if (0x111c < uVar15) {
                uVar22 = uVar22 << 0x11;
                goto LAB_23043bba;
              }
            }
            ptVar28->cwnd = (tcpwnd_size_t)uVar23;
            break;
          case SYN_SENT:
          case FIN_WAIT_1:
            tcp_receive(ptVar28);
            break;
          case SYN_RCVD:
            tcp_receive(ptVar28);
            if ((recv_flags & 0x20) != 0) {
              if ((((flags & 0x10) == 0) || (ptVar28->snd_nxt != ackno)) ||
                 (ptVar28->unsent != (tcp_seg *)0x0)) {
                ptVar28->flags = ptVar28->flags | 2;
                tVar17 = CLOSING;
                goto LAB_23043bda;
              }
              ptVar28->flags = ptVar28->flags | 2;
              tcp_pcb_purge(ptVar28);
              ptVar6 = tcp_active_pcbs;
              if (ptVar28 == tcp_active_pcbs) goto LAB_23043c86;
              goto LAB_23043c9c;
            }
            if ((((flags & 0x10) == 0) || (ptVar28->snd_nxt != ackno)) ||
               (ptVar28->unsent != (tcp_seg *)0x0)) goto switchD_23043a08_caseD_8;
            tVar17 = FIN_WAIT_2;
            goto LAB_23043bda;
          case ESTABLISHED:
            tcp_receive(ptVar28);
            if ((recv_flags & 0x20) == 0) goto switchD_23043a08_caseD_8;
            ptVar28->flags = ptVar28->flags | 2;
            tcp_pcb_purge(ptVar28);
            ptVar6 = tcp_active_pcbs;
            if (ptVar28 == tcp_active_pcbs) goto LAB_23043c86;
            goto LAB_23043d18;
          case FIN_WAIT_2:
            tcp_receive(ptVar28);
            if ((((flags & 0x10) == 0) || (ptVar28->snd_nxt != ackno)) ||
               (ptVar28->unsent != (tcp_seg *)0x0)) goto switchD_23043a08_caseD_8;
            tcp_pcb_purge(ptVar28);
            ptVar6 = tcp_active_pcbs;
            if (ptVar28 != tcp_active_pcbs) goto LAB_23043d52;
LAB_23043c86:
            tcp_active_pcbs = ptVar28->next;
            goto LAB_23043c9e;
          case CLOSE_WAIT:
            tcp_receive(ptVar28);
            if ((((flags & 0x10) != 0) && (ptVar28->snd_nxt == ackno)) &&
               (ptVar28->unsent == (tcp_seg *)0x0)) {
              recv_flags = recv_flags | 0x10;
            }
          default:
            goto switchD_23043a08_caseD_8;
          }
          if ((recv_flags & 0x20) == 0) goto switchD_23043a08_caseD_8;
          ptVar28->flags = ptVar28->flags | 2;
          tVar17 = CLOSE_WAIT;
LAB_23043bda:
          ptVar28->state = tVar17;
          goto switchD_23043a08_caseD_8;
        }
      }
LAB_230432a4:
      lwip_stats.tcp.lenerr = lwip_stats.tcp.lenerr + 1;
    }
    else {
      lwip_stats.tcp.chkerr = lwip_stats.tcp.chkerr + 1;
    }
  }
  else {
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
  }
  lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
LAB_23043728:
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
LAB_2304374c:
  if (ptVar10 == (tcp_pcb *)0x0) goto code_r0x2304374e;
  if ((((ptVar10->netif_idx == '\0') ||
       (ptVar10->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
      ((uVar26 = ptVar10->remote_port, uVar26 == tcphdr->src &&
       ((uVar18 = ptVar10->local_port, uVar18 == tcphdr->dest &&
        (ip_data.current_iphdr_src == (ptVar10->remote_ip).addr)))))) &&
     (ip_data.current_iphdr_dest == (ptVar10->local_ip).addr)) {
    if ((uVar9 & 4) != 0) goto LAB_23043728;
    uVar13 = (uint)tcplen;
    if ((uVar9 & 2) == 0) {
      if ((uVar9 & 1) != 0) {
        ptVar10->tmr = tcp_ticks;
      }
    }
    else {
      iVar16 = seqno - ptVar10->rcv_nxt;
      if ((-1 < iVar16) && ((int)(iVar16 - (uint)ptVar10->rcv_wnd) < 1)) {
        uVar14 = uVar13 + seqno;
        goto LAB_23043702;
      }
    }
    if (uVar13 == 0) goto LAB_23043728;
    ptVar10->flags = ptVar10->flags | 2;
    goto LAB_23043724;
  }
  ptVar10 = ptVar10->next;
  goto LAB_2304374c;
code_r0x2304374e:
  ptVar27 = (tcp_pcb *)0x0;
  ptVar28 = (tcp_pcb *)0x0;
  ptVar24 = tcp_listen_pcbs;
  while (ptVar24 != (tcp_pcb *)0x0) {
    if (((ptVar24->netif_idx == '\0') ||
        (ptVar24->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))) &&
       (ptVar24->local_port == tcphdr->dest)) {
      uVar14 = (ptVar24->local_ip).addr;
      if (ip_data.current_iphdr_dest == uVar14) goto LAB_230437aa;
      if (uVar14 == 0) {
        ptVar27 = ptVar24;
        ptVar28 = ptVar10;
      }
    }
    ptVar10 = ptVar24;
    ptVar24 = ptVar24->next;
  }
  ptVar10 = ptVar28;
  ptVar24 = ptVar27;
  if (ptVar27 == (tcp_pcb *)0x0) {
    uVar9 = lwip_htons(tcphdr->_hdrlen_rsvd_flags);
    if ((uVar9 & 4) != 0) goto LAB_23043728;
    lwip_stats.tcp.proterr = lwip_stats.tcp.proterr + 1;
    lwip_stats.tcp.drop = lwip_stats.tcp.drop + 1;
    uVar26 = tcphdr->src;
    uVar18 = tcphdr->dest;
    uVar14 = seqno + tcplen;
    ptVar10 = (tcp_pcb *)0x0;
  }
  else {
LAB_230437aa:
    if (ptVar10 == (tcp_pcb *)0x0) {
      lwip_stats.tcp.cachehit = lwip_stats.tcp.cachehit + 1;
    }
    else {
      tcp_listen_pcbs = ptVar24;
      ptVar10->next = ptVar24->next;
      ptVar24->next = ptVar6;
    }
    if ((uVar9 & 4) != 0) goto LAB_23043728;
    if ((uVar9 & 0x10) == 0) {
      if ((uVar9 & 2) != 0) {
        ptVar10 = tcp_alloc(ptVar24->prio);
        ptVar4 = tcphdr;
        if (ptVar10 == (tcp_pcb *)0x0) {
          lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
          if (*(code **)&ptVar24->remote_port != (code *)0x0) {
            (**(code **)&ptVar24->remote_port)(ptVar24->callback_arg,0,0xffffffff);
          }
        }
        else {
          (ptVar10->local_ip).addr = ip_data.current_iphdr_dest;
          (ptVar10->remote_ip).addr = ip_data.current_iphdr_src;
          ptVar10->local_port = ptVar24->local_port;
          ptVar10->remote_port = ptVar4->src;
          ptVar10->state = SYN_RCVD;
          uVar14 = seqno + 1;
          ptVar10->rcv_nxt = uVar14;
          ptVar10->rcv_ann_right_edge = uVar14;
          uVar11 = tcp_next_iss(ptVar10);
          uVar14 = seqno;
          ptVar10->snd_wl2 = uVar11;
          ptVar10->snd_nxt = uVar11;
          ptVar10->lastack = uVar11;
          ptVar10->snd_lbb = uVar11;
          ptVar10->snd_wl1 = uVar14 - 1;
          pvVar20 = ptVar24->callback_arg;
          ptVar10->listener = (tcp_pcb_listen *)ptVar24;
          ptVar10->callback_arg = pvVar20;
          ptVar10->so_options = ptVar24->so_options & 0xc;
          ptVar10->netif_idx = ptVar24->netif_idx;
          ptVar6 = ptVar10;
          ptVar10->next = tcp_active_pcbs;
          tcp_active_pcbs = ptVar6;
          tcp_timer_needed();
          tcp_active_pcbs_changed = '\x01';
          if (tcphdr_optlen != 0) {
            tcp_parseopt(&ptVar10->mss);
          }
          uVar26 = tcphdr->wnd;
          uVar9 = ptVar10->mss;
          ptVar10->snd_wnd = uVar26;
          ptVar10->snd_wnd_max = uVar26;
          pnVar12 = ip4_route((ip4_addr_t *)&ptVar10->remote_ip);
          uVar9 = tcp_eff_send_mss_netif
                            (uVar9,pnVar12,(ip_addr_t *)(ip4_addr_t *)&ptVar10->remote_ip);
          ptVar10->mss = uVar9;
          eVar8 = tcp_enqueue_flags(ptVar10,'\x12');
          if (CONCAT31(extraout_var_01,eVar8) == 0) {
LAB_23043724:
            tcp_output(ptVar10);
          }
          else {
            tcp_abandon(ptVar10,0);
          }
        }
      }
      goto LAB_23043728;
    }
    uVar26 = tcphdr->src;
    uVar18 = tcphdr->dest;
    uVar14 = seqno + tcplen;
    ptVar10 = ptVar24;
  }
LAB_23043702:
  tcp_rst(ptVar10,ackno,uVar14,&ip_data.current_iphdr_dest,&ip_data.current_iphdr_src,uVar18,uVar26)
  ;
  goto LAB_23043728;
LAB_23043672:
  ptVar10 = ptVar28->next;
  ptVar27 = ptVar28;
  goto LAB_230434e6;
  while (ptVar6 = ptVar24->next, ptVar28 != ptVar24->next) {
LAB_23043d52:
    ptVar24 = ptVar6;
    if (ptVar24 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
  goto LAB_23043c94;
  while (ptVar6 = ptVar24->next, ptVar28 != ptVar24->next) {
LAB_23043d18:
    ptVar24 = ptVar6;
    if (ptVar24 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
  goto LAB_23043c94;
  while (ptVar6 = ptVar24->next, ptVar28 != ptVar24->next) {
LAB_23043c9c:
    ptVar24 = ptVar6;
    if (ptVar24 == (tcp_pcb *)0x0) goto LAB_23043c9e;
  }
LAB_23043c94:
  ptVar24->next = ptVar28->next;
LAB_23043c9e:
  tcp_active_pcbs_changed = '\x01';
  ptVar28->state = TIME_WAIT;
  ptVar6 = ptVar28;
  ptVar28->next = tcp_tw_pcbs;
  tcp_tw_pcbs = ptVar6;
  tcp_timer_needed();
switchD_23043a08_caseD_8:
  if ((recv_flags & 8) == 0) {
    if (recv_acked != 0) {
      if ((ptVar28->sent != (tcp_sent_fn *)0x0) &&
         (eVar8 = (*ptVar28->sent)(ptVar28->callback_arg,ptVar28,recv_acked),
         CONCAT31(extraout_var_04,eVar8) == -0xd)) goto aborted;
      recv_acked = 0;
    }
    iVar16 = tcp_input_delayed_close(ptVar28);
    if (iVar16 == 0) {
      if (recv_data != (pbuf *)0x0) {
        if ((ptVar28->flags & 0x10) != 0) {
          pbuf_free(recv_data);
LAB_23043b68:
          tcp_abort(ptVar28);
          goto aborted;
        }
        if (ptVar28->recv == (tcp_recv_fn *)0x0) {
          eVar8 = tcp_recv_null((void *)0x0,ptVar28,recv_data,'\0');
          iVar16 = CONCAT31(extraout_var_06,eVar8);
        }
        else {
          eVar8 = (*ptVar28->recv)(ptVar28->callback_arg,ptVar28,recv_data,'\0');
          iVar16 = CONCAT31(extraout_var_05,eVar8);
        }
        if (iVar16 == -0xd) goto aborted;
        if (iVar16 != 0) {
          ptVar28->refused_data = recv_data;
        }
      }
      if ((recv_flags & 0x20) != 0) {
        ppVar25 = ptVar28->refused_data;
        if (ppVar25 == (pbuf *)0x0) {
          if (ptVar28->rcv_wnd != 0x810) {
            ptVar28->rcv_wnd = ptVar28->rcv_wnd + 1;
          }
          if ((ptVar28->recv != (tcp_recv_fn *)0x0) &&
             (eVar8 = (*ptVar28->recv)(ptVar28->callback_arg,ptVar28,(pbuf *)0x0,'\0'),
             CONCAT31(extraout_var_07,eVar8) == -0xd)) goto aborted;
        }
        else {
          ppVar25->flags = ppVar25->flags | 0x20;
        }
      }
      tcp_input_pcb = (tcp_pcb *)0x0;
      iVar16 = tcp_input_delayed_close(ptVar28);
      if (iVar16 == 0) {
        tcp_output(ptVar28);
      }
    }
  }
  else {
    if (ptVar28->errf != (tcp_err_fn *)0x0) {
      (*ptVar28->errf)(ptVar28->callback_arg,-0xe);
    }
    tcp_pcb_remove(&tcp_active_pcbs,ptVar28);
    tcp_free(ptVar28);
  }
aborted:
  tcp_input_pcb = (tcp_pcb *)0x0;
  recv_data = (pbuf *)0x0;
  if (inseg.p != (pbuf *)0x0) {
    pbuf_free(inseg.p);
    inseg.p = (pbuf *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_trigger_input_pcb_close(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  recv_flags = recv_flags | 0x10;
  return;
}



void tcp_seg_add_chksum(u16_t chksum,u16_t len,u16_t *seg_chksum,u8_t *seg_chksum_swapped)

{
  undefined2 in_register_0000202a;
  uint uVar1;
  uint uVar2;
  
  uVar1 = CONCAT22(in_register_0000202a,chksum) + (uint)*seg_chksum;
  uVar1 = uVar1 + (uVar1 >> 0x10);
  uVar2 = uVar1 & 0xffff;
  if ((len & 1) != 0) {
    *seg_chksum_swapped = '\x01' - *seg_chksum_swapped;
    uVar2 = uVar2 >> 8 | (uVar1 & 0xff) << 8;
  }
  *seg_chksum = (u16_t)uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



tcp_seg * tcp_create_segment(tcp_pcb *pcb,pbuf *p,u8_t hdrflags,u32_t seqno,u8_t optflags)

{
  u8_t uVar1;
  u16_t uVar2;
  tcp_seg *seg;
  undefined3 extraout_var;
  u32_t uVar3;
  undefined3 in_register_00002031;
  tcp_hdr *ptVar4;
  
  seg = (tcp_seg *)memp_malloc(MEMP_TCP_SEG);
  if (seg == (tcp_seg *)0x0) {
    pbuf_free(p);
  }
  else {
    seg->flags = optflags;
    seg->next = (tcp_seg *)0x0;
    seg->p = p;
    uVar2 = p->tot_len;
    seg->chksum = 0;
    seg->len = uVar2 + (optflags & 1) * -4;
    seg->chksum_swapped = '\0';
    uVar1 = pbuf_add_header(p,0x14);
    if (CONCAT31(extraout_var,uVar1) == 0) {
      ptVar4 = (tcp_hdr *)seg->p->payload;
      seg->tcphdr = ptVar4;
      uVar2 = lwip_htons(pcb->local_port);
      *(char *)&ptVar4->src = (char)uVar2;
      *(char *)((int)&ptVar4->src + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons(pcb->remote_port);
      *(char *)&ptVar4->dest = (char)uVar2;
      *(char *)((int)&ptVar4->dest + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      uVar3 = lwip_htonl(seqno);
      *(char *)&ptVar4->seqno = (char)uVar3;
      *(char *)((int)&ptVar4->seqno + 1) = (char)(uVar3 >> 8);
      *(char *)((int)&ptVar4->seqno + 3) = (char)(uVar3 >> 0x18);
      *(char *)((int)&ptVar4->seqno + 2) = (char)(uVar3 >> 0x10);
      ptVar4 = seg->tcphdr;
      uVar2 = lwip_htons(((optflags & 1) + 5) * 0x1000 |
                         (ushort)CONCAT31(in_register_00002031,hdrflags));
      *(char *)&ptVar4->_hdrlen_rsvd_flags = (char)uVar2;
      *(char *)((int)&ptVar4->_hdrlen_rsvd_flags + 1) = (char)(uVar2 >> 8);
      ptVar4 = seg->tcphdr;
      *(undefined *)&ptVar4->urgp = 0;
      *(undefined *)((int)&ptVar4->urgp + 1) = 0;
    }
    else {
      lwip_stats.tcp.err = lwip_stats.tcp.err + 1;
      tcp_seg_free(seg);
      seg = (tcp_seg *)0x0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return seg;
}



pbuf * tcp_output_alloc_header_common
                 (u32_t ackno,u16_t datalen,u32_t seqno_be,u16_t src_port,u16_t dst_port,u8_t flags,
                 u16_t wnd)

{
  undefined *puVar1;
  u16_t uVar2;
  pbuf *ppVar3;
  u32_t uVar4;
  undefined3 in_register_0000203d;
  
  ppVar3 = pbuf_alloc(PBUF_IP,datalen + 0x14,PBUF_RAM);
  if (ppVar3 != (pbuf *)0x0) {
    puVar1 = (undefined *)ppVar3->payload;
    uVar2 = lwip_htons(src_port);
    *puVar1 = (char)uVar2;
    puVar1[1] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(dst_port);
    puVar1[2] = (char)uVar2;
    puVar1[4] = (char)seqno_be;
    puVar1[5] = (char)(seqno_be >> 8);
    puVar1[3] = (char)(uVar2 >> 8);
    puVar1[6] = (char)(seqno_be >> 0x10);
    puVar1[7] = (char)(seqno_be >> 0x18);
    uVar4 = lwip_htonl(ackno);
    puVar1[8] = (char)uVar4;
    puVar1[9] = (char)(uVar4 >> 8);
    puVar1[0xb] = (char)(uVar4 >> 0x18);
    puVar1[10] = (char)(uVar4 >> 0x10);
    uVar2 = lwip_htons((ushort)CONCAT31(in_register_0000203d,flags) | 0x5000);
    puVar1[0xc] = (char)uVar2;
    puVar1[0xd] = (char)(uVar2 >> 8);
    uVar2 = lwip_htons(wnd);
    puVar1[0xe] = (char)uVar2;
    puVar1[0xf] = (char)(uVar2 >> 8);
    puVar1[0x10] = 0;
    puVar1[0x11] = 0;
    puVar1[0x12] = 0;
    puVar1[0x13] = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar3;
}



pbuf * tcp_output_alloc_header(tcp_pcb *pcb,u16_t datalen,u32_t seqno_be)

{
  pbuf *ppVar1;
  
  ppVar1 = tcp_output_alloc_header_common
                     (pcb->rcv_nxt,datalen,seqno_be,pcb->local_port,pcb->remote_port,'\x10',
                      pcb->rcv_ann_wnd);
  if (ppVar1 != (pbuf *)0x0) {
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ppVar1;
}



err_t tcp_output_control_segment(tcp_pcb *pcb,pbuf *p,ip_addr_t *src,ip_addr_t *dst)

{
  err_t eVar1;
  u16_t uVar2;
  netif *netif;
  u8_t ttl;
  u8_t tos;
  void *pvVar3;
  
  if ((pcb == (tcp_pcb *)0x0) || (pcb->netif_idx == '\0')) {
    netif = ip4_route((ip4_addr_t *)dst);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  eVar1 = -4;
  if (netif != (netif *)0x0) {
    pvVar3 = p->payload;
    uVar2 = ip_chksum_pseudo(p,'\x06',p->tot_len,(ip4_addr_t *)src,(ip4_addr_t *)dst);
    *(char *)((int)pvVar3 + 0x10) = (char)uVar2;
    *(char *)((int)pvVar3 + 0x11) = (char)(uVar2 >> 8);
    if (pcb == (tcp_pcb *)0x0) {
      tos = '\0';
      ttl = -1;
    }
    else {
      ttl = pcb->ttl;
      tos = pcb->tos;
    }
    lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
    eVar1 = ip4_output_if(p,(ip4_addr_t *)src,(ip4_addr_t *)dst,ttl,tos,'\x06',netif);
  }
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t tcp_write(tcp_pcb *pcb,void *arg,u16_t len,u8_t apiflags)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  u16_t uVar3;
  u16_t uVar4;
  u16_t uVar5;
  undefined2 in_register_00002032;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  tcp_hdr *ptVar10;
  err_t eVar11;
  err_t eVar12;
  uint uVar13;
  tcp_seg *ptVar14;
  tcp_seg *seg;
  tcp_seg *ptVar15;
  uint uVar16;
  pbuf *ppVar17;
  tcp_seg *ptVar18;
  u8_t uStack67;
  u16_t uStack66;
  u8_t chksum_swapped;
  u16_t chksum;
  
  uVar6 = CONCAT22(in_register_00002032,len);
  eVar11 = -0x10;
  if (pcb == (tcp_pcb *)0x0) goto LAB_2304422a;
  uVar7 = (uint)pcb->mss;
  uVar9 = (uint)(pcb->snd_wnd_max >> 1);
  if (uVar7 < uVar9) {
    uVar9 = uVar7;
  }
  if (uVar9 == 0) {
    uVar9 = uVar7;
  }
  eVar11 = -0x10;
  if ((arg == (void *)0x0) ||
     ((pcb->state != CLOSE_WAIT && (eVar11 = -0xb, 2 < (byte)(pcb->state + ~LISTEN)))))
  goto LAB_2304422a;
  if (uVar6 == 0) {
LAB_23044268:
    ptVar2 = pcb->unsent;
    uVar4 = pcb->snd_queuelen;
    if (ptVar2 == (tcp_seg *)0x0) {
      ptVar18 = (tcp_seg *)0x0;
      uVar7 = 0;
      uVar13 = 0;
    }
    else {
      do {
        ptVar18 = ptVar2;
        ptVar2 = ptVar18->next;
      } while (ptVar2 != (tcp_seg *)0x0);
      uVar7 = (uint)pcb->unsent_oversize;
      uVar13 = 0;
      if (uVar7 != 0) {
        uVar13 = (uVar9 - ptVar18->len) + (ptVar18->flags & 1) * -4;
        uVar16 = uVar7;
        if (uVar6 < uVar7) {
          uVar16 = uVar6;
        }
        if ((uVar16 & 0xffff) < (uVar13 & 0xffff)) {
          uVar13 = uVar16;
        }
        uVar13 = uVar13 & 0xffff;
        uVar7 = uVar7 - uVar13 & 0xffff;
        ptVar2 = ptVar18;
      }
    }
    seg = (tcp_seg *)0x0;
    ptVar15 = (tcp_seg *)0x0;
    uVar16 = uVar13;
    while (uVar16 < uVar6) {
      uVar8 = uVar6 - uVar16;
      if (uVar9 < (uVar6 - uVar16 & 0xffff)) {
        uVar8 = uVar9;
      }
      uStack66 = 0;
      uStack67 = '\0';
      ppVar17 = pbuf_alloc(PBUF_TRANSPORT,(u16_t)uVar9,PBUF_RAM);
      if (ppVar17 == (pbuf *)0x0) {
memerr:
        pcb->flags = pcb->flags | 0x80;
        lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
        if (seg != (tcp_seg *)0x0) {
          tcp_segs_free(seg);
        }
        goto LAB_23044228;
      }
      uVar1 = ppVar17->len;
      uVar5 = (u16_t)uVar8;
      ppVar17->tot_len = uVar5;
      ppVar17->len = uVar5;
      uVar3 = lwip_chksum_copy(ppVar17->payload,(void *)((int)arg + uVar16),uVar5);
      tcp_seg_add_chksum(uVar3,uVar5,&uStack66,&uStack67);
      uVar3 = pbuf_clen(ppVar17);
      uVar4 = uVar4 + uVar3;
      uVar7 = (uint)uVar1 - (uVar8 & 0xffff) & 0xffff;
      if (0x10 < uVar4) {
        pbuf_free(ppVar17);
        goto memerr;
      }
      ptVar2 = tcp_create_segment(pcb,ppVar17,'\0',pcb->snd_lbb + uVar16,'\0');
      if (ptVar2 == (tcp_seg *)0x0) goto memerr;
      ptVar2->chksum = uStack66;
      ptVar2->chksum_swapped = uStack67;
      ptVar2->flags = ptVar2->flags | 4;
      ptVar14 = ptVar2;
      if (seg != (tcp_seg *)0x0) {
        ptVar15->next = ptVar2;
        ptVar14 = seg;
      }
      uVar16 = uVar16 + (uVar8 & 0xffff) & 0xffff;
      seg = ptVar14;
      ptVar15 = ptVar2;
    }
    if (uVar13 != 0) {
      ppVar17 = ptVar18->p;
      while (uVar3 = (u16_t)uVar13, ppVar17 != (pbuf *)0x0) {
        ppVar17->tot_len = ppVar17->tot_len + uVar3;
        if (ppVar17->next == (pbuf *)0x0) {
          uVar5 = lwip_chksum_copy((void *)((int)ppVar17->payload + (uint)ppVar17->len),arg,uVar3);
          tcp_seg_add_chksum(uVar5,uVar3,&ptVar18->chksum,&ptVar18->chksum_swapped);
          ptVar18->flags = ptVar18->flags | 4;
          ppVar17->len = ppVar17->len + uVar3;
        }
        ppVar17 = ppVar17->next;
      }
      ptVar18->len = uVar3 + ptVar18->len;
    }
    pcb->unsent_oversize = (u16_t)uVar7;
    if (ptVar18 == (tcp_seg *)0x0) {
      pcb->unsent = seg;
    }
    else {
      ptVar18->next = seg;
    }
    pcb->snd_queuelen = uVar4;
    pcb->snd_lbb = pcb->snd_lbb + uVar6;
    pcb->snd_buf = pcb->snd_buf - len;
    eVar12 = '\0';
    eVar11 = '\0';
    if (((ptVar2 != (tcp_seg *)0x0) && (eVar11 = eVar12, ptVar2->tcphdr != (tcp_hdr *)0x0)) &&
       ((apiflags & 2) == 0)) {
      uVar1 = ptVar2->tcphdr->_hdrlen_rsvd_flags;
      uVar4 = lwip_htons(8);
      ptVar10 = ptVar2->tcphdr;
      uVar1 = uVar4 | uVar1;
      *(char *)&ptVar10->_hdrlen_rsvd_flags = (char)uVar1;
      *(char *)((int)&ptVar10->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
    }
  }
  else {
    if (uVar6 <= pcb->snd_buf) {
      if (pcb->snd_queuelen < 0x10) goto LAB_23044268;
      lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
    }
    pcb->flags = pcb->flags | 0x80;
LAB_23044228:
    eVar11 = -1;
  }
LAB_2304422a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar11;
}



err_t tcp_split_unsent_seg(tcp_pcb *pcb,u16_t split)

{
  byte bVar1;
  ushort *puVar2;
  ushort uVar3;
  tcp_seg *ptVar4;
  uint uVar5;
  u16_t uVar6;
  u16_t uVar7;
  pbuf *ppVar8;
  undefined2 extraout_var;
  u32_t uVar9;
  undefined2 in_register_0000202e;
  byte hdrflags;
  tcp_hdr *ptVar10;
  tcp_seg *ptVar11;
  int iVar12;
  uint uVar13;
  uint uVar14;
  u8_t uStack51;
  u16_t uStack50;
  u8_t chksum_swapped;
  u16_t chksum;
  
  uVar5 = CONCAT22(in_register_0000202e,split);
  ptVar4 = pcb->unsent;
  uStack50 = 0;
  uStack51 = '\0';
  if (ptVar4 != (tcp_seg *)0x0) {
    ptVar11 = (tcp_seg *)0xfffffffa;
    if (uVar5 == 0) goto LAB_230444e0;
    uVar13 = (uint)ptVar4->len;
    if (uVar13 <= uVar5) {
LAB_230444de:
      ptVar11 = (tcp_seg *)0x0;
      goto LAB_230444e0;
    }
    bVar1 = ptVar4->flags;
    iVar12 = (bVar1 & 1) * 4;
    uVar14 = uVar13 - uVar5 & 0xffff;
    ppVar8 = pbuf_alloc(PBUF_TRANSPORT,(u16_t)((uVar14 + iVar12) * 0x10000 >> 0x10),PBUF_RAM);
    if ((ppVar8 != (pbuf *)0x0) &&
       (uVar6 = pbuf_copy_partial(ptVar4->p,(void *)((int)ppVar8->payload + iVar12),
                                  (u16_t)((uVar13 - uVar5) * 0x10000 >> 0x10),
                                  (u16_t)((((uint)ptVar4->p->tot_len - (uint)ptVar4->len) + uVar5) *
                                          0x10000 >> 0x10)), CONCAT22(extraout_var,uVar6) == uVar14)
       ) {
      uVar7 = inet_chksum((void *)((int)ppVar8->payload + iVar12),uVar6);
      tcp_seg_add_chksum(~uVar7,uVar6,&uStack50,&uStack51);
      uVar6 = lwip_htons(ptVar4->tcphdr->_hdrlen_rsvd_flags);
      hdrflags = (byte)uVar6 & 8;
      if ((uVar6 & 8) == 0) {
        uVar6 = uVar6 & 0x3f;
      }
      else {
        uVar6 = uVar6 & 0x37;
        hdrflags = 8;
      }
      if ((uVar6 & 1) != 0) {
        uVar6 = uVar6 & 0xfe;
        hdrflags = hdrflags | 1;
      }
      uVar9 = lwip_htonl(ptVar4->tcphdr->seqno);
      ptVar11 = tcp_create_segment(pcb,ppVar8,hdrflags,uVar5 + uVar9,bVar1 & 0xfb);
      if (ptVar11 != (tcp_seg *)0x0) {
        ptVar11->chksum = uStack50;
        ptVar11->chksum_swapped = uStack51;
        ptVar11->flags = ptVar11->flags | 4;
        uVar7 = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = pcb->snd_queuelen - uVar7;
        pbuf_realloc(ptVar4->p,
                     (u16_t)(((uint)ptVar4->p->tot_len + (uVar5 - uVar13 & 0xffff)) * 0x10000 >>
                            0x10));
        ptVar4->len = (short)((uVar5 - uVar13) * 0x10000 >> 0x10) + ptVar4->len;
        uVar3 = ptVar4->tcphdr->_hdrlen_rsvd_flags;
        uVar6 = lwip_htons(uVar6);
        ptVar10 = ptVar4->tcphdr;
        uVar3 = uVar3 | uVar6;
        *(char *)&ptVar10->_hdrlen_rsvd_flags = (char)uVar3;
        *(char *)((int)&ptVar10->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar3 >> 8);
        uVar6 = pbuf_clen(ptVar4->p);
        pcb->snd_queuelen = uVar6 + pcb->snd_queuelen;
        ppVar8 = ptVar4->p;
        ptVar4->chksum = 0;
        ptVar4->chksum_swapped = '\0';
        uVar5 = (uint)ppVar8->tot_len - (uint)ptVar4->len;
LAB_23044684:
        uVar5 = uVar5 & 0xffff;
        puVar2 = &ppVar8->len;
        if (*puVar2 < uVar5) goto LAB_230446d6;
        do {
          uVar6 = inet_chksum((void *)((int)ppVar8->payload + uVar5),
                              (u16_t)((ppVar8->len - uVar5) * 0x10000 >> 0x10));
          tcp_seg_add_chksum(~uVar6,(u16_t)((ppVar8->len - uVar5) * 0x10000 >> 0x10),&ptVar4->chksum
                             ,&ptVar4->chksum_swapped);
          ppVar8 = ppVar8->next;
          uVar5 = 0;
        } while (ppVar8 != (pbuf *)0x0);
LAB_230446e4:
        uVar6 = pbuf_clen(ptVar11->p);
        pcb->snd_queuelen = uVar6 + pcb->snd_queuelen;
        ptVar11->next = ptVar4->next;
        ptVar4->next = ptVar11;
        ptVar11 = ptVar11->next;
        if (ptVar11 == (tcp_seg *)0x0) {
          pcb->unsent_oversize = 0;
          goto LAB_230444e0;
        }
        goto LAB_230444de;
      }
    }
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
    if (ppVar8 != (pbuf *)0x0) {
      pbuf_free(ppVar8);
    }
  }
  ptVar11 = (tcp_seg *)0xffffffff;
LAB_230444e0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)ptVar11;
LAB_230446d6:
  ppVar8 = ppVar8->next;
  uVar5 = uVar5 - *puVar2;
  if (ppVar8 == (pbuf *)0x0) goto LAB_230446e4;
  goto LAB_23044684;
}



err_t tcp_enqueue_flags(tcp_pcb *pcb,u8_t flags)

{
  err_t eVar1;
  u16_t uVar2;
  pbuf *p;
  tcp_seg *ptVar3;
  uint uVar4;
  tcp_seg *ptVar5;
  tcp_seg *ptVar6;
  
  uVar4 = (flags & 2) >> 1;
  p = pbuf_alloc(PBUF_TRANSPORT,(u16_t)(uVar4 << 2),PBUF_RAM);
  if ((p == (pbuf *)0x0) ||
     (ptVar3 = tcp_create_segment(pcb,p,flags,pcb->snd_lbb,(u8_t)uVar4), ptVar3 == (tcp_seg *)0x0))
  {
    eVar1 = -1;
    pcb->flags = pcb->flags | 0x80;
    lwip_stats.tcp.memerr = lwip_stats.tcp.memerr + 1;
  }
  else {
    ptVar5 = pcb->unsent;
    if (pcb->unsent == (tcp_seg *)0x0) {
      pcb->unsent = ptVar3;
    }
    else {
      do {
        ptVar6 = ptVar5;
        ptVar5 = ptVar6->next;
      } while (ptVar5 != (tcp_seg *)0x0);
      ptVar6->next = ptVar3;
    }
    pcb->unsent_oversize = 0;
    if ((flags & 3) != 0) {
      pcb->snd_lbb = pcb->snd_lbb + 1;
    }
    if ((flags & 1) != 0) {
      pcb->flags = pcb->flags | 0x20;
    }
    uVar2 = pbuf_clen(ptVar3->p);
    pcb->snd_queuelen = uVar2 + pcb->snd_queuelen;
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t tcp_send_fin(tcp_pcb *pcb)

{
  ushort uVar1;
  tcp_seg *ptVar2;
  tcp_seg *ptVar3;
  err_t eVar4;
  u16_t uVar5;
  tcp_hdr *ptVar6;
  
  ptVar2 = pcb->unsent;
  if (pcb->unsent != (tcp_seg *)0x0) {
    do {
      ptVar3 = ptVar2;
      ptVar2 = ptVar3->next;
    } while (ptVar3->next != (tcp_seg *)0x0);
    uVar5 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar5 & 7) == 0) {
      uVar1 = ptVar3->tcphdr->_hdrlen_rsvd_flags;
      uVar5 = lwip_htons(1);
      ptVar6 = ptVar3->tcphdr;
      uVar1 = uVar5 | uVar1;
      *(char *)&ptVar6->_hdrlen_rsvd_flags = (char)uVar1;
      *(char *)((int)&ptVar6->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
      pcb->flags = pcb->flags | 0x20;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
  }
  eVar4 = tcp_enqueue_flags(pcb,'\x01');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar4;
}



err_t tcp_rexmit_rto_prepare(tcp_pcb *pcb)

{
  u8_t uVar1;
  ushort uVar2;
  tcp_seg *ptVar3;
  u16_t uVar4;
  u32_t uVar5;
  tcp_seg *ptVar6;
  
  ptVar3 = pcb->unacked;
  if (pcb->unacked != (tcp_seg *)0x0) {
    do {
      uVar1 = ptVar3->p->ref;
      if (ptVar3->next == (tcp_seg *)0x0) {
        if (uVar1 != '\x01') {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -6;
        }
        ptVar3->next = pcb->unsent;
        ptVar6 = pcb->unacked;
        pcb->unacked = (tcp_seg *)0x0;
        pcb->unsent = ptVar6;
        pcb->flags = pcb->flags | 0x800;
        uVar5 = lwip_htonl(ptVar3->tcphdr->seqno);
        uVar2 = ptVar3->len;
        uVar4 = lwip_htons(ptVar3->tcphdr->_hdrlen_rsvd_flags);
        pcb->rto_end = (uint)((uVar4 & 3) != 0) + uVar5 + uVar2;
        pcb->rttest = 0;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\0';
      }
      ptVar3 = ptVar3->next;
    } while (uVar1 == '\x01');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



err_t tcp_rexmit(tcp_pcb *pcb)

{
  tcp_seg *ptVar1;
  u32_t uVar2;
  u32_t uVar3;
  err_t eVar4;
  tcp_seg *ptVar5;
  
  ptVar1 = pcb->unacked;
  eVar4 = -6;
  if ((ptVar1 != (tcp_seg *)0x0) && (eVar4 = -6, ptVar1->p->ref == '\x01')) {
    ptVar5 = (tcp_seg *)&pcb->unsent;
    pcb->unacked = ptVar1->next;
    while (ptVar5->next != (tcp_seg *)0x0) {
      uVar2 = lwip_htonl(ptVar5->next->tcphdr->seqno);
      uVar3 = lwip_htonl(ptVar1->tcphdr->seqno);
      if (-1 < (int)(uVar2 - uVar3)) break;
      ptVar5 = ptVar5->next;
    }
    ptVar1->next = ptVar5->next;
    ptVar5->next = ptVar1;
    if (ptVar1->next == (tcp_seg *)0x0) {
      pcb->unsent_oversize = 0;
    }
    if (pcb->nrtx != -1) {
      pcb->nrtx = pcb->nrtx + '\x01';
    }
    pcb->rttest = 0;
    eVar4 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar4;
}



void tcp_rexmit_fast(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  uint uVar2;
  uint uVar3;
  
  if (pcb->unacked != (tcp_seg *)0x0) {
    if (((pcb->flags & 4) == 0) && (eVar1 = tcp_rexmit(pcb), CONCAT31(extraout_var,eVar1) == 0)) {
      uVar3 = (uint)pcb->snd_wnd;
      if ((uint)pcb->cwnd < (uint)pcb->snd_wnd) {
        uVar3 = (uint)pcb->cwnd;
      }
      pcb->ssthresh = (tcpwnd_size_t)((int)uVar3 >> 1);
      uVar2 = (uint)pcb->mss << 1;
      if ((uint)((int)uVar3 >> 1) < uVar2) {
        pcb->ssthresh = (tcpwnd_size_t)uVar2;
      }
      pcb->rtime = 0;
      pcb->cwnd = pcb->mss * 3 + pcb->ssthresh;
      pcb->flags = pcb->flags | 4;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_rst(tcp_pcb *pcb,u32_t seqno,u32_t ackno,ip_addr_t *param_4,ip_addr_t *remote_ip,
            u16_t param_6,u16_t remote_port)

{
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(seqno);
  p = tcp_output_alloc_header_common(ackno,0,seqno_be,param_6,remote_port,'\x14',0x1008);
  if (p != (pbuf *)0x0) {
    tcp_output_control_segment(pcb,p,param_4,remote_ip);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t tcp_send_empty_ack(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  int iVar2;
  undefined3 extraout_var;
  tcpflags_t tVar3;
  
  seqno_be = lwip_htonl(pcb->snd_nxt);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p == (pbuf *)0x0) {
    iVar2 = -2;
    pcb->flags = pcb->flags | 3;
  }
  else {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    iVar2 = CONCAT31(extraout_var,eVar1);
    if (iVar2 == 0) {
      tVar3 = pcb->flags & 0xfffc;
    }
    else {
      tVar3 = pcb->flags | 3;
    }
    pcb->flags = tVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



err_t tcp_output(tcp_pcb *pcb)

{
  ushort uVar1;
  ushort uVar2;
  bool bVar3;
  short sVar4;
  tcp_seg *ptVar5;
  tcp_seg *seg;
  err_t eVar6;
  u16_t uVar7;
  u16_t uVar8;
  netif *outif;
  u32_t uVar9;
  undefined2 extraout_var_00;
  undefined2 extraout_var_01;
  uint uVar10;
  undefined3 extraout_var;
  u32_t uVar11;
  int iVar12;
  tcp_hdr *ptVar13;
  pbuf *ppVar14;
  tcp_seg *ptVar15;
  tcp_seg *ptVar16;
  uint uVar17;
  ip4_addr_t *dest;
  
  if (tcp_input_pcb == pcb) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  seg = pcb->unsent;
  if (seg == (tcp_seg *)0x0) {
    uVar1 = pcb->flags;
joined_r0x23044bb0:
    if ((uVar1 & 2) != 0) {
      eVar6 = tcp_send_empty_ack(pcb);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eVar6;
    }
  }
  else {
    uVar1 = pcb->cwnd;
    uVar2 = pcb->snd_wnd;
    dest = (ip4_addr_t *)&pcb->remote_ip;
    if (pcb->netif_idx == '\0') {
      outif = ip4_route(dest);
    }
    else {
      outif = netif_get_by_index(pcb->netif_idx);
    }
    if (outif == (netif *)0x0) {
      iVar12 = -4;
      goto LAB_23044de4;
    }
    if ((pcb->local_ip).addr == 0) {
      (pcb->local_ip).addr = (outif->ip_addr).addr;
    }
    uVar17 = (uint)uVar1;
    if ((uint)uVar2 < (uint)uVar1) {
      uVar17 = (uint)uVar2;
    }
    uVar9 = lwip_htonl(seg->tcphdr->seqno);
    if (uVar17 < uVar9 + ((uint)seg->len - pcb->lastack)) {
      if (((pcb->snd_wnd == uVar17) && (pcb->unacked == (tcp_seg *)0x0)) &&
         (pcb->persist_backoff == '\0')) {
        *(undefined2 *)&pcb->persist_cnt = 0x100;
        pcb->persist_probe = '\0';
      }
      uVar1 = pcb->flags;
      goto joined_r0x23044bb0;
    }
    pcb->persist_backoff = '\0';
    ptVar15 = pcb->unacked;
    ptVar16 = pcb->unacked;
    while (ptVar5 = ptVar15, ptVar5 != (tcp_seg *)0x0) {
      ptVar15 = ptVar5->next;
      ptVar16 = ptVar5;
    }
    do {
      uVar9 = lwip_htonl(seg->tcphdr->seqno);
      if ((uVar17 < (uVar9 - pcb->lastack) + (uint)seg->len) ||
         (((((lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags), pcb->unacked != (tcp_seg *)0x0 &&
             ((pcb->flags & 0x44) == 0)) &&
            ((ptVar15 = pcb->unsent, ptVar15 == (tcp_seg *)0x0 ||
             ((ptVar15->next == (tcp_seg *)0x0 && (ptVar15->len < pcb->mss)))))) &&
           (pcb->snd_buf != 0)) && ((pcb->snd_queuelen < 0x10 && ((pcb->flags & 0xa0) == 0)))))) {
        if (pcb->unsent != (tcp_seg *)0x0) goto output_done;
        break;
      }
      if (pcb->state != SYN_SENT) {
        uVar1 = seg->tcphdr->_hdrlen_rsvd_flags;
        uVar7 = lwip_htons(0x10);
        ptVar13 = seg->tcphdr;
        uVar1 = uVar7 | uVar1;
        *(char *)&ptVar13->_hdrlen_rsvd_flags = (char)uVar1;
        *(char *)((int)&ptVar13->_hdrlen_rsvd_flags + 1) = (char)((uint)uVar1 >> 8);
      }
      if (seg->p->ref == '\x01') {
        ptVar13 = seg->tcphdr;
        uVar9 = lwip_htonl(pcb->rcv_nxt);
        *(char *)&ptVar13->ackno = (char)uVar9;
        *(char *)((int)&ptVar13->ackno + 1) = (char)(uVar9 >> 8);
        *(char *)((int)&ptVar13->ackno + 2) = (char)(uVar9 >> 0x10);
        *(char *)((int)&ptVar13->ackno + 3) = (char)(uVar9 >> 0x18);
        ptVar13 = seg->tcphdr;
        uVar7 = lwip_htons(pcb->rcv_ann_wnd);
        *(char *)&ptVar13->wnd = (char)uVar7;
        *(char *)((int)&ptVar13->wnd + 1) = (char)(uVar7 >> 8);
        pcb->rcv_ann_right_edge = pcb->rcv_nxt + (uint)pcb->rcv_ann_wnd;
        if ((seg->flags & 1) != 0) {
          ptVar13 = seg->tcphdr;
          uVar7 = tcp_eff_send_mss_netif(0x2b0,outif,(ip_addr_t *)dest);
          uVar9 = lwip_htonl(CONCAT22(extraout_var_00,uVar7) | 0x2040000);
          *(u32_t *)(ptVar13 + 1) = uVar9;
        }
        if (pcb->rtime < 0) {
          pcb->rtime = 0;
        }
        if (pcb->rttest == 0) {
          pcb->rttest = tcp_ticks;
          uVar9 = lwip_htonl(seg->tcphdr->seqno);
          pcb->rtseq = uVar9;
        }
        ppVar14 = seg->p;
        sVar4 = (short)((uint)((int)((int)seg->tcphdr - (int)ppVar14->payload) * 0x10000) >> 0x10);
        ppVar14->len = ppVar14->len - sVar4;
        seg->p->tot_len = seg->p->tot_len - sVar4;
        ptVar13 = seg->tcphdr;
        seg->p->payload = ptVar13;
        *(undefined *)&ptVar13->chksum = 0;
        *(undefined *)((int)&ptVar13->chksum + 1) = 0;
        if ((seg->flags & 4) == 0) {
          lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        }
        ppVar14 = seg->p;
        uVar7 = ppVar14->tot_len;
        uVar8 = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
        uVar7 = ip_chksum_pseudo_partial
                          (ppVar14,'\x06',uVar7,
                           (ushort)(CONCAT22(extraout_var_01,uVar8) >> 10) & 0xfc,(ip4_addr_t *)pcb,
                           dest);
        bVar3 = seg->chksum_swapped != '\0';
        if (bVar3) {
          seg->chksum_swapped = '\0';
          seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
        }
        ptVar13 = seg->tcphdr;
        uVar10 = (uint)seg->chksum + (~(uint)uVar7 & 0xffff);
        uVar10 = ~((uVar10 >> 0x10) + uVar10);
        *(char *)&ptVar13->chksum = (char)uVar10;
        *(char *)((int)&ptVar13->chksum + 1) = (char)(uVar10 >> 8);
        lwip_stats.tcp.xmit = lwip_stats.tcp.xmit + 1;
        eVar6 = ip4_output_if(seg->p,(ip4_addr_t *)pcb,dest,pcb->ttl,pcb->tos,'\x06',outif);
        iVar12 = CONCAT31(extraout_var,eVar6);
        if (bVar3) {
          seg->chksum_swapped = '\x01';
          seg->chksum = seg->chksum >> 8 | seg->chksum << 8;
        }
        if (iVar12 != 0) {
          pcb->flags = pcb->flags | 0x80;
          goto LAB_23044de4;
        }
      }
      pcb->unsent = seg->next;
      if (pcb->state != SYN_SENT) {
        pcb->flags = pcb->flags & 0xfffc;
      }
      uVar9 = lwip_htonl(seg->tcphdr->seqno);
      uVar1 = seg->len;
      uVar7 = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
      uVar9 = (uint)((uVar7 & 3) != 0) + uVar9 + uVar1;
      if ((int)(pcb->snd_nxt - uVar9) < 0) {
        pcb->snd_nxt = uVar9;
      }
      uVar1 = seg->len;
      uVar7 = lwip_htons(seg->tcphdr->_hdrlen_rsvd_flags);
      if ((uint)((uVar7 & 3) != 0) + (uint)uVar1 == 0) {
        tcp_seg_free(seg);
      }
      else {
        seg->next = (tcp_seg *)0x0;
        if (pcb->unacked == (tcp_seg *)0x0) {
          pcb->unacked = seg;
          ptVar16 = seg;
        }
        else {
          uVar9 = lwip_htonl(seg->tcphdr->seqno);
          uVar11 = lwip_htonl(ptVar16->tcphdr->seqno);
          ptVar15 = (tcp_seg *)&pcb->unacked;
          if ((int)(uVar9 - uVar11) < 0) {
            while (ptVar15->next != (tcp_seg *)0x0) {
              uVar9 = lwip_htonl(ptVar15->next->tcphdr->seqno);
              uVar11 = lwip_htonl(seg->tcphdr->seqno);
              if (-1 < (int)(uVar9 - uVar11)) break;
              ptVar15 = ptVar15->next;
            }
            seg->next = ptVar15->next;
            ptVar15->next = seg;
          }
          else {
            ptVar16->next = seg;
            ptVar16 = seg;
          }
        }
      }
      seg = pcb->unsent;
    } while (seg != (tcp_seg *)0x0);
    pcb->unsent_oversize = 0;
  }
output_done:
  iVar12 = 0;
  pcb->flags = pcb->flags & 0xff7f;
LAB_23044de4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar12;
}



void tcp_rexmit_rto_commit(tcp_pcb *pcb)

{
  if (pcb->nrtx != -1) {
    pcb->nrtx = pcb->nrtx + '\x01';
  }
  tcp_output(pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_rexmit_rto(tcp_pcb *pcb)

{
  err_t eVar1;
  undefined3 extraout_var;
  
  eVar1 = tcp_rexmit_rto_prepare(pcb);
  if (CONCAT31(extraout_var,eVar1) == 0) {
    tcp_rexmit_rto_commit(pcb);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t tcp_keepalive(tcp_pcb *pcb)

{
  err_t eVar1;
  u32_t seqno_be;
  pbuf *p;
  
  seqno_be = lwip_htonl(pcb->snd_nxt - 1);
  p = tcp_output_alloc_header(pcb,0,seqno_be);
  if (p != (pbuf *)0x0) {
    eVar1 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



err_t tcp_zero_window_probe(tcp_pcb *pcb)

{
  ushort uVar1;
  err_t eVar2;
  u16_t uVar3;
  pbuf *p;
  u32_t uVar4;
  uint uVar5;
  tcp_seg *ptVar6;
  void *pvVar7;
  
  ptVar6 = pcb->unsent;
  if (ptVar6 == (tcp_seg *)0x0) {
    eVar2 = '\0';
  }
  else {
    if (pcb->persist_probe != -1) {
      pcb->persist_probe = pcb->persist_probe + '\x01';
    }
    uVar1 = 0;
    uVar3 = lwip_htons(ptVar6->tcphdr->_hdrlen_rsvd_flags);
    if ((uVar3 & 1) != 0) {
      uVar1 = (ushort)(ptVar6->len == 0);
    }
    p = tcp_output_alloc_header(pcb,uVar1 ^ 1,ptVar6->tcphdr->seqno);
    if (p != (pbuf *)0x0) {
      pvVar7 = p->payload;
      if (uVar1 == 0) {
        pbuf_copy_partial(ptVar6->p,(void *)((int)pvVar7 + 0x14),1,ptVar6->p->tot_len - ptVar6->len)
        ;
      }
      else {
        uVar1 = *(ushort *)((int)pvVar7 + 0xc);
        uVar3 = lwip_htons(0x11);
        uVar5 = (int)(short)(uVar1 & 0xc0ff) | (uint)uVar3;
        *(char *)((int)pvVar7 + 0xc) = (char)uVar5;
        *(char *)((int)pvVar7 + 0xd) = (char)(uVar5 >> 8);
      }
      uVar4 = lwip_htonl(ptVar6->tcphdr->seqno);
      if ((int)(pcb->snd_nxt - (uVar4 + 1)) < 0) {
        pcb->snd_nxt = uVar4 + 1;
      }
      eVar2 = tcp_output_control_segment(pcb,p,(ip_addr_t *)pcb,&pcb->remote_ip);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return eVar2;
    }
    eVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



void sys_timeout_abs(u32_t abs_time,sys_timeout_handler *handler,void *arg)

{
  sys_timeo *psVar1;
  sys_timeo *psVar2;
  sys_timeo *psVar3;
  
  psVar1 = (sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  psVar2 = next_timeout;
  psVar3 = next_timeout;
  if (psVar1 != (sys_timeo *)0x0) {
    psVar1->next = (sys_timeo *)0x0;
    psVar1->h = handler;
    psVar1->arg = arg;
    psVar1->time = abs_time;
    psVar3 = psVar1;
    if (psVar2 != (sys_timeo *)0x0) {
      if ((int)(abs_time - psVar2->time) < 0) {
        psVar1->next = psVar2;
      }
      else {
        do {
          psVar3 = psVar2;
          psVar2 = psVar3->next;
          if (psVar2 == (sys_timeo *)0x0) break;
        } while (-1 < (int)(abs_time - psVar2->time));
        psVar1->next = psVar2;
        psVar3->next = psVar1;
        psVar3 = next_timeout;
      }
    }
  }
  next_timeout = psVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_cyclic_timer(void *arg)

{
  TickType_t TVar1;
  u32_t abs_time;
  u32_t uVar2;
  
  (**(code **)((int)arg + 4))(*(code **)((int)arg + 4));
  TVar1 = sys_now();
                    // WARNING: Load size is inaccurate
  uVar2 = current_timeout_due_time + *arg;
  abs_time = TVar1 + *arg;
  if (-1 < (int)(uVar2 - TVar1)) {
    abs_time = uVar2;
  }
  sys_timeout_abs(abs_time,lwip_cyclic_timer,arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_timeout(u32_t msecs,sys_timeout_handler *handler,void *arg)

{
  TickType_t TVar1;
  
  TVar1 = sys_now();
  sys_timeout_abs(TVar1 + msecs,handler,arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcp_timer_needed(void)

{
  if ((tcpip_tcp_timer_active == 0) &&
     ((tcp_active_pcbs != (tcp_pcb *)0x0 || (tcp_tw_pcbs != (tcp_pcb *)0x0)))) {
    tcpip_tcp_timer_active = 1;
    sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcpip_tcp_timer(void *arg)

{
  tcp_tmr();
  if ((tcp_active_pcbs == (tcp_pcb *)0x0) && (tcp_tw_pcbs == (tcp_pcb *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    tcpip_tcp_timer_active = 0;
    return;
  }
  sys_timeout(0xfa,tcpip_tcp_timer,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_timeouts_init(void)

{
  u32_t *arg;
  u32_t *puVar1;
  
  arg = &DAT_23086494;
  do {
    puVar1 = arg + 2;
    sys_timeout(*arg,lwip_cyclic_timer,arg);
    arg = puVar1;
  } while (puVar1 != (u32_t *)CSWTCH_13);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_untimeout(sys_timeout_handler *handler,void *arg)

{
  sys_timeo *psVar1;
  sys_timeo *psVar2;
  sys_timeo *mem;
  
  psVar1 = (sys_timeo *)0x0;
  mem = next_timeout;
  if (next_timeout != (sys_timeo *)0x0) {
    do {
      psVar2 = mem->next;
      if ((mem->h == handler) && (mem->arg == arg)) {
        if (psVar1 != (sys_timeo *)0x0) {
          psVar1->next = psVar2;
          psVar2 = next_timeout;
        }
        next_timeout = psVar2;
        memp_free(MEMP_SYS_TIMEOUT,mem);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      psVar1 = mem;
      mem = psVar2;
    } while (psVar2 != (sys_timeo *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sys_check_timeouts(void)

{
  sys_timeo *mem;
  sys_timeout_handler *psVar1;
  void *pvVar2;
  TickType_t TVar3;
  
  TVar3 = sys_now();
  while ((mem = next_timeout, next_timeout != (sys_timeo *)0x0 &&
         (-1 < (int)(TVar3 - next_timeout->time)))) {
    psVar1 = next_timeout->h;
    pvVar2 = next_timeout->arg;
    current_timeout_due_time = next_timeout->time;
    next_timeout = next_timeout->next;
    memp_free(MEMP_SYS_TIMEOUT,mem);
    if (psVar1 != (sys_timeout_handler *)0x0) {
      (*psVar1)(pvVar2);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u32_t sys_timeouts_sleeptime(void)

{
  u32_t uVar1;
  TickType_t TVar2;
  
  uVar1 = 0xffffffff;
  if (next_timeout != (sys_timeo *)0x0) {
    TVar2 = sys_now();
    uVar1 = next_timeout->time - TVar2;
    if ((int)uVar1 < 0) {
      uVar1 = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void udp_init(void)

{
  int iVar1;
  
  iVar1 = bl_rand();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  udp_port = (ushort)((uint)(iVar1 << 0x12) >> 0x12) + 0xc000;
  return;
}



void udp_input(pbuf *p,netif *inp)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  u8_t uVar3;
  u16_t uVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined2 extraout_var_03;
  undefined3 extraout_var_00;
  u32_t uVar7;
  uint uVar8;
  udp_pcb *puVar9;
  udp_pcb *puVar10;
  udp_pcb *puVar11;
  u16_t *puVar12;
  int iVar6;
  
  lwip_stats.udp.recv = lwip_stats.udp.recv + 1;
  if (p->len < 8) {
    lwip_stats.udp.lenerr = lwip_stats.udp.lenerr + 1;
    lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
  }
  else {
    puVar12 = (u16_t *)p->payload;
    uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif);
    iVar6 = CONCAT31(extraout_var,uVar3);
    uVar4 = lwip_htons(*puVar12);
    uVar5 = lwip_htons(puVar12[1]);
    puVar1 = udp_pcbs;
    puVar10 = (udp_pcb *)0x0;
    puVar2 = udp_pcbs;
    puVar9 = (udp_pcb *)0x0;
    while (puVar11 = puVar2, puVar11 != (udp_pcb *)0x0) {
      if (((uint)puVar11->local_port == CONCAT22(extraout_var_02,uVar5)) &&
         ((puVar11->netif_idx == '\0' ||
          (puVar11->netif_idx == (u8_t)((ip_data.current_input_netif)->num + '\x01'))))) {
        uVar8 = (puVar11->local_ip).addr;
        if (iVar6 == 0) {
          if ((uVar8 == 0) || (uVar8 == ip_data.current_iphdr_dest)) goto LAB_230454fc;
        }
        else {
          if ((uVar8 == 0) ||
             ((ip_data.current_iphdr_dest == 0xffffffff ||
              (((uVar8 ^ ip_data.current_iphdr_dest) & (inp->netmask).addr) == 0)))) {
LAB_230454fc:
            if ((puVar11->flags & 4) != 0) goto LAB_23045532;
            if (puVar10 == (udp_pcb *)0x0) {
LAB_23045520:
              puVar10 = puVar11;
            }
            else {
              if ((iVar6 == 0) || (ip_data.current_iphdr_dest != 0xffffffff)) {
                if (uVar8 != 0) goto LAB_23045520;
              }
              else {
                uVar7 = (inp->ip_addr).addr;
                if (((puVar10->local_ip).addr != uVar7) && (uVar7 == uVar8)) goto LAB_23045520;
              }
            }
LAB_23045532:
            if (((uint)puVar11->remote_port == CONCAT22(extraout_var_01,uVar4)) &&
               ((uVar7 = (puVar11->remote_ip).addr, uVar7 == 0 ||
                (uVar7 == ip_data.current_iphdr_src)))) {
              if (puVar9 == (udp_pcb *)0x0) {
                lwip_stats.udp.cachehit = lwip_stats.udp.cachehit + 1;
              }
              else {
                udp_pcbs = puVar11;
                puVar9->next = puVar11->next;
                puVar11->next = puVar1;
              }
              goto LAB_23045556;
            }
          }
        }
      }
      puVar2 = puVar11->next;
      puVar9 = puVar11;
    }
    puVar11 = puVar10;
    if ((puVar10 != (udp_pcb *)0x0) || ((inp->ip_addr).addr == ip_data.current_iphdr_dest)) {
LAB_23045556:
      if ((puVar12[3] == 0) ||
         (uVar5 = ip_chksum_pseudo(p,'\x11',p->tot_len,(ip4_addr_t *)&ip_data.current_iphdr_src,
                                   (ip4_addr_t *)&ip_data.current_iphdr_dest),
         CONCAT22(extraout_var_03,uVar5) == 0)) {
        uVar3 = pbuf_remove_header(p,8);
        if (CONCAT31(extraout_var_00,uVar3) == 0) {
          if (puVar11 != (udp_pcb *)0x0) {
            if (puVar11->recv != (udp_recv_fn *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230455e0. Too many branches
                    // WARNING: Treating indirect jump as call
              (*puVar11->recv)(puVar11->recv_arg,puVar11,p,(ip_addr_t *)0x4201fed0,uVar4);
              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
              return;
            }
            goto LAB_23045438;
          }
          if ((iVar6 == 0) && ((ip_data.current_iphdr_dest & 0xf0) != 0xe0)) {
            pbuf_header_force(p,ip_data.current_ip_header_tot_len + 8);
            icmp_dest_unreach(p,ICMP_DUR_PORT);
          }
          lwip_stats.udp.proterr = lwip_stats.udp.proterr + 1;
        }
      }
      else {
        lwip_stats.udp.chkerr = lwip_stats.udp.chkerr + 1;
      }
      lwip_stats.udp.drop = lwip_stats.udp.drop + 1;
    }
  }
LAB_23045438:
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t udp_bind(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  bool bVar1;
  err_t eVar2;
  undefined2 in_register_00002032;
  uint uVar3;
  u32_t uVar4;
  udp_pcb *puVar5;
  short sVar6;
  
  uVar3 = CONCAT22(in_register_00002032,port);
  if (ipaddr == (ip_addr_t *)0x0) {
    ipaddr = &ip_addr_any;
  }
  eVar2 = -0x10;
  puVar5 = udp_pcbs;
  if (pcb != (udp_pcb *)0x0) {
    while (puVar5 != (udp_pcb *)0x0) {
      if (puVar5 == pcb) {
        bVar1 = true;
        goto LAB_23045638;
      }
      puVar5 = puVar5->next;
    }
    bVar1 = false;
LAB_23045638:
    puVar5 = udp_pcbs;
    if (uVar3 == 0) {
      uVar3 = (uint)udp_port;
      sVar6 = 0x4000;
      do {
        puVar5 = udp_pcbs;
        if (uVar3 == 0xffff) {
          uVar3 = 0xc000;
        }
        else {
          uVar3 = uVar3 + 1 & 0xffff;
        }
        while( true ) {
          udp_port = (u16_t)uVar3;
          if (puVar5 == (udp_pcb *)0x0) goto LAB_23045660;
          if (puVar5->local_port == uVar3) break;
          puVar5 = puVar5->next;
        }
        sVar6 = sVar6 + -1;
      } while (sVar6 != 0);
LAB_230456a2:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -8;
    }
    while (puVar5 != (udp_pcb *)0x0) {
      if ((puVar5 != pcb) &&
         ((((pcb->so_options & 4) == 0 || ((puVar5->so_options & 4) == 0)) &&
          (puVar5->local_port == uVar3)))) {
        uVar4 = (puVar5->local_ip).addr;
        if (((uVar4 == ipaddr->addr) || (ipaddr->addr == 0)) || (uVar4 == 0)) goto LAB_230456a2;
      }
      puVar5 = puVar5->next;
    }
LAB_23045660:
    uVar4 = ipaddr->addr;
    pcb->local_port = (u16_t)uVar3;
    (pcb->local_ip).addr = uVar4;
    if (!bVar1) {
      puVar5 = pcb;
      pcb->next = udp_pcbs;
      udp_pcbs = puVar5;
    }
    eVar2 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



err_t udp_sendto_if_src_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum,ip_addr_t *src_ip)

{
  err_t eVar1;
  u8_t uVar2;
  byte bVar3;
  u16_t uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  pbuf *h;
  undefined2 extraout_var_01;
  undefined2 extraout_var_02;
  undefined3 in_register_0000203d;
  uint uVar5;
  undefined *puVar6;
  
  uVar5 = 0xfffffff0;
  if ((((pcb == (udp_pcb *)0x0) || (p == (pbuf *)0x0)) || (dst_ip == (ip_addr_t *)0x0)) ||
     ((src_ip == (ip_addr_t *)0x0 || (netif == (netif *)0x0)))) goto LAB_23045736;
  if (pcb->local_port == 0) {
    eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0);
    uVar5 = CONCAT31(extraout_var,eVar1);
    if (uVar5 != 0) goto LAB_23045736;
  }
  if (p->tot_len < 0xfff8) {
    uVar2 = pbuf_add_header(p,8);
    h = p;
    if (CONCAT31(extraout_var_00,uVar2) != 0) {
      h = pbuf_alloc(PBUF_IP,8,PBUF_RAM);
      if (h == (pbuf *)0x0) goto LAB_23045726;
      if (p->tot_len != 0) {
        pbuf_chain(h,p);
      }
    }
    puVar6 = (undefined *)h->payload;
    uVar4 = lwip_htons(pcb->local_port);
    *puVar6 = (char)uVar4;
    puVar6[1] = (char)(uVar4 >> 8);
    uVar4 = lwip_htons(dst_port);
    puVar6[2] = (char)uVar4;
    puVar6[3] = (char)(uVar4 >> 8);
    puVar6[6] = 0;
    puVar6[7] = 0;
    if (((pcb->flags & 8) != 0) && ((dst_ip->addr & 0xf0) == 0xe0)) {
      h->flags = h->flags | 4;
    }
    uVar4 = lwip_htons(h->tot_len);
    puVar6[4] = (char)uVar4;
    puVar6[5] = (char)(uVar4 >> 8);
    if ((pcb->flags & 1) == 0) {
      if (CONCAT31(in_register_0000203d,have_chksum) == 0) {
        uVar4 = ip_chksum_pseudo(h,'\x11',h->tot_len,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar5 = CONCAT22(extraout_var_02,uVar4);
      }
      else {
        uVar4 = ip_chksum_pseudo_partial
                          (h,'\x11',h->tot_len,8,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip);
        uVar5 = CONCAT22(extraout_var_01,uVar4) + (~(uint)chksum & 0xffff);
        uVar5 = uVar5 + (uVar5 >> 0x10) & 0xffff;
      }
      if (uVar5 == 0) {
        uVar5 = 0xffff;
      }
      puVar6[6] = (char)uVar5;
      puVar6[7] = (char)(uVar5 >> 8);
    }
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      uVar2 = pcb->mcast_ttl;
    }
    else {
      uVar2 = pcb->ttl;
    }
    bVar3 = ip4_output_if_src(h,(ip4_addr_t *)src_ip,(ip4_addr_t *)dst_ip,uVar2,pcb->tos,'\x11',
                              netif);
    uVar5 = (uint)bVar3;
    if (h != p) {
      pbuf_free(h);
    }
    lwip_stats.udp.xmit = lwip_stats.udp.xmit + 1;
  }
  else {
LAB_23045726:
    uVar5 = 0xffffffff;
  }
LAB_23045736:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)uVar5;
}



err_t udp_sendto_if_chksum
                (udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,u8_t have_chksum
                ,u16_t chksum)

{
  err_t eVar1;
  uint uVar2;
  udp_pcb *src_ip;
  
  if ((((pcb != (udp_pcb *)0x0) && (p != (pbuf *)0x0)) && (dst_ip != (ip_addr_t *)0x0)) &&
     (netif != (netif *)0x0)) {
    uVar2 = (pcb->local_ip).addr;
    if ((uVar2 == 0) || ((uVar2 & 0xf0) == 0xe0)) {
      src_ip = (udp_pcb *)&netif->ip_addr;
    }
    else {
      src_ip = pcb;
      if (uVar2 != (netif->ip_addr).addr) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -4;
      }
    }
    eVar1 = udp_sendto_if_src_chksum
                      (pcb,p,dst_ip,dst_port,netif,have_chksum,chksum,(ip_addr_t *)src_ip);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t udp_sendto_chksum(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,u8_t have_chksum,
                       u16_t chksum)

{
  err_t eVar1;
  netif *netif;
  u32_t uVar2;
  
  if (((pcb == (udp_pcb *)0x0) || (p == (pbuf *)0x0)) || (dst_ip == (ip_addr_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if (pcb->netif_idx == '\0') {
    if ((dst_ip->addr & 0xf0) == 0xe0) {
      if (pcb->mcast_ifindex == '\0') {
        uVar2 = (pcb->mcast_ip4).addr;
        if ((uVar2 == 0) || (uVar2 == 0xffffffff)) goto LAB_2304591a;
        netif = ip4_route(&pcb->mcast_ip4);
      }
      else {
        netif = netif_get_by_index(pcb->mcast_ifindex);
      }
      if (netif != (netif *)0x0) goto LAB_2304592e;
    }
LAB_2304591a:
    netif = ip4_route((ip4_addr_t *)dst_ip);
  }
  else {
    netif = netif_get_by_index(pcb->netif_idx);
  }
  if (netif == (netif *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    lwip_stats.udp.rterr = lwip_stats.udp.rterr + 1;
    return -4;
  }
LAB_2304592e:
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,have_chksum,chksum);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t udp_send_chksum(udp_pcb *pcb,pbuf *p,u8_t have_chksum,u16_t chksum)

{
  err_t eVar1;
  
  if ((pcb != (udp_pcb *)0x0) && (p != (pbuf *)0x0)) {
    eVar1 = udp_sendto_chksum(pcb,p,&pcb->remote_ip,pcb->remote_port,have_chksum,chksum);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t udp_sendto(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_chksum(pcb,p,dst_ip,dst_port,'\0',0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t udp_sendto_if(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t udp_sendto_if_src(udp_pcb *pcb,pbuf *p,ip_addr_t *dst_ip,u16_t dst_port,netif *netif,
                       ip_addr_t *src_ip)

{
  err_t eVar1;
  
  eVar1 = udp_sendto_if_src_chksum(pcb,p,dst_ip,dst_port,netif,'\0',0,src_ip);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



void udp_bind_netif(udp_pcb *pcb,netif *netif)

{
  u8_t uVar1;
  
  uVar1 = '\0';
  if (netif != (netif *)0x0) {
    uVar1 = netif->num + '\x01';
  }
  pcb->netif_idx = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t udp_connect(udp_pcb *pcb,ip_addr_t *ipaddr,u16_t port)

{
  err_t eVar1;
  undefined3 extraout_var;
  udp_pcb *puVar2;
  u32_t uVar3;
  int iVar4;
  
  if ((pcb == (udp_pcb *)0x0) || (ipaddr == (ip_addr_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if (pcb->local_port == 0) {
    eVar1 = udp_bind(pcb,(ip_addr_t *)pcb,0);
    iVar4 = CONCAT31(extraout_var,eVar1);
    if (iVar4 != 0) goto LAB_23045a06;
  }
  uVar3 = ipaddr->addr;
  pcb->remote_port = port;
  (pcb->remote_ip).addr = uVar3;
  pcb->flags = pcb->flags | 4;
  puVar2 = udp_pcbs;
  while (puVar2 != (udp_pcb *)0x0) {
    if (puVar2 == pcb) goto LAB_230459f6;
    puVar2 = puVar2->next;
  }
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
LAB_230459f6:
  iVar4 = 0;
LAB_23045a06:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar4;
}



void udp_disconnect(udp_pcb *pcb)

{
  byte bVar1;
  
  if (pcb != (udp_pcb *)0x0) {
    bVar1 = pcb->flags;
    (pcb->remote_ip).addr = 0;
    pcb->remote_port = 0;
    pcb->netif_idx = '\0';
    pcb->flags = bVar1 & 0xfb;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void udp_recv(udp_pcb *pcb,udp_recv_fn *recv,void *recv_arg)

{
  if (pcb != (udp_pcb *)0x0) {
    pcb->recv = recv;
    pcb->recv_arg = recv_arg;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void udp_remove(udp_pcb *pcb)

{
  udp_pcb *puVar1;
  udp_pcb *puVar2;
  
  if (pcb == (udp_pcb *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  puVar1 = udp_pcbs;
  if (udp_pcbs == pcb) {
    udp_pcbs = pcb->next;
  }
  else {
    do {
      puVar2 = puVar1;
      if ((puVar2 == (udp_pcb *)0x0) || (puVar1 = puVar2->next, puVar1 == (udp_pcb *)0x0))
      goto LAB_23045a58;
    } while (puVar1 != pcb);
    puVar2->next = pcb->next;
  }
LAB_23045a58:
  memp_free(MEMP_UDP_PCB,pcb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



udp_pcb * udp_new(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



udp_pcb * udp_new_ip_type(void)

{
  udp_pcb *__s;
  
  __s = (udp_pcb *)memp_malloc(MEMP_UDP_PCB);
  if (__s != (udp_pcb *)0x0) {
    memset(__s,0,0x28);
    __s->ttl = -1;
    __s->mcast_ttl = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



void udp_netif_ip_addr_changed(ip_addr_t *old_addr,ip_addr_t *new_addr)

{
  udp_pcb *puVar1;
  
  if ((((old_addr != (ip_addr_t *)0x0) && (old_addr->addr != 0)) && (new_addr != (ip_addr_t *)0x0))
     && (puVar1 = udp_pcbs, new_addr->addr != 0)) {
    while (puVar1 != (udp_pcb *)0x0) {
      if ((puVar1->local_ip).addr == old_addr->addr) {
        (puVar1->local_ip).addr = new_addr->addr;
      }
      puVar1 = puVar1->next;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



udp_pcb * udp_get_pcbs(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return udp_pcbs;
}



err_t ethernet_input(pbuf *p,netif *netif)

{
  short sVar1;
  u8_t uVar2;
  byte *__s1;
  undefined3 extraout_var;
  int iVar3;
  undefined3 extraout_var_00;
  byte bVar4;
  
  if (p->len < 0xf) {
LAB_23045aec:
    lwip_stats.etharp.proterr = lwip_stats.etharp.proterr + 1;
  }
  else {
    if (p->if_idx == '\0') {
      p->if_idx = netif->num + '\x01';
    }
    __s1 = (byte *)p->payload;
    sVar1 = *(short *)(__s1 + 0xc);
    if ((*__s1 & 1) != 0) {
      if (*__s1 == 1) {
        if ((__s1[1] == 0) && (__s1[2] == 0x5e)) {
          bVar4 = p->flags | 0x10;
LAB_23045b4a:
          p->flags = bVar4;
        }
      }
      else {
        iVar3 = memcmp(__s1,&ethbroadcast,6);
        if (iVar3 == 0) {
          bVar4 = p->flags | 8;
          goto LAB_23045b4a;
        }
      }
    }
    if (sVar1 == 8) {
      if (((netif->flags & 8) != 0) &&
         (uVar2 = pbuf_remove_header(p,0xe), CONCAT31(extraout_var_00,uVar2) == 0)) {
        ip4_input(p,netif);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\0';
      }
      goto free_and_return;
    }
    if (sVar1 != 0x608) goto LAB_23045aec;
    if ((netif->flags & 8) == 0) goto free_and_return;
    uVar2 = pbuf_remove_header(p,0xe);
    if (CONCAT31(extraout_var,uVar2) == 0) {
      etharp_input(p,netif);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
    lwip_stats.etharp.lenerr = lwip_stats.etharp.lenerr + 1;
  }
  lwip_stats.etharp.drop = lwip_stats.etharp.drop + 1;
free_and_return:
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t ethernet_output(netif *netif,pbuf *p,eth_addr *src,eth_addr *dst,u16_t eth_type)

{
  void *__dest;
  u8_t uVar1;
  err_t eVar2;
  u16_t uVar3;
  undefined3 extraout_var;
  
  uVar3 = lwip_htons(eth_type);
  uVar1 = pbuf_add_header(p,0xe);
  if (CONCAT31(extraout_var,uVar1) == 0) {
    __dest = p->payload;
    *(char *)((int)__dest + 0xc) = (char)uVar3;
    *(char *)((int)__dest + 0xd) = (char)(uVar3 >> 8);
    memcpy(__dest,dst,6);
    memcpy((void *)((int)__dest + 6),src,6);
                    // WARNING: Could not recover jumptable at 0x23045c42. Too many branches
                    // WARNING: Treating indirect jump as call
    eVar2 = (*netif->linkoutput)(netif,p);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  lwip_stats.link.lenerr = lwip_stats.link.lenerr + 1;
  return -2;
}



err_t netconn_apimsg(tcpip_callback_fn_conflict *fn,api_msg *apimsg)

{
  err_t eVar1;
  undefined3 extraout_var;
  int iVar2;
  
  eVar1 = tcpip_send_msg_wait_sem((tcpip_callback_fn)fn,apimsg,&apimsg->conn->op_completed);
  iVar2 = CONCAT31(extraout_var,eVar1);
  if (iVar2 == 0) {
    iVar2 = (int)apimsg->err;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar2;
}



err_t netconn_close_shutdown(netconn *conn,u8_t how)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    auStack52 = conn;
    msg.err = how;
    msg.msg._0_4_ = sys_now();
    eVar1 = netconn_apimsg(lwip_netconn_do_close,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



// WARNING: Variable defined which should be unmapped: msg

netconn * netconn_new_with_proto_and_callback(netconn_type t,u8_t proto,netconn_callback *callback)

{
  err_t eVar1;
  netconn *mem;
  undefined3 extraout_var;
  undefined auStack52 [4];
  api_msg msg;
  
  mem = netconn_alloc(t,callback);
  if (mem != (netconn *)0x0) {
    auStack52 = mem;
    msg.err = proto;
    eVar1 = netconn_apimsg(lwip_netconn_do_newconn,(api_msg *)auStack52);
    if (CONCAT31(extraout_var,eVar1) != 0) {
      sys_mbox_valid((int *)&mem->recvmbox);
      sys_mbox_valid((int *)&mem->acceptmbox);
      sys_sem_valid(&mem->op_completed);
      sys_sem_free(&mem->op_completed);
      sys_mbox_free(&mem->recvmbox);
      memp_free(MEMP_NETCONN,mem);
      mem = (netconn *)0x0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return mem;
}



err_t netconn_prepare_delete(netconn *conn)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    auStack52 = conn;
    msg.msg._0_4_ = sys_now();
    eVar1 = netconn_apimsg(lwip_netconn_do_delconn,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t netconn_delete(netconn *conn)

{
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  
  iVar1 = 0;
  if (conn != (netconn *)0x0) {
    eVar2 = netconn_prepare_delete(conn);
    iVar1 = CONCAT31(extraout_var,eVar2);
    if (iVar1 == 0) {
      netconn_free(conn);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



err_t netconn_getaddr(netconn *conn,ip_addr_t *addr,u16_t *port,u8_t local)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if ((addr != (ip_addr_t *)0x0) && (port != (u16_t *)0x0)) {
    auStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_4_ = port;
    msg.msg._4_1_ = local;
    eVar1 = netconn_apimsg(lwip_netconn_do_getaddr,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_bind(netconn *conn,ip_addr_t *addr,u16_t port)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (addr == (ip_addr_t *)0x0) {
      addr = &ip_addr_any;
    }
    auStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_2_ = port;
    eVar1 = netconn_apimsg(lwip_netconn_do_bind,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_connect(netconn *conn,ip_addr_t *addr,u16_t port)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (addr == (ip_addr_t *)0x0) {
      addr = &ip_addr_any;
    }
    auStack52 = conn;
    msg._4_4_ = addr;
    msg.msg._0_2_ = port;
    eVar1 = netconn_apimsg(lwip_netconn_do_connect,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_disconnect(netconn *conn)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    auStack52 = conn;
    eVar1 = netconn_apimsg(lwip_netconn_do_disconnect,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_listen_with_backlog(netconn *conn,u8_t backlog)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    auStack52 = conn;
    eVar1 = netconn_apimsg(lwip_netconn_do_listen,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_tcp_recvd(netconn *conn,size_t len)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    auStack52 = conn;
    msg._4_4_ = len;
    eVar1 = netconn_apimsg(lwip_netconn_do_recv,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_send(netconn *conn,netbuf *buf)

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    auStack52 = conn;
    msg._4_4_ = buf;
    eVar1 = netconn_apimsg(lwip_netconn_do_send,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_write_vectors_partly
                (netconn *conn,netvector *vectors,u16_t vectorcnt,u8_t apiflags,
                size_t *bytes_written)

{
  err_t eVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined2 in_register_00002032;
  size_t *psVar3;
  uint uVar4;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn == (netconn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  eVar1 = -6;
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    if ((((uint)((conn->flags & 2 | apiflags & 4) != 0) | conn->send_timeout) != 0) &&
       (bytes_written == (size_t *)0x0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -6;
    }
    psVar3 = &vectors->len;
    iVar2 = 0;
    msg.msg._8_4_ = 0;
    while (iVar2 < CONCAT22(in_register_00002032,vectorcnt)) {
      uVar4 = *psVar3;
      psVar3 = psVar3 + 2;
      msg.msg._8_4_ = msg.msg._8_4_ + uVar4;
      if (msg.msg._8_4_ < uVar4) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -6;
      }
      iVar2 = iVar2 + 1;
    }
    if (msg.msg._8_4_ != 0) {
      if ((int)msg.msg._8_4_ < 0) {
        if (bytes_written == (size_t *)0x0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -6;
        }
        msg.msg._8_4_ = 0x7fffffff;
      }
      msg.msg._4_4_ = 0;
      msg.msg._12_4_ = 0;
      auStack52 = conn;
      msg._4_4_ = vectors;
      msg.msg._0_2_ = vectorcnt;
      msg.msg._16_1_ = apiflags;
      if (conn->send_timeout == 0) {
        msg.msg._20_4_ = 0;
      }
      else {
        msg.msg._20_4_ = sys_now();
      }
      eVar1 = netconn_apimsg(lwip_netconn_do_write,(api_msg *)auStack52);
      iVar2 = CONCAT31(extraout_var,eVar1);
      if (iVar2 == 0) {
        if (bytes_written == (size_t *)0x0) {
          iVar2 = 0;
        }
        else {
          *bytes_written = msg.msg._12_4_;
        }
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (err_t)iVar2;
    }
    eVar1 = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netconn_write_partly
                (netconn *conn,void *dataptr,size_t size,u8_t apiflags,size_t *bytes_written)

{
  err_t eVar1;
  undefined auStack24 [4];
  netvector vector;
  
  auStack24 = dataptr;
  vector.ptr = (void *)size;
  eVar1 = netconn_write_vectors_partly(conn,(netvector *)auStack24,1,apiflags,bytes_written);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netconn_err(netconn *conn)

{
  err_t eVar1;
  
  eVar1 = '\0';
  if (conn != (netconn *)0x0) {
    sys_arch_protect();
    eVar1 = conn->pending_err;
    conn->pending_err = '\0';
    sys_arch_unprotect();
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netconn_accept(netconn *conn,netconn **new_conn)

{
  int iVar1;
  bool bVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u32_t uVar3;
  int iVar4;
  sys_mbox_t *mbox;
  err_t eStack37;
  err_t err;
  netconn *pnStack36;
  void *accept_ptr;
  
  if ((new_conn == (netconn **)0x0) || (*new_conn = (netconn *)0x0, conn == (netconn *)0x0)) {
    iVar1 = -0x10;
  }
  else {
    eStack37 = netconn_err(conn);
    iVar1 = CONCAT31(extraout_var,eStack37);
    if (iVar1 == 0) {
      mbox = &conn->acceptmbox;
      bVar2 = sys_mbox_valid((int *)mbox);
      if ((CONCAT31(extraout_var_00,bVar2) != 0) && ((conn->flags & 1) == 0)) {
        if ((conn->flags & 2) == 0) {
          uVar3 = sys_arch_mbox_fetch(mbox,(void **)&stack0xffffffdc,conn->recv_timeout);
          if (uVar3 == 0xffffffff) {
            iVar1 = -3;
            goto LAB_23045f9c;
          }
        }
        else {
          uVar3 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc);
          if (uVar3 == 0xffffffff) {
            iVar1 = -7;
            goto LAB_23045f9c;
          }
        }
        if (conn->callback != (netconn_callback *)0x0) {
          (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,0);
        }
        iVar4 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
        if (iVar4 != 0) {
          iVar1 = (int)eStack37;
          goto LAB_23045f9c;
        }
        if (pnStack36 != (netconn *)0x0) {
          *new_conn = pnStack36;
          goto LAB_23045f9c;
        }
      }
      iVar1 = -0xf;
    }
  }
LAB_23045f9c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



err_t netconn_recv_data(netconn *conn,void **new_buf,u8_t apiflags)

{
  bool bVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u32_t uVar3;
  undefined3 extraout_var_01;
  int iVar4;
  void **ppvVar5;
  sys_mbox_t *mbox;
  char cStack37;
  err_t err;
  void **ppvStack36;
  void *buf;
  
  ppvStack36 = (void **)0x0;
  if ((new_buf == (void **)0x0) || (*new_buf = (void *)0x0, conn == (netconn *)0x0)) {
    iVar4 = -0x10;
    goto LAB_23046042;
  }
  mbox = &conn->recvmbox;
  bVar1 = sys_mbox_valid((int *)mbox);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    eVar2 = netconn_err(conn);
    iVar4 = CONCAT31(extraout_var_00,eVar2);
    if (iVar4 != 0) goto LAB_23046042;
LAB_23046074:
    iVar4 = -0xb;
    goto LAB_23046042;
  }
  if (((apiflags & 4 | conn->flags & 3) == 0) && (conn->pending_err == '\0')) {
    uVar3 = sys_arch_mbox_fetch(mbox,(void **)&stack0xffffffdc,conn->recv_timeout);
    iVar4 = -3;
    if (uVar3 == 0xffffffff) goto LAB_23046042;
  }
  else {
    uVar3 = sys_arch_mbox_tryfetch(mbox,(void **)&stack0xffffffdc);
    if (uVar3 == 0xffffffff) {
      eVar2 = netconn_err(conn);
      iVar4 = CONCAT31(extraout_var_01,eVar2);
      if (iVar4 != 0) goto LAB_23046042;
      if ((conn->flags & 1) == 0) {
        iVar4 = -7;
        goto LAB_23046042;
      }
      goto LAB_23046074;
    }
  }
  if ((conn->type & 0xf0) == NETCONN_TCP) {
    iVar4 = lwip_netconn_is_err_msg(ppvStack36,&cStack37);
    ppvVar5 = ppvStack36;
    if (iVar4 == 0) goto LAB_230460ee;
    iVar4 = (int)cStack37;
    if (iVar4 != -0xf) goto LAB_23046042;
  }
  else {
    ppvVar5 = (void **)*ppvStack36;
LAB_230460ee:
    if (conn->callback != (netconn_callback *)0x0) {
      (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,*(u16_t *)(ppvVar5 + 2));
    }
    *new_buf = ppvStack36;
  }
  iVar4 = 0;
LAB_23046042:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar4;
}



err_t netconn_recv_udp_raw_netbuf_flags(netconn *conn,netbuf **new_buf,u8_t apiflags)

{
  err_t eVar1;
  
  if ((conn != (netconn *)0x0) && ((conn->type & 0xf0) != NETCONN_TCP)) {
    eVar1 = netconn_recv_data(conn,new_buf,apiflags);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_recv_data_tcp(netconn *conn,pbuf **new_buf,u8_t apiflags)

{
  int iVar1;
  bool bVar2;
  err_t eVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar4;
  pbuf *ppVar5;
  undefined auStack68 [4];
  api_msg msg;
  
  bVar2 = sys_mbox_valid((int *)&conn->recvmbox);
  iVar1 = -0xb;
  if (CONCAT31(extraout_var,bVar2) == 0) goto LAB_230461cc;
  if ((char)conn->flags < '\0') {
    conn->flags = conn->flags & 0x7f;
  }
  else {
    eVar3 = netconn_recv_data(conn,new_buf,apiflags);
    iVar1 = CONCAT31(extraout_var_01,eVar3);
    if (iVar1 != 0) goto LAB_230461cc;
    ppVar5 = *new_buf;
    if ((apiflags & 8) == 0) {
      uVar4 = 1;
      if (ppVar5 != (pbuf *)0x0) {
        uVar4 = (uint)ppVar5->tot_len;
      }
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        auStack68 = conn;
        msg._4_4_ = uVar4;
        netconn_apimsg(lwip_netconn_do_recv,(api_msg *)auStack68);
      }
    }
    if (ppVar5 != (pbuf *)0x0) goto LAB_230461cc;
    if ((apiflags & 0x10) != 0) {
      iVar1 = -7;
      conn->flags = conn->flags | 0x80;
      goto LAB_230461cc;
    }
  }
  if (conn->callback != (netconn_callback *)0x0) {
    (*conn->callback)(conn,NETCONN_EVT_RCVMINUS,0);
  }
  if (conn->pcb == 0) {
    eVar3 = netconn_err(conn);
    iVar1 = CONCAT31(extraout_var_00,eVar3);
    if (iVar1 == 0) {
      iVar1 = -0xe;
    }
  }
  else {
    netconn_close_shutdown(conn,'\x01');
    iVar1 = -0xf;
  }
LAB_230461cc:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



err_t netconn_recv_tcp_pbuf_flags(netconn *conn,pbuf **new_buf,u8_t apiflags)

{
  err_t eVar1;
  
  if ((conn != (netconn *)0x0) && ((conn->type & 0xf0) == NETCONN_TCP)) {
    eVar1 = netconn_recv_data_tcp(conn,new_buf,apiflags);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_shutdown(netconn *conn,u8_t shut_rx,u8_t shut_tx)

{
  err_t eVar1;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  
  eVar1 = netconn_close_shutdown
                    (conn,CONCAT31(in_register_0000202d,shut_rx) != 0 |
                          (CONCAT31(in_register_00002031,shut_tx) != 0) << 1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar1;
}



err_t netconn_join_leave_group
                (netconn *conn,ip_addr_t *multiaddr,ip_addr_t *netif_addr,netconn_igmp join_or_leave
                )

{
  err_t eVar1;
  undefined auStack52 [4];
  api_msg msg;
  
  if (conn != (netconn *)0x0) {
    if (multiaddr == (ip_addr_t *)0x0) {
      multiaddr = &ip_addr_any;
    }
    if (netif_addr == (ip_addr_t *)0x0) {
      netif_addr = &ip_addr_any;
    }
    auStack52 = conn;
    msg._4_4_ = multiaddr;
    msg.msg._0_4_ = netif_addr;
    msg.msg._5_1_ = join_or_leave;
    eVar1 = netconn_apimsg(lwip_netconn_do_join_leave_group,(api_msg *)auStack52);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return eVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x10;
}



err_t netconn_gethostbyname(char *name,ip_addr_t *addr)

{
  int iVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  err_t eStack37;
  err_t err;
  sys_sem_t sem;
  dns_api_msg msg;
  
  iVar1 = -0x10;
  if ((name != (char *)0x0) && (addr != (ip_addr_t *)0x0)) {
    msg.sem = (sys_sem_t *)&eStack37;
    msg.addr = (ip_addr_t *)&stack0xffffffdc;
    sem = (sys_sem_t)name;
    msg.name = (char *)addr;
    eStack37 = sys_sem_new((sys_sem_t *)msg.addr,'\0');
    iVar1 = CONCAT31(extraout_var,eStack37);
    if (iVar1 == 0) {
      eVar2 = tcpip_send_msg_wait_sem(lwip_netconn_do_gethostbyname,&sem,(sys_sem_t *)msg.addr);
      iVar1 = CONCAT31(extraout_var_00,eVar2);
      sys_sem_free((sys_sem_t *)msg.addr);
      if (iVar1 == 0) {
        iVar1 = (int)eStack37;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



void lwip_netconn_do_dns_found(char *name,ip_addr_t *ipaddr,void *arg)

{
  if (ipaddr == (ip_addr_t *)0x0) {
    **(undefined **)((int)arg + 0xc) = 0xfa;
  }
  else {
    **(undefined **)((int)arg + 0xc) = 0;
    **(u32_t **)((int)arg + 4) = ipaddr->addr;
  }
  sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)((int)arg + 8));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void recv_udp(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  u16_t uVar1;
  bool bVar2;
  err_t eVar3;
  undefined3 extraout_var;
  netbuf *buf;
  undefined3 extraout_var_00;
  u32_t uVar4;
  
  if (arg != (void *)0x0) {
    bVar2 = sys_mbox_valid((int *)(sys_mbox_t *)((int)arg + 0x10));
    if ((CONCAT31(extraout_var,bVar2) != 0) &&
       (buf = (netbuf *)memp_malloc(MEMP_NETBUF), buf != (netbuf *)0x0)) {
      buf->p = p;
      buf->ptr = p;
      uVar4 = 0;
      if (addr != (ip_addr_t *)0x0) {
        uVar4 = addr->addr;
      }
      (buf->addr).addr = uVar4;
      buf->port = port;
      uVar1 = p->tot_len;
      eVar3 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),buf);
      if (CONCAT31(extraout_var_00,eVar3) != 0) {
        netbuf_delete(buf);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304635c. Too many branches
                    // WARNING: Treating indirect jump as call
        (**(code **)((int)arg + 0x2c))(arg,0,uVar1);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
  }
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void setup_tcp(netconn *conn)

{
  tcp_pcb *pcb;
  
  pcb = (tcp_pcb *)conn->pcb;
  tcp_arg(pcb,conn);
  tcp_recv(pcb,recv_tcp);
  tcp_sent(pcb,sent_tcp);
  tcp_poll(pcb,poll_tcp,'\x02');
  tcp_err(pcb,err_tcp);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t lwip_netconn_do_connected(void *arg,tcp_pcb *pcb,err_t err)

{
  byte bVar1;
  err_t eVar2;
  sys_mutex_t mutex;
  undefined3 in_register_00002031;
  
  eVar2 = -6;
  if (arg != (void *)0x0) {
    mutex = *(sys_mutex_t *)((int)arg + 0x28);
    if (mutex != (sys_mutex_t)0x0) {
      *(err_t *)&mutex->pcWriteTo = err;
      mutex = (sys_mutex_t)(**(int **)((int)arg + 0x28) + 0xc);
    }
                    // WARNING: Load size is inaccurate
    if (((*arg & 0xf0) == 0x10) && (CONCAT31(in_register_00002031,err) == 0)) {
      setup_tcp((netconn *)arg);
    }
    bVar1 = *(byte *)((int)arg + 0x24);
    *(undefined4 *)((int)arg + 0x28) = 0;
    *(undefined *)((int)arg + 1) = 0;
    *(byte *)((int)arg + 0x24) = bVar1 & 0xfb;
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,2,0);
    }
    eVar2 = '\0';
    if ((bVar1 & 4) == 0) {
      sys_sem_signal((sys_mutex_t *)mutex);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return eVar2;
}



void err_tcp(void *arg,err_t err)

{
  char cVar1;
  byte bVar2;
  sys_sem_t *sem;
  bool bVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar4;
  void *msg;
  
  sys_arch_protect();
  cVar1 = *(char *)((int)arg + 1);
  *(undefined4 *)((int)arg + 4) = 0;
  *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) | 1;
  *(err_t *)((int)arg + 8) = err;
  *(undefined *)((int)arg + 1) = 0;
  sys_arch_unprotect();
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,4,0);
  }
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,0,0);
  }
  if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
    (**(code **)((int)arg + 0x2c))(arg,2,0);
  }
  uVar4 = (byte)err + 0xf & 0xff;
  msg = (void *)0x0;
  if (uVar4 < 3) {
    msg = *(void **)(CSWTCH_13 + uVar4 * 4);
  }
  bVar3 = sys_mbox_valid((int *)(sys_mbox_t *)((int)arg + 0x10));
  if (CONCAT31(extraout_var,bVar3) != 0) {
    sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),msg);
  }
  bVar3 = sys_mbox_valid((int *)(sys_mbox_t *)((int)arg + 0x14));
  if (CONCAT31(extraout_var_00,bVar3) != 0) {
    sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x14),msg);
  }
  if (((cVar1 == '\x01') || ((byte)(cVar1 - 3U) < 2)) &&
     (bVar2 = *(byte *)((int)arg + 0x24), *(byte *)((int)arg + 0x24) = bVar2 & 0xfb,
     (bVar2 & 4) == 0)) {
    if (cVar1 == '\x04') {
      err = '\0';
    }
    *(err_t *)(*(int *)((int)arg + 0x28) + 4) = err;
    sem = (sys_sem_t *)(**(int **)((int)arg + 0x28) + 0xc);
    sys_sem_valid(sem);
    *(undefined4 *)((int)arg + 0x28) = 0;
    sys_sem_signal((sys_mutex_t *)sem);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t lwip_netconn_do_writemore(netconn *conn)

{
  bool bVar1;
  int iVar2;
  err_t eVar3;
  TickType_t TVar4;
  netconn *pnVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar6;
  api_msg *paVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  byte apiflags;
  byte bVar11;
  
  apiflags = *(byte *)&(conn->current_msg->msg).field_0x14;
  bVar11 = conn->flags & 2 | apiflags & 4;
  if (conn->send_timeout == 0) {
LAB_23046596:
    do {
      paVar7 = conn->current_msg;
      iVar2 = *(int *)&(paVar7->msg).field_0x8;
      uVar9 = (*(int **)&paVar7->msg)[1] - iVar2;
      if (uVar9 < 0x10000) {
        uVar10 = uVar9 & 0xffff;
      }
      else {
        apiflags = apiflags | 2;
        uVar10 = 0xffff;
      }
      uVar6 = (uint)((tcp_pcb *)conn->pcb)->snd_buf;
      if (uVar6 < uVar10) {
        if (bVar11 == 0) {
          apiflags = apiflags | 2;
        }
        else {
          if (uVar6 == 0) {
            iVar2 = -7;
            if (*(int *)&(paVar7->msg).field_0x10 != 0) {
              iVar2 = 0;
            }
            goto LAB_230465ce;
          }
        }
LAB_2304662c:
        bVar1 = false;
        if (((uVar9 & 0xffff) == uVar6) && (1 < *(ushort *)&(paVar7->msg).field_0x4))
        goto LAB_2304663e;
      }
      else {
        uVar6 = uVar10;
        if ((uVar10 != 0xffff) || (uVar9 < 0x10000)) goto LAB_2304662c;
LAB_2304663e:
        apiflags = apiflags | 2;
        bVar1 = true;
      }
      eVar3 = tcp_write((tcp_pcb *)conn->pcb,(void *)(**(int **)&paVar7->msg + iVar2),(u16_t)uVar6,
                        apiflags);
      iVar2 = CONCAT31(extraout_var_00,eVar3);
      if (iVar2 != 0) {
        if (1 < (iVar2 + 1U & 0xff)) goto LAB_2304657e;
        iVar2 = -1;
        break;
      }
      *(uint *)&(conn->current_msg->msg).field_0x10 =
           *(int *)&(conn->current_msg->msg).field_0x10 + uVar6;
      *(uint *)&(conn->current_msg->msg).field_0x8 =
           uVar6 + *(int *)&(conn->current_msg->msg).field_0x8;
      paVar7 = conn->current_msg;
      if (*(int *)&(paVar7->msg).field_0x8 == *(int *)(*(int *)&paVar7->msg + 4)) {
        *(short *)&(paVar7->msg).field_0x4 = *(short *)&(paVar7->msg).field_0x4 + -1;
        paVar7 = conn->current_msg;
        if (*(short *)&(paVar7->msg).field_0x4 != 0) {
          *(int *)&paVar7->msg = *(int *)&paVar7->msg + 8;
          *(undefined4 *)&(conn->current_msg->msg).field_0x8 = 0;
        }
      }
    } while (bVar1);
    if (bVar11 == 0) {
LAB_230466a6:
      if (((*(ushort *)(conn->pcb + 100) < 0xac1) || (7 < *(ushort *)(conn->pcb + 0x66))) &&
         (conn->callback != (netconn_callback *)0x0)) {
        (*conn->callback)(conn,NETCONN_EVT_SENDMINUS,0);
      }
    }
    else {
LAB_230465ce:
      if (*(uint *)&(conn->current_msg->msg).field_0xc <=
          *(uint *)&(conn->current_msg->msg).field_0x10) goto LAB_230466a6;
      if (conn->callback != (netconn_callback *)0x0) {
        (*conn->callback)(conn,NETCONN_EVT_SENDMINUS,0);
      }
      conn->flags = conn->flags | 0x10;
    }
    if (iVar2 == 0) {
      iVar2 = *(int *)&(conn->current_msg->msg).field_0x10;
      iVar8 = *(int *)&(conn->current_msg->msg).field_0xc;
      eVar3 = tcp_output((tcp_pcb *)conn->pcb);
      if (CONCAT31(extraout_var,eVar3) != -4) {
        if (iVar2 != iVar8 && bVar11 == 0) goto LAB_230466ee;
        goto LAB_2304657c;
      }
LAB_2304660e:
      iVar2 = -4;
    }
    else {
      if (iVar2 == -1) {
        eVar3 = tcp_output((tcp_pcb *)conn->pcb);
        if (CONCAT31(extraout_var_01,eVar3) == -4) goto LAB_2304660e;
        if (bVar11 == 0) goto LAB_230466ee;
        iVar8 = *(int *)&(conn->current_msg->msg).field_0x10;
        goto LAB_23046578;
      }
    }
  }
  else {
    TVar4 = sys_now();
    if ((int)(TVar4 - *(int *)&(conn->current_msg->msg).field_0x18) < conn->send_timeout)
    goto LAB_23046596;
    iVar8 = *(int *)&(conn->current_msg->msg).field_0x10;
LAB_23046578:
    iVar2 = -7;
    if (iVar8 != 0) {
LAB_2304657c:
      iVar2 = 0;
    }
  }
LAB_2304657e:
  pnVar5 = conn->current_msg->conn;
  conn->current_msg->err = (err_t)iVar2;
  conn->current_msg = (api_msg *)0x0;
  conn->state = NETCONN_NONE;
  sys_sem_signal((sys_mutex_t *)&pnVar5->op_completed);
LAB_230466ee:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t lwip_netconn_do_close_internal(netconn *conn)

{
  byte bVar1;
  bool bVar2;
  tcp_pcb *pcb;
  netconn *pnVar3;
  err_t eVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  TickType_t TVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  
  bVar1 = *(byte *)&conn->current_msg->msg;
  uVar6 = (uint)bVar1;
  pcb = (tcp_pcb *)conn->pcb;
  if (((uVar6 == 3) ||
      (((bVar1 & 1) != 0 && (((byte)(pcb->state + ~ESTABLISHED) < 2 || (pcb->state == CLOSING))))))
     || ((bVar2 = false, (bVar1 & 2) != 0 && ((pcb->flags & 0x10) != 0)))) {
    tcp_arg(pcb,(void *)0x0);
    bVar2 = true;
  }
  if (pcb->state == LISTEN) {
    tcp_accept(pcb,(tcp_accept_fn)0x0);
    if (!bVar2) goto LAB_2304677c;
LAB_230467be:
    eVar4 = tcp_close(pcb);
    iVar7 = CONCAT31(extraout_var_00,eVar4);
  }
  else {
    if ((bVar1 & 1) != 0) {
      tcp_recv(pcb,(tcp_recv_fn *)0x0);
      tcp_accept(pcb,(tcp_accept_fn)0x0);
    }
    if ((bVar1 & 2) != 0) {
      tcp_sent(pcb,(tcp_sent_fn *)0x0);
    }
    if (bVar2) {
      tcp_poll(pcb,(tcp_poll_fn *)0x0,'\0');
      tcp_err(pcb,(tcp_err_fn *)0x0);
      goto LAB_230467be;
    }
LAB_2304677c:
    eVar4 = tcp_shutdown(pcb,uVar6 & 1,uVar6 & 2);
    iVar7 = CONCAT31(extraout_var,eVar4);
  }
  if ((iVar7 != 0) && (iVar7 == -1)) {
    iVar8 = conn->send_timeout;
    if (iVar8 < 1) {
      iVar8 = 5000;
    }
    TVar5 = sys_now();
    if ((int)(TVar5 - *(int *)&(conn->current_msg->msg).field_0x4) < iVar8) {
      if ((bVar1 & 2) != 0) {
        tcp_sent(pcb,sent_tcp);
      }
      tcp_poll(pcb,poll_tcp,'\x01');
      tcp_err(pcb,err_tcp);
      tcp_arg(pcb,conn);
      goto LAB_23046848;
    }
    if (bVar2) {
      tcp_abort(pcb);
      iVar7 = 0;
    }
  }
  pnVar3 = conn->current_msg->conn;
  conn->current_msg->err = (err_t)iVar7;
  conn->current_msg = (api_msg *)0x0;
  conn->state = NETCONN_NONE;
  if (iVar7 == 0) {
    if (bVar2) {
      conn->pcb = 0;
      if (conn->callback != (netconn_callback *)0x0) {
        (*conn->callback)(conn,NETCONN_EVT_ERROR,0);
      }
    }
    if (((bVar1 & 1) != 0) && (conn->callback != (netconn_callback *)0x0)) {
      (*conn->callback)(conn,NETCONN_EVT_RCVPLUS,0);
    }
    if (((bVar1 & 2) != 0) && (conn->callback != (netconn_callback *)0x0)) {
      (*conn->callback)(conn,NETCONN_EVT_SENDPLUS,0);
    }
  }
  sys_sem_signal((sys_mutex_t *)&pnVar3->op_completed);
  iVar7 = 0;
LAB_23046848:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar7;
}



err_t poll_tcp(void *arg,tcp_pcb *pcb)

{
  int iVar1;
  
  if (*(char *)((int)arg + 1) == '\x01') {
    lwip_netconn_do_writemore((netconn *)arg);
  }
  else {
    if (*(char *)((int)arg + 1) == '\x04') {
      lwip_netconn_do_close_internal((netconn *)arg);
    }
  }
  if (((((*(byte *)((int)arg + 0x24) & 0x10) != 0) && (iVar1 = *(int *)((int)arg + 4), iVar1 != 0))
      && (0xac0 < *(ushort *)(iVar1 + 100))) && (*(ushort *)(iVar1 + 0x66) < 8)) {
    *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) & 0xef;
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,2,0);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



u8_t recv_raw(void *arg,raw_pcb *pcb,pbuf *p,ip_addr_t *addr)

{
  u16_t uVar1;
  bool bVar2;
  err_t eVar3;
  undefined3 extraout_var;
  pbuf *p_00;
  netbuf *buf;
  undefined3 extraout_var_00;
  u16_t len;
  
  if (arg != (void *)0x0) {
    bVar2 = sys_mbox_valid((int *)(sys_mbox_t *)((int)arg + 0x10));
    if ((CONCAT31(extraout_var,bVar2) != 0) &&
       (p_00 = pbuf_clone(PBUF_RAW,PBUF_RAM,p), p_00 != (pbuf *)0x0)) {
      buf = (netbuf *)memp_malloc(MEMP_NETBUF);
      if (buf == (netbuf *)0x0) {
        pbuf_free(p_00);
      }
      else {
        buf->p = p_00;
        buf->ptr = p_00;
        (buf->addr).addr = ip_data.current_iphdr_src;
        buf->port = (ushort)pcb->protocol;
        uVar1 = p_00->tot_len;
        eVar3 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),buf);
        if (CONCAT31(extraout_var_00,eVar3) == 0) {
          if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
            (**(code **)((int)arg + 0x2c))(arg,0,uVar1);
          }
        }
        else {
          netbuf_delete(buf);
        }
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t sent_tcp(void *arg,tcp_pcb *pcb,u16_t len)

{
  undefined2 in_register_00002032;
  int iVar1;
  
  if (arg != (void *)0x0) {
    if (*(char *)((int)arg + 1) == '\x01') {
      lwip_netconn_do_writemore((netconn *)arg);
    }
    else {
      if (*(char *)((int)arg + 1) == '\x04') {
        lwip_netconn_do_close_internal((netconn *)arg);
      }
    }
    iVar1 = *(int *)((int)arg + 4);
    if (((iVar1 != 0) && (0xac0 < *(ushort *)(iVar1 + 100))) && (*(ushort *)(iVar1 + 0x66) < 8)) {
      *(byte *)((int)arg + 0x24) = *(byte *)((int)arg + 0x24) & 0xef;
      if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
        (**(code **)((int)arg + 0x2c))(arg,2,CONCAT22(in_register_00002032,len));
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



err_t recv_tcp(void *arg,tcp_pcb *pcb,pbuf *p,err_t err)

{
  int iVar1;
  bool bVar2;
  err_t eVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  u16_t uVar4;
  
  iVar1 = -6;
  if (arg == (void *)0x0) goto LAB_23046a24;
  bVar2 = sys_mbox_valid((int *)(sys_mbox_t *)((int)arg + 0x10));
  if (CONCAT31(extraout_var,bVar2) == 0) {
    if (p != (pbuf *)0x0) {
      tcp_recved(pcb,p->tot_len);
      pbuf_free(p);
    }
  }
  else {
    if (p == (pbuf *)0x0) {
      uVar4 = 0;
      p = (pbuf *)"";
    }
    else {
      uVar4 = p->tot_len;
    }
    eVar3 = sys_mbox_trypost((sys_mbox_t *)((int)arg + 0x10),p);
    iVar1 = CONCAT31(extraout_var_00,eVar3);
    if (iVar1 != 0) {
      iVar1 = -1;
      goto LAB_23046a24;
    }
    if (*(code **)((int)arg + 0x2c) != (code *)0x0) {
      (**(code **)((int)arg + 0x2c))(arg,0,uVar4);
      goto LAB_23046a24;
    }
  }
  iVar1 = 0;
LAB_23046a24:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (err_t)iVar1;
}



int lwip_netconn_is_err_msg(void *msg,err_t *err)

{
  err_t eVar1;
  
  if ((u8_t *)msg == "") {
    eVar1 = -0xd;
  }
  else {
    if ((u8_t *)msg == "") {
      eVar1 = -0xe;
    }
    else {
      if ((u8_t *)msg != "") {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      eVar1 = -0xf;
    }
  }
  *err = eVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



void lwip_netconn_do_newconn(void *m)

{
  byte *pbVar1;
  tcp_pcb *ptVar2;
  raw_pcb *prVar3;
  udp_pcb *puVar4;
  byte bVar5;
  undefined uVar6;
  int iVar7;
  
                    // WARNING: Load size is inaccurate
  pbVar1 = *m;
  *(undefined *)((int)m + 4) = 0;
  if (*(int *)(pbVar1 + 4) != 0) goto LAB_23046b1c;
  bVar5 = *pbVar1 & 0xf0;
  if (bVar5 == 0x20) {
    puVar4 = udp_new_ip_type();
    *(udp_pcb **)(pbVar1 + 4) = puVar4;
                    // WARNING: Load size is inaccurate
    iVar7 = *(int *)(*m + 4);
    if (iVar7 != 0) {
      if (**m == '\"') {
        *(undefined *)(iVar7 + 0x10) = 1;
      }
                    // WARNING: Load size is inaccurate
      udp_recv(*(udp_pcb **)((int)*m + 4),recv_udp,*m);
LAB_23046b16:
                    // WARNING: Load size is inaccurate
      if (*(int *)(*m + 4) != 0) goto LAB_23046b1c;
    }
LAB_23046b66:
    uVar6 = 0xff;
  }
  else {
    if (bVar5 == 0x40) {
      prVar3 = raw_new_ip_type('\0',*(u8_t *)((int)m + 8));
      *(raw_pcb **)(pbVar1 + 4) = prVar3;
                    // WARNING: Load size is inaccurate
      prVar3 = *(raw_pcb **)((int)*m + 4);
      if (prVar3 != (raw_pcb *)0x0) {
        raw_recv(prVar3,recv_raw,*m);
        goto LAB_23046b16;
      }
      goto LAB_23046b66;
    }
    if (bVar5 == 0x10) {
      ptVar2 = tcp_new_ip_type('\0');
      *(tcp_pcb **)(pbVar1 + 4) = ptVar2;
                    // WARNING: Load size is inaccurate
      if ((*m)->pcb != 0) {
        setup_tcp(*m);
        goto LAB_23046b16;
      }
      goto LAB_23046b66;
    }
    uVar6 = 0xfa;
  }
  *(undefined *)((int)m + 4) = uVar6;
LAB_23046b1c:
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



netconn * netconn_alloc(netconn_type t,netconn_callback *callback)

{
  netconn_type nVar1;
  err_t eVar2;
  netconn *mem;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int size;
  
  mem = (netconn *)memp_malloc(MEMP_NETCONN);
  if (mem == (netconn *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (netconn *)0x0;
  }
  mem->pending_err = '\0';
  mem->type = t;
  mem->pcb = 0;
  nVar1 = t & 0xf0;
  if (nVar1 == NETCONN_UDP) {
LAB_23046ba8:
    size = 2000;
  }
  else {
    if (nVar1 != NETCONN_RAW) {
      if (nVar1 != NETCONN_TCP) goto free_and_return;
      goto LAB_23046ba8;
    }
    size = 0;
  }
  eVar2 = sys_mbox_new(&mem->recvmbox,size);
  if (CONCAT31(extraout_var,eVar2) == 0) {
    eVar2 = sys_sem_new(&mem->op_completed,'\0');
    if (CONCAT31(extraout_var_00,eVar2) == 0) {
      sys_mbox_set_invalid(&mem->acceptmbox);
      mem->state = NETCONN_NONE;
      mem->socket = -1;
      mem->callback = callback;
      mem->current_msg = (api_msg *)0x0;
      mem->send_timeout = 0;
      mem->recv_timeout = 0;
      mem->flags = '\0';
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return mem;
    }
    sys_mbox_free(&mem->recvmbox);
  }
free_and_return:
  memp_free(MEMP_NETCONN,mem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (netconn *)0x0;
}



void netconn_free(netconn *conn)

{
  sys_mbox_valid((int *)&conn->recvmbox);
  sys_mbox_valid((int *)&conn->acceptmbox);
  sys_sem_free(&conn->op_completed);
  sys_sem_set_invalid(&conn->op_completed);
  memp_free(MEMP_NETCONN,conn);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void netconn_drain(netconn *conn)

{
  netconn *conn_00;
  sys_mbox_t *ppQVar1;
  bool bVar2;
  undefined3 extraout_var;
  u32_t uVar3;
  undefined3 extraout_var_00;
  int iVar4;
  err_t eStack37;
  err_t err;
  netconn *pnStack36;
  void *mem;
  
  ppQVar1 = &conn->recvmbox;
  bVar2 = sys_mbox_valid((int *)ppQVar1);
  if (CONCAT31(extraout_var,bVar2) != 0) {
    while (uVar3 = sys_arch_mbox_tryfetch(ppQVar1,(void **)&stack0xffffffdc), uVar3 != 0xffffffff) {
      if ((conn->type & 0xf0) == NETCONN_TCP) {
        iVar4 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
        if (iVar4 == 0) {
          pbuf_free((pbuf *)pnStack36);
        }
      }
      else {
        netbuf_delete((netbuf *)pnStack36);
      }
    }
    sys_mbox_free(ppQVar1);
    sys_mbox_set_invalid(ppQVar1);
  }
  ppQVar1 = &conn->acceptmbox;
  bVar2 = sys_mbox_valid((int *)ppQVar1);
  if (CONCAT31(extraout_var_00,bVar2) != 0) {
    while (uVar3 = sys_arch_mbox_tryfetch(ppQVar1,(void **)&stack0xffffffdc), uVar3 != 0xffffffff) {
      iVar4 = lwip_netconn_is_err_msg(pnStack36,&eStack37);
      conn_00 = pnStack36;
      if (iVar4 == 0) {
        netconn_drain(pnStack36);
        if ((tcp_pcb *)conn_00->pcb != (tcp_pcb *)0x0) {
          tcp_abort((tcp_pcb *)conn_00->pcb);
          conn_00->pcb = 0;
        }
        netconn_free(conn_00);
      }
    }
    sys_mbox_free(ppQVar1);
    sys_mbox_set_invalid(ppQVar1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t accept_function(void *arg,tcp_pcb *newpcb,err_t err)

{
  tcp_pcb *pcb;
  bool bVar1;
  err_t eVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  netconn *conn;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  sys_mbox_t *mbox;
  int iVar3;
  
  if (arg != (void *)0x0) {
    mbox = (sys_mbox_t *)((int)arg + 0x14);
    bVar1 = sys_mbox_valid((int *)mbox);
    if (CONCAT31(extraout_var,bVar1) != 0) {
      if (newpcb != (tcp_pcb *)0x0) {
                    // WARNING: Load size is inaccurate
        conn = netconn_alloc(*arg,*(netconn_callback **)((int)arg + 0x2c));
        if (conn == (netconn *)0x0) {
          eVar2 = sys_mbox_trypost(mbox,"");
          iVar3 = -1;
          if (CONCAT31(extraout_var_01,eVar2) != 0) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -1;
          }
        }
        else {
          conn->pcb = newpcb;
          setup_tcp(conn);
          eVar2 = sys_mbox_trypost(mbox,conn);
          iVar3 = CONCAT31(extraout_var_02,eVar2);
          if (iVar3 != 0) {
            pcb = (tcp_pcb *)conn->pcb;
            tcp_arg(pcb,(void *)0x0);
            tcp_recv(pcb,(tcp_recv_fn *)0x0);
            tcp_sent(pcb,(tcp_sent_fn *)0x0);
            tcp_poll(pcb,(tcp_poll_fn *)0x0,'\0');
            tcp_err(pcb,(tcp_err_fn *)0x0);
            conn->pcb = 0;
            sys_mbox_free(&conn->recvmbox);
            sys_mbox_set_invalid(&conn->recvmbox);
            netconn_free(conn);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -1;
          }
        }
        if (*(code **)((int)arg + 0x2c) == (code *)0x0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return (err_t)iVar3;
        }
        (**(code **)((int)arg + 0x2c))(arg,0,0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return (err_t)iVar3;
      }
      eVar2 = sys_mbox_trypost(mbox,"");
      if ((CONCAT31(extraout_var_00,eVar2) == 0) && (*(code **)((int)arg + 0x2c) != (code *)0x0)) {
        (**(code **)((int)arg + 0x2c))(arg,0,0);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -6;
}



void lwip_netconn_do_delconn(void *m)

{
  netconn *conn;
  int iVar1;
  raw_pcb *pcb;
  byte *pbVar2;
  byte bVar3;
  
                    // WARNING: Load size is inaccurate
  conn = *m;
  if (((conn->state & ~NETCONN_LISTEN) == NETCONN_NONE) ||
     ((conn->state == NETCONN_CONNECT && ((conn->flags & 4) != 0)))) {
    *(undefined *)((int)m + 4) = 0;
    netconn_drain(conn);
                    // WARNING: Load size is inaccurate
    pbVar2 = *m;
    pcb = *(raw_pcb **)(pbVar2 + 4);
    if (pcb != (raw_pcb *)0x0) {
      bVar3 = *pbVar2 & 0xf0;
      if (bVar3 == 0x20) {
        *(undefined4 *)&pcb[1].netif_idx = 0;
                    // WARNING: Load size is inaccurate
        udp_remove(*(udp_pcb **)(*m + 4));
      }
      else {
        if (bVar3 == 0x40) {
          raw_remove(pcb);
        }
        else {
          if (bVar3 == 0x10) {
            pbVar2[1] = 4;
            *(undefined *)((int)m + 8) = 3;
                    // WARNING: Load size is inaccurate
            *(void **)(*m + 0x28) = m;
                    // WARNING: Load size is inaccurate
            lwip_netconn_do_close_internal(*m);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return;
          }
        }
      }
                    // WARNING: Load size is inaccurate
      *(undefined4 *)(*m + 4) = 0;
    }
                    // WARNING: Load size is inaccurate
    if (*(code **)(*m + 0x2c) != (code *)0x0) {
      (**(code **)(*m + 0x2c))(0,0);
    }
                    // WARNING: Load size is inaccurate
    if (*(code **)(*m + 0x2c) != (code *)0x0) {
      (**(code **)(*m + 0x2c))(2,0);
    }
  }
  else {
    *(undefined *)((int)m + 4) = 0xfb;
  }
                    // WARNING: Load size is inaccurate
  iVar1 = sys_sem_valid((sys_sem_t *)(*m + 0xc));
  if (iVar1 != 0) {
                    // WARNING: Load size is inaccurate
    sys_sem_signal((sys_mutex_t *)(*m + 0xc));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_bind(void *m)

{
  err_t eVar1;
  tcp_pcb *pcb;
  byte bVar2;
  
                    // WARNING: Load size is inaccurate
  eVar1 = -6;
  pcb = *(tcp_pcb **)(*m + 4);
  if (pcb != (tcp_pcb *)0x0) {
    bVar2 = **m & 0xf0;
    if (bVar2 == 0x20) {
      eVar1 = udp_bind((udp_pcb *)pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
    }
    else {
      if (bVar2 == 0x40) {
        eVar1 = raw_bind((raw_pcb *)pcb,*(ip_addr_t **)((int)m + 8));
      }
      else {
        if (bVar2 == 0x10) {
          eVar1 = tcp_bind(pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
        }
        else {
          eVar1 = -6;
        }
      }
    }
  }
                    // WARNING: Load size is inaccurate
  *(err_t *)((int)m + 4) = eVar1;
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_connect(void *m)

{
  err_t eVar1;
  byte bVar2;
  udp_pcb *pcb;
  uint uVar3;
  undefined3 extraout_var;
  netconn *conn;
  netconn_type nVar4;
  int iVar5;
  int iVar6;
  
                    // WARNING: Load size is inaccurate
  conn = *m;
  pcb = (udp_pcb *)conn->pcb;
  if (pcb == (udp_pcb *)0x0) {
    uVar3 = 0xfffffff1;
  }
  else {
    nVar4 = conn->type & 0xf0;
    if (nVar4 == NETCONN_UDP) {
      bVar2 = udp_connect(pcb,*(ip_addr_t **)((int)m + 8),*(u16_t *)((int)m + 0xc));
      uVar3 = (uint)bVar2;
    }
    else {
      if (nVar4 == NETCONN_RAW) {
        bVar2 = raw_connect((raw_pcb *)pcb,*(ip_addr_t **)((int)m + 8));
        uVar3 = (uint)bVar2;
      }
      else {
        uVar3 = 0xfffffffa;
        if (nVar4 == NETCONN_TCP) {
          if (conn->state == NETCONN_CONNECT) {
            uVar3 = 0xfffffff7;
          }
          else {
            uVar3 = 0xfffffff6;
            if (conn->state == NETCONN_NONE) {
              setup_tcp(conn);
                    // WARNING: Load size is inaccurate
              eVar1 = tcp_connect(*(tcp_pcb **)(*m + 4),*(ip_addr_t **)((int)m + 8),
                                  *(u16_t *)((int)m + 0xc),lwip_netconn_do_connected);
              uVar3 = CONCAT31(extraout_var,eVar1);
              if (uVar3 == 0) {
                    // WARNING: Load size is inaccurate
                iVar5 = *m;
                *(undefined *)(iVar5 + 1) = 3;
                    // WARNING: Load size is inaccurate
                iVar6 = *m;
                if ((*(byte *)(iVar5 + 0x24) & 2) == 0) {
                  *(byte *)(iVar6 + 0x24) = *(byte *)(iVar6 + 0x24) & 0xfb;
                    // WARNING: Load size is inaccurate
                  *(void **)(*m + 0x28) = m;
                  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                  return;
                }
                uVar3 = 0xfffffffb;
                *(byte *)(iVar6 + 0x24) = *(byte *)(iVar6 + 0x24) | 4;
              }
            }
          }
        }
      }
    }
  }
  *(char *)((int)m + 4) = (char)uVar3;
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_disconnect(void *m)

{
                    // WARNING: Load size is inaccurate
  if ((**m & 0xf0) == 0x20) {
    udp_disconnect(*(udp_pcb **)(*m + 4));
    *(undefined *)((int)m + 4) = 0;
  }
  else {
    *(undefined *)((int)m + 4) = 0xfa;
  }
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_listen(void *m)

{
  bool bVar1;
  tcp_pcb *ptVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  byte *pbVar3;
  err_t aeStack17 [4];
  err_t err;
  
                    // WARNING: Load size is inaccurate
  pbVar3 = *m;
  ptVar2 = *(tcp_pcb **)(pbVar3 + 4);
  if (ptVar2 != (tcp_pcb *)0x0) {
    if ((*pbVar3 & 0xf0) != 0x10) {
      aeStack17[0] = -0x10;
      goto LAB_2304709c;
    }
    if (pbVar3[1] == 0) {
      if (ptVar2->state == CLOSED) {
        ptVar2 = tcp_listen_with_backlog_and_err(ptVar2,-1,aeStack17);
        if (ptVar2 != (tcp_pcb *)0x0) {
                    // WARNING: Load size is inaccurate
          bVar1 = sys_mbox_valid((int *)(*m + 0x10));
          if (CONCAT31(extraout_var,bVar1) != 0) {
                    // WARNING: Load size is inaccurate
            sys_mbox_free((sys_mbox_t *)(*m + 0x10));
                    // WARNING: Load size is inaccurate
            sys_mbox_set_invalid((undefined4 *)(*m + 0x10));
          }
                    // WARNING: Load size is inaccurate
          aeStack17[0] = '\0';
          bVar1 = sys_mbox_valid((int *)(*m + 0x14));
          if (CONCAT31(extraout_var_00,bVar1) == 0) {
                    // WARNING: Load size is inaccurate
            aeStack17[0] = sys_mbox_new((sys_mbox_t *)(*m + 0x14),2000);
          }
          if (aeStack17[0] == '\0') {
                    // WARNING: Load size is inaccurate
            *(undefined *)(*m + 1) = 2;
                    // WARNING: Load size is inaccurate
            *(tcp_pcb **)(*m + 4) = ptVar2;
                    // WARNING: Load size is inaccurate
            tcp_arg(*(tcp_pcb **)((int)*m + 4),*m);
                    // WARNING: Load size is inaccurate
            tcp_accept(*(tcp_pcb **)(*m + 4),accept_function);
          }
          else {
            tcp_close(ptVar2);
                    // WARNING: Load size is inaccurate
            *(undefined4 *)(*m + 4) = 0;
          }
        }
      }
      else {
        aeStack17[0] = -6;
      }
      goto LAB_2304709c;
    }
    if (pbVar3[1] == 2) {
      aeStack17[0] = '\0';
      goto LAB_2304709c;
    }
  }
  aeStack17[0] = -0xb;
LAB_2304709c:
                    // WARNING: Load size is inaccurate
  *(err_t *)((int)m + 4) = aeStack17[0];
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void lwip_netconn_do_send(void *m)

{
  err_t eVar1;
  byte bVar2;
  undefined3 extraout_var;
  uint uVar3;
  pbuf *ppVar4;
  udp_pcb *pcb;
  
                    // WARNING: Load size is inaccurate
  eVar1 = netconn_err(*m);
  uVar3 = CONCAT31(extraout_var,eVar1);
  if (uVar3 == 0) {
                    // WARNING: Load size is inaccurate
    uVar3 = 0xfffffff5;
    pcb = *(udp_pcb **)(*m + 4);
    if (pcb != (udp_pcb *)0x0) {
      bVar2 = **m & 0xf0;
      if (bVar2 == 0x20) {
        ppVar4 = *(pbuf **)((int)m + 8);
        bVar2 = ppVar4->ref & 2;
        if (((ip_addr_t *)&ppVar4->tot_len == (ip_addr_t *)0x0) ||
           (*(pbuf **)&ppVar4->tot_len == (pbuf *)0x0)) {
          bVar2 = udp_send_chksum(pcb,ppVar4->next,bVar2,*(u16_t *)&ppVar4[1].next);
          uVar3 = (uint)bVar2;
        }
        else {
          bVar2 = udp_sendto_chksum(pcb,ppVar4->next,(ip_addr_t *)&ppVar4->tot_len,
                                    *(u16_t *)&ppVar4->type_internal,bVar2,*(u16_t *)&ppVar4[1].next
                                   );
          uVar3 = (uint)bVar2;
        }
      }
      else {
        if (bVar2 == 0x40) {
          ppVar4 = *(pbuf **)((int)m + 8);
          if (((ip_addr_t *)&ppVar4->tot_len == (ip_addr_t *)0x0) ||
             (*(pbuf **)&ppVar4->tot_len == (pbuf *)0x0)) {
            bVar2 = raw_send((raw_pcb *)pcb,ppVar4->next);
            uVar3 = (uint)bVar2;
          }
          else {
            bVar2 = raw_sendto((raw_pcb *)pcb,ppVar4->next,(ip_addr_t *)&ppVar4->tot_len);
            uVar3 = (uint)bVar2;
          }
        }
      }
    }
  }
  *(char *)((int)m + 4) = (char)uVar3;
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_recv(void *m)

{
  uint uVar1;
  uint uVar2;
  
                    // WARNING: Load size is inaccurate
  *(undefined *)((int)m + 4) = 0;
  if ((*(int *)(*m + 4) != 0) && ((**m & 0xf0) == 0x10)) {
    uVar1 = *(uint *)((int)m + 8);
    do {
      uVar2 = uVar1;
      if (0xffff < uVar1) {
        uVar2 = 0xffff;
      }
                    // WARNING: Load size is inaccurate
      uVar1 = uVar1 - uVar2;
      tcp_recved(*(tcp_pcb **)(*m + 4),(u16_t)uVar2);
    } while (uVar1 != 0);
  }
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_write(void *m)

{
  err_t eVar1;
  undefined3 extraout_var;
  int iVar2;
  byte *pbVar3;
  
                    // WARNING: Load size is inaccurate
  eVar1 = netconn_err(*m);
  iVar2 = CONCAT31(extraout_var,eVar1);
                    // WARNING: Load size is inaccurate
  pbVar3 = *m;
  if ((iVar2 == 0) && (iVar2 = -6, (*pbVar3 & 0xf0) == 0x10)) {
    if (pbVar3[1] == 0) {
      iVar2 = -0xb;
      if (*(int *)(pbVar3 + 4) != 0) {
        pbVar3[1] = 1;
                    // WARNING: Load size is inaccurate
        *(void **)(*m + 0x28) = m;
                    // WARNING: Load size is inaccurate
        lwip_netconn_do_writemore(*m);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    else {
      iVar2 = -5;
    }
  }
  *(char *)((int)m + 4) = (char)iVar2;
  sys_sem_signal((sys_mutex_t *)(pbVar3 + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_getaddr(void *m)

{
  byte *pbVar1;
  undefined2 *puVar2;
  byte bVar3;
  undefined2 uVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  int iVar7;
  
                    // WARNING: Load size is inaccurate
  puVar5 = *(undefined4 **)(*m + 4);
  if (puVar5 == (undefined4 *)0x0) {
LAB_23047272:
    *(undefined *)((int)m + 4) = 0xf5;
  }
  else {
    if (*(char *)((int)m + 0x10) == '\0') {
      uVar6 = puVar5[1];
    }
    else {
      uVar6 = *puVar5;
    }
    **(undefined4 **)((int)m + 8) = uVar6;
                    // WARNING: Load size is inaccurate
    pbVar1 = *m;
    *(undefined *)((int)m + 4) = 0;
    bVar3 = *pbVar1 & 0xf0;
    if (bVar3 == 0x20) {
      iVar7 = *(int *)(pbVar1 + 4);
      if (*(char *)((int)m + 0x10) == '\0') {
        if ((*(byte *)(iVar7 + 0x10) & 4) == 0) goto LAB_23047272;
        puVar2 = *(undefined2 **)((int)m + 0xc);
        uVar4 = *(undefined2 *)(iVar7 + 0x14);
      }
      else {
        puVar2 = *(undefined2 **)((int)m + 0xc);
        uVar4 = *(undefined2 *)(iVar7 + 0x12);
      }
    }
    else {
      if (bVar3 == 0x40) {
        if (*(char *)((int)m + 0x10) != '\0') {
          **(ushort **)((int)m + 0xc) = (ushort)*(byte *)(*(int *)(pbVar1 + 4) + 0x10);
          goto LAB_23047290;
        }
        goto LAB_23047272;
      }
      if (bVar3 != 0x10) goto LAB_23047290;
      iVar7 = *(int *)(pbVar1 + 4);
      if (*(char *)((int)m + 0x10) == '\0') {
        if (*(byte *)(iVar7 + 0x14) < 2) goto LAB_23047272;
        uVar4 = *(undefined2 *)(iVar7 + 0x18);
      }
      else {
        uVar4 = *(undefined2 *)(iVar7 + 0x16);
      }
      puVar2 = *(undefined2 **)((int)m + 0xc);
    }
    *puVar2 = uVar4;
  }
LAB_23047290:
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_close(void *m)

{
  netconn_state nVar1;
  netconn *conn;
  undefined uVar2;
  
                    // WARNING: Load size is inaccurate
  conn = *m;
  if ((conn->pcb != 0) && ((conn->type & 0xf0) == NETCONN_TCP)) {
    nVar1 = conn->state;
    if (((*(byte *)((int)m + 8) == 3) || (nVar1 != NETCONN_LISTEN)) && (nVar1 != NETCONN_CONNECT)) {
      if (nVar1 != NETCONN_WRITE) {
        if ((*(byte *)((int)m + 8) & 1) != 0) {
          netconn_drain(conn);
        }
                    // WARNING: Load size is inaccurate
        *(undefined *)(*m + 1) = 4;
                    // WARNING: Load size is inaccurate
        *(void **)(*m + 0x28) = m;
                    // WARNING: Load size is inaccurate
        lwip_netconn_do_close_internal(*m);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar2 = 0xfb;
      goto LAB_23047302;
    }
  }
  uVar2 = 0xf5;
LAB_23047302:
  *(undefined *)((int)m + 4) = uVar2;
  sys_sem_signal((sys_mutex_t *)&conn->op_completed);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_join_leave_group(void *m)

{
  err_t eVar1;
  
  *(undefined *)((int)m + 4) = 0xf5;
                    // WARNING: Load size is inaccurate
  if (*(int *)(*m + 4) != 0) {
    if ((**m & 0xf0) == 0x20) {
      if (*(char *)((int)m + 0x11) == '\0') {
        eVar1 = igmp_joingroup(*(ip4_addr_t **)((int)m + 0xc),*(ip4_addr_t **)((int)m + 8));
      }
      else {
        eVar1 = igmp_leavegroup(*(ip4_addr_t **)((int)m + 0xc),*(ip4_addr_t **)((int)m + 8));
      }
      *(err_t *)((int)m + 4) = eVar1;
    }
    else {
      *(undefined *)((int)m + 4) = 0xfa;
    }
  }
                    // WARNING: Load size is inaccurate
  sys_sem_signal((sys_mutex_t *)(*m + 0xc));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void lwip_netconn_do_gethostbyname(void *arg)

{
  err_t *peVar1;
  err_t eVar2;
  
  peVar1 = *(err_t **)((int)arg + 0xc);
                    // WARNING: Load size is inaccurate
  eVar2 = dns_gethostbyname_addrtype
                    (*arg,*(ip_addr_t **)((int)arg + 4),lwip_netconn_do_dns_found,arg,'\0');
  *peVar1 = eVar2;
  if (**(char **)((int)arg + 0xc) != -5) {
    sys_sem_signal((sys_mutex_t *)*(sys_mutex_t *)((int)arg + 8));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int err_to_errno(err_t err)

{
  undefined3 in_register_00002029;
  
  if ((CONCAT31(in_register_00002029,err) + 0x10U & 0xff) < 0x11) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return err_to_errno_table[-CONCAT31(in_register_00002029,err)];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 5;
}



void netbuf_delete(netbuf *buf)

{
  if (buf == (netbuf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  if (buf->p != (pbuf *)0x0) {
    pbuf_free(buf->p);
    buf->ptr = (pbuf *)0x0;
    buf->p = (pbuf *)0x0;
  }
  memp_free(MEMP_NETBUF,buf);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * netbuf_alloc(netbuf *buf,u16_t size)

{
  pbuf *ppVar1;
  void *pvVar2;
  
  if (buf == (netbuf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (void *)0x0;
  }
  if (buf->p != (pbuf *)0x0) {
    pbuf_free(buf->p);
  }
  ppVar1 = pbuf_alloc(PBUF_TRANSPORT,size,PBUF_RAM);
  buf->p = ppVar1;
  if (ppVar1 == (pbuf *)0x0) {
    pvVar2 = (void *)0x0;
  }
  else {
    buf->ptr = ppVar1;
    pvVar2 = ppVar1->payload;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar2;
}



void netbuf_free(netbuf *buf)

{
  if (buf != (netbuf *)0x0) {
    if (buf->p != (pbuf *)0x0) {
      pbuf_free(buf->p);
    }
    buf->ptr = (pbuf *)0x0;
    buf->p = (pbuf *)0x0;
    buf->flags = '\0';
    buf->toport_chksum = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void icmp_input(pbuf *p,netif *inp)

{
  ip_hdr *__src;
  u32_t uVar1;
  uint uVar2;
  uint __n;
  void *dataptr;
  u8_t uVar3;
  err_t eVar4;
  u16_t uVar5;
  undefined3 extraout_var;
  undefined2 extraout_var_05;
  undefined3 extraout_var_00;
  pbuf *p_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  uint uVar6;
  short sVar7;
  undefined *puVar8;
  
  __src = ip_data.current_ip4_header;
  lwip_stats.icmp.recv = lwip_stats.icmp.recv + 1;
  uVar2 = (ip_data.current_ip4_header)->_v_hl & 0xf;
  __n = uVar2 * 4;
  if ((__n < 0x14) || (p->len < 4)) {
lenerr:
    pbuf_free(p);
    lwip_stats.icmp.lenerr = lwip_stats.icmp.lenerr + 1;
  }
  else {
                    // WARNING: Load size is inaccurate
    if (*p->payload == '\0') goto LAB_2304767c;
    if (*p->payload != '\b') {
      lwip_stats.icmp.proterr = lwip_stats.icmp.proterr + 1;
      lwip_stats.icmp.drop = lwip_stats.icmp.drop + 1;
      goto LAB_2304767c;
    }
    if (((ip_data.current_iphdr_dest & 0xf0) != 0xe0) &&
       (uVar3 = ip4_addr_isbroadcast_u32(ip_data.current_iphdr_dest,ip_data.current_netif),
       CONCAT31(extraout_var,uVar3) == 0)) {
      if (p->tot_len < 8) goto lenerr;
      uVar5 = inet_chksum_pbuf(p);
      if (CONCAT22(extraout_var_05,uVar5) != 0) {
        pbuf_free(p);
        lwip_stats.icmp.chkerr = lwip_stats.icmp.chkerr + 1;
        goto LAB_23047526;
      }
      uVar2 = uVar2 << 0x12;
      uVar3 = pbuf_add_header(p,__n + 0x8e);
      if (CONCAT31(extraout_var_00,uVar3) == 0) {
        uVar3 = pbuf_remove_header(p,__n + 0x8e);
        if (CONCAT31(extraout_var_04,uVar3) == 0) {
LAB_230475c4:
          puVar8 = (undefined *)p->payload;
          uVar3 = pbuf_add_header(p,__n);
          uVar1 = ip_data.current_iphdr_dest;
          if (CONCAT31(extraout_var_03,uVar3) == 0) {
            dataptr = p->payload;
            *(char *)((int)dataptr + 0xc) = (char)ip_data.current_iphdr_dest;
            *(char *)((int)dataptr + 0xd) = (char)(uVar1 >> 8);
            *(char *)((int)dataptr + 0xe) = (char)(uVar1 >> 0x10);
            *(char *)((int)dataptr + 0xf) = (char)(uVar1 >> 0x18);
            uVar1 = ip_data.current_iphdr_src;
            *(char *)((int)dataptr + 0x10) = (char)ip_data.current_iphdr_src;
            *(char *)((int)dataptr + 0x11) = (char)(uVar1 >> 8);
            *(char *)((int)dataptr + 0x12) = (char)(uVar1 >> 0x10);
            *(char *)((int)dataptr + 0x13) = (char)(uVar1 >> 0x18);
            *puVar8 = 0;
            if (*(ushort *)(puVar8 + 2) < 0xfff8) {
              sVar7 = 8;
            }
            else {
              sVar7 = 9;
            }
            sVar7 = *(ushort *)(puVar8 + 2) + sVar7;
            puVar8[2] = (char)sVar7;
            puVar8[3] = (char)((ushort)sVar7 >> 8);
            *(undefined *)((int)dataptr + 8) = 0xff;
            *(undefined *)((int)dataptr + 10) = 0;
            *(undefined *)((int)dataptr + 0xb) = 0;
            uVar5 = inet_chksum(dataptr,(u16_t)(uVar2 >> 0x10));
            *(char *)((int)dataptr + 10) = (char)uVar5;
            *(char *)((int)dataptr + 0xb) = (char)(uVar5 >> 8);
            lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
            ip4_output_if(p,(ip4_addr_t *)&ip_data.current_iphdr_dest,(ip4_addr_t *)0x0,-1,'\0',
                          '\x01',inp);
          }
LAB_2304767c:
          pbuf_free(p);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
      }
      else {
        uVar6 = (uint)p->tot_len + (uVar2 >> 0x10);
        if (((uint)p->tot_len <= (uVar6 & 0xffff)) &&
           (p_00 = pbuf_alloc(PBUF_LINK,(u16_t)(uVar6 * 0x10000 >> 0x10),PBUF_RAM),
           p_00 != (pbuf *)0x0)) {
          if (__n + 8 <= (uint)p_00->len) {
            memcpy(p_00->payload,__src,__n);
            uVar3 = pbuf_remove_header(p_00,__n);
            if ((CONCAT31(extraout_var_01,uVar3) == 0) &&
               (eVar4 = pbuf_copy(p_00,p), CONCAT31(extraout_var_02,eVar4) == 0)) {
              pbuf_free(p);
              p = p_00;
              goto LAB_230475c4;
            }
          }
          pbuf_free(p_00);
        }
      }
    }
    pbuf_free(p);
    lwip_stats.icmp.err = lwip_stats.icmp.err + 1;
  }
LAB_23047526:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Type propagation algorithm not settling

void icmp_dest_unreach(pbuf *p,icmp_dur_type t)

{
  undefined *dataptr;
  u16_t uVar1;
  pbuf *p_00;
  netif *netif;
  void *pvVar2;
  ip4_addr_t iStack36;
  ip4_addr_t iphdr_src;
  
  p_00 = pbuf_alloc(PBUF_IP,0x24,PBUF_RAM);
  if (p_00 != (pbuf *)0x0) {
    dataptr = (undefined *)p_00->payload;
    pvVar2 = p->payload;
    *dataptr = 3;
    dataptr[1] = t;
    dataptr[4] = 0;
    dataptr[5] = 0;
    dataptr[6] = 0;
    dataptr[7] = 0;
    memcpy((void *)((int)p_00->payload + 8),p->payload,0x1c);
    iStack36 = ((ip4_addr_t *)((int)pvVar2 + 0xc))->addr;
    netif = ip4_route(&iStack36);
    if (netif != (netif *)0x0) {
      dataptr[2] = 0;
      dataptr[3] = 0;
      uVar1 = inet_chksum(dataptr,p_00->len);
      dataptr[2] = (char)uVar1;
      dataptr[3] = (char)(uVar1 >> 8);
      lwip_stats.icmp.xmit = lwip_stats.icmp.xmit + 1;
      ip4_output_if(p_00,(ip4_addr_t *)0x0,&iStack36,-1,'\0','\x01',netif);
    }
    pbuf_free(p_00);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



u8_t * dhcp_server_option_find(u8_t *buf,u16_t len,u8_t option)

{
  undefined2 in_register_0000202e;
  byte *pbVar1;
  undefined3 in_register_00002031;
  
  pbVar1 = buf + CONCAT22(in_register_0000202e,len);
  while ((buf < pbVar1 && (*buf != 0xff))) {
    if ((uint)*buf == CONCAT31(in_register_00002031,option)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return buf;
    }
    buf = buf + buf[1] + 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (byte *)0x0;
}



// WARNING: Type propagation algorithm not settling

dhcp_client_node * dhcp_client_find_by_ip(uint8_t *ip)

{
  dhcp_client_node *pdVar1;
  void *in_a1;
  ip4_addr_t iStack20;
  uint32_t ipval;
  
  memcpy(&iStack20,in_a1,4);
  pdVar1 = *(dhcp_client_node **)ip;
  while ((pdVar1 != (dhcp_client_node *)0x0 && (iStack20 != (pdVar1->ipaddr).addr))) {
    pdVar1 = pdVar1->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pdVar1;
}



// WARNING: Type propagation algorithm not settling

void dhcp_server_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *recv_addr,u16_t port)

{
  u8_t uVar1;
  char *pcVar2;
  pbuf *p_to;
  u8_t *puVar3;
  u32_t uVar4;
  u32_t uVar5;
  int iVar6;
  u16_t uVar7;
  undefined4 *puVar8;
  dhcp_client_node *pdVar9;
  undefined4 *rmem;
  undefined4 *puVar10;
  u8_t *buf;
  uint __n;
  ip_addr_t iStack56;
  ip_addr_t addr;
  u32_t tmp;
  
  iStack56 = recv_addr->addr;
  if (((p->len < 0x2c) || (p_to = pbuf_alloc(PBUF_TRANSPORT,0x5dc,PBUF_RAM), p_to == (pbuf *)0x0))
     || (p_to->tot_len < p->tot_len)) goto LAB_2304781c;
  pbuf_copy(p_to,p);
  pbuf_free(p);
  pcVar2 = (char *)p_to->payload;
  p = p_to;
  if (((*pcVar2 != '\x01') || (*(int *)(pcVar2 + 0xec) != 0x63538263)) ||
     (__n = (uint)(byte)pcVar2[2], 6 < __n)) goto LAB_2304781c;
  buf = (u8_t *)(pcVar2 + 0xf0);
  uVar7 = p_to->tot_len - 0xf0;
  puVar3 = dhcp_server_option_find(buf,uVar7,'5');
  if (puVar3 == (u8_t *)0x0) goto LAB_2304781c;
  uVar1 = puVar3[2];
  if (uVar1 == '\x01') {
    pdVar9 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar9 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar9->chaddr,pcVar2 + 0x1c,__n);
      if (iVar6 == 0) goto LAB_23047970;
      pdVar9 = pdVar9->next;
    }
    puVar3 = dhcp_server_option_find(buf,uVar7,'2');
    if ((puVar3 == (u8_t *)0x0) ||
       (pdVar9 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar9 == (dhcp_client_node *)0x0)) {
      while (pdVar9 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
            pdVar9 != (dhcp_client_node *)0x0) {
        uVar4 = lwip_htonl(*(u32_t *)((int)arg + 0x18));
        uVar4 = uVar4 + 1;
        uVar5 = lwip_htonl(*(u32_t *)((int)arg + 0x14));
        if (uVar5 < uVar4) {
          uVar4 = lwip_htonl(*(u32_t *)((int)arg + 0x10));
        }
        uVar5 = lwip_htonl(uVar4);
        *(u32_t *)((int)arg + 0x18) = uVar5;
      }
      pdVar9 = (dhcp_client_node *)mem_malloc(0x14);
      if (pdVar9 == (dhcp_client_node *)0x0) goto LAB_2304781c;
      memcpy(pdVar9->chaddr,pcVar2 + 0x1c,(uint)(byte)pcVar2[2]);
      (pdVar9->ipaddr).addr = *(u32_t *)((int)arg + 0x18);
      pdVar9->next = *(dhcp_client_node **)((int)arg + 0xc);
      *(dhcp_client_node **)((int)arg + 0xc) = pdVar9;
    }
LAB_23047970:
    pdVar9->lease_end = 0x80510100;
    *pcVar2 = '\x02';
    pcVar2[3] = '\0';
    pcVar2[8] = '\0';
    pcVar2[9] = '\0';
    memcpy(pcVar2 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0xed] = -0x7e;
    pcVar2[0xec] = 'c';
    pcVar2[0xef] = 'c';
    pcVar2[0x2c] = '\0';
    pcVar2[0x6c] = '\0';
    pcVar2[0xee] = 'S';
    memcpy(pcVar2 + 0x10,&pdVar9->ipaddr,4);
    pcVar2[0xf0] = '5';
    pcVar2[0xf1] = '\x01';
    pcVar2[0xf2] = '\x02';
LAB_230479e0:
    pcVar2[0xf3] = '6';
    pcVar2[0xf4] = '\x04';
    memcpy(pcVar2 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0xf9] = '3';
    pcVar2[0xfa] = '\x04';
    addr = 0x15180;
    memcpy(pcVar2 + 0xfb,&addr,4);
    pcVar2[0xff] = '\x01';
    pcVar2[0x100] = '\x04';
    memcpy(pcVar2 + 0x101,(void *)(*(int *)((int)arg + 4) + 8),4);
    pcVar2[0x105] = '\x06';
    pcVar2[0x106] = '\x04';
    memcpy(pcVar2 + 0x107,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0x10b] = '\x03';
    pcVar2[0x10c] = '\x04';
    memcpy(pcVar2 + 0x10d,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0x111] = -1;
    if (0x112 < p_to->tot_len) {
      uVar7 = 0x112;
LAB_23047a78:
      pbuf_realloc(p_to,uVar7);
    }
  }
  else {
    if (uVar1 != '\x03') {
      if (uVar1 == '\a') {
        puVar8 = *(undefined4 **)((int)arg + 0xc);
        puVar10 = (undefined4 *)0x0;
        while (rmem = puVar8, rmem != (undefined4 *)0x0) {
          iVar6 = memcmp(rmem + 1,pcVar2 + 0x1c,(uint)(byte)pcVar2[2]);
          puVar8 = (undefined4 *)*rmem;
          if (iVar6 == 0) {
            if (*(undefined4 **)((int)arg + 0xc) == rmem) {
              *(undefined4 **)((int)arg + 0xc) = puVar8;
            }
            else {
              *puVar10 = puVar8;
            }
            mem_free(rmem);
            break;
          }
          puVar8 = (undefined4 *)*puVar8;
          puVar10 = rmem;
        }
      }
      goto LAB_2304781c;
    }
    pdVar9 = *(dhcp_client_node **)((int)arg + 0xc);
    while (pdVar9 != (dhcp_client_node *)0x0) {
      iVar6 = memcmp(pdVar9->chaddr,pcVar2 + 0x1c,__n);
      if (iVar6 == 0) goto LAB_23047bd2;
      pdVar9 = pdVar9->next;
    }
    puVar3 = dhcp_server_option_find(buf,uVar7,'2');
    if ((puVar3 != (u8_t *)0x0) &&
       (pdVar9 = dhcp_client_find_by_ip((uint8_t *)((int)arg + 0xc)),
       pdVar9 != (dhcp_client_node *)0x0)) {
      iVar6 = memcmp(pdVar9->chaddr,pcVar2 + 0x1c,(uint)(byte)pcVar2[2]);
      if (iVar6 == 0) {
LAB_23047bd2:
        pdVar9->lease_end = 0x80510100;
        *pcVar2 = '\x02';
        pcVar2[3] = '\0';
        pcVar2[8] = '\0';
        pcVar2[9] = '\0';
        memcpy(pcVar2 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
        pcVar2[0xed] = -0x7e;
        pcVar2[0xec] = 'c';
        pcVar2[0xef] = 'c';
        pcVar2[0x2c] = '\0';
        pcVar2[0x6c] = '\0';
        pcVar2[0xee] = 'S';
        memcpy(pcVar2 + 0x10,&pdVar9->ipaddr,4);
        pcVar2[0xf0] = '5';
        pcVar2[0xf1] = '\x01';
        pcVar2[0xf2] = '\x05';
        goto LAB_230479e0;
      }
      puts("IP Found, but MAC address is NOT the same\r\n");
    }
    *pcVar2 = '\x02';
    pcVar2[3] = '\0';
    pcVar2[8] = '\0';
    pcVar2[9] = '\0';
    memcpy(pcVar2 + 0x14,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0xed] = -0x7e;
    pcVar2[0xee] = 'S';
    pcVar2[0xec] = 'c';
    pcVar2[0xef] = 'c';
    pcVar2[0x2c] = '\0';
    pcVar2[0x6c] = '\0';
    memset(pcVar2 + 0x10,0,4);
    pcVar2[0xf0] = '5';
    pcVar2[0xf1] = '\x01';
    pcVar2[0xf2] = '\x06';
    pcVar2[0xf3] = '6';
    pcVar2[0xf4] = '\x04';
    memcpy(pcVar2 + 0xf5,(void *)(*(int *)((int)arg + 4) + 4),4);
    pcVar2[0xf9] = -1;
    if (0xfa < p_to->tot_len) {
      uVar7 = 0xfa;
      goto LAB_23047a78;
    }
  }
  iStack56 = 0xffffffff;
  udp_sendto_if(pcb,p_to,&iStack56,port,*(netif **)((int)arg + 4));
LAB_2304781c:
  pbuf_free(p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



err_t dhcp_server_start(netif *netif,ip4_addr_t *start,ip4_addr_t *end)

{
  dhcp_server *pdVar1;
  udp_pcb *puVar2;
  
  pdVar1 = lw_dhcp_server;
  while (pdVar1 != (dhcp_server *)0x0) {
    if (pdVar1->netif == netif) {
      (pdVar1->start).addr = start->addr;
      (pdVar1->end).addr = end->addr;
      (pdVar1->current).addr = start->addr;
      goto LAB_23047c96;
    }
    pdVar1 = pdVar1->next;
  }
  pdVar1 = (dhcp_server *)mem_malloc(0x1c);
  if (pdVar1 != (dhcp_server *)0x0) {
    memset(pdVar1,0,0x1c);
    pdVar1->netif = netif;
    pdVar1->node_list = (dhcp_client_node *)0x0;
    pdVar1->next = lw_dhcp_server;
    lw_dhcp_server = pdVar1;
    (pdVar1->start).addr = start->addr;
    (pdVar1->end).addr = end->addr;
    (pdVar1->current).addr = start->addr;
    puVar2 = udp_new();
    pdVar1->pcb = puVar2;
    if (puVar2 != (udp_pcb *)0x0) {
      puVar2->so_options = puVar2->so_options | 0x20;
      udp_bind(pdVar1->pcb,&ip_addr_any,0x43);
      udp_recv(pdVar1->pcb,dhcp_server_recv,pdVar1);
LAB_23047c96:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



err_t dhcp_server_stop(netif *netif)

{
  dhcp_server *rmem;
  
  rmem = lw_dhcp_server;
  while( true ) {
    if (rmem == (dhcp_server *)0x0) {
      printf("[DHCP] [DHCPD] CRITICAL: no dhcp_server instance found\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -6;
    }
    if (rmem->netif == netif) break;
    rmem = rmem->next;
  }
  if (rmem->pcb != (udp_pcb *)0x0) {
    udp_remove(rmem->pcb);
  }
  lw_dhcp_server = (dhcp_server *)0x0;
  mem_free(rmem);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void dhcpd_start(netif *netif)

{
  err_t eVar1;
  char *pcVar2;
  undefined3 extraout_var;
  ip4_addr_t iStack60;
  ip4_addr_t ip_start;
  ip4_addr_t ip_end;
  char str_tmp [20];
  ip4_addr_t *piVar3;
  
  dhcp_stop(netif);
  set_if(netif,"192.168.169.1","0.0.0.0","255.255.255.0");
  netif_set_up(netif);
  memcpy(&ip_end,"192.168.169.1",0xe);
  pcVar2 = strchr((char *)&ip_end,0x2e);
  if (((pcVar2 == (char *)0x0) || (pcVar2 = strchr(pcVar2 + 1,0x2e), pcVar2 == (char *)0x0)) ||
     (pcVar2 = strchr(pcVar2 + 1,0x2e), pcVar2 == (char *)0x0)) {
    piVar3 = &ip_end;
    pcVar2 = "[DHCP] DHCPD_SERVER_IP: %s error!\r\n";
  }
  else {
    sprintf(pcVar2 + 1,"%d",2);
    ip4addr_aton((char *)&ip_end,&iStack60);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    sprintf(pcVar2 + 1,"%d",0xfe);
    ip4addr_aton((char *)&ip_end,&ip_start);
    printf("[DHCP] ip_start: [%s]\r\n",&ip_end);
    eVar1 = dhcp_server_start(netif,&iStack60,&ip_start);
    piVar3 = (ip4_addr_t *)CONCAT31(extraout_var,eVar1);
    if (piVar3 == (ip4_addr_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    pcVar2 = "[DHCP] dhcp_server_start res: %d.\r\n";
  }
  printf(pcVar2,piVar3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void tcpc_entry(void *arg)

{
  int iVar1;
  char *buffer;
  int s;
  int iVar2;
  ssize_t sVar3;
  char *fmt;
  undefined4 uStack68;
  int flag;
  sockaddr_in addr;
  
  iVar1 = tcpc_entry::counter_shared;
  tcpc_entry::counter_shared = tcpc_entry::counter_shared + 1;
  printf("[TCPC] [THREAD] [%d] host is %s, counter is %d\r\n",iVar1,arg,iVar1);
  buffer = (char *)pvPortMalloc(0x400);
  if (buffer == (char *)0x0) {
    printf("[TCPC] [THREAD] [%d] [%d] NO mem for holding data\r\n",iVar1,tcpc_entry::counter_shared)
    ;
  }
  else {
    s = lwip_socket(2,1,6);
    if (s < 0) {
      printf("[TCPC] [THREAD] [%d] [%d] create socket failed, ret is sock %d!\r\n",iVar1,
             tcpc_entry::counter_shared,s);
    }
    else {
      flag._1_1_ = '\x02';
      flag._2_2_ = lwip_htons(7000);
      addr._0_4_ = ipaddr_addr((char *)arg);
      iVar2 = lwip_connect(s,(sockaddr *)&flag,0x10);
      if (iVar2 < 0) {
        printf("[TCPC] [THREAD] [%d] [%d] Connect failed!\n",iVar1,tcpc_entry::counter_shared);
      }
      else {
        printf("[TCPC] [THREAD] [%d] [%d] Connect to iperf server successful!\n",iVar1,
               tcpc_entry::counter_shared);
        uStack68 = 1;
        lwip_setsockopt(s,6,1,&uStack68,4);
        memset(buffer,0,0x400);
        iVar2 = 0;
        while( true ) {
          snprintf(buffer,0x400,"Data Seq %d",iVar2);
          sVar3 = lwip_write(s,buffer,0x400);
          if (sVar3 < 0) break;
          printf("[TCPC] [THREAD] [%d] [%d] send success with ret %d, %s\r\n",iVar1,
                 tcpc_entry::counter_shared,sVar3,buffer);
          sVar3 = lwip_read(s,buffer,0x400);
          if (sVar3 < 0) {
            fmt = "[TCPC] [THREAD] [%d] [%d] recv failed with ret %d\r\n";
            goto LAB_23047f9a;
          }
          printf("[TCPC] [THREAD] [%d] [%d] recv success with ret %d, %s\r\n",iVar1,
                 tcpc_entry::counter_shared,sVar3,buffer);
          vTaskDelay(1000);
          iVar2 = iVar2 + 1;
        }
        fmt = "[TCPC] [THREAD] [%d] [%d] send failed with ret %d\r\n";
LAB_23047f9a:
        printf(fmt,iVar1,tcpc_entry::counter_shared,sVar3);
      }
      lwip_close(s);
    }
    vPortFree(buffer);
  }
  vPortFree(arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void tcpclient_cmd(char *buf,int len,int argc,char **argv)

{
  size_t sVar1;
  char *__dest;
  char acStack48 [4];
  char names [32];
  
  if (argc == 2) {
    sVar1 = strlen(argv[1]);
    __dest = (char *)pvPortMalloc(sVar1 + 4);
    if (__dest == (char *)0x0) {
      printf("[TCPC] run out of mem for host alloc\r\n");
    }
    strcpy(__dest,argv[1]);
    counter_4093 = counter_4093 + '\x01';
    snprintf(acStack48,0x20,"tcp%u");
    aos_task_new(acStack48,tcpc_entry,__dest,0x800);
  }
  else {
    printf("[TCPC] host IP address is required. Ex. 192.168.1.1\r\n");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int network_netutils_tcpclinet_cli_register(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void TCP_Server(void *pvParameters)

{
  uint *puVar1;
  u16_t uVar2;
  void *__s;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  TickType_t TVar6;
  int iVar7;
  size_t size;
  ssize_t sVar8;
  undefined2 extraout_var;
  TickType_t *pTVar9;
  int *piVar10;
  uint uVar11;
  int iVar12;
  uint uVar13;
  uint s;
  uint *puVar14;
  socklen_t sStack208;
  uint32_t client_addrlen;
  int yes;
  _types_fd_set fdsr;
  timeval tv;
  sockaddr_in server_addr;
  sockaddr_in client_addr;
  int connect_time [5];
  int time_diff [5];
  int time_last [5];
  int client_fd [5];
  
  client_addrlen = 1;
  __s = pvPortMalloc(0x2800);
  memset(__s,0,0x2800);
  memset(time_last + 4,0,0x14);
  memset(connect_time + 4,0,0x14);
  memset(time_diff + 4,0,0x14);
  memset(client_addr.sin_zero + 4,0,0x14);
  uVar3 = lwip_socket(2,1,6);
  s = uVar3 >> 0x1f;
  if ((int)uVar3 < 0) {
    printf("socket creat failed\r\n");
    vPortFree(__s);
    vTaskDelete((TaskHandle_t)0x0);
  }
  else {
    printf("socket:%d\r\n",0);
  }
  iVar4 = lwip_setsockopt(s,0xfff,4,&client_addrlen,4);
  if (iVar4 == -1) {
    pcVar5 = "setsockopt failed\r\n";
  }
  else {
    tv._13_1_ = 2;
    tv._14_2_ = lwip_htons(0x141e);
    server_addr._0_4_ = lwip_htonl(0);
    iVar4 = lwip_bind(s,(sockaddr *)&tv.field_0xc,0x10);
    if (iVar4 < 0) {
      pcVar5 = "bind failed\r\n";
    }
    else {
      iVar4 = lwip_listen(s,5);
      if (iVar4 < 0) {
        pcVar5 = "listen failed\r\n";
      }
      else {
        printf("We are waiting a connection on port 5150.\r\n");
        printf(&DAT_2308690c);
        sStack208 = 0x10;
        TVar6 = xTaskGetTickCount();
        iVar4 = 0;
        do {
          *(TickType_t *)((int)time_diff + iVar4 + 0x10) = TVar6;
          iVar7 = atoi((char *)pvParameters);
          *(int *)(client_addr.sin_zero + iVar4 + 4) = iVar7;
          iVar4 = iVar4 + 4;
        } while (iVar4 != 0x14);
        iVar4 = 0;
        uVar3 = s;
LAB_23048202:
        iVar7 = 0;
        do {
          *(undefined *)((int)&yes + iVar7) = 0;
          iVar7 = iVar7 + 1;
        } while (iVar7 != 8);
        fdsr.fds_bits[1] = 1;
        tv.tv_sec._0_4_ = 0;
        yes = yes | 1 << s;
        tv.tv_sec._4_4_ = 0;
        iVar7 = 0;
        do {
          puVar1 = (uint *)((int)time_last + iVar7 + 0x10);
          uVar11 = *puVar1;
          if (uVar11 != 0) {
            (&yes)[uVar11 >> 5] = 1 << (uVar11 & 0x1f) | (&yes)[uVar11 >> 5];
            TVar6 = xTaskGetTickCount();
            pTVar9 = (TickType_t *)((int)time_diff + iVar7 + 0x10);
            uVar11 = TVar6 - *pTVar9;
            *(uint *)((int)connect_time + iVar7 + 0x10) = uVar11;
            if (999 < uVar11) {
              *pTVar9 = TVar6;
              piVar10 = (int *)(client_addr.sin_zero + iVar7 + 4);
              iVar12 = *piVar10;
              *piVar10 = iVar12 + -1;
              if (iVar12 + -1 < 1) {
                iVar4 = iVar4 + -1;
                lwip_close(*puVar1);
                iVar12 = atoi((char *)pvParameters);
                uVar13 = *puVar1;
                *puVar1 = 0;
                *piVar10 = iVar12;
                uVar11 = uVar13 >> 5;
                (&yes)[uVar11] = ~(1 << (uVar13 & 0x1f)) & (&yes)[uVar11];
                printf("disconnect becase time out\r\n");
              }
            }
          }
          iVar7 = iVar7 + 4;
        } while (iVar7 != 0x14);
        iVar7 = lwip_select(uVar3 + 1,(_types_fd_set *)&yes,(_types_fd_set *)0x0,
                            (_types_fd_set *)0x0,(timeval *)(fdsr.fds_bits + 1));
        if (-1 < iVar7) {
          if (iVar7 != 0) {
            puVar14 = (uint *)(time_last + 4);
            iVar7 = 0;
            puVar1 = puVar14;
            do {
              uVar11 = *puVar1;
              if ((uVar11 != s) && ((1 << (uVar11 & 0x1f) & (&yes)[uVar11 >> 5]) != 0)) {
                TVar6 = xTaskGetTickCount();
                memset(__s,0,0x2800);
                size = lwip_recv(*puVar1,__s,0x2800,0);
                if ((int)size < 1) {
                  printf("recv failed:%d\r\n",size);
                  lwip_close(*puVar1);
                  iVar12 = atoi((char *)pvParameters);
                  *(int *)(client_addr.sin_zero + iVar7 * 4 + 4) = iVar12;
                  uVar11 = *puVar1 >> 5;
                  (&yes)[uVar11] = ~(1 << (*puVar1 & 0x1f)) & (&yes)[uVar11];
                }
                else {
                  iVar12 = atoi((char *)pvParameters);
                  *(int *)(client_addr.sin_zero + iVar7 * 4 + 4) = iVar12;
                  time_diff[iVar7 + 4] = TVar6;
                  printf("We successfully received %d bytes from %d client\r\n",size,iVar7);
                  printf("%s\r\n",__s);
                  sVar8 = lwip_send(*puVar1,__s,size,0);
                  if (0 < sVar8) {
                    printf("We successfully send %d bytes to %d client\r\n",sVar8,iVar7);
                    printf("\r\n");
                    goto LAB_2304837e;
                  }
                  printf("send failed\r\n",sVar8);
                  lwip_close(*puVar1);
                  iVar12 = atoi((char *)pvParameters);
                  uVar11 = *puVar1;
                  *(int *)(client_addr.sin_zero + iVar7 * 4 + 4) = iVar12;
                  uVar13 = uVar11 >> 5;
                  (&yes)[uVar13] = ~(1 << (uVar11 & 0x1f)) & (&yes)[uVar13];
                }
                *puVar1 = 0;
                iVar4 = iVar4 + -1;
              }
LAB_2304837e:
              iVar7 = iVar7 + 1;
              puVar1 = puVar1 + 1;
            } while (iVar7 != 5);
            if ((yes & 1 << s) != 0) {
              uVar11 = lwip_accept(s,(sockaddr *)(server_addr.sin_zero + 4),&sStack208);
              if ((int)uVar11 < 1) {
                printf("accept failed\r\n");
              }
              else {
                printf("new_sock:%d\r\n",uVar11);
                pcVar5 = ip4addr_ntoa((ip4_addr_t *)&client_addr);
                uVar2 = lwip_htons(server_addr.sin_zero._6_2_);
                printf("We successfully got a connection from %s:%d\r\n",pcVar5,
                       CONCAT22(extraout_var,uVar2));
                printf("We are waiting to receive data\r\n");
                if (iVar4 < 5) {
                  iVar7 = 0;
                  do {
                    if (*puVar14 == 0) {
                      TVar6 = xTaskGetTickCount();
                      time_diff[iVar7 + 4] = TVar6;
                      iVar12 = atoi((char *)pvParameters);
                      *(int *)(client_addr.sin_zero + iVar7 * 4 + 4) = iVar12;
                      time_last[iVar7 + 4] = uVar11;
                      if ((int)uVar3 < (int)uVar11) {
                        uVar3 = uVar11;
                      }
                      iVar4 = iVar4 + 1;
                      printf("amount:%d\r\n",iVar4);
                      break;
                    }
                    iVar7 = iVar7 + 1;
                    puVar14 = puVar14 + 1;
                  } while (iVar7 != 5);
                }
                else {
                  printf("Max connections arrived!\r\n");
                  lwip_send(uVar11,&DAT_23086a6c,4,0);
                  lwip_close(uVar11);
                }
              }
            }
          }
          goto LAB_23048202;
        }
        pcVar5 = "select failed\r\n";
      }
    }
  }
  printf(pcVar5);
  vPortFree(__s);
  lwip_close(s);
  vTaskDelete((TaskHandle_t)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_tcp_server(char *buf,int len,int argc,char **argv)

{
  if (argc != 2) {
    printf("Please Input Parameter!\r\n");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  xTaskCreate(TCP_Server,"TCP Server",0x400,argv[1],0x14,(TaskHandle_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int network_netutils_tcpserver_cli_register(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void iperf_server_udp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 1);
  strcpy(__dest,name);
  aos_task_new("ipus",iperf_server_udp,__dest,0x1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void iperf_client_udp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ipu",iperf_client_udp,__dest,0x1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void iperf_server_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ips",iperf_server,__dest,0x1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void iperf_client_tcp_entry(char *name)

{
  size_t sVar1;
  char *__dest;
  
  sVar1 = strlen(name);
  __dest = (char *)pvPortMalloc(sVar1 + 4);
  strcpy(__dest,name);
  aos_task_new("ipc",iperf_client_tcp,__dest,0x1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void iperf_server_udp(void *arg)

{
  err_t eVar1;
  udp_pcb *pcb;
  undefined3 extraout_var;
  char *fmt;
  ip_addr_t iStack84;
  ip_addr_t source_ip;
  iperf_server_udp_ctx context;
  
  if (arg == (void *)0x0) {
    vAssertCalled();
  }
  pcb = udp_new();
  if (pcb == (udp_pcb *)0x0) {
    printf("Create UDP Control block failed!\r\n");
  }
  else {
    iStack84 = ipaddr_addr((char *)arg);
    eVar1 = udp_bind(pcb,&iStack84,0x1389);
    if (CONCAT31(extraout_var,eVar1) == 0) {
      printf("bind UDP socket successfully!\r\n");
      memset(&source_ip,0,0x40);
      udp_recv(pcb,iperf_server_udp_recv_fn,&source_ip);
      while ((ip_addr_t)source_ip == (ip_addr_t)0x0) {
        vTaskDelay(1000);
      }
      fmt = "ipus exit..\r\n";
    }
    else {
      fmt = "Bind failed!\r\n";
    }
    printf(fmt);
    udp_remove(pcb);
  }
  vPortFree(arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void iperf_server_udp_recv_fn(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  float fVar1;
  uint uVar2;
  uint32_t uVar3;
  uint uVar4;
  SFtype a;
  SFtype a_00;
  SFtype a_01;
  int iVar5;
  uint32_t uVar6;
  undefined4 uVar7;
  byte *pbVar8;
  uint uVar9;
  int iVar10;
  float in_fa0;
  DFtype DVar11;
  char acStack96 [4];
  char speed [32];
  
  memset(acStack96,0,0x20);
  if (p == (pbuf *)0x0) goto LAB_23048846;
  uVar3 = bl_timer_now_us();
  *(uint32_t *)((int)arg + 0x20) = uVar3;
  uVar6 = *(uint32_t *)((int)arg + 0x18);
  if (*(uint32_t *)((int)arg + 0x18) == 0) {
    uVar6 = uVar3;
  }
  *(uint32_t *)((int)arg + 0x18) = uVar6;
  uVar6 = *(uint32_t *)((int)arg + 0x1c);
  if (*(uint32_t *)((int)arg + 0x1c) == 0) {
    uVar6 = uVar3;
  }
  *(uint32_t *)((int)arg + 0x1c) = uVar6;
  uVar9 = p->tot_len + 0x36;
  uVar2 = *(int *)((int)arg + 0x30) + uVar9;
  iVar10 = (uint)(uVar2 < uVar9) + *(int *)((int)arg + 0x34);
  *(uint *)((int)arg + 0x30) = uVar2;
  *(int *)((int)arg + 0x34) = iVar10;
  *(int *)((int)arg + 4) = *(int *)((int)arg + 4) + 1;
  pbVar8 = (byte *)p->payload;
  uVar9 = (uint)pbVar8[2] << 8 | (uint)*pbVar8 << 0x18 | (uint)pbVar8[1] << 0x10 | (uint)pbVar8[3];
  if ((int)uVar9 < 0) {
    pbVar8[0xc] = 0x80;
    pbVar8[0xd] = 0;
    pbVar8[0xe] = 0;
    pbVar8[0xf] = 0;
    pbVar8[0x10] = 0;
    pbVar8[0x11] = 0;
    pbVar8[0x12] = 0;
    pbVar8[0x13] = 0;
    uVar7 = *(undefined4 *)((int)arg + 0x28);
    pbVar8[0x18] = 0;
    pbVar8[0x19] = 0;
    pbVar8[0x14] = (byte)((uint)uVar7 >> 0x18);
    pbVar8[0x15] = (byte)((uint)uVar7 >> 0x10);
    pbVar8[0x16] = (byte)((uint)uVar7 >> 8);
    pbVar8[0x17] = (byte)uVar7;
    pbVar8[0x1a] = 0;
    pbVar8[0x1b] = 0;
    pbVar8[0x1c] = 0;
    pbVar8[0x1d] = 0;
    pbVar8[0x1e] = 0;
    pbVar8[0x1f] = 0;
    uVar7 = *(undefined4 *)((int)arg + 0x10);
    pbVar8[0x20] = (byte)((uint)uVar7 >> 0x18);
    pbVar8[0x21] = (byte)((uint)uVar7 >> 0x10);
    pbVar8[0x22] = (byte)((uint)uVar7 >> 8);
    pbVar8[0x23] = (byte)uVar7;
    uVar7 = *(undefined4 *)((int)arg + 0xc);
    pbVar8[0x24] = (byte)((uint)uVar7 >> 0x18);
    pbVar8[0x25] = (byte)((uint)uVar7 >> 0x10);
    pbVar8[0x26] = (byte)((uint)uVar7 >> 8);
    pbVar8[0x27] = (byte)uVar7;
    uVar7 = *(undefined4 *)((int)arg + 4);
    pbVar8[0x28] = (byte)((uint)uVar7 >> 0x18);
    pbVar8[0x29] = (byte)((uint)uVar7 >> 0x10);
    pbVar8[0x2a] = (byte)((uint)uVar7 >> 8);
    pbVar8[0x2b] = (byte)uVar7;
    printf("iperf finish...\r\nreceive:%ld,out of order:%ld\r\n",*(undefined4 *)((int)arg + 4),
           *(undefined4 *)((int)arg + 0xc));
    udp_sendto(pcb,p,addr,port);
    *(undefined4 *)arg = 1;
  }
  else {
    if (499999 < uVar3 - uVar6) {
      __floatundisf();
      uVar4 = *(int *)((int)arg + 0x28) + uVar2;
      iVar10 = *(int *)((int)arg + 0x2c) + iVar10 + (uint)(uVar4 < uVar2);
      *(uint *)((int)arg + 0x28) = uVar4;
      *(int *)((int)arg + 0x2c) = iVar10;
      a = __floatundisf();
      fVar1 = ((in_fa0 * 1000000.0) / (float)(uVar3 - uVar6)) * 7.629395e-06;
      if (fVar1 < (float)*(undefined8 *)((int)arg + 0x38)) {
        *(ulonglong *)((int)arg + 0x38) = (ulonglong)(uint)fVar1;
      }
      if ((float)*(undefined8 *)((int)arg + 0x3c) < fVar1) {
        *(ulonglong *)((int)arg + 0x3c) = (ulonglong)(uint)fVar1;
      }
      __extendsfdf2(a);
      a_00 = a;
      iVar5 = iVar10;
      __extendsfdf2(a);
      a_01 = a_00;
      __extendsfdf2(a_00);
      DVar11 = __extendsfdf2(a_01);
      snprintf(acStack96,0x20,"%.4f(%.4f %.4f %.4f) Mbps, out of order: %lu.\r\n",a_00,iVar5,a,
               iVar10,SUB84(DVar11,0));
      printf("%s",acStack96);
      iVar10 = *(int *)((int)arg + 0x14);
      *(undefined4 *)((int)arg + 0x1c) = *(undefined4 *)((int)arg + 0x20);
      *(undefined4 *)((int)arg + 0x30) = 0;
      *(undefined4 *)((int)arg + 0x34) = 0;
      *(undefined4 *)((int)arg + 0x14) = 0;
      *(int *)((int)arg + 0xc) = *(int *)((int)arg + 0xc) + iVar10;
    }
  }
  iVar10 = *(int *)((int)arg + 8);
  if (uVar9 == iVar10 + 1U) {
    if (iVar10 < (int)uVar9) goto LAB_2304895c;
  }
  else {
    if (iVar10 < (int)uVar9) {
      *(uint *)((int)arg + 0x10) = (uVar9 - iVar10) + *(int *)((int)arg + 0x10) + -1;
LAB_2304895c:
      *(uint *)((int)arg + 8) = uVar9;
    }
    else {
      *(int *)((int)arg + 0x14) = *(int *)((int)arg + 0x14) + 1;
    }
  }
  pbuf_free(p);
LAB_23048846:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void iperf_client_udp(void *arg)

{
  float fVar1;
  u32_t *data;
  int iVar2;
  TickType_t TVar3;
  TickType_t TVar4;
  SFtype a;
  SFtype a_00;
  SFtype a_01;
  u32_t uVar5;
  ssize_t sVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  u32_t n;
  int iVar11;
  uint uVar12;
  DFtype DVar13;
  float fVar14;
  float fVar15;
  undefined auStack192 [4];
  sockaddr_in laddr;
  sockaddr_in raddr;
  char speed [64];
  
  memset(raddr.sin_zero + 4,0,0x40);
  data = (u32_t *)pvPortMalloc(0x514);
  if (data != (u32_t *)0x0) {
    iVar9 = 0;
    do {
      *(char *)((int)data + iVar9) = (char)iVar9;
      iVar9 = iVar9 + 1;
    } while (iVar9 != 0x514);
    iVar9 = lwip_socket(2,2,0x11);
    if (iVar9 < 0) {
      printf("create socket failed!\r\n");
    }
    else {
      memset(auStack192,0,0x10);
      auStack192[1] = '\x02';
      auStack192._2_2_ = lwip_htons(0x138a);
      laddr._0_4_ = ipaddr_addr("0.0.0.0");
      iVar2 = lwip_bind(iVar9,(sockaddr *)auStack192,0x10);
      if (iVar2 != -1) {
        printf("bind UDP socket successfully!\r\n");
        memset(laddr.sin_zero + 4,0,0x10);
        laddr.sin_zero[5] = '\x02';
        laddr.sin_zero._6_2_ = lwip_htons(0x1389);
        raddr._0_4_ = ipaddr_addr((char *)arg);
        TVar3 = xTaskGetTickCount();
        fVar14 = 8000.0;
        fVar15 = 0.0;
        n = 1;
        iVar2 = 0;
        iVar11 = 0;
        uVar10 = 0;
        do {
          TVar4 = xTaskGetTickCount();
          uVar12 = uVar10;
          if (4999 < TVar4 - TVar3) {
            uVar12 = iVar11 + uVar10;
            iVar2 = iVar2 + (iVar11 >> 0x1f) + (uint)(uVar12 < uVar10);
            iVar7 = iVar2;
            a = __floatundisf();
            fVar1 = ((((float)iVar11 / 125.0) / (float)(TVar4 - TVar3)) * 1000.0) / 1000.0;
            if (fVar1 < fVar14) {
              fVar14 = fVar1;
            }
            if (fVar15 < fVar1) {
              fVar15 = fVar1;
            }
            iVar11 = 0;
            __extendsfdf2(a);
            a_00 = a;
            iVar8 = iVar7;
            __extendsfdf2(a);
            a_01 = a_00;
            __extendsfdf2(a_00);
            DVar13 = __extendsfdf2(a_01);
            snprintf(raddr.sin_zero + 4,0x40,"%.4f(%.4f %.4f %.4f) Mbps!\r\n",a_00,iVar8,a,iVar7,
                     SUB84(DVar13,0));
            printf("%s",raddr.sin_zero + 4);
            TVar3 = TVar4;
          }
          uVar5 = lwip_htonl(n);
          *data = uVar5;
          data[1] = 0;
          data[2] = 0;
          while (sVar6 = lwip_sendto(iVar9,data,0x514,0,(sockaddr *)(laddr.sin_zero + 4),0x10),
                sVar6 < 1) {
            if (sVar6 == 0) goto LAB_23048bb0;
            if (sVar6 != -1) {
              lwip_close(iVar9);
              vTaskDelay(2000);
              printf("disconnected! ret %d\r\n",sVar6);
              vTaskDelete((TaskHandle_t)0x0);
              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
              return;
            }
          }
          iVar11 = iVar11 + sVar6;
LAB_23048bb0:
          n = n + 1;
          uVar10 = uVar12;
        } while( true );
      }
      printf("Bind failed!\r\n");
      lwip_close(iVar9);
    }
    vTaskDelay(1000);
  }
  vPortFree(arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void iperf_server(void *arg)

{
  float fVar1;
  u16_t uVar2;
  void *mem;
  int s;
  int iVar3;
  char *pcVar4;
  int s_00;
  undefined2 extraout_var;
  TickType_t TVar5;
  ssize_t sVar6;
  TickType_t TVar7;
  SFtype a;
  SFtype a_00;
  SFtype a_01;
  int iVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  DFtype DVar12;
  float fVar13;
  float fVar14;
  socklen_t sStack168;
  uint32_t sin_size;
  int flag;
  sockaddr_in server_addr;
  sockaddr_in client_addr;
  char speed [32];
  
  memset(client_addr.sin_zero + 4,0,0x20);
  mem = pvPortMalloc(0x1450);
  if (mem == (void *)0x0) {
    printf("No memory\r\n");
  }
  else {
    s = lwip_socket(2,1,0);
    if (s < 0) {
      printf("Socket error\r\n");
    }
    else {
      flag._1_1_ = '\x02';
      flag._2_2_ = lwip_htons(0x1389);
      server_addr._0_4_ = 0;
      memset(&server_addr.sin_addr,0,8);
      iVar3 = lwip_bind(s,(sockaddr *)&flag,0x10);
      if (iVar3 == -1) {
        pcVar4 = "Unable to bind\r\n";
      }
      else {
        iVar3 = lwip_listen(s,5);
        if (iVar3 != -1) {
          fVar13 = 8000.0;
          fVar14 = 0.0;
          uVar10 = 0;
          iVar3 = 0;
LAB_23048d00:
          sStack168 = 0x10;
          s_00 = lwip_accept(s,(sockaddr *)(server_addr.sin_zero + 4),&sStack168);
          pcVar4 = ip4addr_ntoa((ip4_addr_t *)&client_addr);
          uVar2 = lwip_htons(server_addr.sin_zero._6_2_);
          printf("new client connected from (%s, %d)\r\n",pcVar4,CONCAT22(extraout_var,uVar2));
          sin_size = 1;
          lwip_setsockopt(s_00,6,1,&sin_size,4);
          TVar5 = xTaskGetTickCount();
          do {
            iVar11 = 0;
            do {
              sVar6 = lwip_recv(s_00,mem,0x1450,0);
              if (sVar6 < 1) {
                if (-1 < s_00) {
                  lwip_close(s_00);
                }
                goto LAB_23048d00;
              }
              iVar11 = iVar11 + sVar6;
              TVar7 = xTaskGetTickCount();
            } while (TVar7 - TVar5 < 5000);
            iVar3 = iVar3 + (iVar11 >> 0x1f) + (uint)(iVar11 + uVar10 < uVar10);
            iVar8 = iVar3;
            a = __floatundisf();
            fVar1 = ((((float)iVar11 / 125.0) / (float)(TVar7 - TVar5)) * 1000.0) / 1000.0;
            if (fVar1 < fVar13) {
              fVar13 = fVar1;
            }
            if (fVar14 < fVar1) {
              fVar14 = fVar1;
            }
            __extendsfdf2(a);
            a_00 = a;
            iVar9 = iVar8;
            __extendsfdf2(a);
            a_01 = a_00;
            __extendsfdf2(a_00);
            DVar12 = __extendsfdf2(a_01);
            snprintf(client_addr.sin_zero + 4,0x20,"%.4f(%.4f %.4f %.4f) Mbps!\r\n",a_00,iVar9,a,
                     iVar8,SUB84(DVar12,0));
            printf("%s",client_addr.sin_zero + 4);
            uVar10 = iVar11 + uVar10;
            TVar5 = TVar7;
          } while( true );
        }
        pcVar4 = "Listen error\r\n";
      }
      printf(pcVar4);
      lwip_close(s);
    }
    vPortFree(mem);
  }
  if (arg != (void *)0x0) {
    vPortFree(arg);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void iperf_client_tcp(void *arg)

{
  float fVar1;
  void *data;
  int s;
  int iVar2;
  TickType_t TVar3;
  TickType_t TVar4;
  SFtype a;
  SFtype a_00;
  SFtype a_01;
  ssize_t sVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  DFtype DVar11;
  float fVar12;
  float fVar13;
  undefined4 uStack148;
  int flag;
  sockaddr_in addr;
  char speed [32];
  
  memset(addr.sin_zero + 4,0,0x20);
  data = pvPortMalloc(0x1450);
  if (data == (void *)0x0) {
    vPortFree(arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar8 = 0;
  do {
    *(char *)((int)data + iVar8) = (char)iVar8;
    iVar8 = iVar8 + 1;
  } while (iVar8 != 0x1450);
  fVar12 = 8000.0;
  fVar13 = 0.0;
  uVar9 = 0;
  iVar8 = 0;
  do {
    while (s = lwip_socket(2,1,6), s < 0) {
      printf("create socket failed!\r\n");
LAB_23048efe:
      vTaskDelay(1000);
    }
    flag._1_1_ = '\x02';
    flag._2_2_ = lwip_htons(0x1389);
    addr._0_4_ = ipaddr_addr((char *)arg);
    iVar2 = lwip_connect(s,(sockaddr *)&flag,0x10);
    if (iVar2 == -1) {
      printf("Connect failed!\r\n");
      lwip_close(s);
      goto LAB_23048efe;
    }
    printf("Connect to iperf server successful!\r\n");
    uStack148 = 1;
    lwip_setsockopt(s,6,1,&uStack148,4);
    TVar3 = xTaskGetTickCount();
    iVar2 = 0;
    uVar10 = uVar9;
    do {
      while( true ) {
        TVar4 = xTaskGetTickCount();
        uVar9 = uVar10;
        if (4999 < TVar4 - TVar3) {
          uVar9 = iVar2 + uVar10;
          iVar8 = iVar8 + (iVar2 >> 0x1f) + (uint)(uVar9 < uVar10);
          iVar6 = iVar8;
          a = __floatundisf();
          fVar1 = ((((float)iVar2 / 125.0) / (float)(TVar4 - TVar3)) * 1000.0) / 1000.0;
          if (fVar1 < fVar12) {
            fVar12 = fVar1;
          }
          if (fVar13 < fVar1) {
            fVar13 = fVar1;
          }
          iVar2 = 0;
          __extendsfdf2(a);
          a_00 = a;
          iVar7 = iVar6;
          __extendsfdf2(a);
          a_01 = a_00;
          __extendsfdf2(a_00);
          DVar11 = __extendsfdf2(a_01);
          snprintf(addr.sin_zero + 4,0x20,"%.4f(%.4f %.4f %.4f) Mbps!\r\n",a_00,iVar7,a,iVar6,
                   SUB84(DVar11,0));
          printf("%s",addr.sin_zero + 4);
          TVar3 = TVar4;
        }
        sVar5 = lwip_send(s,data,0x1450,0);
        uVar10 = uVar9;
        if (sVar5 < 1) break;
        iVar2 = iVar2 + sVar5;
      }
    } while (sVar5 == 0);
    lwip_close(s);
    vTaskDelay(2000);
    printf("disconnected!\r\n");
  } while( true );
}



void ipus_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPUS] Connecting with default address 0.0.0.0\r\n");
    name = "0.0.0.0";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPUS] illegal address\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    name = argv[1];
  }
  iperf_server_udp_entry(name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ipu_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPU] Connecting with default address 192.168.11.1\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPU] illegal address\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    name = argv[1];
  }
  iperf_client_udp_entry(name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ipc_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    printf("[NET] [IPC] [IPC] Connecting with default address 192.168.11.1\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPC] illegal address\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    name = argv[1];
  }
  iperf_client_tcp_entry(name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ips_test_cmd(char *buf,int len,int argc,char **argv)

{
  char *name;
  
  if (argc == 1) {
    puts("[NET] [IPC] [IPS] Starting iperf server on 0.0.0.0\r\n");
    name = "192.168.11.1";
  }
  else {
    if (argc != 2) {
      printf("[NET] [IPC] [IPS] illegal address\r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    name = argv[1];
  }
  iperf_server_entry(name);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int network_netutils_iperf_cli_register(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void cmd_netstat(char *buf,int len,int argc,char **argv)

{
  tcpip_callback(stats_netstat,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int network_netutils_netstat_cli_register(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void ping_usage(void)

{
  printf("%s");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ping_free(void *arg)

{
  u16_t uVar1;
  undefined2 extraout_var;
  utils_list_hdr *node;
  utils_memp_pool_t *pool;
  
  while (*(int *)((int)arg + 0x20) != 0) {
    uVar1 = lwip_htons(*(u16_t *)(*(int *)((int)arg + 0x20) + 4));
    printf("The sequence number %d timed out\r\n",CONCAT22(extraout_var,uVar1));
    pool = *(utils_memp_pool_t **)((int)arg + 0x18);
    node = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(pool,node);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  raw_remove(*(raw_pcb **)((int)arg + 0x1c));
  utils_memp_deinit(*(utils_memp_pool_t **)((int)arg + 0x18));
  vPortFree(arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ping_timeout(void *arg)

{
  undefined2 uVar1;
  utils_memp_pool_t *puVar2;
  undefined *dataptr;
  u16_t uVar3;
  utils_list_hdr *puVar4;
  pbuf *p;
  utils_list_hdr *puVar5;
  TickType_t TVar6;
  undefined2 extraout_var;
  uint uVar7;
  ushort length;
  
  while (*(int *)((int)arg + 0x20) != 0) {
    TVar6 = sys_now();
    if (TVar6 - *(int *)(*(int *)((int)arg + 0x20) + 8) <= (uint)*(ushort *)((int)arg + 0x10))
    break;
    uVar3 = lwip_htons(*(u16_t *)(*(int *)((int)arg + 0x20) + 4));
    printf("The sequence number %d timed out\r\n",CONCAT22(extraout_var,uVar3));
    puVar2 = *(utils_memp_pool_t **)((int)arg + 0x18);
    puVar4 = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(puVar2,puVar4);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  if (*(char *)((int)arg + 0x12) == '\n') {
    puVar2 = *(utils_memp_pool_t **)((int)arg + 0x18);
    puVar4 = utils_list_pop_front((utils_list *)((int)arg + 0x20));
    utils_memp_free(puVar2,puVar4);
    *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
  }
  length = *(short *)((int)arg + 10) + 8;
  p = pbuf_alloc(PBUF_IP,length,PBUF_RAM);
  if (p != (pbuf *)0x0) {
    if ((p->len == p->tot_len) && (p->next == (pbuf *)0x0)) {
      dataptr = (undefined *)p->payload;
      puVar4 = (utils_list_hdr *)utils_memp_malloc(*(utils_memp_pool_t **)((int)arg + 0x18));
      if (puVar4 != (utils_list_hdr *)0x0) {
        *dataptr = 8;
        dataptr[1] = 0;
        dataptr[2] = 0;
        dataptr[3] = 0;
        uVar1 = *(undefined2 *)((int)arg + 0xe);
        dataptr[4] = (char)uVar1;
        dataptr[5] = (char)((ushort)uVar1 >> 8);
        uVar3 = *(short *)((int)arg + 0xc) + 1;
        *(u16_t *)((int)arg + 0xc) = uVar3;
        uVar3 = lwip_htons(uVar3);
        dataptr[6] = (char)uVar3;
        dataptr[7] = (char)(uVar3 >> 8);
        uVar7 = 0;
        while (uVar7 < length - 8) {
          dataptr[uVar7 + 8] = (char)uVar7;
          uVar7 = uVar7 + 1;
        }
        uVar3 = inet_chksum(dataptr,length);
        dataptr[2] = (char)uVar3;
        dataptr[3] = (char)(uVar3 >> 8);
        *(undefined2 *)&puVar4[1].next = *(undefined2 *)(dataptr + 6);
        raw_sendto(*(raw_pcb **)((int)arg + 0x1c),p,(ip_addr_t *)((int)arg + 0x14));
        puVar5 = (utils_list_hdr *)sys_now();
        puVar4[2].next = puVar5;
        utils_list_push_back((utils_list *)((int)arg + 0x20),puVar4);
        *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + '\x01';
        *(int *)((int)arg + 4) = *(int *)((int)arg + 4) + 1;
      }
    }
    pbuf_free(p);
  }
  sys_timeout((uint)*(ushort *)((int)arg + 8),ping_timeout,arg);
                    // WARNING: Load size is inaccurate
  if (*(int *)((int)arg + 4) == *arg) {
    sys_untimeout(ping_timeout,arg);
    sys_timeout((uint)*(ushort *)((int)arg + 0x10),ping_free,arg);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: echo_hdr
// WARNING: Could not reconcile some variable overlaps

u8_t ping_recv(void *arg,raw_pcb *pcb,pbuf *p,ip_addr_t *addr)

{
  byte bVar1;
  ushort uVar2;
  void **node;
  void **ppvVar3;
  u16_t uVar4;
  char *pcVar5;
  undefined2 extraout_var;
  TickType_t TVar6;
  byte bStack24;
  byte bStack23;
  icmp_echo_hdr echo_hdr;
  
  if (((uint)p->tot_len != *(ushort *)((int)arg + 10) + 0x1c) ||
     (*(u32_t *)((int)arg + 0x14) != addr->addr)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return '\0';
  }
  memcpy(&bStack24,(void *)((int)p->payload + 0x14),8);
  bStack24 = bStack24 | bStack23;
  if (bStack24 == 0) {
    if ((((echo_hdr._0_2_ == *(short *)((int)arg + 0xe)) && (*(char *)((int)arg + 0x12) != '\0')) &&
        (node = *(void ***)((int)arg + 0x20), node != (void **)0x0)) &&
       (*(ushort *)(node + 1) <= echo_hdr.chksum)) {
      if (echo_hdr.chksum == *(ushort *)(node + 1)) {
        *(void **)((int)arg + 0x20) = *node;
      }
      else {
        do {
          ppvVar3 = node;
          node = (void **)*ppvVar3;
          if (node == (void **)0x0) goto LAB_230494a0;
        } while (*(ushort *)(node + 1) < echo_hdr.chksum);
        if (echo_hdr.chksum != *(ushort *)(node + 1)) goto LAB_230494a0;
        if (node == *(void ***)((int)arg + 0x24)) {
          *(void ***)((int)arg + 0x24) = ppvVar3;
        }
        node = (void **)*ppvVar3;
        *ppvVar3 = *node;
      }
      uVar2 = p->tot_len;
      pcVar5 = ip4addr_ntoa((ip4_addr_t *)((int)arg + 0x14));
      uVar4 = lwip_htons(echo_hdr.chksum);
      bVar1 = *(byte *)((int)p->payload + 8);
      TVar6 = sys_now();
      printf("%d bytes from %s: icmp_seq=%d ttl=%d time=%lu ms\r\n ",(uint)uVar2,pcVar5,
             CONCAT22(extraout_var,uVar4),(uint)bVar1,TVar6 - (int)node[2]);
      utils_memp_free(*(utils_memp_pool_t **)((int)arg + 0x18),node);
      *(char *)((int)arg + 0x12) = *(char *)((int)arg + 0x12) + -1;
      pbuf_free(p);
      bStack24 = 1;
    }
  }
  else {
    bStack24 = 0;
  }
LAB_230494a0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (u8_t)bStack24;
}



ping_var * ping_api_init(u16_t interval,u16_t size,u32_t count,u16_t timeout,ip_addr_t *dest)

{
  ping_var *recv_arg;
  int iVar1;
  char *fmt;
  raw_pcb *pcb;
  
  recv_arg = (ping_var *)pvPortMalloc(0x28);
  if (recv_arg == (ping_var *)0x0) {
    printf("mem malloc failed!\r\n");
  }
  else {
    recv_arg->total_count = count;
    recv_arg->data_size = size;
    recv_arg->requests_count = 0;
    recv_arg->interval = interval;
    recv_arg->seq_num = 0;
    iVar1 = bl_rand();
    recv_arg->id = (u16_t)iVar1;
    recv_arg->timeout = timeout;
    recv_arg->node_num = '\0';
    (recv_arg->dest).addr = dest->addr;
    iVar1 = utils_memp_init(&recv_arg->pool,0xc,10,'\x04');
    if (iVar1 == 0) {
      utils_list_init(&recv_arg->req_list);
      pcb = raw_new('\x01');
      if (pcb != (raw_pcb *)0x0) {
        recv_arg->pcb = pcb;
        raw_recv(pcb,ping_recv,recv_arg);
        raw_bind(pcb,&ip_addr_any);
        sys_timeout(0,ping_timeout,recv_arg);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return recv_arg;
      }
      fmt = "pcb null, maybe the pcb pool or sys_timeout pool is empty\r\n";
    }
    else {
      fmt = "pool_alloc failed\n";
    }
    printf(fmt);
    printf("ping_init failed\r\n");
    vPortFree(recv_arg);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return recv_arg;
}



// WARNING: Type propagation algorithm not settling

void ping_cmd(char *buf,int len,int argc,char **argv)

{
  uint uVar1;
  int iVar2;
  hostent *phVar3;
  char *fmt;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  u32_t count;
  undefined auStack84 [4];
  getopt_env_t getopt_env;
  
  uVar1 = 5000;
  utils_getopt_init((getopt_env_t *)auStack84,0);
  count = 0;
  uVar6 = 0x20;
  uVar5 = 1000;
LAB_230495e6:
  while( true ) {
    while( true ) {
      iVar2 = utils_getopt((getopt_env_t *)auStack84,argc,argv,":i:s:c:W:h");
      if (iVar2 == -1) {
        if (getopt_env.optarg + 1 == (char *)argc) {
          phVar3 = lwip_gethostbyname(argv[(int)getopt_env.optarg]);
          if (phVar3 == (hostent *)0x0) {
            printf("Failed to resolve domain name\r\n");
          }
          else {
            ping_api_init((u16_t)uVar5,(u16_t)uVar6,count,(u16_t)uVar1,
                          (ip_addr_t *)((ip_addr_t *)phVar3->h_addr_list)->addr);
          }
          goto LAB_23049622;
        }
        printf("Need target address\r\n");
        goto LAB_23049676;
      }
      if (iVar2 != 99) break;
      count = atoi(auStack84);
    }
    if (iVar2 < 100) break;
    if (iVar2 == 0x69) {
      uVar5 = atoi(auStack84);
      uVar5 = uVar5 & 0xffff;
    }
    else {
      if (iVar2 == 0x73) {
        uVar6 = atoi(auStack84);
        uVar6 = uVar6 & 0xffff;
      }
      else {
        if (iVar2 == 0x68) {
LAB_23049676:
          ping_usage();
LAB_23049622:
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
      }
    }
  }
  if (iVar2 == 0x3f) {
    pcVar4 = *argv;
    fmt = "%s: unknown option %c\r\n";
  }
  else {
    if (iVar2 == 0x57) {
      uVar1 = atoi(auStack84);
      uVar1 = uVar1 & 0xffff;
      goto LAB_230495e6;
    }
    if (iVar2 != 0x3a) goto LAB_230495e6;
    pcVar4 = *argv;
    fmt = "%s: %c requires an argument\r\n";
  }
  printf(fmt,pcVar4,getopt_env.opterr);
  goto LAB_23049676;
}



int network_netutils_ping_cli_register(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int dirent_type(void *addr)

{
  int iVar1;
  byte bVar2;
  
  bVar2 = *(byte *)((int)addr + 3) & 7;
  if ((*(byte *)((int)addr + 3) & 7) == 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = 2;
    if ((bVar2 != 2) && (iVar1 = 3, bVar2 == 1)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



uint32_t dirent_hardfh(void *addr)

{
  uint uVar1;
  
                    // WARNING: Load size is inaccurate
  uVar1 = *addr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_childaddr(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1 << 0x18 | uVar1 >> 0x18 & 0xfffffff0 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



uint32_t dirent_size(void *addr)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)addr + 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1 << 0x18 | uVar1 >> 0x18 | (uVar1 & 0xff00) << 8 | uVar1 >> 8 & 0xff00;
}



int romfs_close(file_t *fp)

{
  fp->f_arg = (void *)0x0;
  fp->offset = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int romfs_ioctl(file_t *fp,int cmd,ulong arg)

{
  size_t sVar1;
  uint32_t uVar2;
  int iVar3;
  void *pvVar4;
  
  iVar3 = -2;
  if (((fp != (file_t *)0x0) && (arg != 0)) && (iVar3 = -3, cmd == 1)) {
    pvVar4 = fp->f_arg;
    sVar1 = strlen((char *)((int)pvVar4 + 0x10));
    *(size_t *)arg = (sVar1 + 0x10 & 0xfffffff0) + 0x10 + (int)pvVar4;
    uVar2 = dirent_size(fp->f_arg);
    *(uint32_t *)(arg + 4) = uVar2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



ssize_t romfs_read(file_t *fp,char *buf,size_t length)

{
  size_t sVar1;
  uint32_t uVar2;
  uint uVar3;
  void *pvVar4;
  
  pvVar4 = fp->f_arg;
  sVar1 = strlen((char *)((int)pvVar4 + 0x10));
  uVar2 = dirent_size(fp->f_arg);
  uVar3 = fp->offset;
  if (uVar3 < uVar2) {
    pvVar4 = (void *)((sVar1 + 0x10 & 0xfffffff0) + 0x10 + uVar3 + (int)pvVar4);
    if (uVar3 + length < uVar2) {
      memcpy(buf,pvVar4,length);
      fp->offset = fp->offset + length;
    }
    else {
      length = uVar2 - uVar3;
      memcpy(buf,pvVar4,length);
      fp->offset = uVar2;
    }
  }
  else {
    length = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return length;
}



int file_info(char *path,char **p_addr_start_input,char **p_addr_end_input)

{
  char *addr;
  char *pcVar1;
  char *pcVar2;
  size_t sVar3;
  int iVar4;
  uint32_t uVar5;
  TickType_t TVar6;
  
  addr = *p_addr_start_input;
  pcVar1 = *p_addr_end_input;
  sVar3 = strlen(path);
  if (sVar3 < 0x41) {
    if (romfs_root == addr) {
      sVar3 = strlen(addr + 0x10);
      addr = addr + (sVar3 + 0x10 & 0xfffffff0) + 0x50;
    }
    do {
      iVar4 = dirent_type(addr);
      if (iVar4 == 1) {
        sVar3 = strlen(path);
        iVar4 = memcmp(path,addr + 0x10,sVar3);
        if ((iVar4 == 0) && (sVar3 = strlen(path), addr[sVar3 + 0x10] == '\0')) {
          uVar5 = dirent_hardfh(addr);
          pcVar2 = romfs_root;
          if (uVar5 != 0) {
LAB_230498ea:
            pcVar1 = pcVar2 + uVar5;
          }
          *p_addr_start_input = addr;
          *p_addr_end_input = pcVar1;
          iVar4 = 0;
          goto LAB_230498f6;
        }
      }
      else {
        if (iVar4 == 2) {
          sVar3 = strlen(path);
          iVar4 = memcmp(path,addr + 0x10,sVar3);
          if ((iVar4 == 0) &&
             (sVar3 = strlen(path), pcVar2 = romfs_root, addr[sVar3 + 0x10] == '\0')) {
            uVar5 = dirent_hardfh(addr);
            goto LAB_230498ea;
          }
        }
        else {
          if (iVar4 != 0) {
            if (TrapNetCounter == 0) {
              TVar6 = xTaskGetTickCount();
            }
            else {
              TVar6 = xTaskGetTickCountFromISR();
            }
            iVar4 = dirent_type(addr);
            bl_printk("[%10u][%s: %s:%4d] addr_start = %p, dirent_type(addr_start) = %d\r\n",TVar6,
                      &DAT_23072bcc,"bl_romfs.c",0xe6,addr,iVar4);
            log_buf_out("bl_romfs.c",0xe7,addr,8,LOG_BUF_OUT_DATA_TYPE_HEX);
            if (TrapNetCounter == 0) {
              TVar6 = xTaskGetTickCount();
            }
            else {
              TVar6 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] unknow the dirent_type.\r\n",TVar6,&DAT_23072bcc,
                      "bl_romfs.c",0xe8);
            goto LAB_230499b6;
          }
        }
      }
      pcVar2 = romfs_root;
      uVar5 = dirent_hardfh(addr);
      addr = pcVar2 + uVar5;
    } while (addr < pcVar1);
    if (TrapNetCounter == 0) {
      TVar6 = xTaskGetTickCount();
    }
    else {
      TVar6 = xTaskGetTickCountFromISR();
    }
    bl_printk(
              "[%10u][%s: %s:%4d] start >= end, not found path = %s, addr_start = %p, addr_end = %p\r\n"
              ,TVar6,&DAT_23081ce8,"bl_romfs.c",0xef,path,addr,pcVar1);
  }
LAB_230499b6:
  iVar4 = -1;
LAB_230498f6:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int romfs_closedir(file_t *fp,aos_dir_t *dir)

{
  if (dir != (aos_dir_t *)0x0) {
    aos_free(dir);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



off_t romfs_lseek(file_t *fp,off_t off,int whence)

{
  size_t sVar1;
  uint32_t uVar2;
  uint uVar3;
  
  uVar3 = 0xffffffff;
  if (fp == (file_t *)0x0) goto LAB_23049a5c;
  uVar2 = dirent_size(fp->f_arg);
  if (whence == 0) {
    uVar3 = off;
    if (off < 0) {
      printf("not support whence.\r\n");
      uVar3 = 0xfffffffe;
      goto LAB_23049a5c;
    }
LAB_23049a86:
    if (uVar3 <= uVar2) {
      fp->offset = uVar3;
      goto LAB_23049a5c;
    }
  }
  else {
    if (whence == 2) {
      sVar1 = uVar2;
      if (0 < off) {
        printf("not support whence.\r\n");
        uVar3 = 0xfffffffd;
        goto LAB_23049a5c;
      }
    }
    else {
      if (whence != 1) {
        printf("not support whence.\r\n");
        uVar3 = 0xfffffffc;
        goto LAB_23049a5c;
      }
      sVar1 = fp->offset;
    }
    uVar3 = off + sVar1;
    if (-1 < (int)uVar3) goto LAB_23049a86;
  }
  printf("not support whence.\r\n");
  uVar3 = 0xfffffffb;
LAB_23049a5c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3;
}



aos_dirent_t * romfs_readdir(file_t *fp,aos_dir_t *dir)

{
  void *pvVar1;
  uint32_t uVar2;
  char *pcVar3;
  aos_dirent_t *paVar4;
  int iVar5;
  uint uVar6;
  void *addr;
  
  if (dir == (aos_dir_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (aos_dirent_t *)0x0;
  }
LAB_23049af6:
  do {
    pcVar3 = romfs_root;
    if ((void *)dir[2].dd_vfs_fd == (void *)0x0) {
      dir[2].dd_vfs_fd = dir[1].dd_vfs_fd;
    }
    else {
      pvVar1 = (void *)dir[1].dd_rsv;
      if (pvVar1 <= (void *)dir[2].dd_vfs_fd) {
LAB_23049b32:
        paVar4 = (aos_dirent_t *)0x0;
        goto LAB_23049b34;
      }
      while( true ) {
        addr = (void *)dir[2].dd_vfs_fd;
        if (pvVar1 <= addr) goto LAB_23049b32;
        uVar2 = dirent_hardfh(addr);
        if (uVar2 == 0) break;
        if (addr == (void *)0x0) goto LAB_23049b32;
        iVar5 = dirent_type(addr);
        if (iVar5 - 1U < 2) break;
        dir[2].dd_vfs_fd = (int)(pcVar3 + uVar2);
      }
    }
    strncpy((char *)((int)&dir[3].dd_vfs_fd + 1),(char *)(dir[2].dd_vfs_fd + 0x10),0x40);
    pvVar1 = (void *)dir[2].dd_vfs_fd;
    *(undefined *)((int)&dir[0xb].dd_vfs_fd + 1) = 0;
    uVar2 = dirent_hardfh(pvVar1);
    if (uVar2 == 0) {
      pcVar3 = (char *)dir[1].dd_rsv;
    }
    else {
      pcVar3 = romfs_root + uVar2;
    }
    dir[2].dd_vfs_fd = (int)pcVar3;
    uVar6 = dir[3].dd_vfs_fd & 0xffff00;
    if (uVar6 == 0x2e2e00) {
      if (*(char *)((int)&dir[3].dd_vfs_fd + 3) != '\0') goto LAB_23049b2c;
      goto LAB_23049af6;
    }
    if (uVar6 != 0x2e00) {
LAB_23049b2c:
      paVar4 = (aos_dirent_t *)&dir[2].dd_rsv;
LAB_23049b34:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return paVar4;
    }
  } while( true );
}



uint32_t dirent_file(char *path,void **p_addr_start_input,void **p_addr_end_input)

{
  bool bVar1;
  char *pcVar2;
  char *pcVar3;
  size_t sVar4;
  size_t sVar5;
  int iVar6;
  TickType_t TVar7;
  char *pcVar8;
  uint32_t uVar9;
  char *pcVar10;
  undefined4 uVar11;
  uint uVar12;
  char *pcStack124;
  char *addr_start;
  char *addr_end;
  char name [65];
  
  sVar4 = strlen(path);
  sVar5 = strlen("/romfs");
  if (sVar5 <= sVar4) {
    sVar4 = strlen("/romfs");
    iVar6 = memcmp(path,"/romfs",sVar4);
    if (iVar6 == 0) {
      sVar4 = strlen("/romfs");
      pcVar8 = path + sVar4;
      if (*pcVar8 == '/') {
        pcVar8 = pcVar8 + 1;
      }
      else {
        if (*pcVar8 != '\0') {
          if (TrapNetCounter == 0) {
            TVar7 = xTaskGetTickCount();
          }
          else {
            TVar7 = xTaskGetTickCountFromISR();
          }
          uVar11 = 0x11a;
          goto LAB_23049bf0;
        }
      }
      bVar1 = false;
      uVar12 = *(uint *)(romfs_root + 8);
      pcStack124 = romfs_root;
      addr_start = romfs_root +
                   (uVar12 >> 8 & 0xff00 | uVar12 << 0x18 | uVar12 >> 0x18 | (uVar12 & 0xff00) << 8)
      ;
      while (*pcVar8 != '\0') {
        pcVar10 = strchr(pcVar8,0x2f);
        pcVar3 = pcStack124;
        pcVar2 = romfs_root;
        if (bVar1) {
          uVar9 = dirent_childaddr(pcStack124);
          pcStack124 = pcVar2 + uVar9;
          if (pcVar3 == pcStack124) {
            uVar9 = 0xfffffffe;
            goto LAB_23049dae;
          }
        }
        if (pcVar10 == (char *)0x0) {
          sVar4 = strlen(pcVar8);
          if (0x40 < sVar4) {
            if (TrapNetCounter == 0) {
              TVar7 = xTaskGetTickCount();
            }
            else {
              TVar7 = xTaskGetTickCountFromISR();
            }
            uVar11 = 0x138;
            pcVar8 = "[%10u][%s: %s:%4d] name too long!\r\n";
            goto LAB_23049c0a;
          }
          iVar6 = file_info(pcVar8,&pcStack124,&addr_start);
          if (iVar6 != 0) {
            if (TrapNetCounter == 0) {
              TVar7 = xTaskGetTickCount();
            }
            else {
              TVar7 = xTaskGetTickCountFromISR();
            }
            bl_printk(
                      "[%10u][%s: %s:%4d] file info error, p_name = %s, addr_start = %p, addr_end = %p\r\n"
                      ,TVar7,&DAT_23081ce8,"bl_romfs.c",0x13c,pcVar8,pcStack124,addr_start);
            goto LAB_23049c0e;
          }
          break;
        }
        memset(&addr_end,0,0x41);
        memcpy(&addr_end,pcVar8,(size_t)(pcVar10 + -(int)pcVar8));
        iVar6 = file_info((char *)&addr_end,&pcStack124,&addr_start);
        if (iVar6 != 0) {
          if (TrapNetCounter == 0) {
            TVar7 = xTaskGetTickCount();
          }
          else {
            TVar7 = xTaskGetTickCountFromISR();
          }
          uVar11 = 0x147;
          pcVar8 = "[%10u][%s: %s:%4d] file info error.\r\n";
          goto LAB_23049c0a;
        }
        pcVar8 = pcVar10 + 1;
        bVar1 = true;
      }
      uVar9 = 0;
      *p_addr_start_input = pcStack124;
      *p_addr_end_input = addr_start;
      goto LAB_23049dae;
    }
    if (TrapNetCounter == 0) {
      TVar7 = xTaskGetTickCount();
    }
    else {
      TVar7 = xTaskGetTickCountFromISR();
    }
    uVar11 = 0x115;
LAB_23049bf0:
    pcVar8 = "[%10u][%s: %s:%4d] not support path.\r\n";
LAB_23049c0a:
    bl_printk(pcVar8,TVar7,&DAT_23072bcc,"bl_romfs.c",uVar11);
  }
LAB_23049c0e:
  uVar9 = 0xffffffff;
LAB_23049dae:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar9;
}



// WARNING: Variable defined which should be unmapped: end_addr

aos_dir_t * romfs_opendir(file_t *fp,char *path)

{
  char *pcVar1;
  TickType_t TVar2;
  aos_dir_t *__s;
  uint32_t uVar3;
  size_t sVar4;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] romfs_root is null.\r\n",TVar2,&DAT_23072bcc,"bl_romfs.c",0x20d);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (aos_dir_t *)0x0;
  }
  __s = (aos_dir_t *)aos_malloc(0x5d);
  if (__s != (aos_dir_t *)0x0) {
    memset(__s,0,0x5d);
    uVar3 = dirent_file(path,&pcStack24,&start_addr);
    pcVar1 = romfs_root;
    if (uVar3 == 0) {
      if (pcStack24 == romfs_root) {
        sVar4 = strlen(pcStack24 + 0x10);
        __s[1].dd_vfs_fd = (int)(pcStack24 + (sVar4 + 0x10 & 0xfffffff0) + 0x50);
      }
      else {
        uVar3 = dirent_childaddr(pcStack24);
        if (uVar3 == 0) goto LAB_23049e32;
        __s[1].dd_vfs_fd = (int)(pcVar1 + uVar3);
      }
      __s[2].dd_vfs_fd = 0;
      __s[1].dd_rsv = (int)start_addr;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __s;
    }
    aos_free(__s);
  }
LAB_23049e32:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (aos_dir_t *)0x0;
}



// WARNING: Variable defined which should be unmapped: end_addr

int romfs_stat(file_t *fp,char *path,stat *st)

{
  char *addr;
  uint32_t uVar1;
  TickType_t TVar2;
  int iVar3;
  uint32_t uVar4;
  mode_t mVar5;
  char *pcStack24;
  char *start_addr;
  char *end_addr;
  
  pcStack24 = (char *)0x0;
  start_addr = (char *)0x0;
  uVar1 = dirent_file(path,&pcStack24,&start_addr);
  addr = pcStack24;
  if (uVar1 == 0) {
    if (pcStack24 == romfs_root) {
      st->st_size = 0;
    }
    else {
      iVar3 = dirent_type(pcStack24);
      if (iVar3 == 1) {
        st->st_size = 0;
        mVar5 = 0x4000;
      }
      else {
        if (iVar3 != 2) {
          if (TrapNetCounter == 0) {
            TVar2 = xTaskGetTickCount();
          }
          else {
            TVar2 = xTaskGetTickCountFromISR();
          }
          bl_printk("[%10u][%s: %s:%4d] dirent_type err.\r\n",TVar2,&DAT_23081ce8,"bl_romfs.c",0x1fa
                   );
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0xfffffffe;
        }
        uVar4 = dirent_size(addr);
        st->st_size = uVar4;
        mVar5 = 0x8000;
      }
      st->st_mode = mVar5;
    }
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] dirent_file res = %d\r\n",TVar2,&DAT_23081ce8,"bl_romfs.c",0x1ea,
              uVar1);
    uVar1 = 0xffffffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int romfs_open(file_t *fp,char *path,int flags)

{
  bool bVar1;
  char cVar2;
  int iVar3;
  TickType_t TVar4;
  char *pcVar5;
  size_t sVar6;
  size_t sVar7;
  uint32_t uVar8;
  undefined4 uVar9;
  size_t unaff_s4;
  void *pvStack40;
  char *start_addr;
  char *end_addr;
  
  if (romfs_root == (char *)0x0) {
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    uVar9 = 0x162;
    pcVar5 = "[%10u][%s: %s:%4d] romfs_root is null.\r\n";
  }
  else {
    sVar6 = strlen(path);
    sVar7 = strlen("/romfs");
    iVar3 = strncmp(path,"/romfs",sVar7);
    if (iVar3 == 0) {
      sVar7 = 0;
      while (sVar6 != sVar7) {
        cVar2 = path[sVar7];
        if (0x19 < (byte)(cVar2 + 0x9fU)) {
          if (((byte)(cVar2 + 0xbfU) < 0x1a) || ((byte)(cVar2 - 0x30U) < 10)) {
            if (cVar2 == '/') goto LAB_2304a102;
          }
          else {
            if (cVar2 == '/') {
LAB_2304a102:
              if (sVar7 == 0) {
                unaff_s4 = 0;
              }
              else {
                bVar1 = sVar7 == unaff_s4;
                unaff_s4 = sVar7;
                if (bVar1) {
                  if (TrapNetCounter == 0) {
                    TVar4 = xTaskGetTickCount();
                  }
                  else {
                    TVar4 = xTaskGetTickCountFromISR();
                  }
                  uVar9 = 0x73;
                  pcVar5 = "[%10u][%s: %s:%4d] format error.\r\n";
                  goto LAB_2304a048;
                }
              }
            }
            else {
              if ((cVar2 != '_') && (1 < (byte)(cVar2 - 0x2dU))) {
                if (TrapNetCounter == 0) {
                  TVar4 = xTaskGetTickCount();
                }
                else {
                  TVar4 = xTaskGetTickCountFromISR();
                }
                bl_printk("[%10u][%s: %s:%4d] is_path_ch. i = %d\r\n",TVar4,&DAT_23072bcc,
                          "bl_romfs.c",0x69,sVar7);
                goto LAB_2304a0d4;
              }
            }
          }
        }
        sVar7 = sVar7 + 1;
      }
      uVar8 = dirent_file(path,&pvStack40,&start_addr);
      if (uVar8 == 0) {
        fp->offset = 0;
        fp->f_arg = pvStack40;
      }
      else {
        iVar3 = -2;
      }
      goto LAB_23049fb4;
    }
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    uVar9 = 0x61;
    pcVar5 = "[%10u][%s: %s:%4d] format is error.\r\n";
LAB_2304a048:
    bl_printk(pcVar5,TVar4,&DAT_23072bcc,"bl_romfs.c",uVar9);
LAB_2304a0d4:
    if (TrapNetCounter == 0) {
      TVar4 = xTaskGetTickCount();
    }
    else {
      TVar4 = xTaskGetTickCountFromISR();
    }
    uVar9 = 0x168;
    pcVar5 = "[%10u][%s: %s:%4d] path format is error.\r\n";
  }
  bl_printk(pcVar5,TVar4,&DAT_23072bcc,"bl_romfs.c",uVar9);
  iVar3 = -1;
LAB_23049fb4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



// WARNING: Variable defined which should be unmapped: info

int romfs_register(void)

{
  uint __s1;
  int iVar1;
  TickType_t TVar2;
  char *format;
  size_t __n;
  undefined4 uVar3;
  undefined auStack44 [4];
  bl_mtd_info_t info;
  
  iVar1 = bl_mtd_open("media",&handle_romfs,2);
  if (iVar1 == 0) {
    memset(auStack44,0,0x1c);
    bl_mtd_info(handle_romfs,(bl_mtd_info_t *)auStack44);
    __s1 = info.size;
    if ((void *)info.size == (void *)0x0) {
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x8d;
      format = "[%10u][%s: %s:%4d] romfs has no XIP-Addr\r\n";
    }
    else {
      __n = strlen("-rom1fs-");
      iVar1 = memcmp((void *)__s1,"-rom1fs-",__n);
      if (iVar1 == 0) {
        romfs_root = (char *)info.size;
        log_buf_out("bl_romfs.c",0x98,(void *)info.size,0x40,LOG_BUF_OUT_DATA_TYPE_HEX);
        iVar1 = aos_register_fs("/romfs",&romfs_ops,(void *)0x0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
      if (TrapNetCounter == 0) {
        TVar2 = xTaskGetTickCount();
      }
      else {
        TVar2 = xTaskGetTickCountFromISR();
      }
      uVar3 = 0x92;
      format = "[%10u][%s: %s:%4d] romfs magic is NOT correct\r\n";
    }
    bl_printk(format,TVar2,&DAT_23072bcc,"bl_romfs.c",uVar3);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] [EF] [PART] [XIP] error when get romfs partition %d\r\n",TVar2,
              &DAT_23072bcc,"bl_romfs.c",0x86,iVar1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void _startup_sntp(void *arg)

{
  puts("--------------------------------------- Start NTP now\r\n");
  sntp_setoperatingmode('\0');
  sntp_setservername('\0',"0.asia.pool.ntp.org");
  sntp_init();
  puts("--------------------------------------- Start NTP Done\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void cmd_sntp_date(char *buf,int len,int argc,char **argv)

{
  uint uStack44;
  uint32_t seconds;
  uint32_t frags;
  utils_time_date_t date;
  
  uStack44 = 0;
  seconds = 0;
  puts("test epoch from 1581863713 --->>>\r\n");
  puts("Should be Sunday, February 16, 2020 2:35:13 PM\r\n");
  utils_time_date_from_epoch(0x5e495321,(undefined *)&frags);
  printf("Date & time is: %u-%02u-%02u %02u:%02u:%02u (Day %u of week, Day %u of Year)\r\n",
         date._4_4_,(uint)date.ntp_minute,(uint)date.ntp_hour,(uint)(byte)frags,(uint)frags._1_1_,
         (uint)frags._2_1_,(uint)frags._3_1_);
  puts("SNTP GMT time is\r\n");
  sntp_get_time(&uStack44,&seconds);
  utils_time_date_from_epoch(uStack44,(undefined *)&frags);
  printf("Date & time is: %u-%02u-%02u %02u:%02u:%02u (Day %u of week, Day %u of Year)\r\n",
         date._4_4_,(uint)date.ntp_minute,(uint)date.ntp_hour,(uint)(byte)frags,(uint)frags._1_1_,
         (uint)frags._2_1_,(uint)frags._3_1_);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_sntp_time(char *buf,int len,int argc,char **argv)

{
  uint32_t uStack24;
  uint32_t seconds;
  uint32_t frags;
  
  uStack24 = 0;
  seconds = 0;
  sntp_get_time(&uStack24,&seconds);
  printf("[NTP] time is %lu:%lu\r\n",uStack24,seconds);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void cmd_sntp_start(char *buf,int len,int argc,char **argv)

{
  tcpip_callback(_startup_sntp,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int sntp_cli_init(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void sntp_retry(void *arg)

{
  uint uVar1;
  
  sys_timeout(sntp_retry_timeout,sntp_request,(void *)0x0);
  uVar1 = sntp_retry_timeout << 1;
  if ((uVar1 < 0x249f1) && (sntp_retry_timeout < uVar1)) {
    sntp_retry_timeout = uVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_recv(void *arg,udp_pcb *pcb,pbuf *p,ip_addr_t *addr,u16_t port)

{
  int iVar1;
  byte bVar2;
  u8_t uVar3;
  undefined3 extraout_var;
  u32_t uVar4;
  u32_t uVar5;
  uint uVar6;
  undefined2 in_register_0000203a;
  u32_t uStack40;
  sntp_timestamps timestamps;
  
  printf("SNTP time now\r\n",CONCAT22(in_register_0000203a,port));
  iVar1 = -0x10;
  if (p->tot_len == 0x30) {
    bVar2 = pbuf_get_at(p,0);
    if (sntp_opmode == '\0') {
      iVar1 = -3;
      if ((bVar2 & 7) != 4) goto LAB_2304a444;
    }
    else {
      iVar1 = -3;
      if ((sntp_opmode != '\x01') || ((bVar2 & 7) != 5)) goto LAB_2304a444;
    }
    uVar3 = pbuf_get_at(p,1);
    if (CONCAT31(extraout_var,uVar3) == 0) {
      printf("sntp_recv: Received Kiss-of-Death\r\n");
      iVar1 = 1;
    }
    else {
      pbuf_copy_partial(p,&uStack40,8,0x28);
      iVar1 = 0;
    }
  }
LAB_2304a444:
  pbuf_free(p);
  printf("Try process\r\n");
  if (iVar1 == 0) {
    uVar4 = lwip_htonl(uStack40);
    uVar5 = lwip_htonl(timestamps.xmit.sec);
    printf("Processing...\r\n");
    vTaskEnterCritical();
    ntp_frag = uVar5;
    ntp_sec = uVar4 + 0x7c558180;
    time_obtained = xTaskGetTickCount();
    uVar6 = ntp_frag / 1000 + ntp_sec * 1000;
    bl_sys_time_update(uVar6,(int)((ulonglong)ntp_sec * 1000 >> 0x20) +
                             (uint)(uVar6 < ntp_sec * 1000));
    vTaskExitCritical();
    printf("sntp_process: %ld, %lu us\r\n",uVar4 + 0x7c558180,
           (int)((ulonglong)uVar5 * 1000000 >> 0x20));
    sntp_servers[0].reachability = sntp_servers[0].reachability | 1;
    if (sntp_opmode == '\0') {
      sys_untimeout(sntp_retry,(void *)0x0);
      sys_untimeout(sntp_request,(void *)0x0);
      sntp_retry_timeout = 15000;
      sys_timeout(3600000,sntp_request,(void *)0x0);
    }
  }
  else {
    if ((iVar1 == 1) && (sntp_opmode == '\0')) {
      sntp_retry((void *)0x0);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_send_request(ip_addr_t *server_addr)

{
  undefined *__s;
  pbuf *p;
  code *handler;
  
  p = pbuf_alloc(PBUF_TRANSPORT,0x30,PBUF_RAM);
  if (p == (pbuf *)0x0) {
    handler = sntp_request;
  }
  else {
    __s = (undefined *)p->payload;
    memset(__s,0,0x30);
    *__s = 0x23;
    udp_sendto(sntp_pcb,p,server_addr,0x7b);
    pbuf_free(p);
    sntp_servers[0].reachability = sntp_servers[0].reachability << 1;
    handler = sntp_retry;
  }
  sys_timeout(15000,handler,(void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_request(void *arg)

{
  err_t eVar1;
  undefined3 extraout_var;
  ip_addr_t iStack20;
  ip_addr_t sntp_server_address;
  
  if (sntp_servers[0].name == (char *)0x0) {
    iStack20 = sntp_servers[0].addr;
    if (sntp_servers[0].addr == 0) {
LAB_2304a64e:
      sys_timeout(15000,sntp_retry,(void *)0x0);
      goto LAB_2304a640;
    }
  }
  else {
    sntp_servers[0].addr = 0;
    eVar1 = dns_gethostbyname(sntp_servers[0].name,&iStack20,sntp_dns_found,(void *)0x0);
    if (CONCAT31(extraout_var,eVar1) == -5) goto LAB_2304a640;
    if (CONCAT31(extraout_var,eVar1) != 0) goto LAB_2304a64e;
  }
  sntp_servers[0].addr = iStack20;
  sntp_send_request(&iStack20);
LAB_2304a640:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_dns_found(char *hostname,ip_addr_t *ipaddr,void *arg)

{
  if (ipaddr != (ip_addr_t *)0x0) {
    sntp_servers[0].addr = ipaddr->addr;
    sntp_send_request(ipaddr);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  sntp_retry((void *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_init(void)

{
  udp_pcb *pcb;
  uint uVar1;
  
  if (sntp_pcb == (udp_pcb *)0x0) {
    sntp_pcb = udp_new_ip_type();
    printf("[SNTP] pcb isready, %p\r\n");
    if (sntp_pcb != (udp_pcb *)0x0) {
      udp_recv(sntp_pcb,sntp_recv,(void *)0x0);
      pcb = sntp_pcb;
      if (sntp_opmode == '\0') {
        sntp_retry_timeout = 15000;
        uVar1 = bl_rand();
        sys_timeout(uVar1 % 5000,sntp_request,(void *)0x0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      if (sntp_opmode == '\x01') {
        sntp_pcb->so_options = sntp_pcb->so_options | 0x20;
        udp_bind(pcb,&ip_addr_any,0x7b);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sntp_setoperatingmode(u8_t operating_mode)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  sntp_opmode = operating_mode;
  return;
}



int sntp_get_time(uint32_t *seconds,uint32_t *frags)

{
  TickType_t TVar1;
  int iVar2;
  uint uVar3;
  
  vTaskEnterCritical();
  if (ntp_sec == 0) {
    *seconds = 0;
    *frags = 0;
  }
  else {
    TVar1 = xTaskGetTickCount();
    iVar2 = TVar1 - time_obtained;
    uVar3 = ntp_frag / 1000;
    *seconds = iVar2 / 1000 + ntp_sec;
    *frags = iVar2 % 1000 + uVar3;
  }
  vTaskExitCritical();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void sntp_setservername(u8_t idx,char *server)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,idx) == 0) {
    sntp_servers[0].name = server;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



char * utils_bin2hex(char *dst,void *src,size_t count)

{
  char cVar1;
  byte *pbVar2;
  char *pcVar3;
  
  pbVar2 = (byte *)src;
  pcVar3 = dst;
  while (pbVar2 != (byte *)((int)src + count)) {
    cVar1 = "0123456789ABCDEF"[*pbVar2 & 0xf];
    *pcVar3 = "0123456789ABCDEF"[*pbVar2 >> 4];
    pcVar3[1] = cVar1;
    pbVar2 = pbVar2 + 1;
    pcVar3 = pcVar3 + 2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return dst + count * 2;
}



void utils_sha256_init(iot_sha256_context *ctx)

{
  memset(ctx,0,0x6c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_sha256_free(iot_sha256_context *ctx)

{
  iot_sha256_context *piVar1;
  
  piVar1 = ctx + 1;
  if (ctx != (iot_sha256_context *)0x0) {
    while (ctx != piVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (iot_sha256_context *)((int)ctx->total + 1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_sha256_starts(iot_sha256_context *ctx)

{
  ctx->state[0] = 0x6a09e667;
  ctx->state[1] = 0xbb67ae85;
  ctx->state[2] = 0x3c6ef372;
  ctx->state[3] = 0xa54ff53a;
  ctx->state[4] = 0x510e527f;
  ctx->state[5] = 0x9b05688c;
  ctx->state[6] = 0x1f83d9ab;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[7] = 0x5be0cd19;
  ctx->is224 = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_sha256_process(iot_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint *puVar9;
  uint32_t *puVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint32_t *puVar22;
  uint32_t *puVar23;
  uint uVar24;
  uint32_t uVar25;
  uint uVar26;
  uint32_t *puVar27;
  uint32_t uVar28;
  uint local_150;
  uint32_t A [8];
  uint32_t W [64];
  
  puVar18 = &local_150;
  puVar9 = &local_150;
  puVar10 = ctx->state;
  do {
    uVar7 = *puVar10;
    puVar10 = puVar10 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar10);
  puVar22 = A + 7;
  pbVar3 = data;
  puVar10 = puVar22;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar10 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
               (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar10 = puVar10 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar10 = K;
  puVar27 = puVar22;
  do {
    puVar23 = puVar10 + 8;
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + *puVar10 + *puVar27 +
                    ((A[5] ^ A[4]) & A[3] ^ A[5]);
    uVar12 = A[2] + iVar13;
    uVar14 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             A[5] + puVar10[1] + puVar27[1] + ((A[3] ^ A[4]) & uVar12 ^ A[4]);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) + ((uVar14 | local_150) & A[0] | uVar14 & local_150)
            + iVar13;
    uVar11 = A[1] + iVar13;
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             A[4] + puVar10[2] + puVar27[2] + ((uVar12 ^ A[3]) & uVar11 ^ A[3]);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & local_150 | uVar14 & uVar1) +
            iVar13;
    uVar8 = A[0] + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             A[3] + puVar10[3] + puVar27[3] + ((uVar12 ^ uVar11) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = local_150 + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar10[4] + puVar27[4] + ((uVar11 ^ uVar8) & uVar6 ^ uVar11);
    A[2] = ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
           (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) + iVar13
    ;
    A[6] = uVar14 + iVar13;
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             uVar11 + puVar10[5] + puVar27[5] + ((uVar8 ^ uVar6) & A[6] ^ uVar8);
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar16 | A[2]) & uVar5 | uVar16 & A[2]) + iVar13;
    A[5] = uVar1 + iVar13;
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             uVar8 + puVar10[6] + puVar27[6] + ((uVar6 ^ A[6]) & A[5] ^ uVar6);
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar16 | A[2] & A[1]) + iVar13;
    A[4] = uVar5 + iVar13;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar6 + puVar10[7] + puVar27[7] + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    A[3] = uVar16 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar10 = puVar23;
    puVar27 = puVar27 + 8;
  } while (puVar23 != K + 0x10);
  do {
    uVar19 = puVar22[0xe];
    uVar1 = puVar22[1];
    uVar20 = puVar22[0xf];
    uVar24 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar22[9] + *puVar22 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar11 = puVar22[3];
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + ((A[5] ^ A[4]) & A[3] ^ A[5]) + puVar2[0x10] +
                    uVar24;
    uVar16 = A[2] + iVar13;
    uVar15 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    uVar6 = puVar22[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar22[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[3] ^ A[4]) & uVar16 ^ A[4]) + A[5] + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) + ((local_150 | uVar15) & A[0] | local_150 & uVar15)
            + iVar13;
    uVar14 = A[1] + iVar13;
    uVar6 = ((uVar24 * 0x8000 | uVar24 >> 0x11) ^ (uVar24 * 0x2000 | uVar24 >> 0x13) ^ uVar24 >> 10)
            + uVar6 + puVar22[0xb] +
            ((uVar11 >> 7 | uVar11 << 0x19) ^ (uVar11 << 0xe | uVar11 >> 0x12) ^ uVar11 >> 3);
    iVar13 = ((A[3] ^ uVar16) & uVar14 ^ A[3]) + A[4] + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar22[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & local_150 | uVar15 & uVar5) +
            iVar13;
    uVar12 = A[0] + iVar13;
    uVar26 = puVar22[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar11 + puVar22[0xc] +
            ((uVar26 >> 7 | uVar26 << 0x19) ^ (uVar26 << 0xe | uVar26 >> 0x12) ^ uVar26 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + A[3] + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar11 = local_150 + iVar13;
    puVar22[0x12] = uVar6;
    uVar21 = puVar22[5];
    uVar26 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar26 + puVar22[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar11 ^ uVar14) + uVar16 + puVar2[0x14] + uVar26;
    A[2] = ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
           (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) + iVar13
    ;
    A[6] = uVar15 + iVar13;
    uVar6 = puVar22[6];
    puVar22[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             ((uVar12 ^ uVar11) & A[6] ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar17 | A[2]) & uVar8 | uVar17 & A[2]) + iVar13;
    A[5] = uVar5 + iVar13;
    uVar1 = puVar22[7];
    puVar22[0x14] = uVar26;
    uVar7 = uVar20 + uVar6 +
            ((uVar26 * 0x8000 | uVar26 >> 0x11) ^ (uVar26 * 0x2000 | uVar26 >> 0x13) ^ uVar26 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             ((uVar11 ^ A[6]) & A[5] ^ uVar11) + uVar12 + puVar2[0x16] + uVar7;
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar17 | A[2] & A[1]) + iVar13;
    A[4] = uVar8 + iVar13;
    uVar5 = puVar22[8];
    puVar22[0x15] = uVar16;
    puVar22[0x10] = uVar24;
    uVar28 = puVar2[0x17];
    uVar25 = uVar24 + uVar1 +
             ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10
             ) + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar22[0x17] = uVar25;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar11 + uVar28 + uVar25 + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    puVar22[0x16] = uVar7;
    puVar22 = puVar22 + 8;
    A[3] = uVar17 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar2 = puVar2 + 8;
  } while (W + 0x2f != puVar22);
  puVar10 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar22 = puVar10 + 1;
    puVar18 = (uint *)((int *)puVar18 + 1);
    *puVar10 = *puVar10 + iVar13;
    puVar10 = puVar22;
  } while ((uint32_t *)ctx->buffer != puVar22);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_sha256_update(iot_sha256_context *ctx,uchar *input,uint32_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    utils_sha256_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    utils_sha256_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_sha256_update(iot_sha256_context *ctx,uchar *input,uint32_t ilen)

{
  if (ilen != 0) {
    utils_sha256_update(ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

void utils_sha256_finish(iot_sha256_context *ctx,uint8_t *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  utils_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  utils_sha256_update(ctx,&uStack24,8);
  *output = *(uint8_t *)((int)ctx->state + 3);
  output[1] = (uint8_t)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uint8_t)(ctx->state[0] >> 8);
  output[3] = (uint8_t)ctx->state[0];
  output[4] = *(uint8_t *)((int)ctx->state + 7);
  output[5] = (uint8_t)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uint8_t)(ctx->state[1] >> 8);
  output[7] = (uint8_t)ctx->state[1];
  output[8] = *(uint8_t *)((int)ctx->state + 0xb);
  output[9] = (uint8_t)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uint8_t)(ctx->state[2] >> 8);
  output[0xb] = (uint8_t)ctx->state[2];
  output[0xc] = *(uint8_t *)((int)ctx->state + 0xf);
  output[0xd] = (uint8_t)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uint8_t)(ctx->state[3] >> 8);
  output[0xf] = (uint8_t)ctx->state[3];
  output[0x10] = *(uint8_t *)((int)ctx->state + 0x13);
  output[0x11] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uint8_t)(ctx->state[4] >> 8);
  output[0x13] = (uint8_t)ctx->state[4];
  output[0x14] = *(uint8_t *)((int)ctx->state + 0x17);
  output[0x15] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uint8_t)(ctx->state[5] >> 8);
  output[0x17] = (uint8_t)ctx->state[5];
  output[0x18] = *(uint8_t *)((int)ctx->state + 0x1b);
  output[0x19] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uint8_t)(ctx->state[6] >> 8);
  output[0x1b] = (uint8_t)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uint8_t *)((int)ctx->state + 0x1f);
    output[0x1d] = (uint8_t)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uint8_t)(ctx->state[7] >> 8);
    output[0x1f] = (uint8_t)ctx->state[7];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bl_printk(char *format,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list args;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(format,&uStack28);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int log_buf_out(char *file,int line,void *inbuf,int len,LOG_BUF_OUT_DATA_TYPE_T type)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  TickType_t TVar4;
  char *pcVar5;
  uint uVar6;
  undefined3 in_register_00002039;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  void *pvVar11;
  
  iVar7 = CONCAT31(in_register_00002039,type);
  if (len < 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  iVar10 = len / 0x32;
  if (len % 0x32 == 0) {
    pvVar11 = (void *)(iVar10 * 0x32 + (int)inbuf);
    while (pvVar11 != inbuf) {
      iVar8 = 0;
      iVar10 = 0;
      do {
        uVar6 = (uint)*(byte *)((int)inbuf + iVar10);
        if (iVar7 == 1) {
          uVar6 = SEXT14((char)*(byte *)((int)inbuf + iVar10));
          pcVar5 = "%3d ";
        }
        else {
          pcVar5 = "%3u ";
          if (iVar7 != 2) {
            pcVar5 = "%02x ";
          }
        }
        iVar3 = sprintf(log_buf + iVar8,pcVar5,uVar6);
        iVar10 = iVar10 + 1;
        iVar8 = iVar8 + iVar3;
      } while (iVar10 != 0x32);
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2308789c,file,line,iVar8,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
    }
  }
  else {
    iVar8 = 0;
    do {
      iVar3 = 0;
      iVar9 = 0;
      if (iVar10 == iVar8) {
        do {
          uVar6 = (uint)*(byte *)((int)inbuf + iVar9);
          if (iVar7 == 1) {
            uVar6 = SEXT14((char)*(byte *)((int)inbuf + iVar9));
            pcVar5 = "%3d ";
          }
          else {
            pcVar5 = "%3u ";
            if (iVar7 != 2) {
              pcVar5 = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,pcVar5,uVar6);
          iVar9 = iVar9 + 1;
          iVar3 = iVar3 + iVar2;
        } while (len % 0x32 != iVar9);
      }
      else {
        do {
          uVar6 = (uint)*(byte *)((int)inbuf + iVar9);
          if (iVar7 == 1) {
            uVar6 = SEXT14((char)*(byte *)((int)inbuf + iVar9));
            pcVar5 = "%3d ";
          }
          else {
            pcVar5 = "%3u ";
            if (iVar7 != 2) {
              pcVar5 = "%02x ";
            }
          }
          iVar2 = sprintf(log_buf + iVar3,pcVar5,uVar6);
          iVar9 = iVar9 + 1;
          iVar3 = iVar3 + iVar2;
        } while (iVar9 != 0x32);
      }
      if (TrapNetCounter == 0) {
        TVar4 = xTaskGetTickCount();
      }
      else {
        TVar4 = xTaskGetTickCountFromISR();
      }
      bl_printk("[%10u][%s: %s:%4d] %.*s\r\n",TVar4,&UNK_2308789c,file,line,iVar3,log_buf);
      inbuf = (void *)((int)inbuf + 0x32);
      bVar1 = iVar8 < iVar10;
      iVar8 = iVar8 + 1;
    } while (bVar1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int utils_dns_domain_get(uint8_t *records,uint8_t *buf,int *len)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  iVar6 = *len;
  uVar3 = (uint)*records;
  iVar2 = 1;
  iVar5 = 0;
  while ((iVar4 = iVar5, iVar1 = iVar2, uVar3 != 0 && (0 < iVar6))) {
    uVar3 = uVar3 - 1;
    buf[iVar4] = records[iVar1];
    iVar2 = iVar1 + 1;
    iVar5 = iVar4 + 1;
    iVar6 = iVar6 + -1;
    if ((uVar3 == 0) && (iVar6 != 0)) {
      buf[iVar5] = '.';
      uVar3 = (uint)records[iVar2];
      iVar2 = iVar1 + 2;
      iVar5 = iVar4 + 2;
    }
  }
  *len = iVar4;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void utils_list_init(utils_list *list)

{
  list->first = (utils_list_hdr *)0x0;
  list->last = (utils_list_hdr *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void utils_list_push_back(utils_list *list,utils_list_hdr *list_hdr)

{
  if (list->first == (utils_list_hdr *)0x0) {
    list->first = list_hdr;
  }
  else {
    list->last->next = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = (utils_list_hdr *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



utils_list_hdr * utils_list_pop_front(utils_list *list)

{
  utils_list_hdr *puVar1;
  
  puVar1 = list->first;
  if (puVar1 != (utils_list_hdr *)0x0) {
    list->first = puVar1->next;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return puVar1;
}



void utils_hexdump(void *mem,uint len)

{
  uint uVar1;
  int iVar2;
  uint c;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  iVar2 = 0;
  if ((len & 0xf) != 0) {
    iVar2 = 0x10 - (len & 0xf);
  }
  uVar4 = 0;
  while (uVar1 = uVar4, iVar2 + len != uVar1) {
    if ((uVar1 & 0xf) == 0) {
      printf("0x%06x: ",uVar1);
    }
    if (uVar1 < len) {
      printf("%02x ",(uint)*(byte *)((int)mem + uVar1));
    }
    else {
      printf("   ");
    }
    uVar4 = uVar1 + 1;
    if ((uVar1 & 0xf) == 0xf) {
      uVar5 = uVar1 - 0xf;
      iVar3 = 0x11;
      if (uVar4 < uVar5) {
        iVar3 = 1;
      }
      while (uVar5 != (uVar1 - 0x10) + iVar3) {
        c = 0x20;
        if ((uVar5 < len) && (c = (uint)*(byte *)((int)mem + uVar5), (_ctype_[c + 1] & 0x97) == 0))
        {
          c = 0x2e;
        }
        bl_putchar(c);
        uVar5 = uVar5 + 1;
      }
      puts("\r\n");
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



undefined4 utils_time_date_from_epoch(uint param_1,undefined *param_2)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  undefined4 uStack20;
  undefined2 uStack16;
  undefined uStack14;
  char cStack13;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack12 = 0x1e1f1c1f;
  uStack8 = 0x1f1f1e1f;
  uStack4 = 0x1f1e1f1e;
  uStack20 = 0x60504;
  uStack16 = 0x201;
  uStack14 = 3;
  *(undefined2 *)(param_2 + 6) = 0;
  param_2[2] = (char)(param_1 % 0x3c);
  param_2[1] = (char)((param_1 / 0x3c) % 0x3c);
  *param_2 = (char)((param_1 / 0xe10) % 0x18);
  uVar4 = param_1 / 0x15180;
  *(uint *)(param_2 + 0xc) = uVar4;
  param_2[3] = *(undefined *)((int)&uStack20 + uVar4 % 7);
  uVar3 = 0x7b4;
  uVar2 = param_1 / 0x1e13380 + 0x7b2;
  *(uint *)(param_2 + 8) = uVar2;
  while (uVar3 < uVar2) {
    if (((int)uVar3 % 100 != 0) || ((int)uVar3 % 400 == 0)) {
      param_2[6] = param_2[6] + '\x01';
    }
    uVar3 = uVar3 + 4;
  }
  uVar2 = (uVar4 - (byte)param_2[6]) / 0x16d + 0x7b2;
  *(uint *)(param_2 + 8) = uVar2;
  uVar3 = (uVar4 - (byte)param_2[6]) % 0x16d + 1;
  *(uint *)(param_2 + 0x10) = uVar3;
  if ((((uVar2 & 3) == 0) && (uVar2 % 100 != 0)) || (uVar2 % 400 == 0)) {
    uStack12 = 0x1e1f1d1f;
    param_2[7] = 1;
  }
  param_2[5] = 0;
  uVar2 = 0;
  while( true ) {
    uVar4 = (uint)(byte)param_2[5];
    if ((0xb < uVar4) || (uVar3 <= uVar2)) break;
    bVar1 = *(byte *)((int)&uStack12 + uVar4);
    param_2[5] = param_2[5] + 1;
    uVar2 = uVar2 + bVar1 & 0xffff;
  }
  param_2[4] = (char)uVar3 - ((char)uVar2 - (&cStack13)[uVar4]);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int utils_getopt_init(getopt_env_t *env,int opterr)

{
  if (env != (getopt_env_t *)0x0) {
    env->optarg = (char *)0x0;
    env->optind = 1;
    env->opterr = opterr;
    env->optopt = 0;
    env->__optpos = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int utils_getopt(getopt_env_t *env,int argc,char **argv,char *optstring)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  char **ppcVar5;
  int iVar6;
  byte *pbVar7;
  char *pcVar8;
  byte *pbVar9;
  
  if (env == (getopt_env_t *)0x0) {
LAB_2304bc30:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xffffffff;
  }
  iVar6 = env->optind;
  if (argc <= iVar6) {
LAB_2304bd32:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xffffffff;
  }
  ppcVar5 = argv + iVar6;
  pcVar8 = *ppcVar5;
  if (pcVar8 == (char *)0x0) goto LAB_2304bd32;
  if (*pcVar8 != '-') {
    if (*optstring == '-') {
      env->optind = iVar6 + 1;
      env->optarg = *ppcVar5;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 1;
    }
    goto LAB_2304bd32;
  }
  if (pcVar8[1] == '\0') goto LAB_2304bd32;
  if ((pcVar8[1] == '-') && (pcVar8[2] == '\0')) {
    env->optind = iVar6 + 1;
    goto LAB_2304bc30;
  }
  if (env->__optpos == 0) {
    env->__optpos = 1;
  }
  pbVar9 = (byte *)(*ppcVar5 + env->__optpos);
  uVar4 = (uint)*pbVar9;
  iVar2 = (uint)(uVar4 != 0) + env->__optpos;
  env->__optpos = iVar2;
  if ((*ppcVar5)[iVar2] == '\0') {
    env->optind = iVar6 + 1;
    env->__optpos = 0;
  }
  if ((*optstring - 0x2bU & 0xfd) == 0) {
    optstring = optstring + 1;
  }
  iVar6 = 0;
  do {
    iVar2 = iVar6 + 1;
    pbVar7 = (byte *)(optstring + iVar6);
    uVar3 = (uint)*pbVar7;
    if (uVar3 == 0) {
      if (uVar4 == 0) goto LAB_2304bcb4;
      goto LAB_2304bc96;
    }
    iVar6 = iVar2;
  } while (uVar4 != uVar3);
  if (uVar4 == 0x3a) {
LAB_2304bc96:
    env->optopt = uVar4;
    if ((*optstring != ':') && (env->opterr != 0)) {
      bVar1 = *pbVar9;
      pcVar8 = *argv;
      iVar6 = -0x728;
LAB_2304bd2c:
      printf("ERROR failed! net_set_(non)block() returned -0x%x\r\n" + iVar6 + 0x14,pcVar8,
             (uint)bVar1);
    }
  }
  else {
LAB_2304bcb4:
    if (optstring[iVar2] != ':') goto LAB_2304bca8;
    env->optarg = (char *)0x0;
    iVar6 = env->__optpos;
    if ((pbVar7[2] != 0x3a) || (iVar6 != 0)) {
      iVar2 = env->optind;
      env->optind = iVar2 + 1;
      pcVar8 = argv[iVar2];
      env->__optpos = 0;
      env->optarg = pcVar8 + iVar6;
    }
    if (env->optind <= argc) goto LAB_2304bca8;
    env->optopt = uVar4;
    uVar4 = 0x3a;
    if (*optstring == ':') goto LAB_2304bca8;
    if (env->opterr != 0) {
      bVar1 = *pbVar9;
      pcVar8 = *argv;
      iVar6 = -0x708;
      goto LAB_2304bd2c;
    }
  }
  uVar4 = 0x3f;
LAB_2304bca8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar4;
}



// WARNING: Variable defined which should be unmapped: pTemp

void Bl_F_fast(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int count,
              uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack40;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack40 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = '\0';
  puVar3[3] = (uchar)count;
  puVar3[1] = '\0';
  puVar3[2] = '\0';
  bl_sha_mutex_take();
  utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 0xfff;
  tmpLen = (int)digest1;
  do {
    iStack40 = 0x14;
    utils_hmac_sha1_fast((uchar **)&tmpLen,&iStack40,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  bl_sha_mutex_give();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int utils_wifi_psk_cal_fast_bin(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F_fast(digest1 + 0x10,auStack88,password,ssid,ssidlength,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



// WARNING: Type propagation algorithm not settling

int utils_memp_init(utils_memp_pool_t **pool,uint16_t node_size,uint16_t pool_cap,uint8_t align_req)

{
  uint uVar1;
  uint uVar2;
  utils_memp_pool_t *puVar3;
  int iVar4;
  undefined2 in_register_0000202e;
  undefined2 in_register_00002032;
  uint32_t uVar5;
  utils_memp_node uVar6;
  uint32_t uVar7;
  utils_memp_node uVar8;
  uint uVar9;
  
  uVar5 = CONCAT22(in_register_00002032,pool_cap);
  uVar9 = align_req + 3 & 0xfc;
  uVar2 = CONCAT22(in_register_0000202e,node_size) + 3 + uVar9 & -uVar9 & 0xffff;
  uVar1 = -uVar9 & uVar9 + 0x1f;
  puVar3 = (utils_memp_pool_t *)pvPortMalloc(uVar2 * uVar5 + uVar1);
  if (puVar3 == (utils_memp_pool_t *)0x0) {
    iVar4 = -1;
  }
  else {
    uVar8 = (utils_memp_node)((int)&puVar3->node_size + uVar1);
    ((utils_memp_node *)&puVar3->first_node)->next = (utils_memp_node *)uVar8;
    puVar3->node_size = CONCAT22(in_register_0000202e,node_size);
    puVar3->pool_cap = uVar5;
    puVar3->pool_size = 0;
    puVar3->align_req = (uint8_t)uVar9;
    puVar3->padded_node_size = uVar2;
    puVar3->mem = (utils_memp_node *)0x0;
    uVar7 = 0;
    uVar6 = (utils_memp_node)0x0;
    while (uVar7 != uVar5) {
      *(utils_memp_node *)uVar8 = uVar6;
      uVar7 = uVar7 + 1 & 0xffff;
      uVar6 = uVar8;
      uVar8 = (utils_memp_node)((int)uVar8 + uVar2);
    }
    ((utils_memp_node *)&puVar3->mem)->next = (utils_memp_node *)uVar6;
    ((utils_memp_node *)&puVar3->last_node)->next = (utils_memp_node *)uVar6;
    *pool = puVar3;
    iVar4 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int utils_memp_deinit(utils_memp_pool_t *pool)

{
  if (pool != (utils_memp_pool_t *)0x0) {
    vPortFree(pool);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void * utils_memp_malloc(utils_memp_pool_t *pool)

{
  utils_memp_node *puVar1;
  utils_memp_node *puVar2;
  
  puVar2 = (utils_memp_node *)0x0;
  if (pool != (utils_memp_pool_t *)0x0) {
    puVar2 = (utils_memp_node *)0x0;
    if ((pool->pool_size != pool->pool_cap) &&
       (puVar2 = pool->mem, puVar2 != (utils_memp_node *)0x0)) {
      puVar1 = puVar2->next;
      pool->pool_size = pool->pool_size + 1;
      pool->mem = puVar1;
      puVar2->next = (utils_memp_node *)0xa5;
      puVar2 = puVar2 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return puVar2;
}



int utils_memp_free(utils_memp_pool_t *pool,void *node)

{
  utils_memp_node *puVar1;
  
  puVar1 = (utils_memp_node *)((int)node + -4);
  if ((((pool != (utils_memp_pool_t *)0x0) && (puVar1 != (utils_memp_node *)0x0)) &&
      (pool->pool_size != 0)) &&
     ((((utils_memp_node *)pool->first_node <= puVar1 &&
       (puVar1 <= (utils_memp_node *)pool->last_node)) &&
      (((uint)((int)puVar1 - (int)(utils_memp_node *)pool->first_node) % pool->padded_node_size == 0
       && (*(int *)((int)node + -4) == 0xa5)))))) {
    *(utils_memp_node **)((int)node + -4) = pool->mem;
    pool->mem = puVar1;
    pool->pool_size = pool->pool_size - 1;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int utils_tlv_bl_pack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  undefined2 in_register_00002032;
  uint32_t uVar1;
  int iVar2;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint32_t)*arg1;
  }
  else {
    if (CONCAT22(in_register_00002032,type) != 7) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -2;
    }
                    // WARNING: Load size is inaccurate
    uVar1 = *arg1;
  }
  iVar2 = -1;
  if (3 < buf_sz) {
    *buf = uVar1;
    iVar2 = 4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int utils_tlv_bl_unpack_auto(uint32_t *buf,int buf_sz,uint16_t type,void *arg1)

{
  int iVar1;
  undefined2 in_register_00002032;
  bool bVar2;
  uint32_t uVar3;
  
  if (CONCAT22(in_register_00002032,type) == 1) {
    if (buf_sz < 4) {
      bVar2 = true;
      iVar1 = -1;
    }
    else {
      iVar1 = 4;
      bVar2 = *buf != 0;
    }
    *(bool *)arg1 = bVar2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (CONCAT22(in_register_00002032,type) != 7) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -2;
  }
  if (buf_sz < 4) {
    uVar3 = 0;
    iVar1 = -1;
  }
  else {
    uVar3 = *buf;
    iVar1 = 4;
  }
  *(uint32_t *)arg1 = uVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void utils_hmac_sha1_fast
               (uchar **ppText,int *pTextLen,int textNum,uchar *key,int key_len,uchar *output,
               int outputLen)

{
  uint *puVar1;
  uint32_t *puVar2;
  uint *puVar3;
  uchar **ppuVar4;
  int iVar5;
  uint *hash;
  uint local_120;
  uint64_t pBuf [11];
  undefined auStack196 [4];
  bl_sha_ctx_t sha_ctx;
  
  if (0x40 < key_len) {
    bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
    bl_sha_update((bl_sha_ctx_t *)auStack196,key,key_len);
    bl_sha_finish((bl_sha_ctx_t *)auStack196,key);
    key_len = 0x14;
  }
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  hash = (uint *)((int)pBuf + 0x3c);
  puVar1 = &local_120;
  do {
    puVar3 = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x36363636;
    puVar1[1] = puVar1[1] ^ 0x36363636;
    puVar1 = puVar3;
  } while (puVar3 != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  iVar5 = 0;
  while (iVar5 < textNum) {
    puVar2 = (uint32_t *)(pTextLen + iVar5);
    ppuVar4 = ppText + iVar5;
    iVar5 = iVar5 + 1;
    bl_sha_update((bl_sha_ctx_t *)auStack196,*ppuVar4,*puVar2);
  }
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)hash);
  memset(&local_120,0,0x40);
  memcpy(&local_120,key,key_len);
  puVar1 = &local_120;
  do {
    puVar3 = puVar1 + 2;
    *puVar1 = *puVar1 ^ 0x5c5c5c5c;
    puVar1[1] = puVar1[1] ^ 0x5c5c5c5c;
    puVar1 = puVar3;
  } while (puVar3 != hash);
  bl_sha_init((bl_sha_ctx_t *)auStack196,BL_SHA1);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)&local_120,0x40);
  bl_sha_update((bl_sha_ctx_t *)auStack196,(uint8_t *)puVar3,0x14);
  bl_sha_finish((bl_sha_ctx_t *)auStack196,(uint8_t *)puVar3);
  memcpy(output,puVar3,outputLen);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int vfs_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if (g_vfs_init != '\x01') {
    g_vfs_mutex = (SemaphoreHandle_t)xQueueCreateMutexStatic('\x01',(StaticQueue_t *)&xMutexBuffer);
    iVar1 = -1;
    if (g_vfs_mutex != (SemaphoreHandle_t)0x0) {
      inode_init();
      iVar1 = 0;
      g_vfs_init = '\x01';
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int aos_open(char *path,int flags)

{
  size_t sVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  int iVar3;
  code *pcVar4;
  
  if (path == (char *)0x0) {
    iVar3 = -0x16;
  }
  else {
    sVar1 = strlen(path);
    if (0x400 < sVar1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x5b;
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -2;
    }
    node->i_flags = flags;
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x17;
    }
    pcVar4 = *(code **)node->ops;
    if (node->type == '\x03') {
      if (pcVar4 == (code *)0x0) goto LAB_2304c23a;
      iVar3 = (*pcVar4)(file,path,flags);
    }
    else {
      if (pcVar4 == (code *)0x0) goto LAB_2304c23a;
      iVar3 = (*pcVar4)(node,file);
    }
    if (iVar3 == 0) {
LAB_2304c23a:
      iVar3 = get_fd(file);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar3;
    }
    del_file(file);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int aos_close(int fd)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  file = get_file(fd);
  iVar1 = -2;
  if (file != (file_t *)0x0) {
    iVar1 = 0;
    pcVar3 = *(code **)(file->node->ops + 4);
    if (pcVar3 != (code *)0x0) {
      iVar1 = (*pcVar3)();
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    }
    else {
      iVar1 = -1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



ssize_t aos_read(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 8);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c2d6. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return sVar2;
    }
    sVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar2;
}



ssize_t aos_write(int fd,void *buf,size_t nbytes)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  ssize_t sVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    sVar2 = -2;
  }
  else {
    UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0xc);
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c304. Too many branches
                    // WARNING: Treating indirect jump as call
      sVar2 = (*UNRECOVERED_JUMPTABLE)(buf,nbytes);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return sVar2;
    }
    sVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar2;
}



int aos_ioctl(int fd,int cmd,ulong arg)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  int iVar2;
  
  if (fd < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x16;
  }
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    iVar2 = -2;
  }
  else {
    iVar2 = pfVar1->node->ops;
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x44);
    }
    else {
      UNRECOVERED_JUMPTABLE = *(code **)(iVar2 + 0x10);
    }
    if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c340. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(cmd,arg);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    iVar2 = -0x58;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



off_t aos_lseek(int fd,off_t offset,int whence)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  off_t oVar2;
  
  pfVar1 = get_file(fd);
  if (pfVar1 == (file_t *)0x0) {
    oVar2 = -2;
  }
  else {
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0x10);
      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c384. Too many branches
                    // WARNING: Treating indirect jump as call
        oVar2 = (*UNRECOVERED_JUMPTABLE)(offset,whence);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return oVar2;
      }
    }
    oVar2 = -0x58;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return oVar2;
}



int aos_stat(char *path,stat *st)

{
  int iVar1;
  BaseType_t BVar2;
  inode_t *node;
  file_t *file;
  code *pcVar3;
  
  if (path == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x16;
  }
  BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar2 == 1) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x13;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file == (file_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -2;
    }
    iVar1 = -0x58;
    if ((node->type == '\x03') && (pcVar3 = *(code **)(node->ops + 0x18), pcVar3 != (code *)0x0)) {
      iVar1 = (*pcVar3)(file,path,st);
    }
    BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
    if (BVar2 == 1) {
      del_file(file);
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



aos_dir_t * aos_opendir(char *path)

{
  BaseType_t BVar1;
  inode_t *node;
  file_t *file;
  aos_dir_t *paVar2;
  int iVar3;
  code *pcVar4;
  
  if ((path != (char *)0x0) &&
     (BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff), BVar1 == 1)) {
    node = inode_open(path);
    if (node == (inode_t *)0x0) {
      xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (aos_dir_t *)0x0;
    }
    file = new_file(node);
    xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (file != (file_t *)0x0) {
      if (((node->type == '\x03') && (pcVar4 = *(code **)(node->ops + 0x24), pcVar4 != (code *)0x0))
         && (paVar2 = (aos_dir_t *)(*pcVar4)(file,path), paVar2 != (aos_dir_t *)0x0)) {
        iVar3 = get_fd(file);
        paVar2->dd_vfs_fd = iVar3;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return paVar2;
      }
      BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar1 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (aos_dir_t *)0x0;
}



int aos_closedir(aos_dir_t *dir)

{
  int iVar1;
  file_t *file;
  BaseType_t BVar2;
  code *pcVar3;
  
  iVar1 = -0x16;
  if (dir != (aos_dir_t *)0x0) {
    iVar1 = -2;
    file = get_file(dir->dd_vfs_fd);
    if (file != (file_t *)0x0) {
      iVar1 = -0x58;
      if ((file->node->type == '\x03') &&
         (pcVar3 = *(code **)(file->node->ops + 0x2c), pcVar3 != (code *)0x0)) {
        iVar1 = (*pcVar3)(dir);
      }
      BVar2 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
      if (BVar2 == 1) {
        del_file(file);
        xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
      }
      else {
        iVar1 = -1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



aos_dirent_t * aos_readdir(aos_dir_t *dir)

{
  code *UNRECOVERED_JUMPTABLE;
  file_t *pfVar1;
  aos_dirent_t *paVar2;
  
  if (dir == (aos_dir_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (aos_dirent_t *)0x0;
  }
  pfVar1 = get_file(dir->dd_vfs_fd);
  if (pfVar1 != (file_t *)0x0) {
    if (pfVar1->node->type == '\x03') {
      UNRECOVERED_JUMPTABLE = *(code **)(pfVar1->node->ops + 0x28);
      if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2304c59a. Too many branches
                    // WARNING: Treating indirect jump as call
        paVar2 = (aos_dirent_t *)(*UNRECOVERED_JUMPTABLE)(dir);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return paVar2;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (aos_dirent_t *)0x0;
}



file_t * new_file(inode_t *node)

{
  file_t *pfVar1;
  int iVar2;
  
  pfVar1 = files;
  iVar2 = 0;
  do {
    if (pfVar1->node == (inode_t *)0x0) {
      files[iVar2].node = node;
      files[iVar2].f_arg = (void *)0x0;
      files[iVar2].offset = 0;
      inode_ref(node);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return files + iVar2;
    }
    iVar2 = iVar2 + 1;
    pfVar1 = pfVar1 + 1;
  } while (iVar2 != 0x3c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (file_t *)0x0;
}



void del_file(file_t *file)

{
  inode_unref(file->node);
  file->node = (inode_t *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int get_fd(file_t *file)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ((int)(file + -0x5801c68) >> 2) * -0x55555555 + 2;
}



file_t * get_file(int fd)

{
  inode_t *piVar1;
  
  if (fd - 2U < 0x3c) {
    piVar1 = (inode_t *)((inode_t *)(files + (fd - 2U)))->ops;
    if (piVar1 != (inode_t *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (file_t *)(inode_t *)(files + (fd - 2U));
    }
  }
  else {
    piVar1 = (inode_t *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (file_t *)piVar1;
}



int inode_init(void)

{
  memset(g_vfs_dev_nodes,0,600);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int inode_alloc(void)

{
  int iVar1;
  inode_t *piVar2;
  
  piVar2 = g_vfs_dev_nodes;
  iVar1 = 0;
  do {
    if (piVar2->type == '\0') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    iVar1 = iVar1 + 1;
    piVar2 = piVar2 + 1;
  } while (iVar1 != 0x1e);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0xc;
}



inode_t * inode_open(char *path)

{
  inode_t *piVar1;
  int iVar2;
  size_t sVar3;
  char *__s;
  
  piVar1 = g_vfs_dev_nodes;
  do {
    __s = piVar1->i_name;
    if (__s != (char *)0x0) {
      if (piVar1->type == '\x03') {
        sVar3 = strlen(__s);
        iVar2 = strncmp(__s,path,sVar3);
        if ((iVar2 == 0) && (sVar3 = strlen(piVar1->i_name), path[sVar3] == '/')) goto LAB_2304c6bc;
      }
      iVar2 = strcmp(piVar1->i_name,path);
      if (iVar2 == 0) goto LAB_2304c6bc;
    }
    piVar1 = piVar1 + 1;
  } while (piVar1 != (inode_t *)deleteAcceptedTopic);
  piVar1 = (inode_t *)0x0;
LAB_2304c6bc:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return piVar1;
}



int inode_forearch_name(anon_subr_int_void_ptr_inode_t_ptr *cb,void *arg)

{
  inode_t *piVar1;
  int iVar2;
  int iVar3;
  
  piVar1 = g_vfs_dev_nodes;
  iVar2 = 0;
  do {
    if (piVar1->i_name != (char *)0x0) {
      iVar2 = iVar2 + 1;
      iVar3 = (*cb)(arg,piVar1);
      if (iVar3 != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
    }
    piVar1 = piVar1 + 1;
  } while (piVar1 != (inode_t *)deleteAcceptedTopic);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void inode_ref(inode_t *node)

{
  node->refs = node->refs + '\x01';
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void inode_unref(inode_t *node)

{
  if (node->refs != '\0') {
    node->refs = node->refs + -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int inode_reserve(char *path,inode_t **inode)

{
  inode_t *piVar1;
  int iVar2;
  size_t __n;
  char *__dest;
  
  if (((path != (char *)0x0) && (inode != (inode_t **)0x0)) &&
     (*inode = (inode_t *)0x0, *path == '/')) {
    iVar2 = inode_alloc();
    if (-1 < iVar2) {
      piVar1 = (inode_t *)0x0;
      if (iVar2 < 0x1e) {
        piVar1 = g_vfs_dev_nodes + iVar2;
      }
      __n = strlen(path);
      __dest = (char *)pvPortMalloc(__n + 1);
      iVar2 = -0xc;
      if (__dest != (char *)0x0) {
        memcpy(__dest,path,__n);
        piVar1->i_name = __dest;
        __dest[__n] = '\0';
        *inode = piVar1;
        iVar2 = 0;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x16;
}



int aos_register_driver(char *path,file_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      piStack36->ops = ops;
      piStack36->type = '\x01';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int aos_register_fs(char *path,fs_ops_t *ops,void *arg)

{
  BaseType_t BVar1;
  int iVar2;
  inode_t *piStack36;
  inode_t *node;
  
  piStack36 = (inode_t *)0x0;
  BVar1 = xQueueSemaphoreTake((QueueHandle_t)g_vfs_mutex,0xffffffff);
  if (BVar1 == 1) {
    iVar2 = inode_reserve(path,&piStack36);
    if (iVar2 == 0) {
      piStack36->ops = ops;
      piStack36->type = '\x03';
      piStack36->i_arg = arg;
    }
    BVar1 = xQueueGenericSend((QueueHandle_t)g_vfs_mutex,(void *)0x0,0,0);
    if (BVar1 == 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    if (piStack36->i_name != (char *)0x0) {
      vPortFree(piStack36->i_name);
    }
    memset(piStack36,0,0x14);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int vfs_uart_open(inode_t *inode,file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  StreamBufferHandle_t pSVar2;
  inode_t *piVar3;
  
  if ((fp == (file_t *)0x0) || (piVar3 = fp->node, piVar3 == (inode_t *)0x0)) {
    iVar1 = -0x16;
  }
  else {
    iVar1 = 0;
    if (piVar3->refs == '\x01') {
      uart = (uart_dev_t *)piVar3->i_arg;
      aos_mutex_new((aos_mutex_t *)&uart->mutex);
      pSVar2 = xStreamBufferGenericCreate(uart->rx_buf_size,1,0);
      uart->rx_ringbuf_handle = pSVar2;
      pSVar2 = xStreamBufferGenericCreate(uart->tx_buf_size,1,0);
      uart->tx_ringbuf_handle = pSVar2;
      if ((uart->rx_ringbuf_handle != (void *)0x0) && (pSVar2 != (StreamBufferHandle_t)0x0)) {
        hal_uart_notify_register(uart,UART_TX_INT,__uart_tx_irq);
        hal_uart_notify_register(uart,UART_RX_INT,__uart_rx_irq);
        iVar1 = hal_uart_init(uart);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x16;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void __uart_rx_irq(void *p_arg)

{
  size_t sStack88;
  uint32_t length;
  BaseType_t xHigherPriorityTaskWoken;
  uint8_t tmp_buf [64];
  
  sStack88 = 0;
  length = 0;
  hal_uart_recv_II((uart_dev_t *)p_arg,&xHigherPriorityTaskWoken,0x40,&sStack88,0);
  if ((sStack88 != 0) &&
     (xStreamBufferSendFromISR
                (*(StreamBufferHandle_t *)((int)p_arg + 0x10),&xHigherPriorityTaskWoken,sStack88,
                 (BaseType_t *)&length), length != 0)) {
    vTaskSwitchContext();
  }
  if (*(int *)((int)p_arg + 0x24) != 0) {
    *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) = *(ushort *)(*(int *)((int)p_arg + 0x28) + 6) | 1;
    (**(code **)((int)p_arg + 0x24))
              (*(undefined4 *)((int)p_arg + 0x28),*(undefined4 *)((int)p_arg + 0x2c),
               *(code **)((int)p_arg + 0x24));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void __uart_tx_irq(void *p_arg)

{
  size_t sVar1;
  undefined uStack21;
  uint8_t ch;
  int iStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  iStack20 = 0;
  sVar1 = xStreamBufferReceiveFromISR
                    (*(StreamBufferHandle_t *)((int)p_arg + 0x14),&uStack21,1,
                     (BaseType_t *)&stack0xffffffec);
  if (iStack20 != 0) {
    vTaskSwitchContext();
  }
  if (sVar1 == 1) {
    hal_uart_send((uart_dev_t *)p_arg,&uStack21,1,0);
  }
  else {
    hal_uart_send_trigger_off((uart_dev_t *)p_arg);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int vfs_uart_close(file_t *fp)

{
  uart_dev_t *uart;
  int32_t iVar1;
  inode_t *piVar2;
  
  if ((fp == (file_t *)0x0) || (piVar2 = fp->node, piVar2 == (inode_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x16;
  }
  if (piVar2->refs != '\x01') {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  uart = (uart_dev_t *)piVar2->i_arg;
  if (uart != (uart_dev_t *)0x0) {
    aos_mutex_free((aos_mutex_t *)&uart->mutex);
    vStreamBufferDelete((StreamBufferHandle_t)uart->rx_ringbuf_handle);
    vStreamBufferDelete((StreamBufferHandle_t)uart->tx_ringbuf_handle);
    iVar1 = hal_uart_finalize(uart);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x16;
}



ssize_t vfs_uart_read(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  TickType_t xTicksToWait;
  size_t sVar2;
  void *pvVar3;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) && (pvVar3 = fp->node->i_arg, nbytes != 0)) &&
       (pvVar3 != (void *)0x0)) {
      aos_mutex_lock((aos_mutex_t *)((int)pvVar3 + 0x20),0xffffffff);
      sVar1 = 0;
      xTicksToWait = -(uint)(*(char *)((int)pvVar3 + 0x34) == '\x01');
      do {
        sVar2 = xStreamBufferReceive
                          (*(StreamBufferHandle_t *)((int)pvVar3 + 0x10),(void *)((int)buf + sVar1),
                           nbytes - sVar1,xTicksToWait);
        sVar1 = sVar1 + sVar2;
        if (sVar1 == nbytes) break;
      } while (xTicksToWait != 0);
      aos_mutex_unlock((aos_mutex_t *)((int)pvVar3 + 0x20));
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



ssize_t vfs_uart_write(file_t *fp,void *buf,size_t nbytes)

{
  size_t sVar1;
  uart_dev_t *uart;
  
  sVar1 = 0xffffffea;
  if (fp != (file_t *)0x0) {
    sVar1 = 0xffffffea;
    if (((fp->node != (inode_t *)0x0) &&
        (uart = (uart_dev_t *)fp->node->i_arg, uart != (uart_dev_t *)0x0)) &&
       (sVar1 = xStreamBufferSend((StreamBufferHandle_t)uart->tx_ringbuf_handle,buf,nbytes,0),
       0 < (int)sVar1)) {
      hal_uart_send_trigger(uart);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



int vfs_uart_poll(file_t *fp,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  void *pvVar1;
  BaseType_t BVar2;
  undefined3 in_register_0000202d;
  
  pvVar1 = fp->node->i_arg;
  aos_mutex_lock((aos_mutex_t *)((int)pvVar1 + 0x20),0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    vTaskEnterCritical();
    *(undefined4 *)((int)pvVar1 + 0x24) = 0;
    *(undefined4 *)((int)pvVar1 + 0x2c) = 0;
    vTaskExitCritical();
  }
  else {
    vTaskEnterCritical();
    *(poll_notify_t **)((int)pvVar1 + 0x24) = notify;
    *(pollfd **)((int)pvVar1 + 0x28) = fd;
    *(void **)((int)pvVar1 + 0x2c) = opa;
    vTaskExitCritical();
    BVar2 = xStreamBufferIsEmpty(*(StreamBufferHandle_t *)((int)pvVar1 + 0x10));
    if (BVar2 != 1) {
      *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) =
           *(ushort *)(*(int *)((int)pvVar1 + 0x28) + 6) | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock((aos_mutex_t *)((int)pvVar1 + 0x20));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int vfs_uart_sync(file_t *fp)

{
  uart_dev_t *uart;
  int iVar1;
  
  if (fp == (file_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x16;
  }
  iVar1 = -0x16;
  if (fp->node != (inode_t *)0x0) {
    uart = (uart_dev_t *)fp->node->i_arg;
    if (uart != (uart_dev_t *)0x0) {
      aos_mutex_lock((aos_mutex_t *)&uart->mutex,0xffffffff);
      hal_uart_send_flush(uart,0);
      aos_mutex_unlock((aos_mutex_t *)&uart->mutex);
      iVar1 = 0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int uart_ioctl_cmd_waimode(uart_dev_t *uart_dev,int cmd,ulong arg)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  int iVar4;
  
  iVar1 = -0x16;
  if (arg != 0) {
    iVar4 = *(int *)(arg + 4);
    uVar3 = *(int *)(arg + 8) * 1000;
    iVar1 = 0;
    do {
      sVar2 = xStreamBufferReceive
                        ((StreamBufferHandle_t)uart_dev->rx_ringbuf_handle,
                         (void *)(*(int *)arg + iVar1),iVar4 - iVar1,uVar3 / 1000);
      iVar1 = iVar1 + sVar2;
      if (iVar4 == iVar1) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
      if (uVar3 < 1000) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
    } while ((cmd != 4) || (iVar1 < 1));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int uart_ioctl_cmd_setconfig(uart_dev_t *uart_dev,ulong arg)

{
  hal_uart_parity_t parity;
  
  if (arg != 0) {
    parity = *(hal_uart_parity_t *)(arg + 4);
    if ((parity != ODD_PARITY) && (parity != EVEN_PARITY)) {
      parity = NO_PARITY;
    }
    hal_uart_setconfig(uart_dev,*(uint32_t *)arg,parity);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x16;
}



int vfs_uart_ioctl(file_t *fp,int cmd,ulong arg)

{
  int iVar1;
  uart_dev_t *uart_dev;
  uint8_t uVar2;
  
  iVar1 = -0x16;
  if (fp == (file_t *)0x0) goto LAB_2304ccd2;
  iVar1 = -0x16;
  if ((fp->node == (inode_t *)0x0) ||
     (uart_dev = (uart_dev_t *)fp->node->i_arg, uart_dev == (uart_dev_t *)0x0)) goto LAB_2304ccd2;
  aos_mutex_lock((aos_mutex_t *)&uart_dev->mutex,0xffffffff);
  switch(cmd) {
  case 2:
    hal_uart_send_flush(uart_dev,0);
    goto LAB_2304ccea;
  case 3:
    hal_uart_setbaud(uart_dev,arg);
    goto LAB_2304ccea;
  case 4:
  case 5:
    iVar1 = uart_ioctl_cmd_waimode(uart_dev,cmd,arg);
    break;
  case 6:
    uVar2 = '\x01';
    goto LAB_2304cd04;
  case 7:
    uVar2 = '\x02';
LAB_2304cd04:
    uart_dev->read_block_flag = uVar2;
LAB_2304ccea:
    iVar1 = -1;
    break;
  case 8:
    iVar1 = uart_ioctl_cmd_setconfig(uart_dev,arg);
  }
  aos_mutex_unlock((aos_mutex_t *)&uart_dev->mutex);
LAB_2304ccd2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



yloop_ctx_t * get_context(void)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = (yloop_ctx_t *)aos_task_getspecific(g_loop_key);
  if (pyVar1 == (yloop_ctx_t *)0x0) {
    aos_task_setspecific(g_loop_key,g_main_ctx);
    pyVar1 = g_main_ctx;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pyVar1;
}



void aos_loop_set_eventfd(int fd)

{
  yloop_ctx_t *pyVar1;
  
  pyVar1 = get_context();
  pyVar1->eventfd = fd;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



aos_loop_t aos_loop_init(void)

{
  aos_task_key_t key;
  yloop_ctx_t *pyVar1;
  
  pyVar1 = (yloop_ctx_t *)aos_task_getspecific(g_loop_key);
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    aos_task_key_create(&g_loop_key);
  }
  else {
    if (pyVar1 != (yloop_ctx_t *)0x0) {
      printf("yloopyloop already inited");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return pyVar1;
    }
  }
  pyVar1 = (yloop_ctx_t *)pvPortMalloc(0x1c);
  if (pyVar1 != (yloop_ctx_t *)0x0) {
    memset(pyVar1,0,0x1c);
  }
  if (g_main_ctx == (yloop_ctx_t *)0x0) {
    g_main_ctx = pyVar1;
  }
  (pyVar1->timeouts).prev = (dlist_s *)pyVar1;
  key = g_loop_key;
  pyVar1->eventfd = -1;
  (pyVar1->timeouts).next = (dlist_s *)pyVar1;
  aos_task_setspecific(key,pyVar1);
  aos_event_service_init();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pyVar1;
}



int aos_poll_read_fd(int sock,aos_poll_call_t *cb,void *private_data)

{
  yloop_ctx_t *pyVar1;
  yloop_sock_t *pyVar2;
  pollfd *__dest;
  uint uVar3;
  int iVar4;
  uint uVar5;
  
  pyVar1 = get_context();
  if (sock < 0) {
    iVar4 = -0x16;
  }
  else {
    uVar5 = (uint)pyVar1->reader_count;
    pyVar2 = (yloop_sock_t *)pvPortMalloc((uVar5 + 1) * 0xc);
    __dest = (pollfd *)pvPortMalloc((uVar5 + 1) * 8);
    if ((pyVar2 == (yloop_sock_t *)0x0) || (__dest == (pollfd *)0x0)) {
      printf("yloopout of memory");
      vPortFree(pyVar2);
      vPortFree(__dest);
      iVar4 = -0xc;
    }
    else {
      uVar3 = aos_fcntl(sock,3,0);
      aos_fcntl(sock,4,uVar3 | 0x4000);
      pyVar1->reader_count = pyVar1->reader_count + '\x01';
      memcpy(pyVar2,pyVar1->readers,uVar5 * 0xc);
      vPortFree(pyVar1->readers);
      pyVar1->readers = pyVar2;
      memcpy(__dest,pyVar1->pollfds,uVar5 << 3);
      pyVar2 = pyVar2 + uVar5;
      vPortFree(pyVar1->pollfds);
      pyVar1->pollfds = __dest;
      pyVar2->sock = sock;
      pyVar2->private_data = private_data;
      pyVar2->cb = cb;
      iVar4 = 0;
      if ((int)(uint)pyVar1->max_sock < sock) {
        pyVar1->max_sock = (uint16_t)sock;
        iVar4 = 0;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int aos_post_delayed_action(int ms,aos_call_t *action,void *param)

{
  yloop_ctx_t *pyVar1;
  dlist_s *pdVar2;
  int iVar3;
  pollfd *ppVar4;
  aos_call_t *paVar5;
  yloop_sock_t *pyVar6;
  dlist_s *pdVar7;
  yloop_ctx_t *pyVar8;
  
  if (action != (aos_call_t *)0x0) {
    paVar5 = action;
    pyVar1 = get_context();
    pdVar2 = (dlist_s *)pvPortMalloc(0x20);
    iVar3 = -0xc;
    if (pdVar2 != (dlist_s *)0x0) {
      aos_now_ms();
      ppVar4 = (pollfd *)(iVar3 + ms);
      pyVar6 = (yloop_sock_t *)(paVar5 + (uint)(ppVar4 < (uint)ms) + (ms >> 0x1f));
      pdVar2[1].prev = (dlist_s *)ppVar4;
      pdVar2[1].next = (dlist_s *)pyVar6;
      pdVar2[2].prev = (dlist_s *)param;
      pdVar2[2].next = (dlist_s *)action;
      pdVar2[3].prev = (dlist_s *)ms;
      pyVar8 = (yloop_ctx_t *)(pyVar1->timeouts).next;
      while (((pyVar8 != pyVar1 && ((int)pyVar8->readers <= (int)pyVar6)) &&
             ((pyVar8->readers != pyVar6 || (pyVar8->pollfds <= ppVar4))))) {
        pyVar8 = (yloop_ctx_t *)(pyVar8->timeouts).next;
      }
      pdVar7 = (pyVar8->timeouts).prev;
      pdVar2->next = (dlist_s *)pyVar8;
      iVar3 = 0;
      pdVar2->prev = pdVar7;
      pdVar7->next = pdVar2;
      (pyVar8->timeouts).prev = pdVar2;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x16;
}



void aos_loop_run(yloop_sock_t *param_1)

{
  yloop_ctx_t *pyVar1;
  yloop_sock_t *pyVar2;
  yloop_ctx_t *pyVar3;
  yloop_ctx_t *pyVar4;
  yloop_sock_t *extraout_a1;
  yloop_ctx_t *pyVar5;
  dlist_s *pdVar6;
  int iVar7;
  dlist_s *pdVar8;
  yloop_sock_t *pyVar9;
  yloop_sock_t *nfds;
  longlong lVar10;
  
  pyVar3 = get_context();
  pyVar4 = pyVar3;
  while (pyVar3->terminate == false) {
    pyVar1 = (yloop_ctx_t *)(pyVar3->timeouts).next;
    nfds = (yloop_sock_t *)(uint)pyVar3->reader_count;
    if ((pyVar3 == pyVar1) && (nfds == (yloop_sock_t *)0x0)) break;
    pyVar5 = (yloop_ctx_t *)0xffffffff;
    if (pyVar3 != pyVar1) {
      aos_now_ms();
      if (((int)param_1 < (int)pyVar1->readers) ||
         ((pyVar1->readers == param_1 && (pyVar4 < (yloop_ctx_t *)pyVar1->pollfds)))) {
        pyVar5 = (yloop_ctx_t *)((int)(yloop_ctx_t *)pyVar1->pollfds - (int)pyVar4);
      }
      else {
        pyVar5 = (yloop_ctx_t *)0x0;
      }
    }
    iVar7 = 0;
    while (iVar7 < (int)nfds) {
      pyVar3->pollfds[iVar7].fd = pyVar3->readers[iVar7].sock;
      pyVar3->pollfds[iVar7].events = 1;
      iVar7 = iVar7 + 1;
    }
    param_1 = nfds;
    pyVar1 = (yloop_ctx_t *)aos_poll(pyVar3->pollfds,(int)nfds,(int)pyVar5);
    pyVar4 = pyVar1;
    if ((int)pyVar1 < 0) {
      pyVar4 = (yloop_ctx_t *)__errno();
      if ((pyVar4->timeouts).prev != (dlist_s *)0x4) {
        printf("yloopaos_poll");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
    }
    pyVar5 = (yloop_ctx_t *)(pyVar3->timeouts).next;
    if (pyVar3 != pyVar5) {
      lVar10 = aos_now_ms();
      if (((int)pyVar5->readers <= (int)param_1) &&
         ((pyVar5->readers != param_1 || ((yloop_ctx_t *)pyVar5->pollfds <= pyVar4)))) {
        pdVar8 = (pyVar5->timeouts).next;
        pdVar6 = (pyVar5->timeouts).prev;
        pdVar6->next = pdVar8;
        pdVar8->prev = pdVar6;
        param_1 = (yloop_sock_t *)
                  (**(code **)&pyVar5->max_sock)
                            (pyVar5->eventfd,*(code **)&pyVar5->max_sock,(int)lVar10);
        vPortFree(pyVar5);
        pyVar4 = pyVar5;
      }
    }
    pyVar2 = (yloop_sock_t *)0x0;
    if (0 < (int)pyVar1) {
      while (pyVar2 != nfds) {
        if ((pyVar3->pollfds[(int)pyVar2].revents & 1U) != 0) {
          pyVar9 = pyVar3->readers + (int)pyVar2;
          pyVar4 = (yloop_ctx_t *)(*pyVar9->cb)(pyVar9->sock,pyVar9->private_data);
          param_1 = extraout_a1;
        }
        pyVar2 = (yloop_sock_t *)((int)&pyVar2->sock + 1);
      }
    }
  }
  pyVar3->terminate = false;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void vfs_poll_notify(pollfd *fd,void *arg)

{
  aos_sem_signal((aos_sem_t *)arg);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_poll(pollfd *fds,int nfds,int timeout)

{
  ushort *puVar1;
  int iVar2;
  uint fd;
  file_t *pfVar3;
  ushort *puVar4;
  int iVar5;
  code *pcVar6;
  int iVar7;
  pollfd *ppVar8;
  aos_sem_t aStack60;
  poll_arg parg;
  _types_fd_set rfds;
  
  aos_sem_new(&aStack60,0);
  iVar5 = 0;
  do {
    *(undefined *)((int)&parg.sem.hdl + iVar5) = 0;
    iVar5 = iVar5 + 1;
  } while (iVar5 != 8);
  puVar1 = (ushort *)&fds->revents;
  iVar5 = 0;
  puVar4 = puVar1;
  while (iVar5 < nfds) {
    *puVar4 = 0;
    iVar5 = iVar5 + 1;
    puVar4 = puVar4 + 4;
  }
  iVar5 = 0;
  ppVar8 = fds;
  do {
    if (nfds <= iVar5) {
      if (timeout < 0) {
        timeout = 0xffffffff;
      }
      aos_sem_wait(&aStack60,timeout);
      iVar5 = 0;
      while (iVar5 < nfds) {
        if ((1 << (*(uint *)(puVar1 + -3) & 0x1f) &
            (uint)(&parg)[*(uint *)(puVar1 + -3) >> 5].sem.hdl) != 0) {
          *puVar1 = *puVar1 | 1;
        }
        iVar5 = iVar5 + 1;
        puVar1 = puVar1 + 4;
      }
      iVar5 = 0;
check_poll:
      iVar2 = 0;
      iVar7 = 0;
      while (iVar7 < nfds) {
        if (((1 < fds->fd) && (pfVar3 = get_file(fds->fd), pfVar3 != (file_t *)0x0)) &&
           (pcVar6 = *(code **)(pfVar3->node->ops + 0x14), (*pcVar6)(0,0,0,0,pcVar6),
           fds->revents != 0)) {
          iVar2 = iVar2 + 1;
        }
        iVar7 = iVar7 + 1;
        fds = fds + 1;
      }
      aos_sem_free(&aStack60);
      if (iVar5 != 0) {
        iVar2 = 0;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    fd = ppVar8->fd;
    if ((int)fd < 2) {
      (&parg)[fd >> 5].sem.hdl = (void *)(1 << (fd & 0x1f) | (uint)(&parg)[fd >> 5].sem.hdl);
    }
    else {
      pfVar3 = get_file(fd);
      if (pfVar3 == (file_t *)0x0) {
        iVar5 = -1;
        goto check_poll;
      }
      pcVar6 = *(code **)(pfVar3->node->ops + 0x14);
      (*pcVar6)(1,vfs_poll_notify,ppVar8,&aStack60,pcVar6);
    }
    iVar5 = iVar5 + 1;
    ppVar8 = ppVar8 + 1;
  } while( true );
}



int aos_fcntl(int fd,int cmd,int val)

{
  int iVar1;
  
  iVar1 = -0x16;
  if ((-1 < fd) && (iVar1 = 0, fd < 2)) {
    iVar1 = -2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void dfl_entry(void *arg)

{
  code *pcVar1;
  undefined4 uVar2;
  
  uVar2 = *(undefined4 *)((int)arg + 8);
  pcVar1 = *(code **)((int)arg + 4);
  vPortFree(arg);
  (*pcVar1)(uVar2);
  vTaskDelete((TaskHandle_t)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_task_new(char *name,anon_subr_void_void_ptr *fn,void *arg,int stack_size)

{
  StaticTask_t *pxTaskBuffer;
  StaticTask_t **pvParameters;
  StackType_t *puxStackBuffer;
  TaskHandle_t ptVar1;
  int iVar2;
  
  pxTaskBuffer = (StaticTask_t *)pvPortMalloc(0x9c);
  pvParameters = (StaticTask_t **)pvPortMalloc(0xc);
  puxStackBuffer = (StackType_t *)pvPortMalloc(stack_size);
  memset(puxStackBuffer,0,stack_size);
  memset(pxTaskBuffer,0,0x9c);
  pxTaskBuffer[1].pxDummy1 = (void *)0xfffffff0;
  pxTaskBuffer[1].xDummy3[0].pvDummy3[3] = puxStackBuffer;
  strncpy((char *)(pxTaskBuffer[1].xDummy3 + 1),name,0x1f);
  *(undefined4 *)(pxTaskBuffer[1].ucDummy7 + 4) = 0x20171020;
  *pvParameters = pxTaskBuffer;
  pvParameters[1] = (StaticTask_t *)fn;
  pvParameters[2] = (StaticTask_t *)arg;
  ptVar1 = xTaskCreateStatic(dfl_entry,name,(uint)stack_size >> 2,pvParameters,10,puxStackBuffer,
                             pxTaskBuffer);
  if (ptVar1 == (TaskHandle_t)0x0) {
    vPortFree(pxTaskBuffer);
    vPortFree(puxStackBuffer);
    vPortFree(pvParameters);
    iVar2 = -1;
  }
  else {
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void aos_task_exit(int code)

{
  vTaskDelete((TaskHandle_t)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_task_key_create(aos_task_key_t *key)

{
  TaskHandle_t ptVar1;
  uint uVar2;
  aos_task_key_t aVar3;
  int iVar4;
  StackType_t *pSVar5;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
    pSVar5 = ptVar1[1].pxTopOfStack;
    if (((uint)pSVar5 & 1) == 0) {
      aVar3 = 0;
      uVar2 = 1;
    }
    else {
      if (((uint)pSVar5 & 2) == 0) {
        aVar3 = 1;
        uVar2 = 2;
      }
      else {
        if (((uint)pSVar5 & 4) == 0) {
          aVar3 = 2;
          uVar2 = 4;
        }
        else {
          if (((uint)pSVar5 & 8) != 0) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -1;
          }
          aVar3 = 3;
          uVar2 = 8;
        }
      }
    }
    ptVar1[1].pxTopOfStack = (StackType_t *)((uint)pSVar5 | uVar2);
    *key = aVar3;
    iVar4 = 0;
  }
  else {
    iVar4 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int aos_task_setspecific(aos_task_key_t key,void *vp)

{
  TaskHandle_t ptVar1;
  int iVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    iVar2 = -1;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      *(void **)(ptVar1[1].pcTaskName + key * 4 + -0x30) = vp;
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void * aos_task_getspecific(aos_task_key_t key)

{
  TaskHandle_t ptVar1;
  void *pvVar2;
  
  ptVar1 = xTaskGetCurrentTaskHandle();
  if (key < 4) {
    pvVar2 = (void *)0x0;
    if (*(int *)(ptVar1[1].pcTaskName + 4) == 0x20171020) {
      pvVar2 = *(void **)(ptVar1[1].pcTaskName + key * 4 + -0x30);
    }
  }
  else {
    pvVar2 = (void *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar2;
}



int aos_mutex_new(aos_mutex_t *mutex)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateMutex('\x01');
  mutex->hdl = pQVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)(pQVar1 == (QueueHandle_t)0x0);
}



void aos_mutex_free(aos_mutex_t *mutex)

{
  vQueueDelete((QueueHandle_t)mutex->hdl);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_mutex_lock(aos_mutex_t *mutex,uint ms)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueSemaphoreTake((QueueHandle_t)mutex->hdl,ms);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int aos_mutex_unlock(aos_mutex_t *mutex)

{
  if (mutex != (aos_mutex_t *)0x0) {
    xQueueGenericSend((QueueHandle_t)mutex->hdl,(void *)0x0,0,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int aos_sem_new(aos_sem_t *sem,int count)

{
  QueueHandle_t pQVar1;
  
  pQVar1 = xQueueCreateCountingSemaphore(0x80,count);
  sem->hdl = pQVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void aos_sem_free(aos_sem_t *sem)

{
  if (sem != (aos_sem_t *)0x0) {
    vQueueDelete((QueueHandle_t)sem->hdl);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_sem_wait(aos_sem_t *sem,uint ms)

{
  BaseType_t BVar1;
  
  if (sem != (aos_sem_t *)0x0) {
    BVar1 = xQueueSemaphoreTake((QueueHandle_t)sem->hdl,ms);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -(uint)(BVar1 != 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void aos_sem_signal(aos_sem_t *sem)

{
  int iStack20;
  BaseType_t xHigherPriorityTaskWoken;
  
  iStack20 = 0;
  if (sem != (aos_sem_t *)0x0) {
    if (TrapNetCounter == 0) {
      xQueueGenericSend((QueueHandle_t)sem->hdl,(void *)0x0,0,0);
    }
    else {
      xQueueGiveFromISR((QueueHandle_t)sem->hdl,&iStack20);
      if (iStack20 != 0) {
        vTaskSwitchContext();
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * aos_malloc(size_t xWantedSize)

{
  size_t sVar1;
  size_t sVar2;
  BlockLink_t *pBVar3;
  A_BLOCK_LINK *pAVar4;
  BlockLink_t *pBVar5;
  uint uVar6;
  uint uVar7;
  
  if (pxEnd == (BlockLink_t *)0x0) {
    vAssertCalled();
  }
  vTaskSuspendAll();
  sVar2 = xFreeBytesRemaining;
  sVar1 = xBlockAllocatedBit;
  if (((xBlockAllocatedBit & xWantedSize) == 0) && (xWantedSize != 0)) {
    uVar7 = xWantedSize + 8;
    if ((uVar7 & 7) != 0) {
      uVar7 = (uVar7 & 0xfffffff8) + 8;
    }
    if ((uVar7 == 0) || (xFreeBytesRemaining < uVar7)) goto LAB_230321ba;
    pAVar4 = xStart.pxNextFreeBlock;
    pBVar3 = &xStart;
    do {
      pBVar5 = pBVar3;
      pBVar3 = (BlockLink_t *)pAVar4;
      if (uVar7 <= pBVar3->xBlockSize) break;
      pAVar4 = pBVar3->pxNextFreeBlock;
    } while (pBVar3->pxNextFreeBlock != (A_BLOCK_LINK *)0x0);
    if (pxEnd == pBVar3) goto LAB_230321ba;
    pAVar4 = pBVar5->pxNextFreeBlock;
    pBVar5->pxNextFreeBlock = pBVar3->pxNextFreeBlock;
    uVar6 = pBVar3->xBlockSize;
    pAVar4 = pAVar4 + 1;
    if (0x10 < uVar6 - uVar7) {
      pBVar5 = (BlockLink_t *)((int)&pBVar3->pxNextFreeBlock + uVar7);
      pBVar5->xBlockSize = uVar6 - uVar7;
      pBVar3->xBlockSize = uVar7;
      prvInsertBlockIntoFreeList(pBVar5);
      uVar6 = pBVar3->xBlockSize;
    }
    xFreeBytesRemaining = sVar2 - uVar6;
    if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
      xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    }
    pBVar3->xBlockSize = sVar1 | uVar6;
    pBVar3->pxNextFreeBlock = (A_BLOCK_LINK *)0x0;
    xTaskResumeAll();
    if (pAVar4 != (A_BLOCK_LINK *)0x0) goto LAB_230321c4;
  }
  else {
LAB_230321ba:
    xTaskResumeAll();
  }
  vApplicationMallocFailedHook();
  pAVar4 = (A_BLOCK_LINK *)0x0;
LAB_230321c4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pAVar4;
}



void aos_free(void *pv)

{
  uint uVar1;
  
  if (pv == (void *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  uVar1 = *(uint *)((int)pv + -4);
  if ((uVar1 & xBlockAllocatedBit) == 0) {
    vAssertCalled();
    if (*(int *)((int)pv + -8) == 0) {
      uVar1 = *(uint *)((int)pv + -4);
      if ((uVar1 & xBlockAllocatedBit) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      goto LAB_230322ce;
    }
  }
  else {
    if (*(int *)((int)pv + -8) == 0) goto LAB_230322ce;
  }
  vAssertCalled();
  uVar1 = *(uint *)((int)pv + -4);
  if (((uVar1 & xBlockAllocatedBit) == 0) || (*(int *)((int)pv + -8) != 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
LAB_230322ce:
  *(size_t *)((int)pv + -4) = ~xBlockAllocatedBit & uVar1;
  vTaskSuspendAll();
  xFreeBytesRemaining = *(int *)((int)pv + -4) + xFreeBytesRemaining;
  prvInsertBlockIntoFreeList((BlockLink_t *)((int)pv + -8));
  xTaskResumeAll();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



longlong aos_now_ms(void)

{
  BaseType_t BVar1;
  longlong in_fa0;
  TickType_t TStack24;
  TickType_t ticks;
  BaseType_t overflow_count;
  
  TStack24 = 0;
  ticks = 0;
  BVar1 = xTaskGetTickCount2(&TStack24,(BaseType_t *)&ticks);
  if (BVar1 != 1) {
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



int event_poll(file_t *f,_Bool setup,poll_notify_t *notify,pollfd *fd,void *opa)

{
  aos_mutex_t *mutex;
  undefined3 in_register_0000202d;
  
  mutex = (aos_mutex_t *)f->f_arg;
  aos_mutex_lock(mutex,0xffffffff);
  if (CONCAT31(in_register_0000202d,setup) == 0) {
    mutex[1].hdl = (void *)0x0;
    mutex[3].hdl = (void *)0x0;
  }
  else {
    mutex[1].hdl = notify;
    mutex[2].hdl = fd;
    mutex[3].hdl = opa;
    if (mutex[4].hdl != (void *)0x0) {
      fd->revents = fd->revents | 1;
      (*notify)(fd,opa);
    }
  }
  aos_mutex_unlock(mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int event_open(inode_t *node,file_t *file)

{
  aos_mutex_t *mutex;
  
  mutex = (aos_mutex_t *)aos_malloc(0x28);
  memset(mutex,0,0x28);
  aos_mutex_new(mutex);
  mutex[5].hdl = mutex + 5;
  mutex[6].hdl = mutex + 5;
  mutex[8].hdl = mutex + 8;
  mutex[9].hdl = mutex + 8;
  file->f_arg = mutex;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



ssize_t _event_write(void *buf,size_t len,_Bool urgent)

{
  int *piVar1;
  undefined3 in_register_00002031;
  int in_a3;
  int iVar2;
  int *piVar3;
  int **ppiVar4;
  size_t __n;
  
  __n = CONCAT31(in_register_00002031,urgent);
  aos_mutex_lock((aos_mutex_t *)buf,0xffffffff);
  if ((*(int *)((int)buf + 0x1c) < 1) || (piVar1 = *(int **)((int)buf + 0x24), __n != piVar1[2])) {
    piVar1 = (int *)aos_malloc(__n + 0xc);
    if (piVar1 == (int *)0x0) {
      __n = 0xffffffff;
      goto out;
    }
  }
  else {
    piVar3 = (int *)piVar1[1];
    iVar2 = *piVar1;
    *(int **)(iVar2 + 4) = piVar3;
    *piVar3 = iVar2;
    *(int *)((int)buf + 0x1c) = *(int *)((int)buf + 0x1c) + -1;
  }
  *(int *)((int)buf + 0x10) = *(int *)((int)buf + 0x10) + 1;
  piVar1[2] = __n;
  memcpy(piVar1 + 3,(void *)len,__n);
  if (in_a3 == 0) {
    iVar2 = *(int *)((int)buf + 0x14);
    piVar1[1] = (int)buf + 0x14;
    *piVar1 = iVar2;
    *(int **)(iVar2 + 4) = piVar1;
    *(int **)((int)buf + 0x14) = piVar1;
  }
  else {
    ppiVar4 = *(int ***)((int)buf + 0x18);
    *piVar1 = (int)buf + 0x14;
    piVar1[1] = (int)ppiVar4;
    *(int **)((int)buf + 0x18) = piVar1;
    *ppiVar4 = piVar1;
  }
  if (*(int *)((int)buf + 4) != 0) {
    *(ushort *)(*(int *)((int)buf + 8) + 6) = *(ushort *)(*(int *)((int)buf + 8) + 6) | 1;
    (**(code **)((int)buf + 4))
              (*(undefined4 *)((int)buf + 8),*(undefined4 *)((int)buf + 0xc),
               *(code **)((int)buf + 4));
  }
out:
  aos_mutex_unlock((aos_mutex_t *)buf);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __n;
}



int event_ioctl(file_t *f,int cmd,ulong arg)

{
  int iVar1;
  
  if (((cmd & 0xfU) != 1) && ((cmd & 0xfU) != 2)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  iVar1 = _event_write(f->f_arg,arg,SUB41(cmd >> 4,0));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



ssize_t event_write(file_t *f,void *buf,size_t len)

{
  ssize_t sVar1;
  
  sVar1 = _event_write(f->f_arg,(size_t)buf,SUB41(len,0));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



int event_close(file_t *file)

{
  aos_mutex_t *mutex;
  aos_mutex_t *paVar1;
  void *pvVar2;
  void **ppvVar3;
  
  mutex = (aos_mutex_t *)file->f_arg;
  aos_mutex_free(mutex);
  while (paVar1 = (aos_mutex_t *)mutex[6].hdl, paVar1 != mutex + 5) {
    pvVar2 = paVar1->hdl;
    ppvVar3 = (void **)paVar1[1].hdl;
    *(void ***)((int)pvVar2 + 4) = ppvVar3;
    *ppvVar3 = pvVar2;
    aos_free(paVar1);
  }
  while (paVar1 = (aos_mutex_t *)mutex[9].hdl, paVar1 != mutex + 8) {
    pvVar2 = paVar1->hdl;
    ppvVar3 = (void **)paVar1[1].hdl;
    *(void ***)((int)pvVar2 + 4) = ppvVar3;
    *ppvVar3 = pvVar2;
    aos_free(paVar1);
  }
  aos_free(mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Type propagation algorithm not settling

ssize_t event_read(file_t *f,void *buf,size_t len)

{
  aos_mutex_t *mutex;
  void *pv;
  int iVar1;
  int *piVar2;
  void **ppvVar3;
  uint __n;
  
  mutex = (aos_mutex_t *)f->f_arg;
  __n = (uint)mutex[4].hdl;
  if (__n != 0) {
    aos_mutex_lock(mutex,0xffffffff);
    pv = mutex[6].hdl;
                    // WARNING: Load size is inaccurate
    iVar1 = *pv;
    piVar2 = *(int **)((int)pv + 4);
    *(int **)(iVar1 + 4) = piVar2;
    *piVar2 = iVar1;
    __n = *(uint *)((int)pv + 8);
    if (len < *(uint *)((int)pv + 8)) {
      __n = len;
    }
    memcpy(buf,(void *)((int)pv + 0xc),__n);
    if ((int)mutex[7].hdl < 4) {
      ppvVar3 = (void **)mutex[9].hdl;
      *(aos_mutex_t **)pv = mutex + 8;
      *(void ***)((int)pv + 4) = ppvVar3;
      mutex[9].hdl = pv;
      *ppvVar3 = pv;
      mutex[7].hdl = (void *)((int)mutex[7].hdl + 1);
    }
    else {
      aos_free(pv);
    }
    mutex[4].hdl = (void *)((int)mutex[4].hdl + -1);
    aos_mutex_unlock(mutex);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __n;
}



int vfs_device_init(void)

{
  int iVar1;
  
  iVar1 = 0;
  if ((inited != 1) &&
     (iVar1 = aos_register_driver("/dev/event",&event_fops,(void *)0x0), iVar1 == 0)) {
    inited = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Could not reconcile some variable overlaps

void event_read_cb(int fd,void *param)

{
  dlist_s *pdVar1;
  ssize_t sVar2;
  undefined auStack32 [4];
  input_event_t event;
  
  sVar2 = aos_read(fd,auStack32,0x10);
  if (sVar2 == 0x10) {
    pdVar1 = g_local_event_list.next;
    if ((short)event.time == 0x100) {
      (*event._4_4_)(event.value,event._4_4_);
    }
    else {
      while (pdVar1 != (dlist_s *)&g_local_event_list) {
        if ((*(short *)&((dlist_t *)pdVar1)[2].prev == 0) ||
           ((short)event.time == *(short *)&((dlist_t *)pdVar1)[2].prev)) {
          (*(code *)((dlist_t *)pdVar1)[1].prev)
                    (auStack32,((dlist_t *)pdVar1)[1].next,((dlist_t *)pdVar1)[1].prev);
        }
        pdVar1 = ((dlist_t *)pdVar1)->next;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int aos_event_service_init(void)

{
  int sock;
  
  sock = aos_open("/dev/event",0);
  if (local_event.fd < 0) {
    local_event.fd = sock;
  }
  aos_poll_read_fd(sock,event_read_cb,(void *)0x0);
  aos_loop_set_eventfd(sock);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

int aos_post_event(uint16_t type,uint16_t code,ulong value)

{
  undefined2 in_register_0000202a;
  int iVar1;
  undefined4 local_20;
  input_event_t event;
  
  event.time._0_2_ = (ushort)((CONCAT22(in_register_0000202a,type) << 0x11) >> 0x11);
  local_20 = 0;
  event.value = 0;
  event.time._2_2_ = code;
  event._4_4_ = value;
  iVar1 = aos_ioctl(local_event.fd,(CONCAT22(in_register_0000202a,type) >> 0xf) + 0x101,
                    (ulong)&local_20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int aos_register_event_filter(uint16_t type,aos_event_cb *cb,void *priv)

{
  dlist_s *pdVar1;
  int iVar2;
  
  if (cb != (aos_event_cb *)0x0) {
    pdVar1 = (dlist_s *)aos_malloc(0x14);
    iVar2 = -0xc;
    if (pdVar1 != (dlist_s *)0x0) {
      pdVar1[1].prev = (dlist_s *)cb;
      *(uint16_t *)&pdVar1[2].prev = type;
      pdVar1->prev = g_local_event_list.prev;
      pdVar1[1].next = (dlist_s *)priv;
      pdVar1->next = (dlist_s *)&g_local_event_list;
      (g_local_event_list.prev)->next = pdVar1;
      iVar2 = 0;
      g_local_event_list.prev = pdVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x16;
}



IoT_Error_t aws_iot_shadow_init(AWS_IoT_Client *pClient,ShadowInitParameters_t *pParams)

{
  IoT_Error_t IVar1;
  int iVar2;
  undefined3 extraout_var;
  undefined auStack68 [4];
  IoT_Client_Init_Params mqttInitParams;
  
  memcpy(auStack68,&DAT_230879c0,0x34);
  iVar2 = -2;
  if ((pClient != (AWS_IoT_Client *)0x0) && (pParams != (ShadowInitParameters_t *)0x0)) {
    auStack68[0] = pParams->enableAutoReconnect;
    mqttInitParams._0_4_ = pParams->pHost;
    mqttInitParams.pHostURL._0_2_ = pParams->port;
    mqttInitParams._8_4_ = pParams->pRootCA;
    mqttInitParams.pRootCALocation = pParams->pClientCRT;
    mqttInitParams.pDeviceCertLocation = pParams->pClientKey;
    mqttInitParams.pDevicePrivateKeyLocation = (char *)0x1388;
    mqttInitParams.tlsHandshakeTimeout_ms._0_1_ = true;
    mqttInitParams._36_4_ = pParams->disconnectHandler;
    IVar1 = aws_iot_mqtt_init(pClient,(IoT_Client_Init_Params *)auStack68);
    iVar2 = CONCAT31(extraout_var,IVar1);
    if (iVar2 == 0) {
      resetClientTokenSequenceNum();
      shadowJsonVersionNum = 0;
      initDeltaTokens();
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar2;
}



IoT_Error_t aws_iot_shadow_connect(AWS_IoT_Client *pClient,ShadowConnectParameters_t *pParams)

{
  uint uVar1;
  IoT_Error_t IVar2;
  byte bVar3;
  undefined3 extraout_var;
  size_t sVar4;
  undefined auStack88 [4];
  IoT_Client_Connect_Params ConnectParams;
  
  uVar1 = 0xfffffffe;
  memcpy(auStack88,&iotClientConnectParamsDefault,0x38);
  if (((pClient != (AWS_IoT_Client *)0x0) && (pParams != (ShadowConnectParameters_t *)0x0)) &&
     (pParams->pMqttClientId != (char *)0x0)) {
    snprintf(myThingName,0x14,"%s",pParams->pMyThingName);
    snprintf(mqttClientID,0x50,"%s",pParams->pMqttClientId);
    ConnectParams.struct_id[0] = MQTT_3_1_1;
    ConnectParams.pClientID._2_2_ = 600;
    ConnectParams.clientIDLen = 1;
    ConnectParams._4_4_ = pParams->pMqttClientId;
    ConnectParams.pClientID._0_2_ = pParams->mqttClientIdLen;
    ConnectParams._44_4_ = (char *)0x0;
    ConnectParams.will._16_4_ = (char *)0x0;
    IVar2 = aws_iot_mqtt_connect(pClient,(IoT_Client_Connect_Params *)auStack88);
    uVar1 = CONCAT31(extraout_var,IVar2);
    if (uVar1 == 0) {
      initializeRecords(pClient);
      if (pParams->deleteActionHandler != (pApplicationHandler_t *)0x0) {
        snprintf(deleteAcceptedTopic,0x50,"$aws/things/%s/shadow/delete/accepted",myThingName);
        sVar4 = strlen(deleteAcceptedTopic);
        bVar3 = aws_iot_mqtt_subscribe
                          (pClient,deleteAcceptedTopic,(uint16_t)sVar4,QOS1,
                           pParams->deleteActionHandler,myThingName);
        uVar1 = (uint)bVar3;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar1;
}



IoT_Error_t aws_iot_shadow_register_delta(AWS_IoT_Client *pMqttClient,jsonStruct_t *pStruct)

{
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  
  if ((pMqttClient != (AWS_IoT_Client *)0x0) && (pStruct != (jsonStruct_t *)0x0)) {
    _Var1 = aws_iot_mqtt_is_client_connected(pMqttClient);
    if (CONCAT31(extraout_var,_Var1) != 0) {
      IVar2 = registerJsonTokenOnDelta(pStruct);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar2;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return MQTT_CONNECTION_ERROR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_shadow_yield(AWS_IoT_Client *pClient,uint32_t timeout)

{
  IoT_Error_t IVar1;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    HandleExpiredResponseCallbacks();
    IVar1 = aws_iot_mqtt_yield(pClient,timeout);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_shadow_disconnect(AWS_IoT_Client *pClient)

{
  ClientState expectedCurrentState;
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar3;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    iVar3 = -0xd;
    if (CONCAT31(extraout_var,_Var1) != 0) {
      IVar2 = aws_iot_mqtt_set_client_state(pClient,expectedCurrentState,CLIENT_STATE_DISCONNECTING)
      ;
      iVar3 = CONCAT31(extraout_var_00,IVar2);
      if (iVar3 == 0) {
        IVar2 = _aws_iot_mqtt_internal_disconnect(pClient);
        iVar3 = CONCAT31(extraout_var_01,IVar2);
        if (iVar3 == 0) {
          (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_MANUALLY;
        }
        else {
          (pClient->clientStatus).clientState = expectedCurrentState;
        }
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)iVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_update
          (AWS_IoT_Client *pClient,char *pThingName,char *pJsonString,fpActionCallback_t *callback,
          void *pContextData,uint8_t timeout_seconds,_Bool isPersistentSubscribe)

{
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  size_t jsonSize;
  undefined3 in_register_0000203d;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  _Var1 = aws_iot_mqtt_is_client_connected(pClient);
  if (CONCAT31(extraout_var,_Var1) != 0) {
    jsonSize = strlen(pJsonString);
    IVar2 = aws_iot_shadow_internal_action
                      (pThingName,SHADOW_UPDATE,pJsonString,jsonSize,callback,pContextData,
                       CONCAT31(in_register_0000203d,timeout_seconds),isPersistentSubscribe);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return MQTT_CONNECTION_ERROR;
}



IoT_Error_t aws_iot_shadow_set_autoreconnect_status(AWS_IoT_Client *pClient,_Bool newStatus)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    (pClient->clientStatus).isAutoReconnectEnabled = newStatus;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_internal_action
          (char *pThingName,ShadowActions_t action,char *pJsonDocumentToBeSent,size_t jsonSize,
          fpActionCallback_t *callback,void *pCallbackContext,uint32_t timeout_seconds,
          _Bool isSticky)

{
  int iVar1;
  _Bool _Var2;
  _Bool _Var3;
  _Bool _Var4;
  IoT_Error_t IVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  int iVar6;
  uint8_t uStack141;
  char acStack140 [3];
  uint8_t indexAckWaitList;
  char extractedClientToken [90];
  
  iVar1 = -2;
  if ((pThingName != (char *)0x0) && (pJsonDocumentToBeSent != (char *)0x0)) {
    _Var2 = extractClientToken(pJsonDocumentToBeSent,jsonSize,acStack140,0x5a);
    if ((CONCAT31(extraout_var,_Var2) == 0) || (callback == (fpActionCallback_t *)0x0)) {
      iVar6 = 0;
    }
    else {
      _Var3 = getNextFreeIndexOfAckWaitList(&uStack141);
      iVar1 = -1;
      if (CONCAT31(extraout_var_00,_Var3) == 0) goto LAB_2304daaa;
      _Var4 = isSubscriptionPresent(pThingName,action);
      iVar6 = CONCAT31(extraout_var_01,_Var4);
      if (iVar6 == 0) {
        IVar5 = subscribeToShadowActionAcks(pThingName,action,isSticky);
        iVar1 = CONCAT31(extraout_var_02,IVar5);
        iVar6 = CONCAT31(extraout_var_00,_Var3);
        if (iVar1 != 0) goto LAB_2304daaa;
      }
      else {
        incrementSubscriptionCnt(pThingName,action,isSticky);
      }
    }
    IVar5 = publishToShadowAction(pThingName,action,pJsonDocumentToBeSent);
    iVar1 = CONCAT31(extraout_var_03,IVar5);
    if ((((CONCAT31(extraout_var,_Var2) != 0) && (callback != (fpActionCallback_t *)0x0)) &&
        (iVar1 == 0)) && (iVar6 != 0)) {
      addToAckWaitList(uStack141,pThingName,action,acStack140,callback,pCallbackContext,
                       timeout_seconds);
    }
  }
LAB_2304daaa:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar1;
}



IoT_Error_t
convertDataToString(char *pStringBuffer,size_t maxSizoStringBuffer,JsonPrimitiveType type,
                   void *pData)

{
  uint uVar1;
  undefined3 in_register_00002031;
  int iVar2;
  char *format;
  char *pcVar3;
  IoT_Error_t IVar4;
  size_t sVar5;
  
  iVar2 = CONCAT31(in_register_00002031,type);
  if (maxSizoStringBuffer == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SHADOW_JSON_ERROR;
  }
  if (iVar2 == 0) {
                    // WARNING: Load size is inaccurate
    pcVar3 = *pData;
    format = "%li,";
LAB_2304db20:
    uVar1 = snprintf(pStringBuffer,maxSizoStringBuffer,format,pcVar3);
  }
  else {
    if (iVar2 == 1) {
                    // WARNING: Load size is inaccurate
      pcVar3 = (char *)(int)*pData;
      format = "%hi,";
      goto LAB_2304db20;
    }
    if (iVar2 == 2) {
                    // WARNING: Load size is inaccurate
      pcVar3 = (char *)(int)*pData;
      format = "%hhi,";
      goto LAB_2304db20;
    }
    if (iVar2 == 3) {
                    // WARNING: Load size is inaccurate
      pcVar3 = *pData;
      format = "%lu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 4) {
                    // WARNING: Load size is inaccurate
      pcVar3 = (char *)(uint)*pData;
      format = "%hu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 5) {
                    // WARNING: Load size is inaccurate
      pcVar3 = (char *)(uint)*pData;
      format = "%hhu,";
      goto LAB_2304db20;
    }
    if (iVar2 == 7) {
                    // WARNING: Load size is inaccurate
      pcVar3 = *pData;
      sVar5 = *(size_t *)((int)pData + 4);
    }
    else {
      if (iVar2 != 6) {
        if (iVar2 == 8) {
                    // WARNING: Load size is inaccurate
          if (*pData == '\0') {
            pcVar3 = "false";
          }
          else {
            pcVar3 = "true";
          }
LAB_2304dbe6:
          iVar2 = -0x538;
        }
        else {
          pcVar3 = (char *)pData;
          if (iVar2 != 9) {
            uVar1 = 0;
            if (iVar2 != 10) goto LAB_2304dc16;
            goto LAB_2304dbe6;
          }
          iVar2 = -0x534;
        }
        format = "ERROR failed! net_set_(non)block() returned -0x%x\r\n" + iVar2 + 0x14;
        goto LAB_2304db20;
      }
      pcVar3 = pStringBuffer;
      sVar5 = maxSizoStringBuffer;
      __extendsfdf2((SFtype)pStringBuffer);
    }
    uVar1 = snprintf(pStringBuffer,maxSizoStringBuffer,"%f,",pcVar3,sVar5);
  }
  if ((int)uVar1 < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SHADOW_JSON_ERROR;
  }
LAB_2304dc16:
  IVar4 = SUCCESS;
  if (maxSizoStringBuffer <= uVar1) {
    IVar4 = SHADOW_JSON_BUFFER_TRUNCATED;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar4;
}



void resetClientTokenSequenceNum(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  clientTokenNum = 0;
  return;
}



IoT_Error_t aws_iot_shadow_init_json_document(char *pJsonDocument,size_t maxSizeOfJsonDocument)

{
  uint uVar1;
  IoT_Error_t IVar2;
  
  if (pJsonDocument != (char *)0x0) {
    uVar1 = snprintf(pJsonDocument,maxSizeOfJsonDocument,"{\"state\":{");
    IVar2 = SHADOW_JSON_ERROR;
    if ((-1 < (int)uVar1) && (IVar2 = SUCCESS, maxSizeOfJsonDocument <= uVar1)) {
      IVar2 = SHADOW_JSON_BUFFER_TRUNCATED;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_shadow_add_reported(char *pJsonDocument,size_t maxSizeOfJsonDocument,uint8_t count,...)

{
  int *piVar1;
  IoT_Error_t IVar2;
  size_t sVar3;
  uint uVar4;
  undefined3 extraout_var;
  int *in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  int iVar5;
  undefined4 in_a6;
  undefined4 in_a7;
  int iVar6;
  uint n;
  int **ppiStack84;
  va_list pArgs;
  int *piStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  ppiStack84 = &piStack20;
  if (pJsonDocument == (char *)0x0) {
LAB_2304dc88:
    iVar5 = -2;
  }
  else {
    piStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    sVar3 = strlen(pJsonDocument);
    n = maxSizeOfJsonDocument - sVar3;
    if (n < 2) {
LAB_2304dcb6:
      iVar5 = -0x2d;
    }
    else {
      sVar3 = strlen(pJsonDocument);
      uVar4 = snprintf(pJsonDocument + sVar3,n,"\"reported\":{");
      iVar5 = -0x2d;
      if (-1 < (int)uVar4) {
        iVar6 = 0;
        if (uVar4 < n) {
          while (iVar6 < _count) {
            sVar3 = strlen(pJsonDocument);
            n = maxSizeOfJsonDocument - sVar3;
            if (n < 2) goto LAB_2304dcb6;
            piVar1 = *ppiStack84;
            ppiStack84 = ppiStack84 + 1;
            if (piVar1 == (int *)0x0) goto LAB_2304dc88;
            sVar3 = strlen(pJsonDocument);
            uVar4 = snprintf(pJsonDocument + sVar3,n,"\"%s\":",*piVar1);
            if ((int)uVar4 < 0) goto LAB_2304dcb6;
            if (n <= uVar4) goto LAB_2304dd10;
            if ((*piVar1 == 0) || (piVar1[1] == 0)) goto LAB_2304dc88;
            sVar3 = strlen(pJsonDocument);
            IVar2 = convertDataToString(pJsonDocument + sVar3,n,*(JsonPrimitiveType *)(piVar1 + 3),
                                        (void *)piVar1[1]);
            iVar5 = CONCAT31(extraout_var,IVar2);
            if (iVar5 != 0) goto LAB_2304dc8a;
            iVar6 = (iVar6 + 1) * 0x1000000 >> 0x18;
          }
          sVar3 = strlen(pJsonDocument);
          uVar4 = snprintf(pJsonDocument + (sVar3 - 1),n,"},");
          iVar5 = -0x2d;
          if (((int)uVar4 < 0) || (iVar5 = 0, uVar4 < n)) goto LAB_2304dc8a;
        }
LAB_2304dd10:
        iVar5 = -0x2c;
      }
    }
  }
LAB_2304dc8a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar5;
}



int32_t FillWithClientTokenSize
                  (char *pBufferToBeUpdatedWithClientToken,size_t maxSizeOfJsonDocument)

{
  int iVar1;
  
  clientTokenNum = clientTokenNum + 1;
  iVar1 = snprintf(pBufferToBeUpdatedWithClientToken,maxSizeOfJsonDocument,"%s-%d",mqttClientID);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



IoT_Error_t aws_iot_finalize_json_document(char *pJsonDocument,size_t maxSizeOfJsonDocument)

{
  size_t sVar1;
  uint uVar2;
  uint uVar3;
  
  if (pJsonDocument == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  sVar1 = strlen(pJsonDocument);
  uVar3 = maxSizeOfJsonDocument - sVar1;
  if (1 < uVar3) {
    sVar1 = strlen(pJsonDocument);
    uVar2 = snprintf(pJsonDocument + (sVar1 - 1),uVar3,"}, \"%s\":\"","clientToken");
    if (-1 < (int)uVar2) {
      if (uVar3 <= uVar2) goto LAB_2304ddbe;
      sVar1 = strlen(pJsonDocument);
      uVar3 = maxSizeOfJsonDocument - sVar1;
      if (1 < uVar3) {
        sVar1 = strlen(pJsonDocument);
        uVar2 = FillWithClientTokenSize(pJsonDocument + sVar1,uVar3);
        if (-1 < (int)uVar2) {
          if (uVar3 <= uVar2) {
LAB_2304ddbe:
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return SHADOW_JSON_BUFFER_TRUNCATED;
          }
          sVar1 = strlen(pJsonDocument);
          uVar3 = maxSizeOfJsonDocument - sVar1;
          if (1 < uVar3) {
            sVar1 = strlen(pJsonDocument);
            uVar2 = snprintf(pJsonDocument + sVar1,uVar3,"\"}");
            if (-1 < (int)uVar2) {
              if (uVar2 < uVar3) {
                gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                return SUCCESS;
              }
              goto LAB_2304ddbe;
            }
          }
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SHADOW_JSON_ERROR;
}



_Bool isJsonValidAndParse(char *pJsonDocument,size_t jsonSize,void *pJsonHandler,
                         int32_t *pTokenCount)

{
  int iVar1;
  _Bool _Var2;
  
  jsmn_init(&shadowJsonParser);
  iVar1 = jsmn_parse(&shadowJsonParser,pJsonDocument,jsonSize,jsonTokenStruct,0x78);
  _Var2 = false;
  if ((0 < iVar1) && (_Var2 = false, jsonTokenStruct[0].type == JSMN_OBJECT)) {
    *pTokenCount = iVar1;
    _Var2 = true;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



_Bool isJsonKeyMatchingAndUpdateValue
                (char *pJsonDocument,void *pJsonHandler,int32_t tokenCount,jsonStruct_t *pDataStruct
                ,uint32_t *pDataLength,int32_t *pDataPosition)

{
  JsonPrimitiveType JVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar3;
  uint32_t uVar4;
  undefined auStack80 [4];
  int iStack76;
  int iStack72;
  jsmntok_t jStack64;
  
  iVar3 = 1;
  while (iVar3 < tokenCount) {
    iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar3,pDataStruct->pKey);
    if (CONCAT31(extraout_var,iVar2) == 0) {
      iVar3 = iVar3 + 1;
      memcpy(auStack80,jsonTokenStruct + iVar3,0x10);
      iStack72 = jsonTokenStruct[iVar3].end;
      iVar3 = jsonTokenStruct[iVar3].start;
      uVar4 = iStack72 - iVar3;
      iStack76 = iVar3;
      memcpy(&jStack64,auStack80,0x10);
      JVar1 = pDataStruct->type;
      if (JVar1 == SHADOW_JSON_BOOL) {
        if (pDataStruct->dataLength != 0) {
          parseBooleanValue((_Bool *)pDataStruct->pData,pJsonDocument,&jStack64);
        }
      }
      else {
        if (JVar1 == SHADOW_JSON_INT32) {
          if (3 < pDataStruct->dataLength) {
            parseInteger32Value((int32_t *)pDataStruct->pData,pJsonDocument,&jStack64);
          }
        }
        else {
          if (JVar1 == SHADOW_JSON_INT16) {
            if (1 < pDataStruct->dataLength) {
              parseInteger16Value((int16_t *)pDataStruct->pData,pJsonDocument,&jStack64);
            }
          }
          else {
            if (JVar1 == SHADOW_JSON_INT8) {
              if (pDataStruct->dataLength != 0) {
                parseInteger8Value((int8_t *)pDataStruct->pData,pJsonDocument,&jStack64);
              }
            }
            else {
              if (JVar1 == SHADOW_JSON_UINT32) {
                if (3 < pDataStruct->dataLength) {
                  parseUnsignedInteger32Value
                            ((uint32_t *)pDataStruct->pData,pJsonDocument,&jStack64);
                }
              }
              else {
                if (JVar1 == SHADOW_JSON_UINT16) {
                  if (1 < pDataStruct->dataLength) {
                    parseUnsignedInteger16Value
                              ((uint16_t *)pDataStruct->pData,pJsonDocument,&jStack64);
                  }
                }
                else {
                  if (JVar1 == SHADOW_JSON_UINT8) {
                    if (pDataStruct->dataLength != 0) {
                      parseUnsignedInteger8Value
                                ((uint8_t *)pDataStruct->pData,pJsonDocument,&jStack64);
                    }
                  }
                  else {
                    if (JVar1 == SHADOW_JSON_FLOAT) {
                      if (3 < pDataStruct->dataLength) {
                        parseFloatValue((float *)pDataStruct->pData,pJsonDocument,&jStack64);
                      }
                    }
                    else {
                      if (JVar1 == SHADOW_JSON_DOUBLE) {
                        if (7 < pDataStruct->dataLength) {
                          parseDoubleValue((double *)pDataStruct->pData,pJsonDocument,&jStack64);
                        }
                      }
                      else {
                        if (JVar1 == SHADOW_JSON_STRING) {
                          parseStringValue((char *)pDataStruct->pData,pDataStruct->dataLength,
                                           pJsonDocument,&jStack64);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      *pDataPosition = iVar3;
      *pDataLength = uVar4;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return true;
    }
    iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar3,"metadata");
    if (CONCAT31(extraout_var_00,iVar2) == 0) break;
    iVar3 = iVar3 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool extractClientToken(char *pJsonDocument,size_t jsonSize,char *pExtractedClientToken,
                        size_t clientTokenSize)

{
  uint __n;
  int iVar1;
  int8_t iVar2;
  int iVar3;
  undefined3 extraout_var;
  
  jsmn_init(&shadowJsonParser);
  iVar3 = jsmn_parse(&shadowJsonParser,pJsonDocument,jsonSize,jsonTokenStruct,0x78);
  if ((0 < iVar3) && (jsonTokenStruct[0].type == JSMN_OBJECT)) {
    iVar1 = 1;
    do {
      if (iVar1 == iVar3) goto LAB_2304e086;
      iVar2 = jsoneq(pJsonDocument,jsonTokenStruct + iVar1,"clientToken");
      iVar1 = iVar1 + 1;
    } while (CONCAT31(extraout_var,iVar2) != 0);
    __n = jsonTokenStruct[iVar1].end - jsonTokenStruct[iVar1].start & 0xff;
    if (__n + 1 <= clientTokenSize) {
      strncpy(pExtractedClientToken,pJsonDocument + jsonTokenStruct[iVar1].start,__n);
      pExtractedClientToken[__n] = '\0';
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return true;
    }
  }
LAB_2304e086:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



_Bool extractVersionNumber
                (char *pJsonDocument,void *pJsonHandler,int32_t tokenCount,uint32_t *pVersionNumber)

{
  int iVar1;
  int iVar2;
  int8_t iVar3;
  IoT_Error_t IVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  
  iVar1 = 1;
  do {
    iVar2 = iVar1;
    if (tokenCount <= iVar2) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return false;
    }
    iVar3 = jsoneq(pJsonDocument,jsonTokenStruct + iVar2,"version");
    iVar1 = iVar2 + 1;
  } while ((CONCAT31(extraout_var,iVar3) != 0) ||
          (IVar4 = parseUnsignedInteger32Value
                             (pVersionNumber,pJsonDocument,jsonTokenStruct + iVar2 + 1),
          CONCAT31(extraout_var_00,IVar4) != 0));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return true;
}



void shadow_delta_callback
               (AWS_IoT_Client *pClient,char *topicName,uint16_t topicNameLen,
               IoT_Publish_Message_Params *params,void *pData)

{
  JsonTokenTable_t *pJVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar3;
  int32_t local_30;
  int32_t tokenCount;
  int32_t DataPosition;
  uint32_t dataLength;
  uint32_t tempVersionNumber;
  
  dataLength = 0;
  if (params->payloadLen < 0x201) {
    memcpy(shadowRxBuf,params->payload,params->payloadLen);
    shadowRxBuf[params->payloadLen] = '\0';
    _Var2 = isJsonValidAndParse(shadowRxBuf,0x201,(void *)0x0,&local_30);
    if (CONCAT31(extraout_var,_Var2) != 0) {
      if ((shadowDiscardOldDeltaFlag != false) &&
         (_Var2 = extractVersionNumber(shadowRxBuf,(void *)0x0,local_30,&dataLength),
         CONCAT31(extraout_var_00,_Var2) != 0)) {
        if (dataLength <= shadowJsonVersionNum) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return;
        }
        shadowJsonVersionNum = dataLength;
      }
      pJVar1 = tokenTable;
      uVar3 = 0;
      while (uVar3 < tokenTableIndex) {
        if (((pJVar1->isFree == false) &&
            (_Var2 = isJsonKeyMatchingAndUpdateValue
                               (shadowRxBuf,(void *)0x0,local_30,(jsonStruct_t *)pJVar1->pStruct,
                                (uint32_t *)&DataPosition,&tokenCount),
            CONCAT31(extraout_var_01,_Var2) != 0)) &&
           (pJVar1->callback != (jsonStructCallback_t *)0x0)) {
          (*pJVar1->callback)(shadowRxBuf + tokenCount,DataPosition,(jsonStruct_t *)pJVar1->pStruct)
          ;
        }
        uVar3 = uVar3 + 1;
        pJVar1 = pJVar1 + 1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int16_t findIndexOfSubscriptionList(char *pTopic)

{
  SubscriptionRecord_t *__s2;
  ushort uVar1;
  int iVar2;
  
  __s2 = SubscriptionList;
  uVar1 = 0;
  do {
    if ((__s2->isFree == false) && (iVar2 = strcmp(pTopic,(char *)__s2), iVar2 == 0))
    goto LAB_2304e25a;
    uVar1 = uVar1 + 1 & 0xff;
    __s2 = __s2 + 1;
  } while (uVar1 != 0x14);
  uVar1 = 0xffff;
LAB_2304e25a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (int16_t)uVar1;
}



// WARNING: Variable defined which should be unmapped: ackTypeBuf

void topicNameFromThingAndAction
               (char *pTopic,char *pThingName,ShadowActions_t action,ShadowAckTopicTypes_t ackType)

{
  char *pcVar1;
  undefined3 in_register_00002031;
  int iVar2;
  undefined3 in_register_00002035;
  char acStack40 [4];
  char actionBuf [10];
  char ackTypeBuf [10];
  
  iVar2 = CONCAT31(in_register_00002031,action);
  if (iVar2 == 0) {
    pcVar1 = "get";
  }
  else {
    if (iVar2 == 1) {
      pcVar1 = "update";
    }
    else {
      if (iVar2 != 2) goto LAB_2304e29c;
      pcVar1 = "delete";
    }
  }
  strncpy(acStack40,pcVar1,10);
LAB_2304e29c:
  if (CONCAT31(in_register_00002035,ackType) == 0) {
    pcVar1 = "accepted";
  }
  else {
    if (CONCAT31(in_register_00002035,ackType) != 1) {
      snprintf(pTopic,0x50,"$aws/things/%s/shadow/%s",pThingName,acStack40);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    pcVar1 = "rejected";
  }
  strncpy(actionBuf + 8,pcVar1,10);
  snprintf(pTopic,0x50,"$aws/things/%s/shadow/%s/%s",pThingName,acStack40,actionBuf + 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: TemporaryTopicNameRejected

void unsubscribeFromAcceptedAndRejected(uint8_t index)

{
  byte bVar1;
  AWS_IoT_Client *pAVar2;
  IoT_Error_t IVar3;
  int16_t iVar4;
  undefined3 in_register_00002029;
  int iVar5;
  short extraout_var_01;
  size_t sVar6;
  undefined3 extraout_var;
  short extraout_var_02;
  undefined3 extraout_var_00;
  char acStack176 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  iVar5 = CONCAT31(in_register_00002029,index);
  topicNameFromThingAndAction
            (acStack176,AckWaitList[iVar5].thingName,AckWaitList[iVar5].action,SHADOW_ACCEPTED);
  topicNameFromThingAndAction
            (TemporaryTopicNameAccepted + 0x4c,AckWaitList[iVar5].thingName,
             AckWaitList[iVar5].action,SHADOW_REJECTED);
  iVar4 = findIndexOfSubscriptionList(acStack176);
  pAVar2 = pMqttClient;
  iVar5 = CONCAT22(extraout_var_01,iVar4);
  if (-1 < extraout_var_01) {
    bVar1 = SubscriptionList[iVar5].count;
    if ((SubscriptionList[iVar5].isSticky == false) && (bVar1 == 1)) {
      sVar6 = strlen(acStack176);
      IVar3 = aws_iot_mqtt_unsubscribe(pAVar2,acStack176,(uint16_t)sVar6);
      if (CONCAT31(extraout_var,IVar3) == 0) {
        SubscriptionList[iVar5].isFree = true;
      }
    }
    else {
      if (1 < bVar1) {
        SubscriptionList[iVar5].count = bVar1 - 1;
      }
    }
  }
  iVar4 = findIndexOfSubscriptionList(TemporaryTopicNameAccepted + 0x4c);
  pAVar2 = pMqttClient;
  iVar5 = CONCAT22(extraout_var_02,iVar4);
  if (-1 < extraout_var_02) {
    bVar1 = SubscriptionList[iVar5].count;
    if ((SubscriptionList[iVar5].isSticky == false) && (bVar1 == 1)) {
      sVar6 = strlen(TemporaryTopicNameAccepted + 0x4c);
      IVar3 = aws_iot_mqtt_unsubscribe(pAVar2,TemporaryTopicNameAccepted + 0x4c,(uint16_t)sVar6);
      if (CONCAT31(extraout_var_00,IVar3) == 0) {
        SubscriptionList[iVar5].isFree = true;
      }
    }
    else {
      if (1 < bVar1) {
        SubscriptionList[iVar5].count = bVar1 - 1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void AckStatusCallback(AWS_IoT_Client *pClient,char *topicName,uint16_t topicNameLen,
                      IoT_Publish_Message_Params *params,void *pData)

{
  int iVar1;
  _Bool _Var2;
  undefined3 extraout_var;
  char *pcVar3;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar4;
  Shadow_Ack_Status_t SVar5;
  ToBeReceivedAckRecord_t *__s1;
  int32_t iStack164;
  int32_t tokenCount;
  char temporaryClientToken [110];
  
  if (0x200 < params->payloadLen) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memcpy(shadowRxBuf,params->payload,params->payloadLen);
  shadowRxBuf[params->payloadLen] = '\0';
  _Var2 = isJsonValidAndParse(shadowRxBuf,0x201,(void *)0x0,&iStack164);
  if (CONCAT31(extraout_var,_Var2) != 0) {
    pcVar3 = strstr(topicName,myThingName);
    if ((pcVar3 != (char *)0x0) &&
       ((pcVar3 = strstr(topicName,"get/accepted"), pcVar3 != (char *)0x0 ||
        (pcVar3 = strstr(topicName,"delta"), pcVar3 != (char *)0x0)))) {
      tokenCount = 0;
      _Var2 = extractVersionNumber(shadowRxBuf,(void *)0x0,iStack164,(uint32_t *)&tokenCount);
      if ((CONCAT31(extraout_var_00,_Var2) != 0) && (shadowJsonVersionNum < (uint)tokenCount)) {
        shadowJsonVersionNum = tokenCount;
      }
    }
    _Var2 = extractClientToken(shadowRxBuf,0x201,(char *)&tokenCount,0x6e);
    if (CONCAT31(extraout_var_01,_Var2) != 0) {
      __s1 = AckWaitList;
      iVar1 = 0;
      do {
        if (__s1->isFree == false) {
          iVar4 = strcmp((char *)__s1,(char *)&tokenCount);
          if (iVar4 == 0) {
            pcVar3 = strstr(topicName,"accepted");
            SVar5 = SHADOW_ACK_ACCEPTED;
            if (pcVar3 == (char *)0x0) {
              strstr(topicName,"rejected");
              SVar5 = SHADOW_ACK_REJECTED;
            }
            if (AckWaitList[iVar1].callback != (fpActionCallback_t *)0x0) {
              (*AckWaitList[iVar1].callback)
                        ((char *)(iVar1 * 0x88 + 0x4202086e),AckWaitList[iVar1].action,SVar5,
                         shadowRxBuf,AckWaitList[iVar1].pCallbackContext);
            }
            unsubscribeFromAcceptedAndRejected((uint8_t)iVar1);
            AckWaitList[iVar1].isFree = true;
            break;
          }
        }
        iVar1 = iVar1 + 1;
        __s1 = __s1 + 1;
      } while (iVar1 != 10);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void initDeltaTokens(void)

{
  JsonTokenTable_t *pJVar1;
  
  pJVar1 = tokenTable;
  do {
    pJVar1->isFree = true;
    pJVar1 = pJVar1 + 1;
  } while (pJVar1 != (JsonTokenTable_t *)pUsernameTemp);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  deltaTopicSubscribedFlag = false;
  tokenTableIndex = 0;
  return;
}



IoT_Error_t registerJsonTokenOnDelta(jsonStruct_t *pStruct)

{
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar1;
  size_t sVar2;
  jsonStructCallback_t *pjVar3;
  
  IVar1 = SUCCESS;
  if (deltaTopicSubscribedFlag == false) {
    snprintf(shadowDeltaTopic,0x50,"$aws/things/%s/shadow/update/delta",myThingName);
    pClient = pMqttClient;
    sVar2 = strlen(shadowDeltaTopic);
    IVar1 = aws_iot_mqtt_subscribe
                      (pClient,shadowDeltaTopic,(uint16_t)sVar2,QOS0,shadow_delta_callback,
                       (void *)0x0);
    deltaTopicSubscribedFlag = true;
  }
  if (tokenTableIndex < 0x78) {
    tokenTable[tokenTableIndex].pKey = pStruct->pKey;
    pjVar3 = pStruct->cb;
    tokenTable[tokenTableIndex].pStruct = pStruct;
    tokenTable[tokenTableIndex].callback = pjVar3;
    tokenTable[tokenTableIndex].isFree = false;
    tokenTableIndex = tokenTableIndex + 1;
  }
  else {
    IVar1 = FAILURE;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



void initializeRecords(AWS_IoT_Client *pClient)

{
  ToBeReceivedAckRecord_t *pTVar1;
  SubscriptionRecord_t *pSVar2;
  
  pTVar1 = AckWaitList;
  do {
    pTVar1->isFree = true;
    pTVar1 = pTVar1 + 1;
  } while (pTVar1 != (ToBeReceivedAckRecord_t *)&_fsymc_level_bloop);
  pSVar2 = SubscriptionList;
  do {
    pSVar2->isFree = true;
    pSVar2->count = '\0';
    pSVar2->isSticky = false;
    pSVar2 = pSVar2 + 1;
  } while (pSVar2 != (SubscriptionRecord_t *)&pMqttClient);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  pMqttClient = pClient;
  return;
}



_Bool isSubscriptionPresent(char *pThingName,ShadowActions_t action)

{
  bool bVar1;
  bool bVar2;
  SubscriptionRecord_t *__s2;
  int iVar3;
  char acStack192 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  topicNameFromThingAndAction(acStack192,pThingName,action,SHADOW_ACCEPTED);
  __s2 = SubscriptionList;
  topicNameFromThingAndAction(TemporaryTopicNameAccepted + 0x4c,pThingName,action,SHADOW_REJECTED);
  bVar1 = false;
  bVar2 = false;
  do {
    if (__s2->isFree == false) {
      iVar3 = strcmp(acStack192,(char *)__s2);
      if (iVar3 == 0) {
        bVar2 = true;
      }
      else {
        iVar3 = strcmp(TemporaryTopicNameAccepted + 0x4c,(char *)__s2);
        if (iVar3 == 0) {
          bVar1 = true;
        }
      }
    }
    __s2 = __s2 + 1;
  } while (__s2 != (SubscriptionRecord_t *)&pMqttClient);
  if (bVar1) {
    bVar1 = bVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)bVar1;
}



IoT_Error_t subscribeToShadowActionAcks(char *pThingName,ShadowActions_t action,_Bool isSticky)

{
  uint8_t uVar1;
  AWS_IoT_Client *pAVar2;
  IoT_Error_t IVar3;
  _Bool _Var4;
  size_t sVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  SubscriptionRecord_t *pSVar6;
  SubscriptionRecord_t *pSVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined auStack76 [4];
  Timer subSettlingtimer;
  
  pSVar7 = SubscriptionList;
  pSVar6 = SubscriptionList;
  iVar8 = 0;
  do {
    if (pSVar6->isFree != false) {
      iVar10 = (int)(short)((ushort)iVar8 & 0xff);
      SubscriptionList[iVar8].isFree = false;
      goto LAB_2304e79a;
    }
    iVar8 = iVar8 + 1;
    pSVar6 = pSVar6 + 1;
  } while (iVar8 != 0x14);
  iVar10 = -1;
LAB_2304e79a:
  iVar8 = 0;
LAB_2304e79e:
  if (pSVar7->isFree == false) goto LAB_2304e886;
  iVar11 = (int)(short)((ushort)iVar8 & 0xff);
  IVar3 = SUCCESS;
  pSVar6 = SubscriptionList + iVar8;
  SubscriptionList[iVar8].isFree = false;
  if (iVar10 == -1) goto LAB_2304e8d6;
  pSVar7 = SubscriptionList + iVar10;
  topicNameFromThingAndAction((char *)pSVar7,pThingName,action,SHADOW_ACCEPTED);
  pAVar2 = pMqttClient;
  sVar5 = strlen((char *)pSVar7);
  IVar3 = aws_iot_mqtt_subscribe
                    (pAVar2,(char *)pSVar7,(uint16_t)sVar5,QOS0,AckStatusCallback,(void *)0x0);
  iVar9 = CONCAT31(extraout_var,IVar3);
  if (iVar9 == 0) {
    SubscriptionList[iVar10].count = '\x01';
    *(_Bool *)(iVar10 * 0x53 + 0x420201d2) = isSticky;
    topicNameFromThingAndAction((char *)pSVar6,pThingName,action,SHADOW_REJECTED);
    pAVar2 = pMqttClient;
    sVar5 = strlen((char *)pSVar6);
    IVar3 = aws_iot_mqtt_subscribe
                      (pAVar2,(char *)pSVar6,(uint16_t)sVar5,QOS0,AckStatusCallback,(void *)0x0);
    iVar9 = CONCAT31(extraout_var_00,IVar3);
    if (iVar9 == 0) {
      SubscriptionList[iVar8].count = '\x01';
      *(_Bool *)(iVar8 * 0x53 + 0x420201d2) = isSticky;
      init_timer((Timer *)auStack76);
      countdown_sec((Timer *)auStack76,2);
      do {
        _Var4 = has_timer_expired((Timer *)auStack76);
      } while (CONCAT31(extraout_var_01,_Var4) == 0);
      goto LAB_2304e856;
    }
  }
  goto LAB_2304e89a;
LAB_2304e886:
  iVar8 = iVar8 + 1;
  pSVar7 = pSVar7 + 1;
  if (iVar8 == 0x14) {
    if (iVar10 == -1) {
LAB_2304e856:
      IVar3 = SUCCESS;
    }
    else {
      iVar11 = -1;
      iVar9 = 0;
LAB_2304e89a:
      IVar3 = (IoT_Error_t)iVar9;
      uVar1 = SubscriptionList[iVar10].count;
      SubscriptionList[iVar10].isFree = true;
      pAVar2 = pMqttClient;
      if (uVar1 == '\x01') {
        sVar5 = strlen((char *)(SubscriptionList + iVar10));
        aws_iot_mqtt_unsubscribe(pAVar2,(char *)(SubscriptionList + iVar10),(uint16_t)sVar5);
      }
      if (iVar11 != -1) {
LAB_2304e8d6:
        SubscriptionList[iVar11].isFree = true;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar3;
  }
  goto LAB_2304e79e;
}



// WARNING: Variable defined which should be unmapped: TemporaryTopicNameRejected

void incrementSubscriptionCnt(char *pThingName,ShadowActions_t action,_Bool isSticky)

{
  SubscriptionRecord_t *__s2;
  int iVar1;
  char acStack176 [4];
  char TemporaryTopicNameAccepted [80];
  char TemporaryTopicNameRejected [80];
  
  topicNameFromThingAndAction(acStack176,pThingName,action,SHADOW_ACCEPTED);
  __s2 = SubscriptionList;
  topicNameFromThingAndAction(TemporaryTopicNameAccepted + 0x4c,pThingName,action,SHADOW_REJECTED);
  do {
    if ((__s2->isFree == false) &&
       ((iVar1 = strcmp(acStack176,(char *)__s2), iVar1 == 0 ||
        (iVar1 = strcmp(TemporaryTopicNameAccepted + 0x4c,(char *)__s2), iVar1 == 0)))) {
      __s2->isSticky = isSticky;
      __s2->count = __s2->count + '\x01';
    }
    __s2 = __s2 + 1;
  } while (__s2 != (SubscriptionRecord_t *)&pMqttClient);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
publishToShadowAction(char *pThingName,ShadowActions_t action,char *pJsonDocumentToBeSent)

{
  AWS_IoT_Client *pClient;
  IoT_Error_t IVar1;
  size_t sVar2;
  undefined2 local_70;
  IoT_Publish_Message_Params msgParams;
  char TemporaryTopicName [80];
  
  if (pThingName == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  if (pJsonDocumentToBeSent != (char *)0x0) {
    topicNameFromThingAndAction((char *)&msgParams.payloadLen,pThingName,action,SHADOW_ACTION);
    local_70 = 0;
    msgParams.payload = (void *)strlen(pJsonDocumentToBeSent);
    pClient = pMqttClient;
    msgParams._4_4_ = pJsonDocumentToBeSent;
    sVar2 = strlen((char *)&msgParams.payloadLen);
    IVar1 = aws_iot_mqtt_publish
                      (pClient,(char *)&msgParams.payloadLen,(uint16_t)sVar2,
                       (IoT_Publish_Message_Params *)&local_70);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



_Bool getNextFreeIndexOfAckWaitList(uint8_t *pIndex)

{
  char cVar1;
  ToBeReceivedAckRecord_t *pTVar2;
  uint8_t uVar3;
  
  cVar1 = '\0';
  if (pIndex != (uint8_t *)0x0) {
    pTVar2 = AckWaitList;
    uVar3 = '\0';
    do {
      cVar1 = pTVar2->isFree;
      if ((_Bool)cVar1 != false) {
        *pIndex = uVar3;
        break;
      }
      uVar3 = uVar3 + '\x01';
      pTVar2 = pTVar2 + 1;
    } while (uVar3 != '\n');
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)cVar1;
}



void addToAckWaitList(uint8_t indexAckWaitList,char *pThingName,ShadowActions_t action,
                     char *pExtractedClientToken,fpActionCallback_t *callback,void *pCallbackContext
                     ,uint32_t timeout_seconds)

{
  undefined3 in_register_00002029;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_00002029,indexAckWaitList);
  AckWaitList[iVar1].callback = callback;
  memcpy(AckWaitList + iVar1,pExtractedClientToken,0x5a);
  memcpy(AckWaitList[iVar1].thingName,pThingName,0x14);
  AckWaitList[iVar1].pCallbackContext = pCallbackContext;
  AckWaitList[iVar1].action = action;
  init_timer(&AckWaitList[iVar1].timer);
  countdown_sec(&AckWaitList[iVar1].timer,timeout_seconds);
  AckWaitList[iVar1].isFree = false;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void HandleExpiredResponseCallbacks(void)

{
  ToBeReceivedAckRecord_t *pTVar1;
  uint8_t index;
  _Bool _Var2;
  undefined3 extraout_var;
  
  pTVar1 = AckWaitList;
  index = '\0';
  do {
    if ((pTVar1->isFree == false) &&
       (_Var2 = has_timer_expired(&pTVar1->timer), CONCAT31(extraout_var,_Var2) != 0)) {
      if (pTVar1->callback != (fpActionCallback_t *)0x0) {
        (*pTVar1->callback)(pTVar1->thingName,pTVar1->action,SHADOW_ACK_TIMEOUT,shadowRxBuf,
                            pTVar1->pCallbackContext);
      }
      pTVar1->isFree = true;
      unsubscribeFromAcceptedAndRejected(index);
    }
    index = index + '\x01';
    pTVar1 = pTVar1 + 1;
  } while (index != '\n');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



_Bool has_timer_expired(Timer *timer)

{
  TickType_t TVar1;
  uint uVar2;
  uint uVar3;
  
  TVar1 = xTaskGetTickCount();
  uVar2 = timer->timeout_ticks;
  uVar3 = TVar1 - timer->start_ticks;
  if ((uVar3 < uVar2) && (timer->last_polled_ticks == TVar1)) {
    vTaskDelay(1);
  }
  timer->last_polled_ticks = TVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (_Bool)(uVar2 <= uVar3);
}



void countdown_ms(Timer *timer,uint32_t timeout)

{
  TickType_t TVar1;
  
  TVar1 = xTaskGetTickCount();
  timer->start_ticks = TVar1;
  timer->last_polled_ticks = 0;
  timer->timeout_ticks = timeout;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uint32_t left_ms(Timer *timer)

{
  TickType_t TVar1;
  uint32_t uVar2;
  
  TVar1 = xTaskGetTickCount();
  if (TVar1 - timer->start_ticks < timer->timeout_ticks) {
    uVar2 = (timer->start_ticks + timer->timeout_ticks) - TVar1;
  }
  else {
    uVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



void countdown_sec(Timer *timer,uint32_t timeout)

{
  if (0x418937 < timeout) {
    puts("aws_timer");
    printf("ERRORtimeout is out of range: %lus\r\n",timeout);
  }
  countdown_ms(timer,timeout * 1000);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void init_timer(Timer *timer)

{
  timer->start_ticks = 0;
  timer->timeout_ticks = 0;
  timer->last_polled_ticks = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int jsmn_parse(jsmn_parser *parser,char *js,size_t len,jsmntok_t *tokens,uint num_tokens)

{
  byte bVar1;
  char cVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  jsmntok_t *pjVar6;
  uint uVar7;
  jsmntype_t jVar8;
  jsmntok_t *pjVar9;
  uint uVar10;
  
  uVar5 = parser->toknext;
LAB_2304ebda:
  uVar7 = parser->pos;
  if ((uVar7 < len) && (bVar1 = js[uVar7], bVar1 != 0)) {
    if (bVar1 == 0x2c) {
      if (((tokens != (jsmntok_t *)0x0) && (parser->toksuper != -1)) &&
         (1 < (byte)(tokens[parser->toksuper].type + ~JSMN_UNDEFINED))) {
        uVar7 = parser->toknext;
        pjVar6 = tokens + uVar7;
        while (uVar7 = uVar7 - 1, -1 < (int)uVar7) {
          if ((((byte)(pjVar6[-1].type + ~JSMN_UNDEFINED) < 2) && (pjVar6[-1].start != -1)) &&
             (pjVar6[-1].end == -1)) {
            parser->toksuper = uVar7;
            break;
          }
          pjVar6 = pjVar6 + -1;
        }
      }
      goto LAB_2304ed68;
    }
    if (0x2c < bVar1) {
      if (bVar1 != 0x5d) {
        if (0x5d < bVar1) {
          if (bVar1 == 0x7b) goto LAB_2304ec9c;
          if (bVar1 != 0x7d) goto LAB_2304ef0c;
          goto LAB_2304ed06;
        }
        if (bVar1 == 0x3a) {
LAB_2304ecee:
          parser->toksuper = parser->toknext - 1;
          goto LAB_2304ed68;
        }
        if (bVar1 != 0x5b) goto LAB_2304ef0c;
LAB_2304ec9c:
        uVar5 = uVar5 + 1;
        if (tokens == (jsmntok_t *)0x0) goto LAB_2304ed68;
        uVar7 = parser->toknext;
        if (uVar7 < num_tokens) {
          parser->toknext = uVar7 + 1;
          pjVar6 = tokens + uVar7;
          pjVar6->end = -1;
          pjVar6->start = -1;
          pjVar6->size = 0;
          if (parser->toksuper != -1) {
            tokens[parser->toksuper].size = tokens[parser->toksuper].size + 1;
          }
          jVar8 = JSMN_OBJECT;
          if (bVar1 != 0x7b) {
            jVar8 = JSMN_ARRAY;
          }
          pjVar6->type = jVar8;
          pjVar6->start = parser->pos;
          goto LAB_2304ecee;
        }
        goto LAB_2304ed96;
      }
LAB_2304ed06:
      if (tokens == (jsmntok_t *)0x0) goto LAB_2304ed68;
      jVar8 = JSMN_OBJECT;
      if (bVar1 != 0x7d) {
        jVar8 = JSMN_ARRAY;
      }
      uVar10 = parser->toknext;
      pjVar6 = tokens + uVar10;
      do {
        pjVar9 = pjVar6;
        uVar10 = uVar10 - 1;
        if ((int)uVar10 < 0) {
          if (uVar10 == 0xffffffff) goto LAB_2304ed24;
          goto LAB_2304ed68;
        }
        pjVar6 = pjVar9 + -1;
      } while ((pjVar9[-1].start == -1) || (pjVar9[-1].end != -1));
      if (pjVar6->type == jVar8) {
        parser->toksuper = -1;
        pjVar9[-1].end = uVar7 + 1;
        pjVar6 = tokens + uVar10;
        do {
          if ((pjVar6->start != -1) && (pjVar6->end == -1)) {
            parser->toksuper = uVar10;
            break;
          }
          uVar10 = uVar10 - 1;
          pjVar6 = pjVar6 + -1;
        } while (uVar10 != 0xffffffff);
        goto LAB_2304ed68;
      }
      goto LAB_2304ed24;
    }
    if (bVar1 != 0xd) {
      if (bVar1 < 0xe) {
        if (1 < (byte)(bVar1 - 9)) {
LAB_2304ef0c:
          do {
            uVar10 = parser->pos;
            if (((len <= uVar10) || (bVar1 = js[uVar10], bVar1 == 0)) || (bVar1 == 0x20))
            goto found;
            if (bVar1 < 0x21) {
              if ((8 < bVar1) && ((bVar1 < 0xb || (bVar1 == 0xd)))) goto found;
            }
            else {
              if (bVar1 == 0x3a) goto found;
              if (bVar1 < 0x3b) {
                if (bVar1 == 0x2c) goto found;
              }
              else {
                if ((bVar1 == 0x5d) || (bVar1 == 0x7d)) goto found;
              }
            }
            if (0x5e < (byte)(bVar1 - 0x20)) goto LAB_2304ee20;
            parser->pos = uVar10 + 1;
          } while( true );
        }
        goto LAB_2304ed68;
      }
      if (bVar1 == 0x20) goto LAB_2304ed68;
      if (bVar1 != 0x22) goto LAB_2304ef0c;
      parser->pos = uVar7 + 1;
      while( true ) {
        uVar10 = parser->pos;
        if ((len <= uVar10) || (cVar2 = js[uVar10], cVar2 == '\0')) {
          parser->pos = uVar7;
          goto LAB_2304ec84;
        }
        if (cVar2 == '\"') break;
        if ((cVar2 == '\\') && (uVar3 = uVar10 + 1, uVar3 < len)) {
          parser->pos = uVar3;
          bVar1 = js[uVar3];
          if (bVar1 != 0x66) {
            if (bVar1 < 0x67) {
              if (bVar1 != 0x2f) {
                if (bVar1 < 0x30) {
                  if (bVar1 != 0x22) goto LAB_2304ee20;
                }
                else {
                  if ((bVar1 != 0x5c) && (bVar1 != 0x62)) goto LAB_2304ee20;
                }
              }
            }
            else {
              if (bVar1 != 0x72) {
                if (bVar1 < 0x73) {
                  if (bVar1 != 0x6e) goto LAB_2304ee20;
                }
                else {
                  if (bVar1 != 0x74) {
                    if (bVar1 != 0x75) goto LAB_2304ee20;
                    parser->pos = uVar10 + 2;
                    iVar4 = 4;
                    do {
                      uVar10 = parser->pos;
                      if ((len <= uVar10) || (bVar1 = js[uVar10], bVar1 == 0)) break;
                      if ((9 < (byte)(bVar1 - 0x30)) && (5 < (byte)((bVar1 & 0xdf) + 0xbf)))
                      goto LAB_2304ee20;
                      parser->pos = uVar10 + 1;
                      iVar4 = iVar4 + -1;
                    } while (iVar4 != 0);
                    parser->pos = parser->pos - 1;
                  }
                }
              }
            }
          }
        }
        parser->pos = parser->pos + 1;
      }
      if (tokens == (jsmntok_t *)0x0) goto LAB_2304edc6;
      uVar10 = parser->toknext;
      if (uVar10 < num_tokens) {
        parser->toknext = uVar10 + 1;
        pjVar6 = tokens + uVar10;
        pjVar6->end = -1;
        pjVar6->start = -1;
        pjVar6->size = 0;
        uVar10 = parser->pos;
        pjVar6->type = JSMN_STRING;
        pjVar6->start = uVar7 + 1;
        pjVar6->end = uVar10;
        goto LAB_2304edc6;
      }
      goto LAB_2304ed92;
    }
    goto LAB_2304ed68;
  }
  if (tokens != (jsmntok_t *)0x0) {
    uVar7 = parser->toknext;
    pjVar6 = tokens + uVar7;
    while (uVar7 = uVar7 - 1, -1 < (int)uVar7) {
      if ((pjVar6[-1].start != -1) && (pjVar6[-1].end == -1)) goto LAB_2304ec84;
      pjVar6 = pjVar6 + -1;
    }
  }
LAB_2304ec00:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar5;
found:
  if (tokens == (jsmntok_t *)0x0) {
    parser->pos = uVar10 - 1;
  }
  else {
    uVar10 = parser->toknext;
    if (num_tokens <= uVar10) {
LAB_2304ed92:
      parser->pos = uVar7;
LAB_2304ed96:
      uVar5 = 0xffffffff;
      goto LAB_2304ec00;
    }
    parser->toknext = uVar10 + 1;
    pjVar6 = tokens + uVar10;
    pjVar6->end = -1;
    pjVar6->start = -1;
    pjVar6->size = 0;
    uVar10 = parser->pos;
    pjVar6->type = JSMN_PRIMITIVE;
    pjVar6->start = uVar7;
    pjVar6->end = uVar10;
    parser->pos = parser->pos - 1;
  }
LAB_2304edc6:
  uVar5 = uVar5 + 1;
  if ((parser->toksuper != -1) && (tokens != (jsmntok_t *)0x0)) {
    tokens[parser->toksuper].size = tokens[parser->toksuper].size + 1;
  }
LAB_2304ed68:
  parser->pos = parser->pos + 1;
  goto LAB_2304ebda;
LAB_2304ec84:
  uVar5 = 0xfffffffd;
  goto LAB_2304ec00;
LAB_2304ee20:
  parser->pos = uVar7;
LAB_2304ed24:
  uVar5 = 0xfffffffe;
  goto LAB_2304ec00;
}



void jsmn_init(jsmn_parser *parser)

{
  parser->pos = 0;
  parser->toknext = 0;
  parser->toksuper = -1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int8_t jsoneq(char *json,jsmntok_t *tok,char *s)

{
  int8_t iVar1;
  size_t __n;
  int iVar2;
  
  if (tok->type != JSMN_STRING) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -1;
  }
  __n = strlen(s);
  if (__n == tok->end - tok->start) {
    iVar2 = strncmp(json + tok->start,s,__n);
    iVar1 = -(iVar2 != 0);
  }
  else {
    iVar1 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



IoT_Error_t parseUnsignedInteger32Value(uint32_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar1 = sscanf(jsonString + token->start,"%lu",i);
      IVar2 = SUCCESS;
      if (iVar1 != 1) {
        IVar2 = JSON_PARSE_ERROR;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseUnsignedInteger16Value(uint16_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar1 = sscanf(jsonString + token->start,"%hu",i);
      IVar2 = SUCCESS;
      if (iVar1 != 1) {
        IVar2 = JSON_PARSE_ERROR;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseUnsignedInteger8Value(uint8_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  uint uStack20;
  uint32_t i_word;
  
  if (token->type == JSMN_PRIMITIVE) {
    if (jsonString[token->start] != '-') {
      iVar2 = sscanf(jsonString + token->start,"%lu",&uStack20);
      if ((iVar2 == 1) && (uStack20 < 0x100)) {
        *i = (uint8_t)uStack20;
        IVar1 = SUCCESS;
      }
      else {
        IVar1 = JSON_PARSE_ERROR;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseInteger32Value(int32_t *i,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%ld",i);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseInteger16Value(int16_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  int iStack20;
  int32_t i_word;
  
  if (token->type != JSMN_PRIMITIVE) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return JSON_PARSE_ERROR;
  }
  iVar2 = sscanf(jsonString + token->start,"%li",&iStack20);
  if ((iVar2 == 1) && (iStack20 + 0x8000U < 0x10000)) {
    *i = (int16_t)iStack20;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t parseInteger8Value(int8_t *i,char *jsonString,jsmntok_t *token)

{
  IoT_Error_t IVar1;
  int iVar2;
  int iStack20;
  int32_t i_word;
  
  if (token->type != JSMN_PRIMITIVE) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return JSON_PARSE_ERROR;
  }
  iVar2 = sscanf(jsonString + token->start,"%li",&iStack20);
  if ((iVar2 == 1) && (iStack20 + 0x80U < 0x100)) {
    *i = (int8_t)iStack20;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t parseFloatValue(float *f,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%f",f);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseDoubleValue(double *d,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  IoT_Error_t IVar2;
  
  if (token->type == JSMN_PRIMITIVE) {
    iVar1 = sscanf(jsonString + token->start,"%lf",d);
    IVar2 = SUCCESS;
    if (iVar1 != 1) {
      IVar2 = JSON_PARSE_ERROR;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return JSON_PARSE_ERROR;
}



IoT_Error_t parseBooleanValue(_Bool *b,char *jsonString,jsmntok_t *token)

{
  int iVar1;
  
  if (token->type != JSMN_PRIMITIVE) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return JSON_PARSE_ERROR;
  }
  iVar1 = strncmp(jsonString + token->start,"true",4);
  if (iVar1 == 0) {
    *b = true;
  }
  else {
    iVar1 = strncmp(jsonString + token->start,"false",5);
    if (iVar1 == 0) {
      *b = false;
    }
    else {
      iVar1 = -0x2a;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar1;
}



IoT_Error_t parseStringValue(char *buf,size_t bufLen,char *jsonString,jsmntok_t *token)

{
  size_t __n;
  IoT_Error_t IVar1;
  
  __n = token->end - token->start;
  if (token->type == JSMN_STRING) {
    IVar1 = SHADOW_JSON_ERROR;
    if (__n + 1 <= bufLen) {
      strncpy(buf,jsonString + token->start,__n);
      buf[__n] = '\0';
      IVar1 = SUCCESS;
    }
  }
  else {
    IVar1 = JSON_PARSE_ERROR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



ClientState aws_iot_mqtt_get_client_state(AWS_IoT_Client *pClient)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (pClient->clientStatus).clientState;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CLIENT_STATE_INVALID;
}



IoT_Error_t aws_iot_mqtt_client_lock_mutex(AWS_IoT_Client *pClient,IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pMutex != (IoT_Mutex_t *)0x0)) {
    if ((pClient->clientData).isBlockOnThreadLockEnabled == false) {
      IVar1 = aws_iot_thread_mutex_trylock(pMutex);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar1;
    }
    IVar1 = aws_iot_thread_mutex_lock(pMutex);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_mqtt_client_unlock_mutex(AWS_IoT_Client *pClient,IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pMutex != (IoT_Mutex_t *)0x0)) {
    IVar1 = aws_iot_thread_mutex_unlock(pMutex);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_mqtt_set_client_state
          (AWS_IoT_Client *pClient,ClientState expectedCurrentState,ClientState newState)

{
  uint uVar1;
  IoT_Error_t IVar2;
  byte bVar3;
  undefined3 extraout_var;
  uint uVar4;
  undefined3 in_register_0000202d;
  IoT_Mutex_t *pMutex;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    pMutex = &(pClient->clientData).state_change_mutex;
    IVar2 = aws_iot_mqtt_client_lock_mutex(pClient,pMutex);
    uVar4 = CONCAT31(extraout_var,IVar2);
    if (CONCAT31(extraout_var,IVar2) == 0) {
      uVar1 = 0xffffffe3;
      if ((uint)(pClient->clientStatus).clientState ==
          CONCAT31(in_register_0000202d,expectedCurrentState)) {
        (pClient->clientStatus).clientState = newState;
        uVar1 = 0;
      }
      bVar3 = aws_iot_mqtt_client_unlock_mutex(pClient,pMutex);
      uVar4 = (uint)bVar3;
      if (uVar1 != 0) {
        uVar4 = uVar1;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)uVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
aws_iot_mqtt_set_connect_params
          (AWS_IoT_Client *pClient,IoT_Client_Connect_Params *pNewConnectParams)

{
  IoT_Error_t IVar1;
  size_t sVar2;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    IVar1 = NULL_VALUE_ERROR;
    if (pNewConnectParams != (IoT_Client_Connect_Params *)0x0) {
      (pClient->clientData).options.isWillMsgPresent = pNewConnectParams->isWillMsgPresent;
      (pClient->clientData).options.MQTTVersion = pNewConnectParams->MQTTVersion;
      (pClient->clientData).options.pClientID = pNewConnectParams->pClientID;
      (pClient->clientData).options.clientIDLen = pNewConnectParams->clientIDLen;
      sVar2 = strlen(pUsernameTemp);
      if (sVar2 == 0) {
        snprintf(pUsernameTemp,0x19,"?SDK=C&Version=%d.%d.%d",3,0,1);
      }
      (pClient->clientData).options.pUsername = pUsernameTemp;
      sVar2 = strlen(pUsernameTemp);
      (pClient->clientData).options.usernameLen = (uint16_t)sVar2;
      IVar1 = SUCCESS;
      (pClient->clientData).options.pPassword = pNewConnectParams->pPassword;
      (pClient->clientData).options.passwordLen = pNewConnectParams->passwordLen;
      (pClient->clientData).options.will.pTopicName = (pNewConnectParams->will).pTopicName;
      (pClient->clientData).options.will.topicNameLen = (pNewConnectParams->will).topicNameLen;
      (pClient->clientData).options.will.pMessage = (pNewConnectParams->will).pMessage;
      (pClient->clientData).options.will.msgLen = (pNewConnectParams->will).msgLen;
      (pClient->clientData).options.will.qos = (pNewConnectParams->will).qos;
      (pClient->clientData).options.will.isRetained = (pNewConnectParams->will).isRetained;
      (pClient->clientData).options.keepAliveIntervalInSec =
           pNewConnectParams->keepAliveIntervalInSec;
      (pClient->clientData).options.isCleanSession = pNewConnectParams->isCleanSession;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return IVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



// WARNING: Variable defined which should be unmapped: default_options

IoT_Error_t aws_iot_mqtt_init(AWS_IoT_Client *pClient,IoT_Client_Init_Params *pInitParams)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  MessageHandlers *pMVar2;
  uint32_t uVar3;
  void *pvVar4;
  int iVar5;
  IoT_Mutex_t *pMutex;
  IoT_Mutex_t *pMutex_00;
  IoT_Mutex_t *pMutex_01;
  undefined auStack88 [4];
  IoT_Client_Connect_Params default_options;
  
  iVar5 = -2;
  memcpy(auStack88,&DAT_23087bdc,0x38);
  if ((((pClient != (AWS_IoT_Client *)0x0) && (pInitParams != (IoT_Client_Init_Params *)0x0)) &&
      (pInitParams->pHostURL != (char *)0x0)) &&
     (((pInitParams->port != 0 && (pInitParams->pRootCALocation != (char *)0x0)) &&
      ((pInitParams->pDevicePrivateKeyLocation != (char *)0x0 &&
       (pInitParams->pDeviceCertLocation != (char *)0x0)))))) {
    pMVar2 = (pClient->clientData).messageHandlers;
    do {
      pMVar2->topicName = (char *)0x0;
      pMVar2->pApplicationHandler = (pApplicationHandler_t *)0x0;
      pMVar2->pApplicationHandlerData = (void *)0x0;
      pMVar2->qos = QOS0;
      pMVar2 = pMVar2 + 1;
    } while (pMVar2 != (MessageHandlers *)&(pClient->clientData).disconnectHandler);
    (pClient->clientData).packetTimeoutMs = pInitParams->mqttPacketTimeout_ms;
    uVar3 = pInitParams->mqttCommandTimeout_ms;
    (pClient->clientData).counterNetworkDisconnected = 0;
    (pClient->clientData).commandTimeoutMs = uVar3;
    (pClient->clientData).writeBufSize = 0x200;
    (pClient->clientData).readBufSize = 0x200;
    (pClient->clientData).disconnectHandler = pInitParams->disconnectHandler;
    pvVar4 = pInitParams->disconnectHandlerData;
    (pClient->clientData).nextPacketId = 1;
    (pClient->clientData).disconnectHandlerData = pvVar4;
    IVar1 = aws_iot_mqtt_set_connect_params(pClient,(IoT_Client_Connect_Params *)auStack88);
    iVar5 = CONCAT31(extraout_var,IVar1);
    if (iVar5 == 0) {
      pMutex = &(pClient->clientData).state_change_mutex;
      (pClient->clientData).isBlockOnThreadLockEnabled = pInitParams->isBlockOnThreadLockEnabled;
      IVar1 = aws_iot_thread_mutex_init(pMutex);
      iVar5 = CONCAT31(extraout_var_00,IVar1);
      if (iVar5 == 0) {
        pMutex_00 = &(pClient->clientData).tls_read_mutex;
        IVar1 = aws_iot_thread_mutex_init(pMutex_00);
        iVar5 = CONCAT31(extraout_var_01,IVar1);
        if (iVar5 == 0) {
          pMutex_01 = &(pClient->clientData).tls_write_mutex;
          IVar1 = aws_iot_thread_mutex_init(pMutex_01);
          iVar5 = CONCAT31(extraout_var_02,IVar1);
          if (iVar5 == 0) {
            (pClient->clientStatus).isPingOutstanding = false;
            (pClient->clientStatus).isAutoReconnectEnabled = pInitParams->enableAutoReconnect;
            IVar1 = iot_tls_init(&pClient->networkStack,pInitParams->pRootCALocation,
                                 pInitParams->pDeviceCertLocation,
                                 pInitParams->pDevicePrivateKeyLocation,pInitParams->pHostURL,
                                 pInitParams->port,pInitParams->tlsHandshakeTimeout_ms,
                                 pInitParams->isSSLHostnameVerify);
            iVar5 = CONCAT31(extraout_var_03,IVar1);
            if (iVar5 == 0) {
              init_timer((Timer *)pClient);
              init_timer(&pClient->reconnectDelayTimer);
              (pClient->clientStatus).clientState = CLIENT_STATE_INITIALIZED;
            }
            else {
              aws_iot_thread_mutex_destroy(pMutex_00);
              aws_iot_thread_mutex_destroy(pMutex);
              aws_iot_thread_mutex_destroy(pMutex_01);
              (pClient->clientStatus).clientState = CLIENT_STATE_INVALID;
            }
            goto LAB_2304f50e;
          }
          aws_iot_thread_mutex_destroy(pMutex_00);
        }
        aws_iot_thread_mutex_destroy(pMutex);
      }
    }
  }
LAB_2304f50e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar5;
}



uint16_t aws_iot_mqtt_get_next_packet_id(AWS_IoT_Client *pClient)

{
  uint16_t uVar1;
  
  uVar1 = (pClient->clientData).nextPacketId;
  if (uVar1 == 0xffff) {
    uVar1 = 1;
  }
  else {
    uVar1 = uVar1 + 1;
  }
  (pClient->clientData).nextPacketId = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



_Bool aws_iot_mqtt_is_client_connected(AWS_IoT_Client *pClient)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (_Bool)((pClient->clientStatus).clientState - 3 < 7);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return false;
}



IoT_Error_t aws_iot_mqtt_autoreconnect_set_status(AWS_IoT_Client *pClient,_Bool newStatus)

{
  if (pClient != (AWS_IoT_Client *)0x0) {
    (pClient->clientStatus).isAutoReconnectEnabled = newStatus;
    return SUCCESS;
  }
  return NULL_VALUE_ERROR;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_mqtt_connect(AWS_IoT_Client *pClient,IoT_Client_Connect_Params *pConnectParams)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  ClientState CVar4;
  IoT_Error_t IVar5;
  uchar uVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar7;
  undefined3 extraout_var_02;
  size_t sVar8;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  int iVar9;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  byte c;
  char *pcVar10;
  uint uVar11;
  uint32_t rem_len;
  Network *pNVar12;
  uchar *puVar13;
  uchar *puStack56;
  uchar *curdata;
  MQTTHeader header;
  uchar *ptr;
  Timer connect_timer;
  
  IVar5 = NULL_VALUE_ERROR;
  if (pClient == (AWS_IoT_Client *)0x0) goto LAB_2304f858;
  aws_iot_mqtt_internal_flushBuffers(pClient);
  CVar4 = aws_iot_mqtt_get_client_state(pClient);
  if ((CONCAT31(extraout_var,CVar4) != 1) &&
     ((IVar5 = NETWORK_ALREADY_CONNECTED_ERROR, CVar4 == CLIENT_STATE_INVALID ||
      (2 < (CONCAT31(extraout_var,CVar4) - 0xbU & 0xff))))) goto LAB_2304f858;
  aws_iot_mqtt_set_client_state(pClient,CVar4,CLIENT_STATE_CONNECTING);
  pNVar12 = &pClient->networkStack;
  if ((pConnectParams == (IoT_Client_Connect_Params *)0x0) ||
     (IVar5 = aws_iot_mqtt_set_connect_params(pClient,pConnectParams),
     CONCAT31(extraout_var_01,IVar5) == 0)) {
    IVar5 = (*(pClient->networkStack).connect)(pNVar12,(TLSConnectParams *)0x0);
    iVar9 = CONCAT31(extraout_var_00,IVar5);
    if (CONCAT31(extraout_var_00,IVar5) != 0) goto LAB_2304f86e;
    init_timer((Timer *)&ptr);
    puVar13 = (pClient->clientData).writeBuf;
    countdown_ms((Timer *)&ptr,(pClient->clientData).commandTimeoutMs);
    curdata = (uchar *)((uint)curdata & 0xffffff00);
    uVar2 = (pClient->clientData).writeBufSize;
    (pClient->clientData).keepAliveInterval = (pClient->clientData).options.keepAliveIntervalInSec;
    uVar11 = (uint)(pClient->clientData).options.clientIDLen;
    if (uVar11 == 0) {
      iVar9 = -2;
      goto LAB_2304f86e;
    }
    iVar9 = -0x25;
    if ((pClient->clientData).options.MQTTVersion != MQTT_3_1_1) goto LAB_2304f86e;
    rem_len = uVar11 + 0xc;
    if ((pClient->clientData).options.isWillMsgPresent != false) {
      rem_len = rem_len + (uint)(pClient->clientData).options.will.topicNameLen +
                          (uint)(pClient->clientData).options.will.msgLen + 4;
    }
    if ((pClient->clientData).options.pUsername != (char *)0x0) {
      rem_len = rem_len + (pClient->clientData).options.usernameLen + 2;
    }
    if ((pClient->clientData).options.pPassword != (char *)0x0) {
      rem_len = rem_len + (pClient->clientData).options.passwordLen + 2;
    }
    _header = puVar13;
    uVar7 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
    if (uVar2 < uVar7) {
      iVar9 = -0x21;
      goto LAB_2304f86e;
    }
    IVar5 = aws_iot_mqtt_internal_init_header((MQTTHeader *)&curdata,CONNECT,QOS0,'\0','\0');
    iVar3 = CONCAT31(extraout_var_02,IVar5);
    iVar9 = iVar3;
    if (iVar3 != 0) goto LAB_2304f86e;
    aws_iot_mqtt_internal_write_char((uchar **)&header,(uchar)curdata);
    sVar8 = aws_iot_mqtt_internal_write_len_to_buffer(_header,rem_len);
    _header = _header + sVar8;
    aws_iot_mqtt_internal_write_utf8_string((uchar **)&header,"MQTT",4);
    aws_iot_mqtt_internal_write_char((uchar **)&header,(pClient->clientData).options.MQTTVersion);
    c = ((pClient->clientData).options.isCleanSession != false) << 1;
    if ((pClient->clientData).options.isWillMsgPresent != false) {
      c = c | 4 | (pClient->clientData).options.will.qos << 3 |
                  (pClient->clientData).options.will.isRetained << 5;
    }
    if ((pClient->clientData).options.pPassword != (char *)0x0) {
      c = c | 0x40;
    }
    if ((pClient->clientData).options.pUsername != (char *)0x0) {
      c = c | 0x80;
    }
    aws_iot_mqtt_internal_write_char((uchar **)&header,c);
    aws_iot_mqtt_internal_write_uint_16
              ((uchar **)&header,(pClient->clientData).options.keepAliveIntervalInSec);
    pcVar10 = (pClient->clientData).options.pClientID;
    if (pcVar10 == (char *)0x0) {
      aws_iot_mqtt_internal_write_uint_16((uchar **)&header,0);
    }
    else {
      aws_iot_mqtt_internal_write_utf8_string
                ((uchar **)&header,pcVar10,(pClient->clientData).options.clientIDLen);
    }
    if ((pClient->clientData).options.isWillMsgPresent != false) {
      aws_iot_mqtt_internal_write_utf8_string
                ((uchar **)&header,(pClient->clientData).options.will.pTopicName,
                 (pClient->clientData).options.will.topicNameLen);
      aws_iot_mqtt_internal_write_utf8_string
                ((uchar **)&header,(pClient->clientData).options.will.pMessage,
                 (pClient->clientData).options.will.msgLen);
    }
    pcVar10 = (pClient->clientData).options.pUsername;
    if (pcVar10 != (char *)0x0) {
      aws_iot_mqtt_internal_write_utf8_string
                ((uchar **)&header,pcVar10,(pClient->clientData).options.usernameLen);
    }
    pcVar10 = (pClient->clientData).options.pPassword;
    if (pcVar10 != (char *)0x0) {
      aws_iot_mqtt_internal_write_utf8_string
                ((uchar **)&header,pcVar10,(pClient->clientData).options.passwordLen);
    }
    if (_header + -(int)puVar13 != (uchar *)0x0) {
      IVar5 = aws_iot_mqtt_internal_send_packet
                        (pClient,(size_t)(_header + -(int)puVar13),(Timer *)&ptr);
      iVar9 = CONCAT31(extraout_var_03,IVar5);
      if (iVar9 == 0) {
        IVar5 = aws_iot_mqtt_internal_wait_for_read(pClient,'\x02',(Timer *)&ptr);
        iVar9 = CONCAT31(extraout_var_04,IVar5);
        if (iVar9 == 0) {
          iVar9 = -0x20;
          if (3 < (pClient->clientData).readBufSize) {
            curdata = (uchar *)0x0;
            _header = (uchar *)0x0;
            puStack56 = (pClient->clientData).readBuf;
            uVar6 = aws_iot_mqtt_internal_read_char(&puStack56);
            iVar9 = -1;
            if ((CONCAT31(extraout_var_05,uVar6) >> 4 & 0xff) == 2) {
              IVar5 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                                (puStack56,(uint32_t *)&curdata,(uint32_t *)&header);
              iVar9 = CONCAT31(extraout_var_06,IVar5);
              if (iVar9 == 0) {
                iVar9 = -0x23;
                puStack56 = puStack56 + (int)_header;
                if (curdata == (uchar *)0x2) {
                  aws_iot_mqtt_internal_read_char(&puStack56);
                  uVar6 = aws_iot_mqtt_internal_read_char(&puStack56);
                  switch(CONCAT31(extraout_var_07,uVar6)) {
                  case 0:
                    uVar1 = (pClient->clientData).keepAliveInterval;
                    (pClient->clientStatus).isPingOutstanding = false;
                    countdown_sec((Timer *)pClient,(uint)uVar1);
                    goto LAB_2304f84e;
                  case 1:
                    iVar9 = -0x25;
                    break;
                  case 2:
                    iVar9 = -0x26;
                    break;
                  case 3:
                    iVar9 = -0x27;
                    break;
                  case 4:
                    iVar9 = -0x28;
                    break;
                  case 5:
                    iVar9 = -0x29;
                    break;
                  default:
                    iVar9 = -0x24;
                  }
                }
              }
            }
          }
        }
      }
      goto LAB_2304f86e;
    }
LAB_2304f84e:
    CVar4 = CLIENT_STATE_CONNECTED_IDLE;
  }
  else {
    iVar9 = -0x1a;
LAB_2304f86e:
    (*(pClient->networkStack).disconnect)(pNVar12);
    IVar5 = (*(pClient->networkStack).destroy)(pNVar12);
    CVar4 = CLIENT_STATE_DISCONNECTED_ERROR;
    iVar3 = iVar9;
    if (CONCAT31(extraout_var_08,IVar5) != 0) {
      IVar5 = NETWORK_DISCONNECTED_ERROR;
      goto LAB_2304f858;
    }
  }
  IVar5 = (IoT_Error_t)iVar3;
  aws_iot_mqtt_set_client_state(pClient,CLIENT_STATE_CONNECTING,CVar4);
LAB_2304f858:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar5;
}



IoT_Error_t _aws_iot_mqtt_internal_disconnect(AWS_IoT_Client *pClient)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  int iVar2;
  size_t local_20;
  size_t serialized_len;
  Timer timer;
  
  local_20 = 0;
  IVar1 = aws_iot_mqtt_internal_serialize_zero
                    ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,DISCONNECT,
                     &local_20);
  iVar2 = CONCAT31(extraout_var,IVar1);
  if (iVar2 == 0) {
    init_timer((Timer *)&serialized_len);
    countdown_ms((Timer *)&serialized_len,(pClient->clientData).commandTimeoutMs);
    if (local_20 != 0) {
      aws_iot_mqtt_internal_send_packet(pClient,local_20,(Timer *)&serialized_len);
    }
    (*(pClient->networkStack).disconnect)(&pClient->networkStack);
    IVar1 = (*(pClient->networkStack).destroy)(&pClient->networkStack);
    iVar2 = -(uint)(CONCAT31(extraout_var_00,IVar1) != 0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar2;
}



IoT_Error_t aws_iot_mqtt_disconnect(AWS_IoT_Client *pClient)

{
  ClientState expectedCurrentState;
  _Bool _Var1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar3;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    iVar3 = -0xd;
    if (CONCAT31(extraout_var,_Var1) != 0) {
      IVar2 = aws_iot_mqtt_set_client_state(pClient,expectedCurrentState,CLIENT_STATE_DISCONNECTING)
      ;
      iVar3 = CONCAT31(extraout_var_00,IVar2);
      if (iVar3 == 0) {
        IVar2 = _aws_iot_mqtt_internal_disconnect(pClient);
        iVar3 = CONCAT31(extraout_var_01,IVar2);
        if (iVar3 == 0) {
          (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_MANUALLY;
        }
        else {
          (pClient->clientStatus).clientState = expectedCurrentState;
        }
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)iVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t aws_iot_mqtt_attempt_reconnect(AWS_IoT_Client *pClient)

{
  _Bool _Var1;
  ClientState CVar2;
  IoT_Error_t IVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  int iVar4;
  
  if (pClient != (AWS_IoT_Client *)0x0) {
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    iVar4 = -0xf;
    if (CONCAT31(extraout_var,_Var1) == 0) {
      aws_iot_mqtt_connect(pClient,(IoT_Client_Connect_Params *)0x0);
      CVar2 = aws_iot_mqtt_get_client_state(pClient);
      if (CONCAT31(extraout_var_00,CVar2) == 3) {
        IVar3 = aws_iot_mqtt_resubscribe(pClient);
        iVar4 = CONCAT31(extraout_var_01,IVar3);
        if (iVar4 == 0) {
          iVar4 = 3;
        }
      }
      else {
        aws_iot_mqtt_set_client_state
                  (pClient,CLIENT_STATE_DISCONNECTED_ERROR,CLIENT_STATE_PENDING_RECONNECT);
        iVar4 = 4;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)iVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_internal_serialize_ack
          (uchar *pTxBuf,size_t txBufLen,MessageTypes msgType,uint8_t dup,uint16_t packetId,
          uint32_t *pSerializedLen)

{
  int iVar1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  size_t sVar3;
  undefined3 in_register_00002031;
  uchar auStack40 [4];
  MQTTHeader header;
  uchar *ptr;
  
  auStack40[0] = '\0';
  iVar1 = -2;
  if ((pTxBuf != (uchar *)0x0) && (pSerializedLen != (uint32_t *)0x0)) {
    iVar1 = -0x21;
    if (3 < txBufLen) {
      _header = pTxBuf;
      IVar2 = aws_iot_mqtt_internal_init_header
                        (auStack40,msgType,CONCAT31(in_register_00002031,msgType) == 6,dup,'\0');
      iVar1 = CONCAT31(extraout_var,IVar2);
      if (iVar1 == 0) {
        aws_iot_mqtt_internal_write_char((uchar **)&header,auStack40[0]);
        sVar3 = aws_iot_mqtt_internal_write_len_to_buffer(_header,2);
        _header = _header + sVar3;
        aws_iot_mqtt_internal_write_uint_16((uchar **)&header,packetId);
        *pSerializedLen = (uint32_t)(_header + -(int)pTxBuf);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar1;
}



IoT_Error_t
aws_iot_mqtt_internal_deserialize_publish
          (uint8_t *dup,QoS *qos,uint8_t *retained,uint16_t *pPacketId,char **pTopicName,
          uint16_t *topicNameLen,uchar **payload,size_t *payloadLen,uchar *pRxBuf,size_t rxBufLen)

{
  uchar *puVar1;
  byte bVar2;
  IoT_Error_t IVar3;
  uint16_t uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined2 extraout_var_01;
  int iVar6;
  uchar *in_stack_00000000;
  uint in_stack_00000004;
  uchar *puStack60;
  uchar *curData;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  uint uVar5;
  
  puStack60 = in_stack_00000000;
  curData = (uchar *)0x0;
  decodedLen = 0;
  if ((((dup != (uint8_t *)0x0) && (qos != (QoS *)0x0)) && (retained != (uint8_t *)0x0)) &&
     (pPacketId != (uint16_t *)0x0)) {
    iVar6 = -0x20;
    if (in_stack_00000004 < 4) goto LAB_2304fa38;
    bVar2 = aws_iot_mqtt_internal_read_char(&puStack60);
    uVar5 = CONCAT31(extraout_var,bVar2);
    if ((uVar5 >> 4 & 0xff) == 3) {
      *dup = (byte)((int)uVar5 >> 3) & 1;
      *qos = (byte)((int)uVar5 >> 1) & 3;
      *retained = bVar2 & 1;
      IVar3 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                        (puStack60,(uint32_t *)&curData,&decodedLen);
      iVar6 = CONCAT31(extraout_var_00,IVar3);
      if (iVar6 != 0) goto LAB_2304fa38;
      puStack60 = puStack60 + decodedLen;
      puVar1 = puStack60 + (int)curData;
      if (1 < (int)curData) {
        uVar4 = aws_iot_mqtt_internal_read_uint16_t(&puStack60);
        *topicNameLen = uVar4;
        if (puStack60 + CONCAT22(extraout_var_01,uVar4) <= puVar1) {
          *pTopicName = (char *)puStack60;
          puStack60 = puStack60 + *topicNameLen;
          if (-1 < (int)(puVar1 + -(int)puStack60)) {
            if (*qos != QOS0) {
              uVar4 = aws_iot_mqtt_internal_read_uint16_t(&puStack60);
              *pPacketId = uVar4;
            }
            *payloadLen = (size_t)(puVar1 + -(int)puStack60);
            *payload = puStack60;
            goto LAB_2304fa38;
          }
        }
      }
    }
  }
  iVar6 = -1;
LAB_2304fa38:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar6;
}



// WARNING: Variable defined which should be unmapped: readBytesLen

IoT_Error_t
aws_iot_mqtt_internal_deserialize_ack
          (uchar *pPacketType,uchar *dup,uint16_t *pPacketId,uchar *pRxBuf,size_t rxBuflen)

{
  int iVar1;
  uchar uVar2;
  IoT_Error_t IVar3;
  uint16_t uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uchar *puStack28;
  uchar *curdata;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  
  curdata = (uchar *)0x0;
  decodedLen = 0;
  iVar1 = -2;
  if ((((pPacketType != (uchar *)0x0) && (dup != (uchar *)0x0)) && (pPacketId != (uint16_t *)0x0))
     && ((pRxBuf != (uchar *)0x0 && (iVar1 = -0x20, 3 < rxBuflen)))) {
    puStack28 = pRxBuf;
    uVar2 = aws_iot_mqtt_internal_read_char(&puStack28);
    *dup = (byte)((int)CONCAT31(extraout_var,uVar2) >> 3) & 1;
    *pPacketType = (uchar)(CONCAT31(extraout_var,uVar2) >> 4);
    IVar3 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                      (puStack28,(uint32_t *)&curdata,&decodedLen);
    iVar1 = CONCAT31(extraout_var_00,IVar3);
    if (iVar1 == 0) {
      puStack28 = puStack28 + decodedLen;
      if ((int)curdata < 2) {
        iVar1 = -1;
      }
      else {
        uVar4 = aws_iot_mqtt_internal_read_uint16_t(&puStack28);
        *pPacketId = uVar4;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar1;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_publish
          (AWS_IoT_Client *pClient,char *pTopicName,uint16_t topicNameLen,
          IoT_Publish_Message_Params *pParams)

{
  QoS qos;
  uint8_t retained;
  _Bool _Var1;
  ClientState expectedCurrentState;
  IoT_Error_t IVar2;
  byte bVar3;
  uint16_t uVar4;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar5;
  undefined3 extraout_var_02;
  size_t sVar6;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined2 in_register_00002032;
  uint uVar7;
  int iVar8;
  uint uVar9;
  size_t __n;
  uchar *puVar10;
  void *__src;
  uint32_t rem_len;
  uchar uStack85;
  uchar auStack84 [3];
  uchar dup;
  uchar type;
  uint16_t packet_id;
  Timer timer;
  
  if ((((pClient != (AWS_IoT_Client *)0x0) && (pTopicName != (char *)0x0)) &&
      (CONCAT22(in_register_00002032,topicNameLen) != 0)) &&
     (pParams != (IoT_Publish_Message_Params *)0x0)) {
    _Var1 = aws_iot_mqtt_is_client_connected(pClient);
    uVar7 = 0xfffffff3;
    if (CONCAT31(extraout_var,_Var1) != 0) {
      expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
      if ((CONCAT31(extraout_var_00,expectedCurrentState) == 3) ||
         (uVar7 = 0xffffffe2, CONCAT31(extraout_var_00,expectedCurrentState) == 9)) {
        IVar2 = aws_iot_mqtt_set_client_state
                          (pClient,expectedCurrentState,CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS);
        uVar7 = CONCAT31(extraout_var_01,IVar2);
        if (CONCAT31(extraout_var_01,IVar2) == 0) {
          init_timer((Timer *)&packet_id);
          countdown_ms((Timer *)&packet_id,(pClient->clientData).commandTimeoutMs);
          if (pParams->qos == QOS1) {
            uVar4 = aws_iot_mqtt_get_next_packet_id(pClient);
            pParams->id = uVar4;
          }
          __src = pParams->payload;
          auStack84[0] = '\0';
          puVar10 = (pClient->clientData).writeBuf;
          uVar7 = (pClient->clientData).writeBufSize;
          qos = pParams->qos;
          retained = pParams->isRetained;
          uVar4 = pParams->id;
          __n = pParams->payloadLen;
          uVar9 = 0xfffffffe;
          if (__src != (void *)0x0) {
            iVar8 = CONCAT22(in_register_00002032,topicNameLen) + __n;
            rem_len = iVar8 + 4;
            if (qos == QOS0) {
              rem_len = iVar8 + 2;
            }
            _type = puVar10;
            uVar5 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
            uVar9 = 0xffffffdf;
            if (uVar5 <= uVar7) {
              IVar2 = aws_iot_mqtt_internal_init_header(auStack84,PUBLISH,qos,'\0',retained);
              uVar9 = CONCAT31(extraout_var_02,IVar2);
              if (uVar9 == 0) {
                aws_iot_mqtt_internal_write_char((uchar **)&type,auStack84[0]);
                sVar6 = aws_iot_mqtt_internal_write_len_to_buffer(_type,rem_len);
                _type = _type + sVar6;
                aws_iot_mqtt_internal_write_utf8_string((uchar **)&type,pTopicName,topicNameLen);
                if (qos != QOS0) {
                  aws_iot_mqtt_internal_write_uint_16((uchar **)&type,uVar4);
                }
                memcpy(_type,__src,__n);
                IVar2 = aws_iot_mqtt_internal_send_packet
                                  (pClient,(size_t)(_type + (__n - (int)puVar10)),
                                   (Timer *)&packet_id);
                uVar9 = CONCAT31(extraout_var_03,IVar2);
                if ((uVar9 == 0) && (pParams->qos == QOS1)) {
                  IVar2 = aws_iot_mqtt_internal_wait_for_read(pClient,'\x04',(Timer *)&packet_id);
                  uVar9 = CONCAT31(extraout_var_04,IVar2);
                  if (uVar9 == 0) {
                    IVar2 = aws_iot_mqtt_internal_deserialize_ack
                                      (auStack84,&uStack85,(uint16_t *)&type,
                                       (pClient->clientData).readBuf,
                                       (pClient->clientData).readBufSize);
                    uVar9 = CONCAT31(extraout_var_05,IVar2);
                  }
                }
              }
            }
          }
          bVar3 = aws_iot_mqtt_set_client_state
                            (pClient,CLIENT_STATE_CONNECTED_PUBLISH_IN_PROGRESS,expectedCurrentState
                            );
          uVar7 = (uint)bVar3;
          if (uVar9 != 0) {
            uVar7 = uVar9;
          }
        }
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)uVar7;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



IoT_Error_t
_aws_iot_mqtt_deserialize_suback
          (uint16_t *pPacketId,uint32_t *pGrantedQoSCount,QoS *pGrantedQoSs,uchar *pRxBuf,
          size_t rxBufLen)

{
  uchar *puVar1;
  uchar uVar2;
  IoT_Error_t IVar3;
  QoS QVar4;
  uint16_t uVar5;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar6;
  int iVar7;
  uchar *puStack44;
  uchar *curData;
  uint32_t decodedLen;
  uint32_t readBytesLen;
  
  curData = (uchar *)0x0;
  decodedLen = 0;
  iVar7 = -0x20;
  if (rxBufLen < 5) goto LAB_2304fd42;
  puStack44 = pRxBuf;
  uVar2 = aws_iot_mqtt_internal_read_char(&puStack44);
  if ((CONCAT31(extraout_var,uVar2) >> 4 & 0xff) == 9) {
    IVar3 = aws_iot_mqtt_internal_decode_remaining_length_from_buffer
                      (puStack44,(uint32_t *)&curData,&decodedLen);
    iVar7 = CONCAT31(extraout_var_00,IVar3);
    if (iVar7 != 0) goto LAB_2304fd42;
    puStack44 = puStack44 + decodedLen;
    puVar1 = puStack44 + (int)curData;
    if (1 < (int)curData) {
      uVar5 = aws_iot_mqtt_internal_read_uint16_t(&puStack44);
      *pPacketId = uVar5;
      *pGrantedQoSCount = 0;
      while (puStack44 < puVar1) {
        uVar6 = *pGrantedQoSCount;
        if (1 < uVar6) goto LAB_2304fd40;
        *pGrantedQoSCount = uVar6 + 1;
        QVar4 = aws_iot_mqtt_internal_read_char(&puStack44);
        pGrantedQoSs[uVar6] = QVar4;
      }
      goto LAB_2304fd42;
    }
  }
LAB_2304fd40:
  iVar7 = -1;
LAB_2304fd42:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar7;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
_aws_iot_mqtt_serialize_subscribe
          (uchar *pTxBuf,size_t txBufLen,uint16_t packetId,char **pTopicNameList,
          uint16_t *pTopicNameLenList,QoS *pRequestedQoSs,uint32_t *pSerializedLen)

{
  ushort uVar1;
  int iVar2;
  IoT_Error_t IVar3;
  uint32_t uVar4;
  undefined3 extraout_var;
  size_t sVar5;
  uchar auStack56 [4];
  MQTTHeader header;
  uchar *ptr;
  
  uVar1 = *pTopicNameLenList;
  auStack56[0] = '\0';
  _header = pTxBuf;
  uVar4 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(uVar1 + 5);
  iVar2 = -0x21;
  if (uVar4 <= txBufLen) {
    IVar3 = aws_iot_mqtt_internal_init_header(auStack56,SUBSCRIBE,QOS1,'\0','\0');
    iVar2 = CONCAT31(extraout_var,IVar3);
    if (iVar2 == 0) {
      aws_iot_mqtt_internal_write_char((uchar **)&header,auStack56[0]);
      sVar5 = aws_iot_mqtt_internal_write_len_to_buffer(_header,uVar1 + 5);
      _header = _header + sVar5;
      aws_iot_mqtt_internal_write_uint_16((uchar **)&header,packetId);
      aws_iot_mqtt_internal_write_utf8_string((uchar **)&header,*pTopicNameList,*pTopicNameLenList);
      aws_iot_mqtt_internal_write_char((uchar **)&header,*pRequestedQoSs);
      *pSerializedLen = (uint32_t)(_header + -(int)pTxBuf);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar2;
}



// WARNING: Variable defined which should be unmapped: timer
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_subscribe
          (AWS_IoT_Client *pClient,char *pTopicName,uint16_t topicNameLen,QoS qos,
          pApplicationHandler_t *pApplicationHandler,void *pApplicationHandlerData)

{
  int iVar1;
  _Bool _Var2;
  ClientState expectedCurrentState;
  IoT_Error_t IVar3;
  byte bVar4;
  uint16_t packetId;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  uchar *puVar5;
  MessageHandlers *pMVar6;
  uint uVar7;
  uint uVar8;
  QoS QStack65;
  uint16_t uStack64;
  uint16_t uStack62;
  undefined2 uStack60;
  uint16_t rxPacketId;
  QoS grantedQoS [3];
  size_t sStack52;
  uint32_t serializedLen;
  uint32_t count;
  Timer timer;
  
  if (((pClient == (AWS_IoT_Client *)0x0) || (pTopicName == (char *)0x0)) ||
     (pApplicationHandler == (pApplicationHandler_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  _Var2 = aws_iot_mqtt_is_client_connected(pClient);
  uVar7 = 0xfffffff3;
  if (CONCAT31(extraout_var,_Var2) != 0) {
    expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
    if ((CONCAT31(extraout_var_00,expectedCurrentState) == 3) ||
       (uVar7 = 0xffffffe2, CONCAT31(extraout_var_00,expectedCurrentState) == 9)) {
      IVar3 = aws_iot_mqtt_set_client_state
                        (pClient,expectedCurrentState,CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS);
      uVar7 = CONCAT31(extraout_var_01,IVar3);
      if (CONCAT31(extraout_var_01,IVar3) == 0) {
        uStack60 = 0;
        rxPacketId._0_1_ = 0;
        QStack65 = qos;
        uStack64 = topicNameLen;
        _grantedQoS = pTopicName;
        init_timer((Timer *)&count);
        countdown_ms((Timer *)&count,(pClient->clientData).commandTimeoutMs);
        sStack52 = 0;
        serializedLen = 0;
        packetId = aws_iot_mqtt_get_next_packet_id(pClient);
        uStack62 = 0;
        IVar3 = _aws_iot_mqtt_serialize_subscribe
                          ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,
                           packetId,(char **)grantedQoS,&uStack64,&QStack65,&sStack52);
        uVar8 = CONCAT31(extraout_var_02,IVar3);
        if (uVar8 == 0) {
          pMVar6 = (pClient->clientData).messageHandlers;
          iVar1 = 0;
          do {
            if (pMVar6->topicName == (char *)0x0) {
              IVar3 = aws_iot_mqtt_internal_send_packet(pClient,sStack52,(Timer *)&count);
              uVar8 = CONCAT31(extraout_var_03,IVar3);
              if (uVar8 == 0) {
                IVar3 = aws_iot_mqtt_internal_wait_for_read(pClient,'\t',(Timer *)&count);
                uVar8 = CONCAT31(extraout_var_04,IVar3);
                if (uVar8 == 0) {
                  IVar3 = _aws_iot_mqtt_deserialize_suback
                                    (&uStack62,&serializedLen,(QoS *)&uStack60,
                                     (pClient->clientData).readBuf,(pClient->clientData).readBufSize
                                    );
                  uVar8 = CONCAT31(extraout_var_05,IVar3);
                  if (uVar8 == 0) {
                    puVar5 = (pClient->clientData).writeBuf + iVar1 * 0x10 + -0x40;
                    *(char **)(puVar5 + 0x488) = _grantedQoS;
                    *(pApplicationHandler_t **)(puVar5 + 0x490) = pApplicationHandler;
                    *(void **)(puVar5 + 0x494) = pApplicationHandlerData;
                    *(uint16_t *)(puVar5 + 0x48c) = uStack64;
                    puVar5[0x48e] = QStack65;
                  }
                }
              }
              goto LAB_2304ff0e;
            }
            iVar1 = iVar1 + 1;
            pMVar6 = pMVar6 + 1;
          } while (iVar1 != 5);
          uVar8 = 0xffffffde;
        }
LAB_2304ff0e:
        bVar4 = aws_iot_mqtt_set_client_state
                          (pClient,CLIENT_STATE_CONNECTED_SUBSCRIBE_IN_PROGRESS,expectedCurrentState
                          );
        uVar7 = (uint)bVar4;
        if (uVar8 != 0) {
          uVar7 = uVar8;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar7;
}



// WARNING: Variable defined which should be unmapped: timer
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t aws_iot_mqtt_resubscribe(AWS_IoT_Client *pClient)

{
  uint uVar1;
  _Bool _Var2;
  ClientState CVar3;
  IoT_Error_t IVar4;
  byte bVar5;
  uint16_t packetId_00;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  size_t txBufLen;
  MessageHandlers *pMVar6;
  uint uVar7;
  MessageHandlers *pTopicNameList;
  int iVar8;
  int iVar9;
  uint16_t uStack58;
  undefined2 uStack56;
  uint16_t packetId;
  QoS grantedQoS [3];
  uint32_t len;
  uint32_t count;
  Timer timer;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  _Var2 = aws_iot_mqtt_is_client_connected(pClient);
  uVar7 = 0xfffffff3;
  if (CONCAT31(extraout_var,_Var2) != 0) {
    CVar3 = aws_iot_mqtt_get_client_state(pClient);
    uVar7 = 0xffffffe2;
    if (CONCAT31(extraout_var_00,CVar3) == 3) {
      IVar4 = aws_iot_mqtt_set_client_state
                        (pClient,CLIENT_STATE_CONNECTED_IDLE,
                         CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS);
      uVar7 = CONCAT31(extraout_var_01,IVar4);
      if (CONCAT31(extraout_var_01,IVar4) == 0) {
        pTopicNameList = (pClient->clientData).messageHandlers;
        uStack56 = 0;
        packetId._0_1_ = 0;
        uStack58 = 0;
        _grantedQoS = 0;
        len = 0;
        iVar8 = 0;
        pMVar6 = pTopicNameList;
        do {
          if (pMVar6->topicName == (char *)0x0) break;
          iVar8 = iVar8 + 1;
          pMVar6 = pMVar6 + 1;
        } while (iVar8 != 5);
        iVar9 = 0;
        while (iVar8 != iVar9) {
          if (pTopicNameList->topicName != (char *)0x0) {
            init_timer((Timer *)&count);
            countdown_ms((Timer *)&count,(pClient->clientData).commandTimeoutMs);
            txBufLen = (pClient->clientData).writeBufSize;
            packetId_00 = aws_iot_mqtt_get_next_packet_id(pClient);
            IVar4 = _aws_iot_mqtt_serialize_subscribe
                              ((pClient->clientData).writeBuf,txBufLen,packetId_00,
                               (char **)pTopicNameList,&pTopicNameList->topicNameLen,
                               &pTopicNameList->qos,(uint32_t *)grantedQoS);
            uVar1 = CONCAT31(extraout_var_02,IVar4);
            if (uVar1 != 0) goto LAB_23050076;
            IVar4 = aws_iot_mqtt_internal_send_packet(pClient,_grantedQoS,(Timer *)&count);
            uVar1 = CONCAT31(extraout_var_03,IVar4);
            if (uVar1 != 0) goto LAB_23050076;
            IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\t',(Timer *)&count);
            uVar1 = CONCAT31(extraout_var_04,IVar4);
            if (uVar1 != 0) goto LAB_23050076;
            IVar4 = _aws_iot_mqtt_deserialize_suback
                              (&uStack58,&len,(QoS *)&uStack56,(pClient->clientData).readBuf,
                               (pClient->clientData).readBufSize);
            uVar1 = CONCAT31(extraout_var_05,IVar4);
            if (uVar1 != 0) goto LAB_23050076;
          }
          iVar9 = iVar9 + 1;
          pTopicNameList = pTopicNameList + 1;
        }
        uVar1 = 0;
LAB_23050076:
        bVar5 = aws_iot_mqtt_set_client_state
                          (pClient,CLIENT_STATE_CONNECTED_RESUBSCRIBE_IN_PROGRESS,
                           CLIENT_STATE_CONNECTED_IDLE);
        uVar7 = (uint)bVar5;
        if (uVar1 != 0) {
          uVar7 = uVar1;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar7;
}



// WARNING: Variable defined which should be unmapped: timer
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_unsubscribe(AWS_IoT_Client *pClient,char *pTopicFilter,uint16_t topicFilterLen)

{
  MessageHandlers *pMVar1;
  int iVar2;
  _Bool _Var3;
  ClientState expectedCurrentState;
  IoT_Error_t IVar4;
  uint16_t anInt;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint32_t uVar5;
  undefined3 extraout_var_02;
  size_t sVar6;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  int iVar7;
  undefined2 in_register_00002032;
  MessageHandlers *pMVar8;
  uint32_t rem_len;
  uchar *puVar9;
  MessageHandlers *pMVar10;
  uint uVar11;
  uchar uStack69;
  uchar auStack68 [3];
  uchar type;
  uchar dup;
  uint16_t packet_id;
  Timer timer;
  
  if ((pClient == (AWS_IoT_Client *)0x0) || (pTopicFilter == (char *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  _Var3 = aws_iot_mqtt_is_client_connected(pClient);
  IVar4 = NETWORK_DISCONNECTED_ERROR;
  if (CONCAT31(extraout_var,_Var3) == 0) goto LAB_23050102;
  expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
  if ((CONCAT31(extraout_var_00,expectedCurrentState) != 3) &&
     (IVar4 = MQTT_CLIENT_NOT_IDLE_ERROR, CONCAT31(extraout_var_00,expectedCurrentState) != 9))
  goto LAB_23050102;
  IVar4 = aws_iot_mqtt_set_client_state
                    (pClient,expectedCurrentState,CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS);
  if (CONCAT31(extraout_var_01,IVar4) != 0) {
    IVar4 = aws_iot_mqtt_set_client_state
                      (pClient,CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS,expectedCurrentState);
    goto LAB_23050102;
  }
  pMVar8 = (pClient->clientData).messageHandlers;
  pMVar10 = (MessageHandlers *)&(pClient->clientData).disconnectHandler;
  pMVar1 = pMVar8;
  do {
    if ((pMVar1->topicName != (char *)0x0) &&
       (iVar2 = strcmp(pMVar1->topicName,pTopicFilter), iVar2 == 0)) {
      init_timer((Timer *)&packet_id);
      rem_len = CONCAT22(in_register_00002032,topicFilterLen) + 4;
      countdown_ms((Timer *)&packet_id,(pClient->clientData).commandTimeoutMs);
      uVar11 = (pClient->clientData).writeBufSize;
      anInt = aws_iot_mqtt_get_next_packet_id(pClient);
      puVar9 = (pClient->clientData).writeBuf;
      auStack68[0] = '\0';
      _dup = puVar9;
      uVar5 = aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(rem_len);
      iVar2 = -0x21;
      if (uVar11 < uVar5) goto LAB_23050136;
      IVar4 = aws_iot_mqtt_internal_init_header(auStack68,UNSUBSCRIBE,QOS1,'\0','\0');
      iVar2 = CONCAT31(extraout_var_02,IVar4);
      if (iVar2 != 0) goto LAB_23050136;
      aws_iot_mqtt_internal_write_char((uchar **)&dup,auStack68[0]);
      sVar6 = aws_iot_mqtt_internal_write_len_to_buffer(_dup,rem_len);
      _dup = _dup + sVar6;
      aws_iot_mqtt_internal_write_uint_16((uchar **)&dup,anInt);
      aws_iot_mqtt_internal_write_utf8_string((uchar **)&dup,pTopicFilter,topicFilterLen);
      IVar4 = aws_iot_mqtt_internal_send_packet
                        (pClient,(size_t)(_dup + -(int)puVar9),(Timer *)&packet_id);
      iVar2 = CONCAT31(extraout_var_03,IVar4);
      if (iVar2 != 0) goto LAB_23050136;
      IVar4 = aws_iot_mqtt_internal_wait_for_read(pClient,'\v',(Timer *)&packet_id);
      iVar2 = CONCAT31(extraout_var_04,IVar4);
      if (iVar2 != 0) goto LAB_23050136;
      uStack69 = '\0';
      auStack68[0] = '\0';
      IVar4 = aws_iot_mqtt_internal_deserialize_ack
                        (&uStack69,auStack68,(uint16_t *)&dup,(pClient->clientData).readBuf,
                         (pClient->clientData).readBufSize);
      iVar2 = CONCAT31(extraout_var_05,IVar4);
      if (iVar2 != 0) goto LAB_23050136;
      if (uStack69 == '\v') goto LAB_2305020a;
      break;
    }
    pMVar1 = pMVar1 + 1;
  } while (pMVar1 != pMVar10);
  iVar2 = -1;
LAB_23050136:
  IVar4 = aws_iot_mqtt_set_client_state
                    (pClient,CLIENT_STATE_CONNECTED_UNSUBSCRIBE_IN_PROGRESS,expectedCurrentState);
  if (iVar2 != 0) {
    IVar4 = (IoT_Error_t)iVar2;
  }
LAB_23050102:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar4;
LAB_2305020a:
  do {
    if ((pMVar8->topicName != (char *)0x0) &&
       (iVar7 = strcmp(pMVar8->topicName,pTopicFilter), iVar7 == 0)) {
      pMVar8->topicName = (char *)0x0;
    }
    pMVar8 = pMVar8 + 1;
  } while (pMVar8 != pMVar10);
  goto LAB_23050136;
}



IoT_Error_t _aws_iot_mqtt_handle_disconnect(AWS_IoT_Client *pClient)

{
  IoT_Error_t IVar1;
  undefined3 extraout_var;
  iot_disconnect_handler *piVar2;
  
  IVar1 = aws_iot_mqtt_disconnect(pClient);
  if (CONCAT31(extraout_var,IVar1) != 0) {
    (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_ERROR;
    (*(pClient->networkStack).disconnect)(&pClient->networkStack);
    (*(pClient->networkStack).destroy)(&pClient->networkStack);
  }
  piVar2 = (pClient->clientData).disconnectHandler;
  if (piVar2 != (iot_disconnect_handler *)0x0) {
    (*piVar2)(pClient,(pClient->clientData).disconnectHandlerData);
  }
  (pClient->clientStatus).clientState = CLIENT_STATE_DISCONNECTED_ERROR;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NETWORK_DISCONNECTED_ERROR;
}



// WARNING: Variable defined which should be unmapped: timer_1

IoT_Error_t aws_iot_mqtt_yield(AWS_IoT_Client *pClient,uint32_t timeout_ms)

{
  ushort uVar1;
  uint uVar2;
  ClientState CVar3;
  _Bool _Var4;
  IoT_Error_t IVar5;
  byte bVar6;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  undefined3 extraout_var_10;
  undefined3 extraout_var_11;
  undefined3 extraout_var_12;
  undefined3 extraout_var_13;
  uint timeout;
  anon_subr_IoT_Error_t_Network_ptr_for_isConnected *paVar8;
  uint uVar9;
  Timer *timer_00;
  uint8_t uStack61;
  uint8_t packet_type;
  size_t sStack60;
  size_t serialized_len;
  Timer timer;
  Timer timer_1;
  int iVar7;
  
  uVar2 = 0xfffffffe;
  if ((pClient == (AWS_IoT_Client *)0x0) || (timeout_ms == 0)) goto LAB_23050340;
  CVar3 = aws_iot_mqtt_get_client_state(pClient);
  iVar7 = CONCAT31(extraout_var,CVar3);
  uVar2 = 5;
  if (iVar7 == 0xc) goto LAB_23050340;
  if (iVar7 == 0xd) {
LAB_230502a2:
    init_timer((Timer *)&serialized_len);
    countdown_ms((Timer *)&serialized_len,timeout_ms);
    timer_00 = &pClient->reconnectDelayTimer;
    do {
      CVar3 = aws_iot_mqtt_get_client_state(pClient);
      if (CONCAT31(extraout_var_00,CVar3) == 0xd) {
        if (0x1f400 < (pClient->clientData).currentReconnectWaitInterval) {
          uVar2 = 0xfffffff2;
          goto LAB_2305042e;
        }
        _Var4 = has_timer_expired(timer_00);
        uVar2 = 4;
        if (CONCAT31(extraout_var_01,_Var4) != 0) {
          paVar8 = (pClient->networkStack).isConnected;
          if (paVar8 == (anon_subr_IoT_Error_t_Network_ptr_for_isConnected *)0x0) {
            uVar9 = 0xffffffee;
          }
          else {
            IVar5 = (*paVar8)(&pClient->networkStack);
            uVar9 = CONCAT31(extraout_var_02,IVar5);
            if (uVar9 == 6) {
              IVar5 = aws_iot_mqtt_attempt_reconnect(pClient);
              uVar9 = CONCAT31(extraout_var_03,IVar5);
              if (uVar9 == 3) {
                IVar5 = aws_iot_mqtt_set_client_state
                                  (pClient,CLIENT_STATE_CONNECTED_IDLE,
                                   CLIENT_STATE_CONNECTED_YIELD_IN_PROGRESS);
                uVar2 = CONCAT31(extraout_var_04,IVar5);
                if (CONCAT31(extraout_var_04,IVar5) == 0) {
                  uVar2 = 3;
                }
                goto LAB_2305030e;
              }
            }
          }
          timeout = (pClient->clientData).currentReconnectWaitInterval << 1;
          (pClient->clientData).currentReconnectWaitInterval = timeout;
          uVar2 = 0xfffffff2;
          if (timeout < 0x1f401) {
            countdown_ms(timer_00,timeout);
            uVar2 = uVar9;
          }
        }
      }
      else {
        bVar6 = aws_iot_mqtt_internal_cycle_read(pClient,(Timer *)&serialized_len,&uStack61);
        uVar2 = CONCAT31(extraout_var_08,bVar6);
        if (uVar2 == 0) {
          if (((pClient->clientData).keepAliveInterval == 0) ||
             (_Var4 = has_timer_expired((Timer *)pClient), CONCAT31(extraout_var_09,_Var4) == 0))
          goto LAB_2305030e;
          if ((pClient->clientStatus).isPingOutstanding == false) {
            init_timer((Timer *)&timer.last_polled_ticks);
            countdown_ms((Timer *)&timer.last_polled_ticks,(pClient->clientData).commandTimeoutMs);
            sStack60 = 0;
            IVar5 = aws_iot_mqtt_internal_serialize_zero
                              ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,
                               PINGREQ,(size_t *)&stack0xffffffc4);
            uVar2 = CONCAT31(extraout_var_12,IVar5);
            if (uVar2 == 0) {
              IVar5 = aws_iot_mqtt_internal_send_packet
                                (pClient,sStack60,(Timer *)&timer.last_polled_ticks);
              uVar2 = CONCAT31(extraout_var_13,IVar5);
              if (uVar2 == 0) {
                uVar1 = (pClient->clientData).keepAliveInterval;
                (pClient->clientStatus).isPingOutstanding = true;
                countdown_sec((Timer *)pClient,(uint)uVar1);
                goto LAB_2305030e;
              }
              goto LAB_23050392;
            }
          }
          else {
LAB_23050392:
            IVar5 = _aws_iot_mqtt_handle_disconnect(pClient);
            uVar2 = CONCAT31(extraout_var_10,IVar5);
          }
          if (uVar2 != 0xfffffff3) {
            if (uVar2 == 0) goto LAB_2305030e;
            goto LAB_2305042e;
          }
        }
        else {
          if (((bVar6 & 0xfd) == 0xf4) || (uVar2 == 0xfffffff9)) goto LAB_23050392;
          if (uVar2 != 0xfffffff3) goto LAB_2305042e;
        }
        (pClient->clientData).counterNetworkDisconnected =
             (pClient->clientData).counterNetworkDisconnected + 1;
        if ((pClient->clientStatus).isAutoReconnectEnabled == false) goto LAB_23050326;
        IVar5 = aws_iot_mqtt_set_client_state
                          (pClient,CLIENT_STATE_DISCONNECTED_ERROR,CLIENT_STATE_PENDING_RECONNECT);
        uVar2 = CONCAT31(extraout_var_11,IVar5);
        if (uVar2 != 0) break;
        (pClient->clientData).currentReconnectWaitInterval = 1000;
        countdown_ms(timer_00,1000);
        uVar2 = 4;
      }
LAB_2305030e:
      _Var4 = has_timer_expired((Timer *)&serialized_len);
    } while (CONCAT31(extraout_var_05,_Var4) == 0);
    if (uVar2 != 0xfffffff3) {
LAB_2305042e:
      if (uVar2 != 4) {
        bVar6 = aws_iot_mqtt_set_client_state
                          (pClient,CLIENT_STATE_CONNECTED_YIELD_IN_PROGRESS,
                           CLIENT_STATE_CONNECTED_IDLE);
        if (uVar2 == 0) {
          uVar2 = (uint)bVar6;
        }
      }
      goto LAB_23050340;
    }
  }
  else {
    _Var4 = aws_iot_mqtt_is_client_connected(pClient);
    if (CONCAT31(extraout_var_06,_Var4) != 0) {
      uVar2 = 0xffffffe2;
      if (iVar7 != 3) goto LAB_23050340;
      IVar5 = aws_iot_mqtt_set_client_state
                        (pClient,CLIENT_STATE_CONNECTED_IDLE,
                         CLIENT_STATE_CONNECTED_YIELD_IN_PROGRESS);
      uVar2 = CONCAT31(extraout_var_07,IVar5);
      if (uVar2 != 0) goto LAB_23050340;
      goto LAB_230502a2;
    }
  }
LAB_23050326:
  uVar2 = 0xfffffff3;
LAB_23050340:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar2;
}



IoT_Error_t iot_tls_is_connected(Network *pNetwork)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NETWORK_PHYSICAL_LAYER_CONNECTED;
}



// WARNING: Variable defined which should be unmapped: info_buf

IoT_Error_t iot_tls_connect(Network *pNetwork,TLSConnectParams *params)

{
  _Bool _Var1;
  mbedtls_ssl_context *ssl;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  mbedtls_x509_crt *pmVar5;
  uchar *puVar6;
  char *pcVar7;
  char *pcVar8;
  uint32_t uVar9;
  char *pcVar10;
  char *pcVar11;
  mbedtls_ssl_config *conf;
  mbedtls_net_context *ctx;
  mbedtls_pk_context *ctx_00;
  mbedtls_x509_crt *crt;
  mbedtls_ctr_drbg_context *ctx_01;
  char acStack312 [4];
  char portBuffer [6];
  char info_buf [256];
  
  if (pNetwork == (Network *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NULL_VALUE_ERROR;
  }
  if (params != (TLSConnectParams *)0x0) {
    pcVar8 = params->pRootCALocation;
    pcVar10 = params->pDeviceCertLocation;
    pcVar7 = params->pDevicePrivateKeyLocation;
    pcVar11 = params->pDestinationURL;
    uVar9 = params->timeout_ms;
    _Var1 = params->ServerVerificationFlag;
    (pNetwork->tlsConnectParams).DestinationPort = params->DestinationPort;
    (pNetwork->tlsConnectParams).pDestinationURL = pcVar11;
    (pNetwork->tlsConnectParams).pDeviceCertLocation = pcVar10;
    (pNetwork->tlsConnectParams).pDevicePrivateKeyLocation = pcVar7;
    (pNetwork->tlsConnectParams).pRootCALocation = pcVar8;
    (pNetwork->tlsConnectParams).timeout_ms = uVar9;
    (pNetwork->tlsConnectParams).ServerVerificationFlag = _Var1;
  }
  ctx = &(pNetwork->tlsDataParams).server_fd;
  mbedtls_net_init(ctx);
  ssl = &(pNetwork->tlsDataParams).ssl;
  mbedtls_ssl_init(ssl);
  conf = &(pNetwork->tlsDataParams).conf;
  mbedtls_ssl_config_init(conf);
  ctx_01 = &(pNetwork->tlsDataParams).ctr_drbg;
  mbedtls_ctr_drbg_init(ctx_01);
  crt = &(pNetwork->tlsDataParams).cacert;
  mbedtls_x509_crt_init(crt);
  pmVar5 = &(pNetwork->tlsDataParams).clicert;
  mbedtls_x509_crt_init(pmVar5);
  ctx_00 = &(pNetwork->tlsDataParams).pkey;
  mbedtls_pk_init(ctx_00);
  printf("DEBUG Seeding the random number generator...\r\n");
  mbedtls_entropy_init((mbedtls_entropy_context *)&pNetwork->tlsDataParams);
  pcVar7 = TAG;
  sVar2 = strlen(TAG);
  iVar3 = mbedtls_ctr_drbg_seed
                    (ctx_01,mbedtls_entropy_func,&pNetwork->tlsDataParams,(uchar *)pcVar7,sVar2);
  if (iVar3 != 0) {
    printf("ERROR failed! mbedtls_ctr_drbg_seed returned -0x%x\r\n",-iVar3);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NETWORK_MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
  }
  if (*(pNetwork->tlsConnectParams).pRootCALocation == '/') {
    printf("DEBUG Loading CA root certificate from file ...\r\n");
    iVar3 = mbedtls_x509_crt_parse_file(crt,(pNetwork->tlsConnectParams).pRootCALocation);
  }
  else {
    printf("DEBUG Loading embedded CA root certificate ...\r\n");
    puVar6 = (uchar *)(pNetwork->tlsConnectParams).pRootCALocation;
    sVar2 = strlen((char *)puVar6);
    iVar3 = mbedtls_x509_crt_parse(crt,puVar6,sVar2 + 1);
  }
  if (iVar3 < 0) {
    printf("ERROR failed!  mbedtls_x509_crt_parse returned -0x%x while parsing root cert\r\n",-iVar3
          );
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NETWORK_X509_ROOT_CRT_PARSE_ERROR;
  }
  printf("DEBUG ok (%d skipped)\r\n",iVar3);
  if (*(pNetwork->tlsConnectParams).pDeviceCertLocation == '/') {
    printf("DEBUG Loading client cert from file...\r\n");
    iVar3 = mbedtls_x509_crt_parse_file(pmVar5,(pNetwork->tlsConnectParams).pDeviceCertLocation);
  }
  else {
    printf("DEBUG Loading embedded client certificate...\r\n");
    puVar6 = (uchar *)(pNetwork->tlsConnectParams).pDeviceCertLocation;
    sVar2 = strlen((char *)puVar6);
    iVar3 = mbedtls_x509_crt_parse(pmVar5,puVar6,sVar2 + 1);
  }
  if (iVar3 != 0) {
    printf("ERROR failed!  mbedtls_x509_crt_parse returned -0x%x while parsing device cert\r\n",
           -iVar3);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NETWORK_X509_DEVICE_CRT_PARSE_ERROR;
  }
  if (*(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation == '/') {
    printf("DEBUG Loading client private key from file...\r\n");
    iVar3 = mbedtls_pk_parse_keyfile
                      (ctx_00,(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation,"");
  }
  else {
    printf("DEBUG Loading embedded client private key...\r\n");
    puVar6 = (uchar *)(pNetwork->tlsConnectParams).pDevicePrivateKeyLocation;
    sVar2 = strlen((char *)puVar6);
    iVar3 = mbedtls_pk_parse_key(ctx_00,puVar6,sVar2 + 1,"",0);
  }
  if (iVar3 != 0) {
    printf("ERROR failed!  mbedtls_pk_parse_key returned -0x%x while parsing private key\r\n",-iVar3
          );
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NETWORK_PK_PRIVATE_KEY_PARSE_ERROR;
  }
  printf("DEBUG ok\r\n");
  snprintf(acStack312,6,"%d",(uint)(pNetwork->tlsConnectParams).DestinationPort);
  printf("DEBUG Connecting to %s/%s...\r\n",(pNetwork->tlsConnectParams).pDestinationURL,acStack312)
  ;
  iVar3 = mbedtls_net_connect(ctx,(pNetwork->tlsConnectParams).pDestinationURL,acStack312,0);
  if (iVar3 != 0) {
    printf("ERROR failed! mbedtls_net_connect returned -0x%x\r\n",-iVar3);
    if (iVar3 == -0x52) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return NETWORK_ERR_NET_UNKNOWN_HOST;
    }
    if (iVar3 == -0x42) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return NETWORK_ERR_NET_SOCKET_FAILED;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return NETWORK_ERR_NET_CONNECT_FAILED;
  }
  iVar3 = mbedtls_net_set_block(ctx);
  if (iVar3 != 0) {
    iVar3 = -iVar3;
    pcVar7 = "ERROR failed! net_set_(non)block() returned -0x%x\r\n";
LAB_2305072e:
    printf(pcVar7,iVar3);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SSL_CONNECTION_ERROR;
  }
  printf("DEBUG ok\r\n");
  printf("DEBUG Setting up the SSL/TLS structure...\r\n");
  iVar3 = mbedtls_ssl_config_defaults(conf,0,0,0);
  if (iVar3 != 0) {
    iVar3 = -iVar3;
    pcVar7 = "ERROR failed! mbedtls_ssl_config_defaults returned -0x%x\r\n";
    goto LAB_2305072e;
  }
  mbedtls_ssl_conf_verify(conf,_iot_tls_verify_cert,(void *)0x0);
  iVar3 = 2;
  if ((pNetwork->tlsConnectParams).ServerVerificationFlag == false) {
    iVar3 = 1;
  }
  mbedtls_ssl_conf_authmode(conf,iVar3);
  mbedtls_ssl_conf_rng(conf,mbedtls_ctr_drbg_random,ctx_01);
  mbedtls_ssl_conf_ca_chain(conf,crt,(mbedtls_x509_crl *)0x0);
  iVar3 = mbedtls_ssl_conf_own_cert(conf,pmVar5,ctx_00);
  if (iVar3 != 0) {
    pcVar7 = "ERROR failed! mbedtls_ssl_conf_own_cert returned %d\r\n";
    goto LAB_2305072e;
  }
  mbedtls_ssl_conf_read_timeout(conf,(pNetwork->tlsConnectParams).timeout_ms);
  if ((pNetwork->tlsConnectParams).DestinationPort == 0x1bb) {
    stack0xfffffed0 = "x-amzn-mqtt-ca";
    iVar3 = mbedtls_ssl_conf_alpn_protocols(conf,(char **)(portBuffer + 4));
    if (iVar3 != 0) {
      iVar3 = -iVar3;
      pcVar7 = "ERROR failed! mbedtls_ssl_conf_alpn_protocols returned -0x%x\r\n";
      goto LAB_2305072e;
    }
  }
  iVar3 = mbedtls_ssl_setup(ssl,(mbedtls_ssl_config_conflict *)conf);
  if (iVar3 != 0) {
    iVar3 = -iVar3;
    pcVar7 = "ERROR failed! mbedtls_ssl_setup returned -0x%x\r\n";
    goto LAB_2305072e;
  }
  iVar3 = mbedtls_ssl_set_hostname(ssl,(pNetwork->tlsConnectParams).pDestinationURL);
  if (iVar3 != 0) {
    pcVar7 = "ERROR failed! mbedtls_ssl_set_hostname returned %d\r\n";
    goto LAB_2305072e;
  }
  printf("DEBUG SSL state connect : %d \r\n",(pNetwork->tlsDataParams).ssl.state);
  mbedtls_ssl_set_bio(ssl,ctx,mbedtls_net_send,(mbedtls_ssl_recv_t *)0x0,mbedtls_net_recv_timeout);
  printf("DEBUG ok\r\n");
  printf("DEBUG SSL state connect : %d \r\n",(pNetwork->tlsDataParams).ssl.state);
  printf("DEBUG Performing the SSL/TLS handshake...\r\n");
  while (uVar4 = mbedtls_ssl_handshake(ssl), uVar4 != 0) {
    if ((uVar4 & 0xffffff7f) != 0xffff9700) {
      printf("ERROR failed! mbedtls_ssl_handshake returned -0x%x\r\n",-uVar4);
      if (uVar4 != 0xffffd900) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return SSL_CONNECTION_ERROR;
      }
      printf("ERROR     Unable to verify the server\'s certificate. \r\n");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return SSL_CONNECTION_ERROR;
    }
  }
  pcVar7 = mbedtls_ssl_get_version(ssl);
  pcVar8 = mbedtls_ssl_get_ciphersuite(ssl);
  printf("DEBUG ok [ Protocol is %s ]    [ Ciphersuite is %s ]\r\n",pcVar7,pcVar8);
  iVar3 = mbedtls_ssl_get_record_expansion(ssl);
  if (iVar3 < 0) {
    printf("DEBUG  [ Record expansion is unknown (compression) ]\r\n",iVar3);
  }
  else {
    printf("DEBUG  [ Record expansion is %d ]\r\n",iVar3);
  }
  printf("DEBUG Verifying peer X.509 certificate...\r\n");
  if ((pNetwork->tlsConnectParams).ServerVerificationFlag == false) {
    pcVar7 = "WARNN  Server Verification skipped\r\n";
  }
  else {
    uVar9 = mbedtls_ssl_get_verify_result(ssl);
    (pNetwork->tlsDataParams).flags = uVar9;
    if (uVar9 != 0) {
      printf("ERROR failed\r\n");
      mbedtls_x509_crt_verify_info(portBuffer + 4,0x100,"  ! ",(pNetwork->tlsDataParams).flags);
      printf("ERROR %s\r\n",portBuffer + 4);
      uVar4 = 0xfffffffc;
      goto LAB_23050902;
    }
    pcVar7 = "DEBUG ok\r\n";
  }
  printf(pcVar7);
LAB_23050902:
  pmVar5 = mbedtls_ssl_get_peer_cert(ssl);
  if (pmVar5 != (mbedtls_x509_crt *)0x0) {
    printf("DEBUG Peer certificate information:\r\n");
    pmVar5 = mbedtls_ssl_get_peer_cert(ssl);
    mbedtls_x509_crt_info(portBuffer + 4,0xff,"      ",pmVar5);
    printf("DEBUG %s\r\n",portBuffer + 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar4;
}



int _iot_tls_verify_cert(void *data,mbedtls_x509_crt *crt,int depth,uint32_t *flags)

{
  char acStack272 [4];
  char buf [256];
  
  printf("DEBUG Verify requested for (Depth %d):\r\n",depth);
  mbedtls_x509_crt_info(acStack272,0xff,"",crt);
  printf("DEBUG %s\r\n",acStack272);
  if (*flags == 0) {
    printf("DEBUG   This certificate has no flags\r\n");
  }
  else {
    printf("DEBUG Verify result:%s\r\n",acStack272);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



IoT_Error_t iot_tls_write(Network *pNetwork,uchar *pMsg,size_t len,Timer *timer,size_t *written_len)

{
  uint uVar1;
  int iVar2;
  _Bool _Var3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  IoT_Error_t IVar4;
  
  iVar2 = 0;
  uVar1 = 0;
  do {
    if ((len <= uVar1) || (_Var3 = has_timer_expired(timer), CONCAT31(extraout_var,_Var3) != 0)) {
      *written_len = uVar1;
      _Var3 = has_timer_expired(timer);
      IVar4 = SUCCESS;
      if ((CONCAT31(extraout_var_01,_Var3) != 0) && (IVar4 = SUCCESS, uVar1 != len)) {
        IVar4 = NETWORK_SSL_WRITE_TIMEOUT_ERROR;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return IVar4;
    }
    while ((_Var3 = has_timer_expired(timer), CONCAT31(extraout_var_00,_Var3) == 0 &&
           (iVar2 = mbedtls_ssl_write(&(pNetwork->tlsDataParams).ssl,pMsg + uVar1,len - uVar1),
           iVar2 < 1))) {
      if ((iVar2 != -0x6900) && (iVar2 != -0x6880)) {
        printf("ERROR failed! mbedtls_ssl_write returned -0x%x\r\n",-iVar2);
        *written_len = uVar1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return NETWORK_SSL_WRITE_ERROR;
      }
    }
    uVar1 = uVar1 + iVar2;
  } while( true );
}



IoT_Error_t iot_tls_read(Network *pNetwork,uchar *pMsg,size_t len,Timer *timer,size_t *read_len)

{
  IoT_Error_t IVar1;
  _Bool _Var2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint uVar5;
  undefined3 extraout_var;
  uint timeout;
  size_t sVar6;
  mbedtls_ssl_config *conf;
  
  timeout = (pNetwork->tlsDataParams).conf.read_timeout;
  conf = &(pNetwork->tlsDataParams).conf;
  sVar6 = 0;
  do {
    if (len == 0) goto LAB_23050b08;
    uVar3 = left_ms(timer);
    uVar4 = timeout;
    if (uVar3 <= timeout) {
      uVar4 = left_ms(timer);
    }
    uVar3 = 1;
    if ((uVar4 != 0) && (uVar4 = left_ms(timer), uVar3 = timeout, uVar4 <= timeout)) {
      uVar3 = left_ms(timer);
    }
    mbedtls_ssl_conf_read_timeout(conf,uVar3);
    uVar5 = mbedtls_ssl_read(&(pNetwork->tlsDataParams).ssl,pMsg,len);
    mbedtls_ssl_conf_read_timeout(conf,timeout);
    if ((int)uVar5 < 1) {
      if ((uVar5 == 0) || (((uVar5 & 0xffffff7f) != 0xffff9700 && (uVar5 != 0xffff9800)))) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return NETWORK_SSL_READ_ERROR;
      }
    }
    else {
      sVar6 = sVar6 + uVar5;
      pMsg = pMsg + uVar5;
      len = len - uVar5;
    }
    _Var2 = has_timer_expired(timer);
  } while (CONCAT31(extraout_var,_Var2) == 0);
  if (len == 0) {
LAB_23050b08:
    *read_len = sVar6;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = NETWORK_SSL_NOTHING_TO_READ;
    if (sVar6 != 0) {
      IVar1 = NETWORK_SSL_READ_TIMEOUT_ERROR;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t iot_tls_disconnect(Network *pNetwork)

{
  int iVar1;
  
  do {
    iVar1 = mbedtls_ssl_close_notify(&(pNetwork->tlsDataParams).ssl);
  } while (iVar1 == -0x6880);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



IoT_Error_t iot_tls_destroy(Network *pNetwork)

{
  mbedtls_net_free(&(pNetwork->tlsDataParams).server_fd);
  mbedtls_x509_crt_free(&(pNetwork->tlsDataParams).clicert);
  mbedtls_x509_crt_free(&(pNetwork->tlsDataParams).cacert);
  mbedtls_pk_free(&(pNetwork->tlsDataParams).pkey);
  mbedtls_ssl_free(&(pNetwork->tlsDataParams).ssl);
  mbedtls_ssl_config_free(&(pNetwork->tlsDataParams).conf);
  mbedtls_ctr_drbg_free(&(pNetwork->tlsDataParams).ctr_drbg);
  mbedtls_entropy_free((mbedtls_entropy_context *)&pNetwork->tlsDataParams);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



IoT_Error_t
iot_tls_init(Network *pNetwork,char *pRootCALocation,char *pDeviceCertLocation,
            char *pDevicePrivateKeyLocation,char *pDestinationURL,uint16_t destinationPort,
            uint32_t timeout_ms,_Bool ServerVerificationFlag)

{
  (pNetwork->tlsConnectParams).DestinationPort = destinationPort;
  pNetwork->connect = iot_tls_connect;
  pNetwork->read = iot_tls_read;
  pNetwork->write = iot_tls_write;
  pNetwork->disconnect = iot_tls_disconnect;
  pNetwork->isConnected = iot_tls_is_connected;
  (pNetwork->tlsConnectParams).pDestinationURL = pDestinationURL;
  (pNetwork->tlsConnectParams).pDeviceCertLocation = pDeviceCertLocation;
  (pNetwork->tlsConnectParams).pDevicePrivateKeyLocation = pDevicePrivateKeyLocation;
  (pNetwork->tlsConnectParams).pRootCALocation = pRootCALocation;
  (pNetwork->tlsConnectParams).timeout_ms = timeout_ms;
  (pNetwork->tlsConnectParams).ServerVerificationFlag = ServerVerificationFlag;
  pNetwork->destroy = iot_tls_destroy;
  (pNetwork->tlsDataParams).flags = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



IoT_Error_t aws_iot_thread_mutex_init(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  QueueHandle_t pQVar2;
  
  pQVar2 = xQueueCreateMutex('\x04');
  pMutex->mutex = (SemaphoreHandle_t)pQVar2;
  if (pQVar2 == (QueueHandle_t)0x0) {
    IVar1 = MUTEX_INIT_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_lock(IoT_Mutex_t *pMutex)

{
  xQueueTakeMutexRecursive((QueueHandle_t)pMutex->mutex,0xffffffff);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



IoT_Error_t aws_iot_thread_mutex_trylock(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  BaseType_t BVar2;
  
  BVar2 = xQueueTakeMutexRecursive((QueueHandle_t)pMutex->mutex,0);
  if (BVar2 == 0) {
    IVar1 = MUTEX_LOCK_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_unlock(IoT_Mutex_t *pMutex)

{
  IoT_Error_t IVar1;
  BaseType_t BVar2;
  
  BVar2 = xQueueGiveMutexRecursive((QueueHandle_t)pMutex->mutex);
  if (BVar2 == 0) {
    IVar1 = MUTEX_UNLOCK_ERROR;
  }
  else {
    IVar1 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



IoT_Error_t aws_iot_thread_mutex_destroy(IoT_Mutex_t *pMutex)

{
  vQueueDelete((QueueHandle_t)pMutex->mutex);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Variable defined which should be unmapped: byteRead

IoT_Error_t
_aws_iot_mqtt_internal_readWrapper
          (AWS_IoT_Client *pClient,size_t offset,size_t size,Timer *pTimer,size_t *read_len)

{
  IoT_Error_t IVar1;
  size_t sVar2;
  size_t sVar3;
  size_t sStack20;
  size_t byteRead;
  
  sVar3 = (pClient->clientData).readBufIndex;
  sStack20 = 0;
  sVar2 = (offset - sVar3) + size;
  if ((int)sVar2 < 1) {
    *read_len = size;
    IVar1 = SUCCESS;
  }
  else {
    IVar1 = (*(pClient->networkStack).read)
                      (&pClient->networkStack,(pClient->clientData).readBuf + sVar3,sVar2,pTimer,
                       &sStack20);
    sStack20 = sStack20 + (pClient->clientData).readBufIndex;
    (pClient->clientData).readBufIndex = sStack20;
    *read_len = sStack20 - offset;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar1;
}



size_t aws_iot_mqtt_internal_write_len_to_buffer(uchar *buf,uint32_t length)

{
  bool bVar1;
  byte bVar2;
  size_t sVar3;
  size_t sVar4;
  
  sVar3 = 0;
  do {
    bVar2 = (byte)length & 0x7f;
    if (0x7f < length) {
      bVar2 = bVar2 | 0x80;
    }
    sVar4 = sVar3 + 1;
    buf[sVar3] = bVar2;
    bVar1 = 0x7f < length;
    length = length >> 7;
    sVar3 = sVar4;
  } while (bVar1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar4;
}



IoT_Error_t
aws_iot_mqtt_internal_decode_remaining_length_from_buffer
          (uchar *buf,uint32_t *decodedLen,uint32_t *readBytesLen)

{
  byte bVar1;
  int iVar2;
  uint32_t uVar3;
  int iVar5;
  uint32_t uVar4;
  
  *decodedLen = 0;
  iVar2 = 1;
  uVar4 = 0;
  do {
    uVar3 = uVar4 + 1;
    if (uVar3 == 5) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return MQTT_DECODE_REMAINING_LENGTH_ERROR;
    }
    bVar1 = buf[uVar4];
    iVar5 = (bVar1 & 0x7f) * iVar2;
    iVar2 = iVar2 << 7;
    *decodedLen = *decodedLen + iVar5;
    uVar4 = uVar3;
  } while ((char)bVar1 < '\0');
  *readBytesLen = uVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



uint32_t aws_iot_mqtt_internal_get_final_packet_length_from_remaining_length(uint32_t rem_len)

{
  uint32_t uVar1;
  uint uVar2;
  
  uVar2 = rem_len + 1;
  if (uVar2 < 0x80) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return rem_len + 2;
  }
  if (uVar2 < 0x4000) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return rem_len + 3;
  }
  uVar1 = rem_len + 5;
  if (uVar2 < 0x200000) {
    uVar1 = rem_len + 4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



uint16_t aws_iot_mqtt_internal_read_uint16_t(uchar **pptr)

{
  uchar uVar1;
  uchar uVar2;
  uchar *puVar3;
  
  puVar3 = *pptr;
  uVar1 = *puVar3;
  uVar2 = puVar3[1];
  *pptr = puVar3 + 2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CONCAT11(uVar1,uVar2);
}



void aws_iot_mqtt_internal_write_uint_16(uchar **pptr,uint16_t anInt)

{
  uchar *puVar1;
  
  **pptr = (uchar)(anInt >> 8);
  puVar1 = *pptr;
  *pptr = puVar1 + 1;
  puVar1[1] = (uchar)anInt;
  *pptr = *pptr + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uchar aws_iot_mqtt_internal_read_char(uchar **pptr)

{
  uchar uVar1;
  
  uVar1 = **pptr;
  *pptr = *pptr + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void aws_iot_mqtt_internal_write_char(uchar **pptr,uchar c)

{
  **pptr = c;
  *pptr = *pptr + 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void aws_iot_mqtt_internal_write_utf8_string(uchar **pptr,char *string,uint16_t stringLen)

{
  undefined2 in_register_00002032;
  size_t __n;
  
  __n = CONCAT22(in_register_00002032,stringLen);
  aws_iot_mqtt_internal_write_uint_16(pptr,stringLen);
  if (__n != 0) {
    memcpy(*pptr,string,__n);
    *pptr = *pptr + __n;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



IoT_Error_t
aws_iot_mqtt_internal_init_header
          (MQTTHeader *pHeader,MessageTypes message_type,QoS qos,uint8_t dup,uint8_t retained)

{
  uint uVar1;
  undefined3 in_register_00002031;
  byte bVar2;
  undefined3 in_register_00002039;
  IoT_Error_t IVar3;
  
  IVar3 = NULL_VALUE_ERROR;
  if (pHeader != (MQTTHeader *)0x0) {
    *pHeader = 0;
    uVar1 = (byte)message_type - 1 & 0xff;
    IVar3 = FAILURE;
    if (uVar1 < 0xe) {
      bVar2 = dup << 3 | CSWTCH_27[uVar1] << 4;
      if (CONCAT31(in_register_00002031,qos) == 1) {
        bVar2 = bVar2 | 2;
      }
      *pHeader = bVar2;
      *pHeader = CONCAT31(in_register_00002039,retained) == 1 | *pHeader;
      IVar3 = SUCCESS;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return IVar3;
}



IoT_Error_t aws_iot_mqtt_internal_send_packet(AWS_IoT_Client *pClient,size_t length,Timer *pTimer)

{
  IoT_Error_t IVar1;
  _Bool _Var2;
  byte bVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  uint uVar4;
  IoT_Mutex_t *pMutex;
  size_t sStack36;
  size_t sentLen;
  
  if ((pClient != (AWS_IoT_Client *)0x0) && (pTimer != (Timer *)0x0)) {
    uVar4 = 0xffffffdf;
    if (length < (pClient->clientData).writeBufSize) {
      pMutex = &(pClient->clientData).tls_write_mutex;
      IVar1 = aws_iot_mqtt_client_lock_mutex(pClient,pMutex);
      uVar4 = CONCAT31(extraout_var,IVar1);
      if (uVar4 == 0) {
        sStack36 = 0;
        uVar4 = 0;
        while (((uVar4 < length &&
                (_Var2 = has_timer_expired(pTimer), CONCAT31(extraout_var_00,_Var2) == 0)) &&
               (IVar1 = (*(pClient->networkStack).write)
                                  (&pClient->networkStack,(pClient->clientData).writeBuf + uVar4,
                                   length - uVar4,pTimer,&sStack36),
               CONCAT31(extraout_var_01,IVar1) == 0))) {
          uVar4 = uVar4 + sStack36;
        }
        bVar3 = aws_iot_mqtt_client_unlock_mutex(pClient,pMutex);
        uVar4 = (uint)bVar3;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)uVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return NULL_VALUE_ERROR;
}



// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_internal_cycle_read(AWS_IoT_Client *pClient,Timer *pTimer,uint8_t *pPacketType)

{
  char cVar1;
  ushort uVar2;
  char *pcVar3;
  uint uVar4;
  MessageHandlers *pMVar5;
  IoT_Error_t IVar6;
  ClientState expectedCurrentState;
  byte bVar7;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  undefined3 extraout_var_07;
  char *pcVar8;
  int iVar9;
  char *pcVar10;
  uint uVar11;
  char *pcVar12;
  size_t sVar13;
  char *pcVar14;
  IoT_Mutex_t *pMutex;
  size_t offset;
  int iVar15;
  uchar *in_fa0;
  uchar *extraout_fa0;
  size_t in_fa1;
  size_t extraout_fa1;
  ushort uStack74;
  uint16_t topicNameLen;
  char *pcStack72;
  size_t read_len;
  size_t read_len_1;
  Timer packetTimer;
  
  uVar4 = 0xfffffffe;
  if ((pClient != (AWS_IoT_Client *)0x0) && (pTimer != (Timer *)0x0)) {
    pMutex = &(pClient->clientData).tls_read_mutex;
    IVar6 = aws_iot_mqtt_client_lock_mutex(pClient,pMutex);
    uVar4 = CONCAT31(extraout_var,IVar6);
    if (uVar4 == 0) {
      init_timer((Timer *)&read_len_1);
      countdown_ms((Timer *)&read_len_1,(pClient->clientData).packetTimeoutMs);
      pcStack72 = (char *)0x0;
      IVar6 = _aws_iot_mqtt_internal_readWrapper(pClient,0,1,pTimer,(size_t *)&stack0xffffffb8);
      uVar4 = CONCAT31(extraout_var_00,IVar6);
      if (uVar4 == 0xffffffe7) {
        uVar4 = 2;
      }
      else {
        if (uVar4 == 0) {
          pcVar12 = (char *)0x0;
          iVar15 = 1;
          offset = 0;
          do {
            sVar13 = offset;
            offset = sVar13 + 1;
            if (offset == 5) {
              uVar4 = 0xffffffdd;
              goto LAB_2305102e;
            }
            IVar6 = _aws_iot_mqtt_internal_readWrapper(pClient,offset,1,pTimer,&read_len);
            uVar4 = CONCAT31(extraout_var_01,IVar6);
            if (uVar4 != 0) goto LAB_2305102e;
            bVar7 = (pClient->clientData).readBuf[sVar13 + 1];
            iVar9 = (bVar7 & 0x7f) * iVar15;
            iVar15 = iVar15 << 7;
            pcVar12 = pcVar12 + iVar9;
          } while ((char)bVar7 < '\0');
          pcVar8 = (char *)(pClient->clientData).readBufSize;
          if (pcVar12 + sVar13 + 2 < pcVar8) {
            if ((pcVar12 == (char *)0x0) ||
               ((IVar6 = _aws_iot_mqtt_internal_readWrapper
                                   (pClient,sVar13 + 2,(size_t)pcVar12,pTimer,
                                    (size_t *)&stack0xffffffb8),
                CONCAT31(extraout_var_04,IVar6) == 0 && (pcStack72 == pcVar12)))) {
              (pClient->clientData).readBufIndex = 0;
              *pPacketType = (pClient->clientData).readBuf[0] >> 4;
            }
            else {
              uVar4 = 0xffffffff;
            }
          }
          else {
            pcVar14 = (char *)0x0;
            do {
              IVar6 = (*(pClient->networkStack).read)
                                (&pClient->networkStack,(pClient->clientData).readBuf,(size_t)pcVar8
                                 ,pTimer,(size_t *)&stack0xffffffb8);
              uVar4 = CONCAT31(extraout_var_02,IVar6);
              in_fa0 = extraout_fa0;
              in_fa1 = extraout_fa1;
              if (uVar4 != 0) {
                if (pcVar14 < pcVar12) goto LAB_2305102e;
                break;
              }
              pcVar14 = pcVar14 + (int)pcStack72;
              pcVar10 = (char *)(pClient->clientData).readBufSize;
              pcVar8 = pcVar12 + -(int)pcVar14;
              if (pcVar10 < pcVar12 + -(int)pcVar14) {
                pcVar8 = pcVar10;
              }
            } while (pcVar14 < pcVar12);
            if (pcVar12 == pcVar14) {
              (pClient->clientData).readBufIndex = 0;
              uVar4 = 0xffffffe0;
            }
          }
        }
      }
LAB_2305102e:
      IVar6 = aws_iot_mqtt_client_unlock_mutex(pClient,pMutex);
      if (CONCAT31(extraout_var_03,IVar6) == 0) {
        if (uVar4 == 2) {
          uVar4 = 0;
          goto LAB_23051040;
        }
        if (uVar4 != 0) goto LAB_23051040;
        if (0xb < (*pPacketType - 2 & 0xff)) {
          uVar4 = 0xffffffe1;
          goto LAB_23051040;
        }
        uVar11 = 1 << (*pPacketType - 2 & 0x1f);
        if ((uVar11 & 0x2ad) != 0) goto LAB_23051040;
        if ((int)(uVar11 << 0x14) < 0) {
          uVar2 = (pClient->clientData).keepAliveInterval;
          (pClient->clientStatus).isPingOutstanding = false;
          countdown_sec((Timer *)pClient,(uint)uVar2);
          goto LAB_23051040;
        }
        uVar4 = 0xffffffe1;
        if ((uVar11 & 2) == 0) goto LAB_23051040;
        pcStack72 = (char *)0x0;
        uStack74 = 0;
        read_len = 0;
        IVar6 = aws_iot_mqtt_internal_deserialize_publish
                          ((uint8_t *)((int)&read_len_1 + 2),(QoS *)&read_len_1,
                           (uint8_t *)((int)&read_len_1 + 1),(uint16_t *)&packetTimer,
                           (char **)&stack0xffffffb8,&uStack74,(uchar **)&packetTimer.timeout_ticks,
                           &packetTimer.last_polled_ticks,in_fa0,in_fa1);
        pcVar12 = pcStack72;
        uVar2 = uStack74;
        uVar4 = CONCAT31(extraout_var_05,IVar6);
        if (uVar4 != 0) goto LAB_23051040;
        uVar11 = (uint)uStack74;
        uVar4 = 0xfffffffe;
        if (pcStack72 == (char *)0x0) goto LAB_23051040;
        expectedCurrentState = aws_iot_mqtt_get_client_state(pClient);
        aws_iot_mqtt_set_client_state
                  (pClient,expectedCurrentState,CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN);
        pMVar5 = (pClient->clientData).messageHandlers;
        pcVar8 = pcVar12 + uVar11;
        do {
          if (pMVar5->topicName != (char *)0x0) {
            if ((pMVar5->topicNameLen == uVar11) &&
               (iVar15 = strncmp(pcVar12,pMVar5->topicName,uVar11), iVar15 == 0)) {
LAB_2305118e:
              if (pMVar5->pApplicationHandler != (pApplicationHandler_t *)0x0) {
                (*pMVar5->pApplicationHandler)
                          (pClient,pcVar12,uVar2,(IoT_Publish_Message_Params *)&read_len_1,
                           pMVar5->pApplicationHandlerData);
              }
            }
            else {
              pcVar10 = pMVar5->topicName;
              pcVar14 = pcVar12;
              if (pcVar10 != (char *)0x0) {
                while (cVar1 = *pcVar10, cVar1 != '\0') {
                  if (pcVar8 <= pcVar14) goto LAB_23051140;
                  if (*pcVar14 == '/') {
                    if (cVar1 != '/') goto LAB_23051140;
                  }
                  else {
                    pcVar3 = pcVar14;
                    if (cVar1 == '+') {
                      do {
                        pcVar14 = pcVar3;
                        if (pcVar8 == pcVar14 + 1) break;
                        pcVar3 = pcVar14 + 1;
                      } while (pcVar14[1] != '/');
                    }
                    else {
                      if (cVar1 == '#') {
                        pcVar14 = pcVar8 + -1;
                      }
                      else {
                        if (*pcVar14 != cVar1) goto LAB_23051140;
                      }
                    }
                  }
                  pcVar10 = pcVar10 + 1;
                  pcVar14 = pcVar14 + 1;
                }
                if (pcVar8 == pcVar14) goto LAB_2305118e;
              }
            }
          }
LAB_23051140:
          pMVar5 = pMVar5 + 1;
        } while ((MessageHandlers *)&(pClient->clientData).disconnectHandler != pMVar5);
        IVar6 = aws_iot_mqtt_set_client_state
                          (pClient,CLIENT_STATE_CONNECTED_WAIT_FOR_CB_RETURN,expectedCurrentState);
        uVar4 = CONCAT31(extraout_var_06,IVar6);
        if ((uVar4 != 0) || ((QoS)read_len_1 == QOS0)) goto LAB_23051040;
        IVar6 = aws_iot_mqtt_internal_serialize_ack
                          ((pClient->clientData).writeBuf,(pClient->clientData).writeBufSize,PUBACK,
                           '\0',(uint16_t)packetTimer.start_ticks,&read_len);
        uVar4 = CONCAT31(extraout_var_07,IVar6);
        if (uVar4 != 0) goto LAB_23051040;
        bVar7 = aws_iot_mqtt_internal_send_packet(pClient,read_len,pTimer);
        uVar11 = (uint)bVar7;
      }
      else {
        uVar11 = CONCAT31(extraout_var_03,IVar6);
        if ((uVar4 & 0xfd) != 0) goto LAB_23051040;
      }
      uVar4 = uVar11;
    }
  }
LAB_23051040:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)uVar4;
}



IoT_Error_t aws_iot_mqtt_internal_flushBuffers(AWS_IoT_Client *pClient)

{
  (pClient->clientData).readBufIndex = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Variable defined which should be unmapped: read_packet_type

IoT_Error_t
aws_iot_mqtt_internal_wait_for_read(AWS_IoT_Client *pClient,uint8_t packetType,Timer *pTimer)

{
  _Bool _Var1;
  byte bVar2;
  undefined3 extraout_var;
  undefined3 in_register_0000202d;
  byte abStack17 [4];
  uint8_t read_packet_type;
  
  if (pClient == (AWS_IoT_Client *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (IoT_Error_t)0xfe;
  }
  bVar2 = 0xfe;
  if (pTimer != (Timer *)0x0) {
    abStack17[0] = 0;
    while (_Var1 = has_timer_expired(pTimer), CONCAT31(extraout_var,_Var1) == 0) {
      bVar2 = aws_iot_mqtt_internal_cycle_read(pClient,pTimer,abStack17);
      if ((bVar2 & 0xfd) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return bVar2;
      }
      if ((uint)abStack17[0] == CONCAT31(in_register_0000202d,packetType)) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return bVar2;
      }
    }
    bVar2 = 0xe4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)bVar2;
}



// WARNING: Variable defined which should be unmapped: ptr
// WARNING: Could not reconcile some variable overlaps

IoT_Error_t
aws_iot_mqtt_internal_serialize_zero
          (uchar *pTxBuf,size_t txBufLen,MessageTypes packetType,size_t *pSerializedLength)

{
  int iVar1;
  IoT_Error_t IVar2;
  undefined3 extraout_var;
  size_t sVar3;
  uchar auStack24 [4];
  MQTTHeader header;
  uchar *ptr;
  
  auStack24[0] = '\0';
  iVar1 = -2;
  if (((pTxBuf != (uchar *)0x0) && (pSerializedLength != (size_t *)0x0)) &&
     (iVar1 = -0x21, 3 < txBufLen)) {
    _header = pTxBuf;
    IVar2 = aws_iot_mqtt_internal_init_header(auStack24,packetType,QOS0,'\0','\0');
    iVar1 = CONCAT31(extraout_var,IVar2);
    if (iVar1 == 0) {
      aws_iot_mqtt_internal_write_char((uchar **)&header,auStack24[0]);
      sVar3 = aws_iot_mqtt_internal_write_len_to_buffer(_header,0);
      *pSerializedLength = (size_t)(_header + (sVar3 - (int)pTxBuf));
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (IoT_Error_t)iVar1;
}



size_t format_int(char *q,size_t n,uint flags,int base,int width,int prec)

{
  char *pcVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;
  int in_a6;
  int in_a7;
  int iVar8;
  int iVar9;
  uint uVar10;
  char *pcVar11;
  int iVar12;
  char *pcStack84;
  
  if ((width & 0x80U) == 0) {
    pcStack84 = "0123456789abcdef";
  }
  else {
    pcStack84 = "0123456789ABCDEF";
  }
  uVar10 = 0;
  if (((width & 0x40U) != 0) && (base < 0)) {
    flags = -flags;
    base = -(uint)(flags != 0) - base;
    uVar10 = 1;
  }
  iVar8 = 0;
  uVar3 = flags;
  uVar7 = base;
  while ((uVar3 | uVar7) != 0) {
    __udivdi3();
    iVar8 = iVar8 + 1;
  }
  uVar3 = width & 0x20;
  if ((uVar3 == 0) || (prec != 8)) {
LAB_23051346:
    if ((in_a7 <= iVar8) && (in_a7 = iVar8, (flags | base) == 0)) {
      in_a7 = 1;
    }
  }
  else {
    if (in_a7 <= iVar8) {
      in_a7 = iVar8 + 1;
      goto LAB_23051346;
    }
  }
  iVar8 = in_a7;
  if (((width & 8U) != 0) && (iVar8 = 4, prec != 0x10)) {
    iVar8 = 3;
  }
  iVar9 = (in_a7 + -1) / iVar8 + in_a7;
  iVar2 = (uint)((width & 0x14U | uVar10) != 0) + iVar9;
  if ((uVar3 != 0) && (prec == 0x10)) {
    iVar2 = iVar2 + 2;
  }
  uVar4 = width & 3;
  uVar7 = 0;
  if ((uVar4 == 0) && (uVar7 = uVar4, iVar2 < in_a6)) {
    uVar7 = in_a6 - iVar2;
    uVar6 = 0;
    do {
      if (uVar6 < n) {
        *q = ' ';
        q = q + 1;
      }
      uVar6 = uVar6 + 1;
      in_a6 = iVar2;
    } while (uVar6 != uVar7);
  }
  if (uVar10 == 0) {
    if ((width & 4U) == 0) {
      if ((width & 0x10U) == 0) goto LAB_230513c8;
      if (uVar7 < n) {
        *q = ' ';
        q = q + 1;
      }
    }
    else {
      if (uVar7 < n) {
        *q = '+';
        q = q + 1;
      }
    }
  }
  else {
    if (uVar7 < n) {
      *q = '-';
      q = q + 1;
    }
  }
  uVar7 = uVar7 + 1;
LAB_230513c8:
  if ((uVar3 != 0) && (prec == 0x10)) {
    if (uVar7 < n) {
      *q = '0';
      q = q + 1;
    }
    if (uVar7 + 1 < n) {
      cVar5 = 'X';
      if ((width & 0x80U) == 0) {
        cVar5 = 'x';
      }
      *q = cVar5;
      q = q + 1;
    }
    uVar7 = uVar7 + 2;
  }
  if ((uVar4 == 1) && (iVar9 < in_a6)) {
    while (iVar2 < in_a6) {
      if (uVar7 < n) {
        *q = '0';
        q = q + 1;
      }
      uVar7 = uVar7 + 1;
      in_a6 = in_a6 + -1;
    }
  }
  uVar7 = iVar9 + uVar7;
  pcVar1 = q + iVar9;
  pcVar11 = pcVar1;
  uVar10 = uVar7;
  iVar12 = iVar8;
  while (0 < iVar9) {
    if (iVar12 == 0) {
      uVar10 = uVar10 - 1;
      if (uVar10 < n) {
        pcVar11[-1] = '_';
      }
      pcVar11 = pcVar11 + -1;
      iVar9 = iVar9 + -1;
      iVar12 = iVar8;
    }
    iVar12 = iVar12 + -1;
    uVar10 = uVar10 - 1;
    iVar9 = iVar9 + -1;
    if (uVar10 < n) {
      uVar3 = flags;
      __umoddi3();
      pcVar11[-1] = pcStack84[uVar3];
    }
    __udivdi3();
    pcVar11 = pcVar11 + -1;
  }
  iVar8 = in_a6 + uVar7;
  while (((width & 2U) != 0 && (iVar2 < (int)(iVar8 - uVar7)))) {
    if (uVar7 < n) {
      *pcVar1 = ' ';
      pcVar1 = pcVar1 + 1;
    }
    uVar7 = uVar7 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar7;
}



char * cvt(int ndigits,int *decpt,int *sign,char *buf,int eflag)

{
  int *piVar1;
  byte *pbVar2;
  __gcc_CMPtype _Var3;
  double *pdVar4;
  SItype SVar5;
  byte *in_a5;
  byte *pbVar6;
  int in_a6;
  byte *pbVar7;
  byte *pbVar8;
  double in_fa1;
  double *pdStack80;
  double fi;
  double fj;
  
  piVar1 = (int *)0x4e;
  if (((int)sign < 0x4f) && (piVar1 = sign, (int)sign < 0)) {
    piVar1 = (int *)0x0;
  }
  _Var3 = __ledf2();
  if (_Var3 < 0) {
    *(undefined4 *)eflag = 1;
  }
  else {
    *(undefined4 *)eflag = 0;
  }
  modf(in_fa1,(double *)ndigits);
  pbVar7 = in_a5 + 0x50;
  _Var3 = __eqdf2();
  pbVar2 = pbVar7;
  pbVar6 = in_a5;
  if (_Var3 == 0) {
    _Var3 = __gedf2();
    pbVar8 = (byte *)0x0;
    if (0 < _Var3) {
      while( true ) {
        pdVar4 = (double *)ndigits;
        __muldf3();
        _Var3 = __ledf2();
        if (-1 < _Var3) break;
        pbVar8 = pbVar8 + -1;
        ndigits = (int)pdVar4;
      }
    }
  }
  else {
    while( true ) {
      _Var3 = __eqdf2();
      pbVar8 = pbVar7 + -(int)pbVar2;
      if (_Var3 == 0) break;
      pdVar4 = pdStack80;
      __divdf3();
      modf(in_fa1,pdVar4);
      __adddf3();
      __muldf3();
      SVar5 = __fixdfsi();
      pbVar2[-1] = (char)SVar5 + 0x30;
      pbVar2 = pbVar2 + -1;
    }
    while (pbVar2 < pbVar7) {
      *pbVar6 = *pbVar2;
      pbVar6 = pbVar6 + 1;
      pbVar2 = pbVar2 + 1;
    }
  }
  pbVar2 = (byte *)((int)piVar1 + (int)in_a5);
  if (in_a6 == 0) {
    pbVar2 = pbVar2 + (int)pbVar8;
  }
  *(byte **)buf = pbVar8;
  if (pbVar2 < in_a5) {
    *in_a5 = 0;
  }
  else {
    while ((pbVar6 <= pbVar2 && (pbVar6 < pbVar7))) {
      __muldf3();
      modf(in_fa1,(double *)ndigits);
      SVar5 = __fixdfsi();
      *pbVar6 = (char)SVar5 + 0x30;
      pbVar6 = pbVar6 + 1;
    }
    if (pbVar2 < pbVar7) {
      *pbVar2 = *pbVar2 + 5;
      pbVar6 = pbVar2;
      while (0x39 < *pbVar6) {
        *pbVar6 = 0x30;
        if (in_a5 < pbVar6) {
          pbVar7 = pbVar6 + -1;
          pbVar6 = pbVar6 + -1;
          *pbVar6 = *pbVar7 + 1;
        }
        else {
          *pbVar6 = 0x31;
          *(int *)buf = *(int *)buf + 1;
          if (in_a6 == 0) {
            if (in_a5 < pbVar2) {
              *pbVar2 = 0x30;
            }
            pbVar2 = pbVar2 + 1;
          }
        }
      }
      *pbVar2 = 0;
    }
    else {
      in_a5[0x4f] = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (char *)in_a5;
}



char * ecvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar1;
}



char * fcvtbuf(int ndigits,int *decpt,int *sign,char *buf)

{
  char *pcVar1;
  int in_a4;
  
  pcVar1 = cvt(ndigits,decpt,sign,buf,in_a4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar1;
}



char * flt(char *str,int size,int precision,char fmt,int flags)

{
  bool bVar1;
  byte bVar2;
  int iVar3;
  int iVar4;
  __gcc_CMPtype _Var5;
  char *pcVar6;
  undefined *puVar7;
  size_t sVar8;
  undefined3 in_register_00002035;
  char *pcVar9;
  int *piVar10;
  uint uVar11;
  char cVar12;
  uint in_a5;
  uint uVar13;
  char *pcVar14;
  int *piVar15;
  int iVar16;
  int *piVar17;
  uint in_a6;
  char cVar18;
  char cVar19;
  char *pcVar20;
  char *pcStack232;
  int decpt;
  int sign;
  char tmp [80];
  char cvtbuf [80];
  
  iVar4 = CONCAT31(in_register_00002035,fmt);
  uVar13 = in_a6 & 0x10;
  if (uVar13 == 0) {
    cVar19 = '0';
    if ((in_a6 & 1) == 0) {
      cVar19 = ' ';
    }
  }
  else {
    in_a6 = in_a6 & 0xfffffffe;
    cVar19 = ' ';
  }
  cVar18 = '\0';
  if ((in_a6 & 2) != 0) {
    _Var5 = __ledf2();
    if (_Var5 < 0) {
      precision = precision ^ 0x80000000;
      iVar4 = iVar4 + -1;
      cVar18 = '-';
    }
    else {
      if ((in_a6 & 4) == 0) {
        if ((in_a6 & 8) != 0) {
          iVar4 = iVar4 + -1;
          cVar18 = ' ';
        }
      }
      else {
        iVar4 = iVar4 + -1;
        cVar18 = '+';
      }
    }
  }
  if (flags < 0) {
    flags = 6;
  }
  bVar1 = (in_a5 & 0xfd) != 0x45;
  uVar11 = in_a5;
  if (!bVar1) {
    uVar11 = in_a5 + 0x20 & 0xff;
  }
  if (uVar11 == 0x67) {
    ecvtbuf(size,(int *)precision,(int *)flags,(char *)&pcStack232);
    if ((-5 < (int)(pcStack232 + -1)) && ((int)(pcStack232 + -1) < flags)) {
      piVar17 = (int *)(flags - (int)pcStack232);
LAB_23051924:
      pcVar6 = fcvtbuf(size,(int *)precision,piVar17,(char *)&pcStack232);
      piVar15 = &sign;
      if (decpt != 0) {
        sign._0_1_ = 0x2d;
        piVar15 = (int *)((int)&sign + 1);
      }
      if (*pcVar6 == '\0') {
        *(char *)piVar15 = '0';
        if ((int)piVar17 < 1) {
          piVar15 = (int *)((int)piVar15 + 1);
        }
        else {
          *(char *)((int)piVar15 + 1) = '.';
          pcVar6 = (char *)((int)piVar15 + 2);
          piVar10 = (int *)((int)piVar15 + (int)piVar17);
          do {
            *(char *)((int)piVar15 + 2) = '0';
            piVar15 = (int *)((int)piVar15 + 1);
          } while (piVar10 != piVar15);
          piVar15 = (int *)(pcVar6 + (int)piVar17);
        }
      }
      else {
        pcVar20 = pcVar6;
        if ((int)pcStack232 < 1) {
          *(char *)piVar15 = '0';
          *(char *)((int)piVar15 + 1) = '.';
          piVar17 = piVar15;
          while ((int *)((int)piVar15 - (int)pcStack232) != piVar17) {
            *(char *)((int)piVar17 + 2) = '0';
            piVar17 = (int *)((int)piVar17 + 1);
          }
          piVar15 = (int *)((int)piVar15 + (2 - (int)pcStack232));
          while (cVar12 = *pcVar6, cVar12 != '\0') {
            pcVar6 = pcVar6 + 1;
            *(char *)piVar15 = cVar12;
            piVar15 = (int *)((int)piVar15 + 1);
          }
        }
        else {
          do {
            piVar17 = piVar15;
            if (pcStack232 == pcVar20 + -(int)pcVar6) {
              piVar17 = (int *)((int)piVar15 + 1);
              *(char *)piVar15 = '.';
            }
            pcVar9 = pcVar20 + 1;
            piVar15 = (int *)((int)piVar17 + 1);
            *(char *)piVar17 = *pcVar20;
            pcVar20 = pcVar9;
          } while (*pcVar9 != '\0');
        }
      }
      goto LAB_230518cc;
    }
    piVar15 = (int *)(flags + -1);
  }
  else {
    piVar15 = (int *)flags;
    if (uVar11 != 0x65) {
      piVar15 = &sign;
      piVar17 = (int *)flags;
      if (uVar11 != 0x66) goto LAB_230518cc;
      goto LAB_23051924;
    }
  }
  pcVar6 = ecvtbuf(size,(int *)precision,(int *)((int)piVar15 + 1),(char *)&pcStack232);
  piVar17 = &sign;
  if (decpt != 0) {
    sign._0_1_ = 0x2d;
    piVar17 = (int *)((int)&sign + 1);
  }
  pcVar20 = (char *)((int)piVar17 + 1);
  *(char *)piVar17 = *pcVar6;
  if (0 < (int)piVar15) {
    pcVar20 = (char *)((int)piVar17 + 2);
    *(undefined *)((int)piVar17 + 1) = 0x2e;
  }
  pcVar9 = pcVar6 + 1;
  pcVar14 = pcVar20;
  while (pcVar6 + 1 + (int)piVar15 != pcVar9) {
    *pcVar14 = *pcVar9;
    pcVar9 = pcVar9 + 1;
    pcVar14 = pcVar14 + 1;
  }
  pcVar20 = pcVar20 + (int)piVar15;
  cVar12 = 'E';
  if (bVar1) {
    cVar12 = 'e';
  }
  *pcVar20 = cVar12;
  if (pcStack232 == (char *)0x0) {
    _Var5 = __eqdf2();
    if (_Var5 != 0) {
      pcStack232 = (char *)0xffffffff;
      goto LAB_2305188a;
    }
LAB_230519b0:
    cVar12 = '+';
  }
  else {
    pcStack232 = pcStack232 + -1;
    if (-1 < (int)pcStack232) goto LAB_230519b0;
LAB_2305188a:
    pcStack232 = (char *)-(int)pcStack232;
    cVar12 = '-';
  }
  pcVar20[1] = cVar12;
  pcVar20[4] = (char)((int)pcStack232 % 10) + '0';
  pcVar20[2] = (char)(((int)pcStack232 / 100) % 10) + '0';
  pcVar20[3] = (char)(((int)pcStack232 / 10) % 10) + '0';
  piVar15 = (int *)(pcVar20 + 5);
LAB_230518cc:
  *(char *)piVar15 = '\0';
  if ((in_a6 & 0x20) == 0) {
    if (in_a5 == 0x67) {
      piVar15 = &sign;
      do {
        bVar2 = *(byte *)piVar15;
        piVar15 = (int *)((int)piVar15 + 1);
        if (bVar2 == 0) goto LAB_23051a64;
      } while (bVar2 != 0x2e);
      while ((piVar17 = piVar15, *(byte *)piVar15 != 0 && ((*(byte *)piVar15 & 0xdf) != 0x45))) {
        piVar15 = (int *)((int)piVar15 + 1);
      }
      do {
        piVar10 = piVar17;
        piVar17 = (int *)((int)piVar10 + -1);
      } while (*(byte *)piVar17 == 0x30);
      if (*(byte *)piVar17 == 0x2e) {
        piVar17 = (int *)((int)piVar10 + -2);
      }
      while (piVar15 != piVar17) {
        piVar17 = (int *)((int)piVar17 + 1);
        *(byte *)piVar17 = 0;
      }
    }
  }
  else {
    if ((int *)flags == (int *)0x0) {
      piVar15 = &sign;
      while (bVar2 = *(byte *)piVar15, bVar2 != 0) {
        if (bVar2 == 0x2e) goto LAB_23051a64;
        if ((bVar2 & 0xdf) == 0x45) {
          sVar8 = strnlen((char *)piVar15,0x100);
          puVar7 = (undefined *)(sVar8 + (int)piVar15);
          while (0 < (int)(puVar7 + -(int)piVar15)) {
            puVar7[1] = *puVar7;
            puVar7 = puVar7 + -1;
          }
          *(byte *)piVar15 = 0x2e;
          goto LAB_23051a64;
        }
        piVar15 = (int *)((int)piVar15 + 1);
      }
      *(byte *)piVar15 = 0x2e;
      *(byte *)((int)piVar15 + 1) = 0;
    }
  }
LAB_23051a64:
  sVar8 = strnlen((char *)&sign,0x100);
  iVar4 = iVar4 - sVar8;
  pcVar6 = str;
  if ((in_a6 & 0x11) == 0) {
    while (0 < (int)(str + (iVar4 - (int)pcVar6))) {
      *pcVar6 = ' ';
      pcVar6 = pcVar6 + 1;
    }
    iVar16 = iVar4;
    if (iVar4 < 0) {
      iVar16 = 0;
    }
    str = str + iVar16;
    iVar4 = (iVar4 + -1) - iVar16;
  }
  if (cVar18 != '\0') {
    *str = cVar18;
    str = str + 1;
  }
  pcVar6 = str;
  if (uVar13 == 0) {
    while (0 < (int)(str + (iVar4 - (int)pcVar6))) {
      *pcVar6 = cVar19;
      pcVar6 = pcVar6 + 1;
    }
    iVar16 = iVar4;
    if (iVar4 < 0) {
      iVar16 = 0;
    }
    str = str + iVar16;
    iVar4 = (iVar4 + -1) - iVar16;
  }
  iVar16 = 0;
  while (iVar16 < (int)sVar8) {
    iVar3 = iVar16 + -4;
    pcVar6 = str + iVar16;
    iVar16 = iVar16 + 1;
    *pcVar6 = tmp[iVar3];
  }
  if ((int)sVar8 < 0) {
    sVar8 = 0;
  }
  pcVar20 = str + sVar8;
  pcVar6 = pcVar20;
  while (0 < (int)(pcVar20 + (iVar4 - (int)pcVar6))) {
    *pcVar6 = ' ';
    pcVar6 = pcVar6 + 1;
  }
  if (iVar4 < 0) {
    iVar4 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar20 + iVar4;
}



int vsnprintf(char *buffer,size_t n,char *format,va_list ap)

{
  char *pcVar1;
  size_t sVar2;
  byte *pbVar3;
  int *piVar4;
  undefined4 uVar5;
  char *pcVar6;
  byte bVar7;
  uint uVar8;
  int prec;
  char **ppcVar9;
  char *pcVar10;
  char *pcVar11;
  int iVar12;
  uint width;
  char *pcVar13;
  byte *str;
  char *pcVar14;
  char *pcStack104;
  char *pcStack100;
  char *pcStack88;
  char acStack65 [4];
  char carg;
  
  uVar5 = 0;
  width = 0;
  pcVar13 = (char *)0xffffffff;
  iVar12 = 0;
  pcStack104 = (char *)0x0;
  pcStack100 = (char *)0x0;
  pcVar6 = (char *)0x0;
  str = (byte *)buffer;
  pcVar14 = (char *)0x0;
switchD_23051c14_caseD_5:
  do {
    pbVar3 = (byte *)format;
    format = (char *)(pbVar3 + 1);
    bVar7 = *pbVar3;
    uVar8 = (uint)bVar7;
    if (uVar8 == 0) {
      if (pcVar6 < n) {
        *str = 0;
      }
      else {
        if (n != 0) {
          buffer[n - 1] = '\0';
        }
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (int)pcVar6;
    }
    switch(uVar5) {
    case 0:
      if (uVar8 == 0x25) {
        uVar5 = 1;
        width = 0;
        pcVar13 = (char *)0xffffffff;
        iVar12 = 0;
        pcVar14 = (char *)0x0;
      }
      else {
        if (pcVar6 < n) {
          *str = bVar7;
          str = str + 1;
        }
        pcVar6 = pcVar6 + 1;
      }
      break;
    case 1:
      switch(uVar8 - 0x20 & 0xff) {
      case 0:
        width = width | 0x10;
        break;
      default:
        uVar5 = 2;
        format = (char *)pbVar3;
        break;
      case 3:
        width = width | 0x20;
        break;
      case 7:
        width = width | 8;
        break;
      case 0xb:
        width = width | 4;
        break;
      case 0xd:
        width = width | 2;
        break;
      case 0x10:
        width = width | 1;
      }
      break;
    case 2:
      if ((uVar8 - 0x30 & 0xff) < 10) {
        pcVar14 = (char *)((int)pcVar14 * 10 + (uVar8 - 0x30));
      }
      else {
        if (uVar8 == 0x2a) {
          ppcVar9 = (char **)((int)ap + 4);
                    // WARNING: Load size is inaccurate
          pcVar14 = *ap;
          ap = ppcVar9;
          if ((int)pcVar14 < 0) {
            width = width | 2;
            pcVar14 = (char *)-(int)pcVar14;
          }
        }
        else {
          if (uVar8 == 0x2e) {
            uVar5 = 3;
            pcVar13 = (char *)0x0;
          }
          else {
            uVar5 = 4;
            format = (char *)pbVar3;
          }
        }
      }
      break;
    case 3:
      if ((uVar8 - 0x30 & 0xff) < 10) {
        pcVar13 = (char *)((int)pcVar13 * 10 + (uVar8 - 0x30));
      }
      else {
        if (uVar8 == 0x2a) {
          ppcVar9 = (char **)((int)ap + 4);
                    // WARNING: Load size is inaccurate
          pcVar13 = *ap;
          ap = ppcVar9;
          if ((int)pcVar13 < 0) {
            pcVar13 = (char *)0xffffffff;
          }
        }
        else {
          uVar5 = 4;
          format = (char *)pbVar3;
        }
      }
      break;
    case 4:
      switch(uVar8 - 0x4c & 0xff) {
      case 0:
      case 0x25:
        iVar12 = iVar12 + 2;
        break;
      default:
        if (2 < iVar12) {
          iVar12 = 2;
        }
        if (iVar12 < -2) {
          iVar12 = -2;
        }
        switch(uVar8 - 0x50 & 0xff) {
        case 0:
          width = width | 0x80;
        case 0x20:
          width = width | 0x20;
                    // WARNING: Load size is inaccurate
          pcStack104 = *ap;
          pcStack100 = (char *)0x0;
          ap = (va_list)((int)ap + 4);
          prec = 0x10;
          pcVar13 = &DAT_00000008;
          goto is_integer;
        default:
          if (pcVar6 < n) {
            *str = bVar7;
            str = str + 1;
          }
          uVar5 = 0;
          pcVar6 = pcVar6 + 1;
          goto switchD_23051c14_caseD_5;
        case 8:
          width = width | 0x80;
          prec = 0x10;
          break;
        case 0x13:
                    // WARNING: Load size is inaccurate
          acStack65[0] = (char)*ap;
          pcVar1 = (char *)0x1;
          pcStack88 = acStack65;
          goto is_string;
        case 0x14:
        case 0x19:
          width = width | 0x40;
                    // WARNING: Could not find normalized switch variable to match jumptable
          switch(iVar12) {
          case 0:
                    // WARNING: Load size is inaccurate
            pcStack104 = *ap;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            ap = (va_list)((int)ap + 4);
            prec = 10;
            break;
          case 2:
            ppcVar9 = (char **)((int)ap + 7U & 0xfffffff8);
            ap = ppcVar9 + 2;
            pcStack104 = *ppcVar9;
            pcStack100 = ppcVar9[1];
            prec = 10;
            break;
          default:
            prec = 10;
            break;
          case -2:
                    // WARNING: Load size is inaccurate
            pcStack104 = (char *)(int)*ap;
            pcStack100 = (char *)((int)pcStack104 >> 0x1f);
            ap = (va_list)((int)ap + 4);
            prec = 10;
          }
          goto is_integer;
        case 0x16:
          piVar4 = (int *)((int)ap + 7U & 0xfffffff8);
          str = (byte *)flt((char *)str,*piVar4,piVar4[1],(char)pcVar14,(int)pcVar13);
          uVar5 = 0;
          ap = piVar4 + 2;
          goto switchD_23051c14_caseD_5;
        case 0x1e:
          if (iVar12 + 2U < 5) {
                    // WARNING: Could not recover jumptable at 0x23051f80. Too many branches
                    // WARNING: Treating indirect jump as call
            pcVar13 = (char *)(*(code *)(&PTR_LAB_230885a4)[iVar12 + 2U])
                                        ((&PTR_LAB_230885a4)[iVar12 + 2U]);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return (int)pcVar13;
          }
          uVar5 = 0;
          goto switchD_23051c14_caseD_5;
        case 0x1f:
          prec = 8;
          break;
        case 0x23:
                    // WARNING: Load size is inaccurate
          pcStack88 = *ap;
          if (pcStack88 == (char *)0x0) {
            pcStack88 = "(null)";
          }
          pcVar1 = (char *)strlen(pcStack88);
is_string:
          ap = (va_list)((int)ap + 4);
          if ((pcVar13 != (char *)0xffffffff) && ((int)pcVar13 < (int)pcVar1)) {
            pcVar1 = pcVar13;
          }
          pcVar10 = pcVar6;
          if (((int)pcVar1 < (int)pcVar14) && ((width & 2) == 0)) {
            if ((width & 1) == 0) {
              bVar7 = 0x20;
            }
            else {
              bVar7 = 0x30;
            }
            pcVar10 = pcVar14 + (int)(pcVar6 + -(int)pcVar1);
            do {
              if (pcVar6 < n) {
                *str = bVar7;
                str = str + 1;
              }
              pcVar6 = pcVar6 + 1;
              pcVar14 = pcVar1;
            } while (pcVar6 != pcVar10);
          }
          pcVar6 = pcVar10;
          if (pcVar1 != (char *)0x0) {
            pcVar11 = pcVar10;
            do {
              if (pcVar11 < n) {
                *str = pcStack88[(int)(pcVar11 + -(int)pcVar10)];
                str = str + 1;
              }
              pcVar11 = pcVar11 + 1;
              pcVar6 = pcVar1 + (int)pcVar10;
            } while (pcVar11 != pcVar1 + (int)pcVar10);
          }
          if ((int)pcVar1 < (int)pcVar14) {
            if ((width & 2) == 0) {
              uVar5 = 0;
            }
            else {
              pcVar10 = pcVar6 + -(int)pcVar1;
              do {
                if (pcVar6 < n) {
                  *str = 0x20;
                  str = str + 1;
                }
                pcVar6 = pcVar6 + 1;
              } while (pcVar6 != pcVar14 + (int)pcVar10);
              uVar5 = 0;
              pcVar6 = pcVar14 + (int)pcVar10;
              pcVar14 = pcVar1;
            }
          }
          else {
            uVar5 = 0;
          }
          goto switchD_23051c14_caseD_5;
        case 0x25:
          prec = 10;
          break;
        case 0x28:
          prec = 0x10;
        }
                    // WARNING: Could not find normalized switch variable to match jumptable
        switch(iVar12) {
        case 0:
                    // WARNING: Load size is inaccurate
          pcStack104 = *ap;
          pcStack100 = (char *)0x0;
          ap = (va_list)((int)ap + 4);
          break;
        case 2:
          ppcVar9 = (char **)((int)ap + 7U & 0xfffffff8);
          ap = ppcVar9 + 2;
          pcStack104 = *ppcVar9;
          pcStack100 = ppcVar9[1];
          break;
        case -2:
                    // WARNING: Load size is inaccurate
          pcStack104 = (char *)(uint)*ap;
          pcStack100 = (char *)0x0;
          ap = (va_list)((int)ap + 4);
        }
is_integer:
        if (pcVar6 < n) {
          sVar2 = n - (int)pcVar6;
        }
        else {
          sVar2 = 0;
        }
        sVar2 = format_int((char *)str,sVar2,(uint)pcStack104,(int)pcStack100,width,prec);
        str = str + sVar2;
        uVar5 = 0;
        pcVar6 = pcVar6 + sVar2;
        break;
      case 0x1c:
        iVar12 = iVar12 + -1;
        break;
      case 0x1e:
        iVar12 = 2;
        break;
      case 0x20:
        iVar12 = iVar12 + 1;
        break;
      case 0x28:
      case 0x2e:
        iVar12 = 1;
      }
    }
  } while( true );
}



int vsprintf(char *buffer,char *format,va_list ap)

{
  int iVar1;
  
  iVar1 = vsnprintf(buffer,0x1e0,format,ap);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void vprint(char *fmt,va_list argp)

{
  uint8_t *puVar1;
  int iVar2;
  
  if (sys_log_all_enable == false) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  iVar2 = vsprintf(string,fmt,argp);
  puVar1 = (uint8_t *)string;
  if (0 < iVar2) {
    while( true ) {
      if (*puVar1 == '\0') break;
      bl_uart_data_send('\0',*puVar1);
      puVar1 = puVar1 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bl_putchar(int c)

{
  bl_uart_data_send('\0',(uint8_t)c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int puts(char *s)

{
  int iVar1;
  
  iVar1 = 0;
  if (sys_log_all_enable != false) {
    iVar1 = 0;
    while (s[iVar1] != '\0') {
      bl_uart_data_send('\0',s[iVar1]);
      iVar1 = iVar1 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int printf(char *fmt,...)

{
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list argp;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (sys_log_all_enable != false) {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vprint(fmt,&uStack28);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int sprintf(char *buffer,char *format,...)

{
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(buffer,0xffffffff,format,&uStack24);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int snprintf(char *buffer,size_t n,char *format,...)

{
  int iVar1;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsnprintf(buffer,n,format,&uStack20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int sscanf(char *str,char *format,...)

{
  int iVar1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  uStack24 = in_a2;
  uStack20 = in_a3;
  uStack16 = in_a4;
  uStack12 = in_a5;
  uStack8 = in_a6;
  uStack4 = in_a7;
  iVar1 = vsscanf(str,format,&uStack24);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void set_bit(ulong *bitmap,uint bit)

{
  bitmap[bit >> 5] = bitmap[bit >> 5] | 1 << (bit & 0x1f);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int vsscanf(char *buffer,char *format,va_list ap)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  size_t sVar4;
  uint uVar5;
  uint uVar6;
  byte *pbVar7;
  int base;
  uint uVar8;
  byte **ppbVar9;
  byte **ppbVar10;
  uint bit;
  int iVar11;
  byte *nptr;
  byte *pbVar12;
  size_t n;
  byte *pbVar13;
  int iVar14;
  uint uVar15;
  uint uStack132;
  uint uStack128;
  byte *pbStack100;
  char *qq;
  ulong matchmap [8];
  
  uStack128 = 0;
  uStack132 = 0;
  iVar14 = 0;
  pbVar13 = (byte *)0x0;
  bVar2 = false;
  bVar3 = false;
  iVar11 = 0;
  uVar5 = 0;
  pbVar12 = (byte *)buffer;
  n = 0xffffffff;
  uVar15 = 0;
switchD_23052248_caseD_7:
  nptr = pbVar12;
  pbVar7 = (byte *)format;
  uVar8 = uVar5;
  uVar6 = (uint)*pbVar7;
  format = (char *)(pbVar7 + 1);
  if ((uVar6 == 0) || (uVar15 != 0)) {
    if ((uVar15 == 1) && (iVar14 == 0)) {
      iVar14 = -1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar14;
  }
  uVar5 = uVar8;
  pbVar12 = nptr;
  switch(uVar8) {
  case 0:
    if (uVar6 == 0x25) {
      bVar2 = false;
      bVar3 = false;
      iVar11 = 0;
      uVar5 = 1;
      n = 0xffffffff;
      uVar15 = uVar8;
      goto switchD_23052248_caseD_7;
    }
    uVar5 = (byte)_ctype_[uVar6 + 1] & 8;
    if ((_ctype_[uVar6 + 1] & 8) == 0) {
      uVar15 = 2;
      if (*nptr != uVar6) goto switchD_23052248_caseD_7;
      nptr = nptr + 1;
    }
    else {
      while (uVar5 = (byte)_ctype_[*nptr + 1] & 8, (_ctype_[*nptr + 1] & 8) != 0) {
        nptr = nptr + 1;
      }
    }
    pbVar12 = nptr;
    uVar15 = 0;
    goto switchD_23052248_caseD_7;
  case 1:
    if (uVar6 == 0x2a) {
      bVar3 = true;
      goto switchD_23052248_caseD_7;
    }
    if ((0x29 < uVar6) && ((uVar6 - 0x30 & 0xff) < 10)) {
      bVar2 = true;
      uVar5 = 2;
      n = uVar6 - 0x30;
      goto switchD_23052248_caseD_7;
    }
    break;
  case 2:
    if ((uVar6 - 0x30 & 0xff) < 10) {
      n = n * 10 + -0x30 + uVar6;
      goto switchD_23052248_caseD_7;
    }
    break;
  case 3:
    if (uVar6 == 0x6c) {
      iVar11 = iVar11 + 1;
    }
    else {
      if (0x6c < uVar6) {
        if ((uVar6 == 0x74) || (uVar6 == 0x7a)) {
          iVar11 = 1;
          goto switchD_23052248_caseD_7;
        }
        uVar8 = 0x71;
LAB_230522f0:
        if (uVar6 == uVar8) goto LAB_230522f4;
        if (2 < iVar11) {
          iVar11 = 2;
        }
        if (iVar11 < -2) {
          iVar11 = -2;
        }
        if (uVar6 == 0x69) {
          base = 0;
LAB_230523aa:
          while (uVar8 = (uint)*nptr, (_ctype_[uVar8 + 1] & 8) != 0) {
            nptr = nptr + 1;
          }
          pbVar12 = nptr;
          if (uVar8 == 0) goto LAB_230525ca;
          ppbVar9 = &pbStack100;
          pbVar7 = nptr;
          strntoumax((char *)nptr,(char **)ppbVar9,base,n);
          if (pbStack100 == nptr) goto LAB_2305234e;
          nptr = pbStack100;
          if (!bVar3) {
            iVar14 = iVar14 + 1;
          }
set_integer:
          uVar5 = 0;
          pbVar12 = nptr;
          if (!bVar3) {
            if (iVar11 == 0) {
                    // WARNING: Load size is inaccurate
              ppbVar9 = *ap;
              ap = (va_list)((int)ap + 4);
              *ppbVar9 = pbVar7;
LAB_230524ba:
              uVar5 = 0;
              pbVar12 = nptr;
              goto switchD_23052248_caseD_7;
            }
            if (iVar11 < 1) {
              if (iVar11 == -2) {
                    // WARNING: Load size is inaccurate
                **ap = (byte)pbVar7;
              }
              else {
                if (iVar11 != -1) goto switchD_23052248_caseD_7;
                    // WARNING: Load size is inaccurate
                **ap = (short)pbVar7;
              }
            }
            else {
              if (iVar11 == 2) {
                    // WARNING: Load size is inaccurate
                ppbVar10 = *ap;
                *ppbVar10 = pbVar7;
                ppbVar10[1] = (byte *)ppbVar9;
              }
              else {
                if ((1 < iVar11) && (iVar11 != 0x7fffffff)) goto switchD_23052248_caseD_7;
                    // WARNING: Load size is inaccurate
                **ap = pbVar7;
              }
            }
            ap = (va_list)((int)ap + 4);
          }
          goto switchD_23052248_caseD_7;
        }
        if (uVar6 < 0x6a) {
          if (uVar6 == 0x58) {
scan_int:
            base = 0x10;
            goto LAB_230523aa;
          }
          if (0x58 < uVar6) {
            if (uVar6 == 99) {
              if (!bVar2) {
                n = 1;
              }
              sVar4 = n - 1;
              if (!bVar3) {
                    // WARNING: Load size is inaccurate
                pbVar13 = *ap;
                ap = (va_list)((int)ap + 4);
                n = n - 1;
                while (n != 0xffffffff) {
                  bVar1 = *nptr;
                  uVar8 = (uint)bVar1;
                  pbVar12 = nptr;
                  if (uVar8 == 0) goto LAB_230525ca;
                  nptr = nptr + 1;
                  *pbVar13 = bVar1;
                  n = n - 1;
                  pbVar13 = pbVar13 + 1;
                }
                iVar14 = iVar14 + 1;
                goto LAB_230524ba;
              }
              do {
                n = sVar4;
                if (n == 0xffffffff) goto LAB_230524ba;
                uVar8 = (uint)*nptr;
                sVar4 = n - 1;
              } while (uVar8 != 0);
              goto LAB_230525ca;
            }
            if (uVar6 == 100) goto LAB_2305247c;
            if (uVar6 != 0x5b) goto LAB_2305234e;
            pbVar13 = (byte *)0x0;
            if (!bVar3) {
                    // WARNING: Load size is inaccurate
              pbVar13 = *ap;
              ap = (va_list)((int)ap + 4);
            }
            memset(&qq,0,0x20);
            uStack132 = 0;
            uVar5 = 4;
            goto switchD_23052248_caseD_7;
          }
          if (uVar6 == 0x25) {
            if (*nptr == 0x25) {
              nptr = nptr + 1;
              goto LAB_230524ba;
            }
          }
          else {
            if (uVar6 == 0x50) goto LAB_23052470;
          }
        }
        else {
          if (uVar6 == 0x70) {
LAB_23052470:
            base = 0;
            iVar11 = 0x7fffffff;
            goto LAB_230523aa;
          }
          if (uVar6 < 0x71) {
            if (uVar6 == 0x6e) {
              pbVar7 = nptr + -(int)buffer;
              ppbVar9 = (byte **)((int)pbVar7 >> 0x1f);
              goto set_integer;
            }
            base = 8;
            if (uVar6 == 0x6f) goto LAB_230523aa;
          }
          else {
            if (uVar6 == 0x75) {
LAB_2305247c:
              base = 10;
              goto LAB_230523aa;
            }
            if (uVar6 == 0x78) goto scan_int;
            if (uVar6 == 0x73) {
              n = n - 1;
              if (bVar3) {
                while (n != 0xffffffff) {
                  uVar8 = (uint)*nptr;
                  pbVar12 = nptr;
                  if (uVar8 == 0) goto LAB_230525ca;
                  if ((_ctype_[uVar8 + 1] & 8) != 0) break;
                  nptr = nptr + 1;
                  n = n - 1;
                }
                goto LAB_230524ba;
              }
                    // WARNING: Load size is inaccurate
              pbVar13 = *ap;
              ap = (va_list)((int)ap + 4);
              uVar15 = 1;
              pbVar12 = pbVar13;
              while (n != 0xffffffff) {
                uVar15 = (uint)*nptr;
                if ((uVar15 == 0) || ((_ctype_[uVar15 + 1] & 8) != 0)) break;
                *pbVar12 = *nptr;
                nptr = nptr + 1;
                pbVar12 = pbVar12 + 1;
                n = n - 1;
              }
              if (pbVar12 != pbVar13) {
                *pbVar12 = 0;
                iVar14 = iVar14 + 1;
              }
              uVar15 = (uint)(uVar15 == 0);
              uVar5 = 0;
              pbVar12 = nptr;
              goto switchD_23052248_caseD_7;
            }
          }
        }
LAB_2305234e:
        uVar15 = 2;
        uVar5 = 0;
        pbVar12 = nptr;
        goto switchD_23052248_caseD_7;
      }
      if (uVar6 == 0x68) {
        iVar11 = iVar11 + -1;
      }
      else {
        if (uVar6 != 0x6a) {
          uVar8 = 0x4c;
          goto LAB_230522f0;
        }
LAB_230522f4:
        iVar11 = 2;
      }
    }
    goto switchD_23052248_caseD_7;
  case 4:
    if (uVar6 != 0x5e) {
      set_bit((ulong *)&qq,uVar6);
      goto LAB_2305255e;
    }
    uStack132 = 1;
    goto switchD_23052248_caseD_7;
  case 5:
    if (uVar6 == 0x5d) {
match_run:
      uVar6 = 1;
      while (n != 0) {
        bVar1 = *pbVar12;
        uVar6 = (uint)bVar1;
        if ((uVar6 == 0) || (uStack132 == ((uint)(&qq)[bVar1 >> 5] >> (uVar6 & 0x1f) & 1))) break;
        if (pbVar13 != (byte *)0x0) {
          *pbVar13 = bVar1;
          pbVar13 = pbVar13 + 1;
        }
        pbVar12 = pbVar12 + 1;
      }
      if ((nptr == pbVar12) || (pbVar13 == (byte *)0x0)) {
        uVar15 = 2;
      }
      else {
        *pbVar13 = 0;
        iVar14 = iVar14 + 1;
      }
      pbStack100 = nptr;
      if (uVar6 == 0) {
LAB_230525ca:
        uVar15 = 1;
        uVar5 = uVar8;
      }
    }
    else {
      if (uVar6 == 0x2d) {
        uStack128 = 0x2d;
        uVar5 = 6;
      }
      else {
        set_bit((ulong *)&qq,uVar6);
      }
    }
    goto switchD_23052248_caseD_7;
  case 6:
    bit = uStack128;
    if (uVar6 == 0x5d) goto match_run;
    while ((int)bit < (int)uVar6) {
      set_bit((ulong *)&qq,bit);
      bit = bit + 1;
    }
LAB_2305255e:
    uVar5 = 5;
  default:
    goto switchD_23052248_caseD_7;
  }
  uVar5 = 3;
  format = (char *)pbVar7;
  goto switchD_23052248_caseD_7;
}



uintmax_t strntoumax(char *nptr,char **endptr,int base,size_t n)

{
  byte *pbVar1;
  uint uVar2;
  uint uVar3;
  uintmax_t in_fa0;
  
  while (n != 0) {
    if ((_ctype_[(byte)*nptr + 1] & 8) == 0) {
      if (((byte)*nptr - 0x2b & 0xfd) == 0) {
        nptr = (char *)((byte *)nptr + 1);
        n = n - 1;
      }
      if (base != 0) {
        if ((((base == 0x10) && (1 < n)) && (*nptr == 0x30)) && ((((byte *)nptr)[1] & 0xdf) == 0x58)
           ) {
          n = n - 2;
          nptr = (char *)((byte *)nptr + 2);
        }
        goto LAB_2305267a;
      }
      if (n < 2) {
        if (n == 0) goto joined_r0x23052722;
        if (*nptr != 0x30) {
          n = 1;
          base = 10;
          goto LAB_2305267a;
        }
      }
      else {
        base = 10;
        if (*nptr != 0x30) goto LAB_2305267a;
        if ((((byte *)nptr)[1] & 0xdf) == 0x58) {
          n = n - 2;
          nptr = (char *)((byte *)nptr + 2);
          base = 0x10;
          goto LAB_2305267a;
        }
      }
      n = n - 1;
      nptr = (char *)((byte *)nptr + 1);
      base = 8;
      goto LAB_2305267a;
    }
    nptr = (char *)((byte *)nptr + 1);
    n = n - 1;
  }
  if (base != 0) {
LAB_2305267a:
    pbVar1 = (byte *)nptr + n;
    while ((byte *)nptr != pbVar1) {
      uVar3 = (uint)(byte)*nptr;
      uVar2 = uVar3 - 0x30;
      if (9 < uVar2) {
        if (uVar3 - 0x41 < 0x1a) {
          uVar2 = uVar3 - 0x37;
        }
        else {
          if (0x19 < uVar3 - 0x61) break;
          uVar2 = uVar3 - 0x57;
        }
      }
      if (((int)uVar2 < 0) || (base <= (int)uVar2)) break;
      nptr = (char *)((byte *)nptr + 1);
    }
  }
joined_r0x23052722:
  if (endptr != (char **)0x0) {
    *endptr = nptr;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



BL_Err_Type UART_Init(UART_ID_Type uartId,UART_CFG_Type *uartCfg)

{
  UART_Parity_Type UVar1;
  undefined3 in_register_00002029;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  puVar2 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  uVar5 = uartCfg->uartClk / uartCfg->baudRate;
  if (4 < ((uartCfg->uartClk * 10) / uartCfg->baudRate) % 10) {
    uVar5 = uVar5 + 1;
  }
  puVar2[2] = uVar5 - 1 & 0xffff | (uVar5 - 1) * 0x10000;
  UVar1 = uartCfg->parity;
  uVar5 = *puVar2;
  uVar6 = puVar2[1];
  if (UVar1 == UART_PARITY_ODD) {
    uVar5 = uVar5 | 0x30;
    uVar6 = uVar6 | 0x30;
  }
  else {
    if (UVar1 == UART_PARITY_NONE) {
      uVar5 = uVar5 & 0xffffffef;
      uVar6 = uVar6 & 0xffffffef;
    }
    else {
      if (UVar1 == UART_PARITY_EVEN) {
        uVar5 = uVar5 & 0xffffffdf | 0x10;
        uVar6 = uVar6 & 0xffffffdf | 0x10;
      }
    }
  }
  uVar3 = (uartCfg->dataBits + 4) * 0x100;
  uVar4 = uVar5 & 0xfffff8ff | uVar3;
  uVar3 = uVar6 & 0xfffff8ff | uVar3;
  uVar5 = (uartCfg->stopBits + 1) * 0x1000;
  uVar6 = uVar4 & 0xffffcffd | uVar5;
  if (uartCfg->ctsFlowControl == ENABLE) {
    uVar6 = uVar4 & 0xffffcfff | uVar5 | 2;
  }
  if (uartCfg->rxDeglitch == ENABLE) {
    uVar3 = uVar3 | 0x800;
  }
  else {
    uVar3 = uVar3 & 0xfffff7ff;
  }
  uVar5 = uVar3 & 0xfffffffd;
  if (uartCfg->rtsSoftwareControl == ENABLE) {
    uVar5 = uVar3 | 2;
  }
  *puVar2 = uVar6;
  puVar2[1] = uVar5;
  uVar5 = puVar2[3] & 0xfffffffe;
  if (uartCfg->byteBitInverse == UART_MSB_FIRST) {
    uVar5 = puVar2[3] | 1;
  }
  puVar2[3] = uVar5;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_FifoConfig(UART_ID_Type uartId,UART_FifoCfg_Type *fifoCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  *(uint *)(uVar1 + 0x84) =
       ((fifoCfg->txFifoDmaThreshold - 1) * 0x10000 | *(uint *)(uVar1 + 0x84) & 0xffe0ffff) &
       0xe0ffffff | (fifoCfg->rxFifoDmaThreshold - 1) * 0x1000000;
  uVar3 = *(uint *)(uVar1 + 0x80) & 0xfffffffe;
  if (fifoCfg->txFifoDmaEnable == ENABLE) {
    uVar3 = *(uint *)(uVar1 + 0x80) | 1;
  }
  uVar2 = uVar3 & 0xfffffffd;
  if (fifoCfg->rxFifoDmaEnable == ENABLE) {
    uVar2 = uVar3 | 2;
  }
  *(uint *)(uVar1 + 0x80) = uVar2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_Enable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 | 1;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] | 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_Disable(UART_ID_Type uartId,UART_Direction_Type direct)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if ((direct & ~UART_TXRX) == UART_TX) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((byte)(direct + ~UART_TX) < 2) {
    puVar1[1] = puVar1[1] & 0xfffffffe;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_SetRxTimeoutValue(UART_ID_Type uartId,uint8_t time)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) =
       CONCAT31(in_register_0000202d,time) - 1U |
       *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x18) & 0xffffff00;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_TxFreeRun(UART_ID_Type uartId,BL_Fun_Type txFreeRun)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  
  uVar1 = *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)];
  if (CONCAT31(in_register_0000202d,txFreeRun) == 1) {
    uVar1 = uVar1 | 4;
  }
  else {
    uVar1 = uVar1 & 0xfffffffb;
  }
  *(uint *)uartAddr[CONCAT31(in_register_00002029,uartId)] = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



BL_Err_Type UART_IntMask(UART_ID_Type uartId,UART_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined3 in_register_00002031;
  uint uVar2;
  
  uVar2 = *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24);
  if (CONCAT31(in_register_0000202d,intType) == 8) {
    uVar1 = 0;
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar2 | 0xff;
    }
  }
  else {
    uVar1 = 1 << (intType & 0x1f);
    if (CONCAT31(in_register_00002031,intMask) == 1) {
      uVar1 = uVar1 | uVar2;
    }
    else {
      uVar1 = ~uVar1 & uVar2;
    }
  }
  *(uint *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x24) = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



uint8_t UART_GetTxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)((byte)*(undefined4 *)(uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) &
                  0x3f);
}



BL_Err_Type UART_SendData(UART_ID_Type uartId,uint8_t *data,uint32_t len)

{
  int iVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint8_t *puVar4;
  uint32_t uVar5;
  
  uVar5 = uartAddr[CONCAT31(in_register_00002029,uartId)];
  iVar1 = 160000;
  uVar2 = 0;
  do {
    while( true ) {
      if (len <= uVar2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return SUCCESS;
      }
      uVar3 = UART_GetTxFifoCount(uartId);
      if (CONCAT31(extraout_var,uVar3) == 0) break;
      puVar4 = data + uVar2;
      uVar2 = uVar2 + 1;
      iVar1 = 160000;
      *(uint8_t *)(uVar5 + 0x88) = *puVar4;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TIMEOUT;
}



uint8_t UART_GetRxFifoCount(UART_ID_Type uartId)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)((byte)((uint)*(undefined4 *)
                                 (uartAddr[CONCAT31(in_register_00002029,uartId)] + 0x84) >> 8) &
                  0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Reset(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffb;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Enable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c = _DAT_4000f90c | 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Disable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffe;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Channel_Config(ADC_Chan_Type posCh,ADC_Chan_Type negCh,BL_Fun_Type contEn)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c =
       CONCAT31(in_register_00002029,posCh) << 8 | _DAT_4000f90c & 0xffffe007 |
       CONCAT31(in_register_0000202d,negCh) << 3;
  _DAT_4000f910 =
       (CONCAT31(in_register_00002031,contEn) << 1 | _DAT_4000f910 & 0xfffffffd) & 0xfdffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Start(void)

{
  _DAT_4000f90c = _DAT_4000f90c & 0xfffffffd;
  BL602_Delay_US(100);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c = _DAT_4000f90c | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_FIFO_Cfg(ADC_FIFO_Cfg_Type *fifoCfg)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40002000 =
       (uint)fifoCfg->fifoThreshold << 0x16 | _DAT_40002000 & 0xff3ffffe | (uint)fifoCfg->dmaEn | 2;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t ADC_Get_FIFO_Count(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)((byte)((uint)_DAT_40002000 >> 0x10) & 0x3f);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Parse_Result(uint32_t *orgVal,uint32_t len,ADC_Result_Type *result)

{
  uint uVar1;
  uint uVar2;
  SFtype SVar3;
  uint32_t *puVar4;
  uint uVar5;
  uint uVar6;
  uint32_t *puVar7;
  float fVar8;
  DFtype DVar9;
  
  uVar1 = _DAT_4000f910 >> 2 & 7;
  uVar5 = _DAT_4000f914 >> 2 & 1;
  if (uVar5 == 0) {
    puVar4 = orgVal + len;
    puVar7 = orgVal;
    while (puVar4 != puVar7) {
      uVar5 = *puVar7;
      result->negChan = -1;
      result->posChan = (int8_t)(uVar5 >> 0x15);
      if (uVar1 == 0) {
        uVar5 = *puVar7;
        result->value = (ushort)(uVar5 >> 4) & 0xfff;
        SVar3 = (SFtype)(uVar5 >> 4 & 0xfff);
        __floatsidf((SItype)SVar3);
LAB_23052d30:
        __muldf3();
        __extendsfdf2(SVar3);
        DVar9 = __muldf3();
        fVar8 = SUB84(DVar9,0);
        orgVal = (uint32_t *)__truncdfsf2();
        result->volt = fVar8;
      }
      else {
        if (uVar1 == 1) {
          result->value = (uint16_t)orgVal;
          SVar3 = (SFtype)((uint)orgVal & 0xffff);
          __floatsidf((SItype)SVar3);
          goto LAB_23052d30;
        }
        if ((uVar1 - 2 & 0xfd) == 0) {
          uVar5 = *puVar7;
          result->value = (uint16_t)uVar5;
          SVar3 = (SFtype)(uVar5 & 0xffff);
          __floatsidf((SItype)SVar3);
          goto LAB_23052d30;
        }
      }
      puVar7 = puVar7 + 1;
      result = result + 1;
    }
  }
  else {
    puVar7 = orgVal + len;
    while (orgVal != puVar7) {
      result->posChan = (int8_t)(*orgVal >> 0x15);
      result->negChan = (byte)*(undefined2 *)((int)orgVal + 2) & 0x1f;
      uVar6 = 0;
      if ((int)(*orgVal << 0x10) < 0) {
        *orgVal = -*orgVal;
        uVar6 = uVar5;
      }
      if (uVar1 == 0) {
        uVar2 = *orgVal;
        result->value = (ushort)(uVar2 >> 4) & 0xfff;
        SVar3 = (SFtype)(uVar2 >> 4 & 0xfff);
        __floatsidf((SItype)SVar3);
LAB_23052c3c:
        __muldf3();
        __extendsfdf2(SVar3);
        DVar9 = __muldf3();
        fVar8 = SUB84(DVar9,0);
        __truncdfsf2();
        result->volt = fVar8;
      }
      else {
        if (uVar1 == 1) {
          uVar2 = *orgVal;
          result->value = (ushort)(uVar2 >> 2) & 0x3fff;
          SVar3 = (SFtype)(uVar2 >> 2 & 0x3fff);
          __floatsidf((SItype)SVar3);
          goto LAB_23052c3c;
        }
        if ((uVar1 - 2 & 0xfd) == 0) {
          uVar2 = *orgVal;
          result->value = (uint16_t)uVar2;
          SVar3 = (SFtype)(uVar2 & 0xffff);
          __floatsidf((SItype)SVar3);
          goto LAB_23052c3c;
        }
      }
      if (uVar6 != 0) {
        result->volt = -result->volt;
      }
      result = result + 1;
      orgVal = orgVal + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Tsen_Init(ADC_TSEN_MOD_Type tsenMod)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f90c = _DAT_4000f90c & 0x87ffffff | 0xc0000;
  _DAT_4000f910 = _DAT_4000f910 | 0x4000000;
  _DAT_4000f914 =
       (_DAT_4000f914 & 0xfc3ffdf | CONCAT31(in_register_00002029,tsenMod) << 5) & 0xffffa07f |
       0x20000140;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_LOW(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f914 = _DAT_4000f914 & 0x7fffffff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_SET_TSVBE_HIGH(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f914 = _DAT_4000f914 | 0x80000000;
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t TSEN_Get_V_Error(void)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint uVar3;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  ADC_SET_TSVBE_LOW();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  uVar3 = (uint)regVal._2_2_;
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  ADC_SET_TSVBE_HIGH();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  return uVar3 - regVal._2_2_;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float TSEN_Get_Temp(uint32_t tsen_offset)

{
  BL_Fun_Type BVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  uint32_t *orgVal;
  SFtype SVar3;
  uint32_t uStack44;
  uint32_t regVal;
  ADC_Result_Type result;
  
  uStack44 = 0;
  _DAT_40002000 = _DAT_40002000 | 2;
  ADC_SET_TSVBE_LOW();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var,uVar2) == 0);
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(&uStack44,1,(ADC_Result_Type *)&regVal);
  _DAT_40002000 = _DAT_40002000 | 2;
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  ADC_SET_TSVBE_HIGH();
  ADC_Start();
  do {
    uVar2 = ADC_Get_FIFO_Count();
    BVar1 = adcGainCoeffCal.adcGainCoeffEnable;
  } while (CONCAT31(extraout_var_00,uVar2) == 0);
  orgVal = &uStack44;
  uStack44 = _DAT_40002004;
  adcGainCoeffCal.adcGainCoeffEnable = DISABLE;
  ADC_Parse_Result(orgVal,1,(ADC_Result_Type *)&regVal);
  adcGainCoeffCal.adcGainCoeffEnable = BVar1;
  __extendsfdf2((SFtype)orgVal);
  __divdf3();
  SVar3 = __truncdfsf2();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (float)SVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ADC_Init(ADC_CFG_Type *cfg)

{
  uint uVar1;
  uint uVar2;
  
  _DAT_4000f910 =
       (uint)cfg->resWidth << 2 |
       ((uint)cfg->clkDiv << 0x12 |
        (uint)cfg->v11Sel << 0x1b | (uint)cfg->v18Sel << 0x1d | _DAT_4000f910 & 0x8001fffe |
       (uint)cfg->offsetCalibEn) & 0xffffffe3;
  if ((cfg->gain1 | cfg->gain2) == 0) {
    uVar1 = 0xfffe1fff;
    uVar2 = 0x8000;
  }
  else {
    uVar1 = 0xfffe3fff;
    uVar2 = 0x12000;
  }
  _DAT_4000f914 =
       ((uint)cfg->biasSel << 0x11 |
       (uint)cfg->gain2 << 0x16 | (uint)cfg->gain1 << 0x19 | _DAT_4000f914 & 0x803dffff) & uVar1 &
       0xffffe073 | uVar2 | (uint)cfg->vcm << 7 | (uint)cfg->vref << 3 | 0x1000 |
       (uint)cfg->inputMode << 2;
  _DAT_4000f938 = (int)cfg->offsetCalibVal | _DAT_4000f938 & 0xffff0000;
                    // WARNING: Treating indirect jump as call
  ADC_Gain_Trim();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Write_Common_OP_First_Cfg
               (uint8_t s0RegIndex,uint8_t s0RegType,uint8_t dRegIndex,uint8_t dRegType,uint8_t op,
               uint8_t lastOp)

{
  undefined3 in_register_00002029;
  uint uVar1;
  undefined3 in_register_00002031;
  undefined3 in_register_00002039;
  
  uVar1 = CONCAT31(in_register_00002029,s0RegIndex) | (s0RegType & 0xf) << 8;
  if (CONCAT31(in_register_00002039,op) != 0x19) {
    uVar1 = uVar1 | CONCAT31(in_register_00002031,dRegIndex) << 0xc | (dRegType & 0xf) << 0x14;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004340 = uVar1 & 0xffffff | (op & 0x7f) << 0x18 | (uint)lastOp << 0x1f;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Sec_Eng_PKA_Wait_ISR(void)

{
  int iVar1;
  
  iVar1 = 16000000;
  do {
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return TIMEOUT;
    }
  } while ((_DAT_40004300 & 0x100) == 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Sec_Eng_SHA256_Update(SEC_Eng_SHA256_Ctx *shaCtx,uint8_t *input,uint32_t len)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint32_t *psrc;
  uint uVar5;
  
  uVar2 = _DAT_40004000;
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) goto LAB_230532a2;
  } while ((_DAT_40004000 & 1) != 0);
  bVar1 = shaCtx->shaFeed;
  uVar5 = shaCtx->total[0] & 0x3f;
  uVar4 = shaCtx->total[0] + len;
  shaCtx->total[0] = uVar4;
  if (uVar4 < len) {
    shaCtx->total[1] = shaCtx->total[1] + 1;
  }
  if ((uVar5 != 0) && (uVar4 = 0x40 - uVar5, uVar4 <= len)) {
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar5),input,uVar4);
    _DAT_40004004 = shaCtx->shaBuf;
    _DAT_40004000 = (uint)bVar1 << 6 | uVar2 & 0xffbf | 0x10002;
    len = (len - 0x40) + uVar5;
    shaCtx->shaFeed = '\x01';
    input = input + uVar4;
    uVar5 = 0;
  }
  psrc = (uint32_t *)input;
  if (0x3f < len) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) goto LAB_230532a2;
    } while ((_DAT_40004000 & 1) != 0);
    _DAT_40004000 = (len >> 6) << 0x10 | (uint)shaCtx->shaFeed << 6 | _DAT_40004000 & 0xffbf | 2;
    psrc = (uint32_t *)((int)input + (len & 0xffffffc0));
    _DAT_40004004 = (uint32_t *)input;
    shaCtx->shaFeed = '\x01';
  }
  if ((len & 0x3f) != 0) {
    iVar3 = 16000000;
    do {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) goto LAB_230532a2;
    } while ((_DAT_40004000 & 1) != 0);
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar5),psrc,len & 0x3f);
  }
  iVar3 = 16000000;
  while (iVar3 = iVar3 + -1, iVar3 != 0) {
    if ((_DAT_40004000 & 1) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return SUCCESS;
    }
  }
LAB_230532a2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TIMEOUT;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA256_Init(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,
                        SEC_ENG_SHA_Type shaType,uint32_t *shaTmpBuf,uint32_t *padding)

{
  undefined3 in_register_00002031;
  
  _DAT_40004000 = CONCAT31(in_register_00002031,shaType) << 2 | _DAT_40004000 & 0xffffffe3;
  memset(shaCtx,0,0x14);
  shaCtx->shaPadding = padding;
  shaCtx->shaBuf = shaTmpBuf;
  BL602_MemSet(padding,'\0',0x40);
                    // WARNING: Treating indirect jump as call
  BL602_MemSet(shaCtx->shaPadding,-0x80,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Start(SEC_ENG_SHA_ID_Type shaNo)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004000 = _DAT_40004000 & 0xffffffbf | 0x20;
  return;
}



BL_Err_Type
Sec_Eng_SHA256_Update
          (SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *input,uint32_t len)

{
  BL_Err_Type BVar1;
  
  if (len != 0) {
    BVar1 = Sec_Eng_SHA256_Update(shaCtx,input,len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return BVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Finish(SEC_Eng_SHA256_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *hash)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined uStack24;
  undefined uStack23;
  ushort uStack22;
  uint8_t msgLen [8];
  
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = shaCtx->total[0];
  uVar4 = shaCtx->total[1] << 3;
  uStack24 = (undefined)(uVar4 >> 0x18);
  uStack23 = (undefined)(uVar4 >> 0x10);
  uStack22 = (ushort)((uVar4 | uVar2 >> 0x1d) << 8) | (ushort)(uVar4 >> 8) & 0xff;
  msgLen[0] = (uint8_t)((uVar2 << 3) >> 0x18);
  msgLen[1] = (uint8_t)((uVar2 << 3) >> 0x10);
  msgLen._2_2_ = (ushort)((uVar2 << 0x13) >> 0x18) | (ushort)(uVar2 << 0xb);
  if ((uVar2 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  Sec_Eng_SHA256_Update(shaCtx,shaNo,(uint8_t *)shaCtx->shaPadding,iVar3 - (uVar2 & 0x3f));
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) goto LAB_2305332c;
  } while ((_DAT_40004000 & 1) != 0);
  BL602_MemCpy_Fast(shaCtx->shaPadding,&uStack24,8);
  Sec_Eng_SHA256_Update(shaCtx,(uint8_t *)shaCtx->shaPadding,8);
  uVar1 = _DAT_40004010;
  iVar3 = 16000000;
  while (iVar3 = iVar3 + -1, iVar3 != 0) {
    if ((_DAT_40004000 & 1) == 0) {
      uVar2 = _DAT_40004000 >> 2;
      *hash = (uint8_t)_DAT_40004010;
      hash[1] = (uint8_t)((uint)uVar1 >> 8);
      hash[2] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[3] = (uint8_t)((uint)uVar1 >> 0x18);
      uVar1 = _DAT_40004014;
      hash[4] = (uint8_t)_DAT_40004014;
      hash[5] = (uint8_t)((uint)uVar1 >> 8);
      hash[6] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[7] = (uint8_t)((uint)uVar1 >> 0x18);
      uVar1 = _DAT_40004018;
      hash[8] = (uint8_t)_DAT_40004018;
      hash[9] = (uint8_t)((uint)uVar1 >> 8);
      hash[10] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[0xb] = (uint8_t)((uint)uVar1 >> 0x18);
      uVar1 = _DAT_4000401c;
      hash[0xc] = (uint8_t)_DAT_4000401c;
      hash[0xd] = (uint8_t)((uint)uVar1 >> 8);
      hash[0xe] = (uint8_t)((uint)uVar1 >> 0x10);
      hash[0xf] = (uint8_t)((uint)uVar1 >> 0x18);
      uVar1 = _DAT_40004020;
      hash[0x10] = (uint8_t)_DAT_40004020;
      hash[0x11] = (uint8_t)((uint)uVar1 >> 8);
      hash[0x13] = (uint8_t)((uint)uVar1 >> 0x18);
      hash[0x12] = (uint8_t)((uint)uVar1 >> 0x10);
      uVar1 = _DAT_40004024;
      if ((uVar2 & 6) == 0) {
        hash[0x14] = (uint8_t)_DAT_40004024;
        hash[0x15] = (uint8_t)((uint)uVar1 >> 8);
        hash[0x16] = (uint8_t)((uint)uVar1 >> 0x10);
        hash[0x17] = (uint8_t)((uint)uVar1 >> 0x18);
        uVar1 = _DAT_40004028;
        hash[0x18] = (uint8_t)_DAT_40004028;
        hash[0x19] = (uint8_t)((uint)uVar1 >> 8);
        hash[0x1a] = (uint8_t)((uint)uVar1 >> 0x10);
        hash[0x1b] = (uint8_t)((uint)uVar1 >> 0x18);
        uVar1 = _DAT_4000402c;
        if ((uVar2 & 7) == 0) {
          hash[0x1c] = (uint8_t)_DAT_4000402c;
          hash[0x1d] = (uint8_t)((uint)uVar1 >> 8);
          hash[0x1e] = (uint8_t)((uint)uVar1 >> 0x10);
          hash[0x1f] = (uint8_t)((uint)uVar1 >> 0x18);
        }
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      _DAT_40004000 = _DAT_40004000 & 0xffffff9f;
      return SUCCESS;
    }
  }
LAB_2305332c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TIMEOUT;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Enable_Link(SEC_ENG_SHA_ID_Type shaNo)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004000 = _DAT_40004000 | 0x8020;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_SHA_Disable_Link(SEC_ENG_SHA_ID_Type shaNo)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004000 = _DAT_40004000 & 0xffff7fdf;
  return;
}



void Sec_Eng_SHA256_Link_Init
               (SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint32_t linkAddr,
               uint32_t *shaTmpBuf,uint32_t *padding)

{
  memset(shaCtx,0,0x14);
  shaCtx->shaPadding = padding;
  shaCtx->shaBuf = shaTmpBuf;
  BL602_MemSet(padding,'\0',0x40);
  BL602_MemSet(shaCtx->shaPadding,-0x80,1);
  shaCtx->linkAddr = linkAddr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Link_Update
          (SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *input,uint32_t len)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  
  if (len == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return SUCCESS;
  }
  iVar1 = 16000000;
  do {
    iVar1 = iVar1 + -1;
    if (iVar1 == 0) goto LAB_23053596;
  } while ((_DAT_40004000 & 1) != 0);
  _DAT_40004050 = shaCtx->linkAddr;
  uVar3 = shaCtx->total[0] & 0x3f;
  uVar2 = shaCtx->total[0] + len;
  shaCtx->total[0] = uVar2;
  if (uVar2 < len) {
    shaCtx->total[1] = shaCtx->total[1] + 1;
  }
  if ((uVar3 != 0) && (uVar2 = 0x40 - uVar3, uVar2 <= len)) {
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar3),input,uVar2);
    input = input + uVar2;
    *(uint32_t **)(shaCtx->linkAddr + 4) = shaCtx->shaBuf;
    *(undefined2 *)(shaCtx->linkAddr + 2) = 1;
    _DAT_40004000 = _DAT_40004000 | 2;
    len = (len + uVar3) - 0x40;
    *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr | 0x40;
    uVar3 = 0;
  }
  if (0x3f < len) {
    iVar1 = 16000000;
    do {
      iVar1 = iVar1 + -1;
      if (iVar1 == 0) goto LAB_23053596;
    } while ((_DAT_40004000 & 1) != 0);
    *(uint8_t **)(shaCtx->linkAddr + 4) = input;
    input = input + (len & 0xffffffc0);
    *(short *)(shaCtx->linkAddr + 2) = (short)(len >> 6);
    _DAT_40004000 = _DAT_40004000 | 2;
    *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr | 0x40;
  }
  if ((len & 0x3f) != 0) {
    iVar1 = 16000000;
    do {
      iVar1 = iVar1 + -1;
      if (iVar1 == 0) goto LAB_23053596;
    } while ((_DAT_40004000 & 1) != 0);
    BL602_MemCpy_Fast((void *)((int)shaCtx->shaBuf + uVar3),input,len & 0x3f);
  }
  iVar1 = 16000000;
  while (iVar1 = iVar1 + -1, iVar1 != 0) {
    if ((_DAT_40004000 & 1) == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return SUCCESS;
    }
  }
LAB_23053596:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return TIMEOUT;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_SHA256_Link_Finish(SEC_Eng_SHA256_Link_Ctx *shaCtx,SEC_ENG_SHA_ID_Type shaNo,uint8_t *hash)

{
  uint uVar1;
  uint32_t n;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint8_t uStack40;
  undefined uStack39;
  ushort uStack38;
  uint8_t msgLen [8];
  
  iVar3 = 16000000;
  uVar1 = *(uint *)shaCtx->linkAddr;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) goto LAB_230536c6;
  } while ((_DAT_40004000 & 1) != 0);
  uVar2 = shaCtx->total[0];
  uVar4 = shaCtx->total[1] << 3;
  uStack40 = (uint8_t)(uVar4 >> 0x18);
  uStack39 = (undefined)(uVar4 >> 0x10);
  uStack38 = (ushort)((uVar4 | uVar2 >> 0x1d) << 8) | (ushort)(uVar4 >> 8) & 0xff;
  msgLen[0] = (uint8_t)((uVar2 << 3) >> 0x18);
  msgLen[1] = (uint8_t)((uVar2 << 3) >> 0x10);
  msgLen._2_2_ = (ushort)((uVar2 << 0x13) >> 0x18) | (ushort)(uVar2 << 0xb);
  if ((uVar2 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  _DAT_40004050 = (uint *)shaCtx->linkAddr;
  Sec_Eng_SHA256_Link_Update(shaCtx,shaNo,(uint8_t *)shaCtx->shaPadding,iVar3 - (uVar2 & 0x3f));
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) goto LAB_230536c6;
  } while ((_DAT_40004000 & 1) != 0);
  Sec_Eng_SHA256_Link_Update(shaCtx,shaNo,&uStack40,8);
  iVar3 = 16000000;
  do {
    iVar3 = iVar3 + -1;
    if (iVar3 == 0) {
LAB_230536c6:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return TIMEOUT;
    }
  } while ((_DAT_40004000 & 1) != 0);
  uVar1 = uVar1 >> 2 & 7;
  if (uVar1 == 1) {
    n = 0x1c;
  }
  else {
    if (uVar1 == 0) {
      n = 0x20;
    }
    else {
      n = 0x14;
      if (3 < uVar1) goto LAB_230537a0;
    }
  }
  BL602_MemCpy_Fast(hash,(void *)(shaCtx->linkAddr + 8),n);
LAB_230537a0:
  *(uint *)shaCtx->linkAddr = *(uint *)shaCtx->linkAddr & 0xffffffbf;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_AES_Enable_Link(SEC_ENG_AES_ID_Type aesNo)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004100 = _DAT_40004100 | 0x8000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_AES_Disable_Link(SEC_ENG_AES_ID_Type aesNo)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004100 = _DAT_40004100 & 0xffff7fff;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
Sec_Eng_AES_Link_Work
          (SEC_ENG_AES_ID_Type aesNo,uint32_t linkAddr,uint8_t *in,uint32_t len,uint8_t *out)

{
  BL_Err_Type BVar1;
  int iVar2;
  
  BVar1 = ERROR;
  if ((linkAddr & 3 | len & 0xf) == 0) {
    iVar2 = 16000000;
    do {
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return TIMEOUT;
      }
    } while ((_DAT_40004100 & 1) != 0);
    _DAT_40004150 = linkAddr;
    *(uint8_t **)(linkAddr + 4) = in;
    *(uint8_t **)(linkAddr + 8) = out;
    *(short *)(linkAddr + 2) = (short)(len >> 4);
    iVar2 = 16000000;
    do {
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        _DAT_40004100 = _DAT_40004100 | 6;
        return TIMEOUT;
      }
    } while ((_DAT_40004100 & 1) != 0);
    _DAT_40004100 = (_DAT_40004100 | 6) & 0xfffffffb;
    BVar1 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Reset(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004300 = 8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_BigEndian_Enable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004300 = _DAT_40004300 | 0x1000;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Clear_Int(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004300 = _DAT_40004300 & 0xfffffdff;
  return;
}



void Sec_Eng_PKA_Read_Block(uint32_t *dest,uint32_t *src,uint32_t len)

{
  uint uVar1;
  
  uVar1 = 0;
  while (uVar1 != (len & 0xfffffffc)) {
    dest[uVar1] = *src;
    uVar1 = uVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void Sec_Eng_PKA_Write_Block(uint32_t *dest,uint32_t *src,uint32_t len)

{
  uint32_t *puVar1;
  uint uVar2;
  
  uVar2 = 0;
  while (uVar2 != (len & 0xfffffffc)) {
    puVar1 = src + uVar2;
    uVar2 = uVar2 + 1;
    *dest = *puVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Write_Data
               (SEC_ENG_PKA_REG_SIZE_Type regType,uint8_t regIndex,uint32_t *data,uint16_t size,
               uint8_t lastOp)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  undefined2 in_register_00002036;
  uint uVar2;
  
  uVar1 = regType - 1 & 0xff;
  uVar2 = 0;
  if (uVar1 < 10) {
    uVar2 = (uint)*(ushort *)(CSWTCH_116 + uVar1 * 2);
  }
  _DAT_40004340 =
       size & 0xfff | CONCAT31(in_register_0000202d,regIndex) << 0xc | (regType & 0xf) << 0x14 |
       0x39000000 | (uint)lastOp << 0x1f;
  uVar1 = uVar2 >> 2;
  if (CONCAT22(in_register_00002036,size) < uVar2 >> 2) {
    uVar1 = CONCAT22(in_register_00002036,size);
  }
  Sec_Eng_PKA_Write_Block((uint32_t *)&DAT_40004340,data,uVar1 & 0xffff);
  uVar2 = uVar1 & 0xfffc;
  while ((int)uVar2 < (int)(uVar1 & 0xffff)) {
    _DAT_40004340 = data[uVar2];
    uVar2 = uVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Read_Data
               (SEC_ENG_PKA_REG_SIZE_Type regType,uint8_t regIdx,uint32_t *result,uint8_t retSize)

{
  undefined3 in_register_00002035;
  uint len;
  uint uVar1;
  uint uVar2;
  
  len = CONCAT31(in_register_00002035,retSize);
  uVar2 = regType - 1 & 0xff;
  uVar1 = 0;
  if (uVar2 < 10) {
    uVar1 = (uint)*(ushort *)(CSWTCH_116 + uVar2 * 2);
  }
  if (len <= uVar1 >> 2) {
    _DAT_40004340 = 0;
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    Sec_Eng_PKA_Read_Block(result,(uint32_t *)&DAT_40004340,len);
    uVar1 = len & 0xfffffffc;
    while ((int)uVar1 < (int)len) {
      result[uVar1] = _DAT_40004340;
      uVar1 = uVar1 + 1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_CREG(SEC_ENG_PKA_REG_SIZE_Type dRegType,uint8_t dRegIdx,uint8_t size,uint8_t lastOp
                     )

{
  undefined3 in_register_00002035;
  
  _DAT_40004340 = 0;
  if (CONCAT31(in_register_00002035,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004340 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_Move_Data
               (uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,uint8_t lastOp)

{
  undefined3 in_register_00002039;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'2',lastOp);
  _DAT_40004340 = 0;
  if (CONCAT31(in_register_00002039,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40004340 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_MREM(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s2RegType,uint8_t s2RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'&',lastOp);
  _DAT_40004340 = (s2RegType & 0xf) << 8 | CONCAT31(in_register_0000203d,s2RegIdx);
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_MEXP(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t s2RegType,uint8_t s2RegIdx,
                     uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002045;
  uint8_t in_stack_00000000;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'#',in_stack_00000000);
  _DAT_40004340 =
       CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | (s1RegType & 0xf) << 0x14 |
       CONCAT31(in_register_00002045,s2RegIdx) | (s2RegType & 0xf) << 8;
  if (in_stack_00000000 != '\0') {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LCMP(uint8_t *cout,uint8_t s0RegType,uint8_t s0RegIdx,uint8_t s1RegType,
                     uint8_t s1RegIdx)

{
  undefined3 in_register_00002039;
  
  _DAT_40004340 = CONCAT31(in_register_00002039,s1RegIdx) << 0xc | (s1RegType & 0xf) << 0x14;
  Sec_Eng_PKA_Wait_ISR();
  Sec_Eng_PKA_Clear_Int();
  *cout = (byte)((uint)_DAT_40004300 >> 0x18) & 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LSUB(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x17',lastOp);
  _DAT_40004340 = CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | (s1RegType & 0xf) << 0x14;
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LMUL(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s1RegType,uint8_t s1RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x16',lastOp);
  _DAT_40004340 = CONCAT31(in_register_0000203d,s1RegIdx) << 0xc | (s1RegType & 0xf) << 0x14;
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LDIV(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                     uint8_t s2RegType,uint8_t s2RegIdx,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  undefined3 in_register_00002041;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x14',lastOp);
  _DAT_40004340 = (s2RegType & 0xf) << 8 | CONCAT31(in_register_0000203d,s2RegIdx);
  if (CONCAT31(in_register_00002041,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void Sec_Eng_PKA_LMUL2N(uint8_t dRegType,uint8_t dRegIdx,uint8_t s0RegType,uint8_t s0RegIdx,
                       uint16_t bit_shift,uint8_t lastOp)

{
  undefined3 in_register_0000203d;
  
  Sec_Eng_PKA_Write_Common_OP_First_Cfg(s0RegIdx,s0RegType,dRegIdx,dRegType,'\x13','\0');
  _DAT_40004340 = bit_shift & 0x7fff;
  if (CONCAT31(in_register_0000203d,lastOp) != 0) {
    Sec_Eng_PKA_Wait_ISR();
    Sec_Eng_PKA_Clear_Int();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_IntMask(SEC_ENG_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  int iVar1;
  
  iVar1 = CONCAT31(in_register_0000202d,intMask);
  switch(CONCAT31(in_register_00002029,intType)) {
  case 0:
    if (iVar1 == 0) {
      _DAT_40004200 = _DAT_40004200 & 0xfffff7ff;
    }
    else {
      _DAT_40004200 = _DAT_40004200 | 0x800;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 1:
    if (iVar1 == 0) {
      _DAT_40004100 = _DAT_40004100 & 0xfffff7ff;
    }
    else {
      _DAT_40004100 = _DAT_40004100 | 0x800;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 2:
    if (iVar1 == 0) {
      _DAT_40004000 = _DAT_40004000 & 0xfffff7ff;
    }
    else {
      _DAT_40004000 = _DAT_40004000 | 0x800;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 3:
    if (iVar1 == 0) {
      _DAT_40004300 = _DAT_40004300 & 0xfffff7ff;
    }
    else {
      _DAT_40004300 = _DAT_40004300 | 0x800;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 5:
    if (iVar1 == 0) {
      _DAT_40004500 = _DAT_40004500 & 0xfffff7ff;
    }
    else {
      _DAT_40004500 = _DAT_40004500 | 0x800;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  case 6:
    if (iVar1 == 0) {
      _DAT_40004200 = _DAT_40004200 & 0xfffff7ff;
      _DAT_40004100 = _DAT_40004100 & 0xfffff7ff;
      _DAT_40004000 = _DAT_40004000 & 0xfffff7ff;
      _DAT_40004300 = _DAT_40004300 & 0xfffff7ff;
      _DAT_40004500 = _DAT_40004500 & 0xfffff7ff;
    }
    else {
      _DAT_40004200 = _DAT_40004200 | 0x800;
      _DAT_40004100 = _DAT_40004100 | 0x800;
      _DAT_40004000 = _DAT_40004000 | 0x800;
      _DAT_40004300 = _DAT_40004300 | 0x800;
      _DAT_40004500 = _DAT_40004500 | 0x800;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void DMA_Enable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000c030 = _DAT_4000c030 | 1;
  return;
}



void DMA_Channel_Enable(uint8_t ch)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = *puVar1 | 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void DMA_LLI_Init(uint8_t ch,DMA_LLI_Cfg_Type *lliCfg)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c110);
  *puVar1 = (uint)lliCfg->dir << 0xb | *puVar1 & 0xffffc001 | (uint)lliCfg->dstPeriph << 6 |
            (uint)lliCfg->srcPeriph << 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void DMA_LLI_Update(uint8_t ch,uint32_t LLI)

{
  undefined3 in_register_00002029;
  
                    // WARNING: Treating indirect jump as call
  BL602_MemCpy4((uint32_t *)(CONCAT31(in_register_00002029,ch) * 0x100 + 0x4000c100),(uint32_t *)LLI
                ,4);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void DMA_IntMask(uint8_t ch,DMA_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  int iVar1;
  uint *puVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  undefined3 in_register_00002031;
  int iVar4;
  uint uVar5;
  uint uVar6;
  
  iVar4 = CONCAT31(in_register_00002031,intMask);
  iVar3 = CONCAT31(in_register_0000202d,intType);
  iVar1 = CONCAT31(in_register_00002029,ch) * 0x100;
  if (iVar3 == 1) {
    puVar2 = (uint *)(iVar1 + 0x4000c110);
    uVar6 = *puVar2;
    if (iVar4 == 0) {
      uVar6 = uVar6 & 0xffffbfff;
      goto LAB_23053e98;
    }
    uVar5 = 0x4000;
  }
  else {
    if (iVar3 == 0) {
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      iVar3 = -0x8000;
      if (iVar4 != 0) {
        uVar5 = 0x8000;
        goto LAB_23053e78;
      }
    }
    else {
      if (iVar3 != 2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      uVar6 = *(uint *)(iVar1 + 0x4000c110);
      if (iVar4 != 0) {
        uVar5 = 0xc000;
LAB_23053e78:
        puVar2 = (uint *)(iVar1 + 0x4000c10c);
        *(uint *)(iVar1 + 0x4000c110) = uVar6 | uVar5;
        uVar6 = *puVar2 & 0x7fffffff;
        goto LAB_23053e98;
      }
      iVar3 = -0xc000;
    }
    puVar2 = (uint *)(iVar1 + 0x4000c10c);
    *(uint *)(iVar1 + 0x4000c110) = uVar6 & iVar3 - 1U;
    uVar6 = *puVar2;
    uVar5 = 0x80000000;
  }
  uVar6 = uVar6 | uVar5;
LAB_23053e98:
  *puVar2 = uVar6;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void Default_Handler(void)

{
  bflb_platform_printf("Default_Handler\r\n");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_UART_CLK(uint8_t enable,HBN_UART_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_00002031;
  uint uVar1;
  
  _DAT_40000008 = CONCAT31(in_register_00002031,div) | _DAT_40000008 & 0xffffffe8;
  HBN_Set_UART_CLK_Sel(clkSel);
  uVar1 = _DAT_40000008 | 0x10;
  if (CONCAT31(in_register_00002029,enable) == 0) {
    uVar1 = _DAT_40000008 & 0xffffffef;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_40000008 = uVar1;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_ADC_CLK(uint8_t enable,GLB_ADC_CLK_Type clkSel,uint8_t div)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  undefined3 in_register_00002031;
  uint uVar1;
  
  uVar1 = (CONCAT31(in_register_00002031,div) | _DAT_400000a4 & 0xfffffec0) & 0xffffff7f |
          CONCAT31(in_register_0000202d,clkSel) << 7;
  _DAT_400000a4 = uVar1 & 0xfffffeff;
  if (CONCAT31(in_register_00002029,enable) != 0) {
    _DAT_400000a4 = uVar1 | 0x100;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_UART_Fun_Sel(GLB_UART_SIG_Type sig,GLB_UART_SIG_FUN_Type fun)

{
  undefined3 in_register_0000202d;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_400000c0 =
       ~(0xf << ((sig & 7) << 2)) & _DAT_400000c0 |
       CONCAT31(in_register_0000202d,fun) << ((sig & 7) << 2);
  return SUCCESS;
}



BL_Err_Type GLB_GPIO_Write(GLB_GPIO_Type gpioPin,uint32_t val)

{
  undefined3 in_register_00002029;
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  
  puVar3 = (uint *)((CONCAT31(in_register_00002029,gpioPin) >> 5) * 4 + 0x40000188);
  uVar2 = *puVar3;
  uVar1 = 1 << (gpioPin & 0x1f);
  if (val == 0) {
    uVar1 = ~uVar1 & uVar2;
  }
  else {
    uVar1 = uVar1 | uVar2;
  }
  *puVar3 = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



uint32_t GLB_GPIO_Read(GLB_GPIO_Type gpioPin)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)((1 << (gpioPin & 0x1f) &
                *(uint *)((CONCAT31(in_register_00002029,gpioPin) >> 5) * 4 + 0x40000180)) != 0);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_UART_CLK_Sel(HBN_UART_CLK_Type clkSel)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000f030 = CONCAT31(in_register_00002029,clkSel) << 2 | _DAT_4000f030 & 0xfffffffb;
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Get_RTC_Timer_Val(uint32_t *valLow,uint32_t *valHigh)

{
  _DAT_4000f010 = _DAT_4000f010 & 0x7fffffff;
  *valLow = _DAT_4000f00c;
  *valHigh = _DAT_4000f010 & 0xff;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



void TIMER_SetCompValue(TIMER_Chan_Type timerCh,TIMER_Comp_ID_Type cmpNo,uint32_t val)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  *(uint32_t *)
   ((CONCAT31(in_register_00002029,timerCh) * 3 + CONCAT31(in_register_0000202d,cmpNo)) * 4 +
   0x4000a510) = val;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_SetCountMode(TIMER_Chan_Type timerCh,TIMER_CountMode_Type countMode)

{
  undefined3 in_register_0000202d;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a588 =
       ~(1 << (timerCh + 1 & 0x1f)) & _DAT_4000a588 |
       CONCAT31(in_register_0000202d,countMode) << (timerCh + 1 & 0x1f);
  return;
}



void TIMER_ClearIntStatus(TIMER_Chan_Type timerCh,TIMER_Comp_ID_Type cmpNo)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  
  puVar1 = (uint *)(CONCAT31(in_register_00002029,timerCh) * 4 + 0x4000a578);
  *puVar1 = 1 << (cmpNo & 0x1f) | *puVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type TIMER_Init(TIMER_CFG_Type *timerCfg)

{
  TIMER_Chan_Type timerCh;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  timerCh = timerCfg->timerCh;
  uVar1 = (uint)timerCh;
  if (uVar1 == 0) {
    _DAT_4000a500 = _DAT_4000a500 & 0xfffffff3;
    uVar2 = (uint)timerCfg->clkSrc << 2;
  }
  else {
    _DAT_4000a500 = _DAT_4000a500 & 0xffffff9f;
    uVar2 = (uint)timerCfg->clkSrc << 5;
  }
  _DAT_4000a500 = uVar2 | _DAT_4000a500;
  if (uVar1 == 0) {
    uVar2 = 0xffff00ff;
    uVar3 = (uint)timerCfg->clockDivision << 8;
  }
  else {
    uVar2 = 0xff00ffff;
    uVar3 = (uint)timerCfg->clockDivision << 0x10;
  }
  _DAT_4000a5bc = uVar3 | uVar2 & _DAT_4000a5bc;
  TIMER_SetCountMode(timerCh,timerCfg->countMode);
  *(uint *)(uVar1 * 4 + 0x4000a55c) = (uint)timerCfg->plTrigSrc;
  if (timerCfg->countMode == TIMER_COUNT_PRELOAD) {
    *(uint32_t *)(uVar1 * 4 + 0x4000a550) = timerCfg->preLoadVal;
  }
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_0,timerCfg->matchVal0);
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_1,timerCfg->matchVal1);
  TIMER_SetCompValue(timerCh,TIMER_COMP_ID_2,timerCfg->matchVal2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SUCCESS;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_Enable(TIMER_Chan_Type timerCh)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a584 = 1 << (timerCh + 1 & 0x1f) | _DAT_4000a584;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void TIMER_Disable(TIMER_Chan_Type timerCh)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a584 = ~(1 << (timerCh + 1 & 0x1f)) & _DAT_4000a584;
  return;
}



void TIMER_IntMask(TIMER_Chan_Type timerCh,TIMER_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  uint *puVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  undefined3 in_register_00002031;
  int iVar3;
  uint uVar4;
  
  iVar3 = CONCAT31(in_register_00002031,intMask);
  iVar2 = CONCAT31(in_register_0000202d,intType);
  puVar1 = (uint *)(CONCAT31(in_register_00002029,timerCh) * 4 + 0x4000a544);
  uVar4 = *puVar1;
  if (iVar2 == 1) {
    if (iVar3 == 0) {
      uVar4 = uVar4 | 2;
    }
    else {
      uVar4 = uVar4 & 0xfffffffd;
    }
    goto LAB_2305416e;
  }
  if (iVar2 == 0) {
    if (iVar3 == 0) {
      uVar4 = uVar4 | 1;
    }
    else {
      uVar4 = uVar4 & 0xfffffffe;
    }
    goto LAB_2305416e;
  }
  if (iVar2 == 2) {
    if (iVar3 != 0) goto LAB_230541a6;
  }
  else {
    if (iVar2 != 3) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if (iVar3 != 0) {
      *puVar1 = uVar4 & 0xfffffffe;
      *puVar1 = uVar4 & 0xfffffffd;
LAB_230541a6:
      uVar4 = uVar4 & 0xfffffffb;
      goto LAB_2305416e;
    }
    *puVar1 = uVar4 | 1;
    *puVar1 = uVar4 | 2;
  }
  uVar4 = uVar4 | 4;
LAB_2305416e:
  *puVar1 = uVar4;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Set_Clock(TIMER_ClkSrc_Type clkSrc,uint8_t div)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a500 = CONCAT31(in_register_00002029,clkSrc) << 8 | _DAT_4000a500 & 0xfffffcff;
  _DAT_4000a5bc = _DAT_4000a5bc & 0xffffff | (uint)div << 0x18;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_SetCompValue(uint16_t val)

{
  undefined2 in_register_0000202a;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a568 = CONCAT22(in_register_0000202a,val);
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_ResetCounterValue(void)

{
  _DAT_4000a598 = _DAT_4000a598 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Enable(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a564 = _DAT_4000a564 | 1;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_Disable(void)

{
  _DAT_4000a564 = _DAT_4000a564 & 0xfffffffe;
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void WDT_IntMask(WDT_INT_Type intType,BL_Mask_Type intMask)

{
  undefined3 in_register_00002029;
  undefined3 in_register_0000202d;
  
  if (CONCAT31(in_register_00002029,intType) == 0) {
    if (CONCAT31(in_register_0000202d,intMask) == 0) {
      _DAT_4000a564 = _DAT_4000a564 & 0xfffffffd;
    }
    else {
      _DAT_4000a564 = _DAT_4000a564 | 2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  _DAT_4000a59c = _DAT_4000a59c & 0xffff0000 | 0xbaba;
  _DAT_4000a5a0 = _DAT_4000a5a0 & 0xffff0000 | 0xeb10;
  return;
}



uint32_t EF_Ctrl_Get_Byte_Zero_Cnt(uint8_t val)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  uint uVar2;
  
  uVar2 = 0;
  uVar1 = 0;
  do {
    if ((CONCAT31(in_register_00002029,val) >> (uVar2 & 0x1f) & 1U) == 0) {
      uVar1 = uVar1 + 1;
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 != 8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address(uint8_t *mac)

{
  uint8_t uVar1;
  undefined4 uVar2;
  uint uVar3;
  BL_Err_Type BVar4;
  uint32_t uVar5;
  uint8_t *puVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  EF_Ctrl_Load_Efuse_R0();
  uVar2 = _DAT_40007014;
  uVar10 = 0;
  iVar9 = 0;
  *mac = (uint8_t)_DAT_40007014;
  mac[1] = (uint8_t)((uint)uVar2 >> 8);
  mac[3] = (uint8_t)((uint)uVar2 >> 0x18);
  mac[2] = (uint8_t)((uint)uVar2 >> 0x10);
  uVar3 = _DAT_40007018;
  mac[4] = (uint8_t)_DAT_40007018;
  mac[5] = (uint8_t)(uVar3 >> 8);
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar5 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar5;
  } while (iVar9 != 6);
  BVar4 = ERROR;
  if (((uVar3 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar6 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar8 != puVar6);
    BVar4 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_MAC_Address_Slot_Empty(uint8_t slot,uint8_t reload)

{
  uint8_t uVar1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  uint uVar4;
  uint uVar5;
  
  iVar3 = CONCAT31(in_register_0000202d,reload);
  iVar2 = CONCAT31(in_register_00002029,slot);
  if (iVar2 == 0) {
    EF_Ctrl_Sw_AHB_Clk_0();
    uVar4 = _DAT_40007014;
    uVar5 = _DAT_40007018;
    if (iVar3 != 0) {
      EF_Ctrl_Load_Efuse_R0();
      uVar4 = _DAT_40007014;
      uVar5 = _DAT_40007018;
    }
LAB_230543c8:
    uVar1 = '\x01';
    if ((uVar5 & 0x3fffff | uVar4) == 0) goto LAB_230543d4;
  }
  else {
    if (iVar2 == 1) {
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar4 = _DAT_4000706c;
      uVar5 = _DAT_40007070;
      if (iVar3 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar4 = _DAT_4000706c;
        uVar5 = _DAT_40007070;
      }
      goto LAB_230543c8;
    }
    if (iVar2 == 2) {
      EF_Ctrl_Sw_AHB_Clk_0();
      uVar4 = _DAT_40007004;
      uVar5 = _DAT_40007008;
      if (iVar3 != 0) {
        EF_Ctrl_Load_Efuse_R0();
        uVar4 = _DAT_40007004;
        uVar5 = _DAT_40007008;
      }
      goto LAB_230543c8;
    }
  }
  uVar1 = '\0';
LAB_230543d4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_MAC_Address_Opt(uint8_t slot,uint8_t *mac,uint8_t reload)

{
  uint8_t uVar1;
  uint uVar2;
  BL_Err_Type BVar3;
  undefined3 in_register_00002029;
  uint32_t uVar4;
  undefined3 in_register_00002031;
  uint8_t *puVar5;
  undefined4 uVar6;
  uint8_t *puVar7;
  uint8_t *puVar8;
  int iVar9;
  uint uVar10;
  
  uVar10 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar10) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ERROR;
  }
  if (CONCAT31(in_register_00002031,reload) == 0) {
LAB_23054456:
    uVar6 = _DAT_40007014;
    if ((uVar10 == 0) || (uVar6 = _DAT_4000706c, uVar10 == 1)) goto LAB_2305445e;
  }
  else {
    if (uVar10 != 2) {
      EF_Ctrl_Load_Efuse_R0();
      goto LAB_23054456;
    }
    EF_Ctrl_Load_Efuse_R0();
  }
  uVar6 = _DAT_40007004;
LAB_2305445e:
  *mac = (uint8_t)uVar6;
  mac[1] = (uint8_t)((uint)uVar6 >> 8);
  mac[2] = (uint8_t)((uint)uVar6 >> 0x10);
  mac[3] = (uint8_t)((uint)uVar6 >> 0x18);
  uVar2 = _DAT_40007018;
  if ((uVar10 != 0) && (uVar2 = _DAT_40007008, uVar10 == 1)) {
    uVar2 = _DAT_40007070;
  }
  mac[4] = (uint8_t)uVar2;
  mac[5] = (uint8_t)(uVar2 >> 8);
  uVar10 = 0;
  iVar9 = 0;
  do {
    puVar7 = mac + iVar9;
    iVar9 = iVar9 + 1;
    uVar4 = EF_Ctrl_Get_Byte_Zero_Cnt(*puVar7);
    uVar10 = uVar10 + uVar4;
  } while (iVar9 != 6);
  BVar3 = ERROR;
  if (((uVar2 >> 0x10 ^ uVar10) & 0x3f) == 0) {
    puVar5 = mac + 2;
    puVar7 = mac + 5;
    do {
      uVar1 = *mac;
      puVar8 = puVar7 + -1;
      *mac = *puVar7;
      *puVar7 = uVar1;
      mac = mac + 1;
      puVar7 = puVar8;
    } while (puVar5 != puVar8);
    BVar3 = SUCCESS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_CapCode_Slot_Empty(uint8_t slot,uint8_t reload)

{
  bool bVar1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 in_register_0000202d;
  uint uVar3;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_0000202d,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (iVar2 == 0) {
    uVar3 = _DAT_4000700c >> 2;
  }
  else {
    uVar3 = _DAT_40007070;
    if ((iVar2 != 1) && (bVar1 = false, uVar3 = _DAT_40007008, iVar2 != 2)) goto LAB_2305453e;
    uVar3 = uVar3 >> 0x16;
  }
  bVar1 = (uVar3 & 0xff) == 0;
LAB_2305453e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)bVar1;
}



// WARNING: Variable defined which should be unmapped: tmp
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_CapCode_Opt(uint8_t slot,uint8_t *code,uint8_t reload)

{
  BL_Err_Type BVar1;
  uint8_t uVar2;
  undefined3 in_register_00002029;
  uint uVar3;
  undefined3 extraout_var;
  undefined3 in_register_00002031;
  uint uVar4;
  uint32_t tmp;
  
  uVar3 = CONCAT31(in_register_00002029,slot);
  if (2 < uVar3) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ERROR;
  }
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (uVar3 == 0) {
    uVar4 = _DAT_4000700c >> 2;
  }
  else {
    uVar4 = _DAT_40007008;
    if (uVar3 == 1) {
      uVar4 = _DAT_40007070;
    }
    uVar4 = uVar4 >> 0x16;
  }
  if ((uVar4 & 0x80) != 0) {
    uVar2 = EF_Ctrl_Get_Trim_Parity(uVar4 & 0x3f,'\x06');
    if ((uVar4 >> 6 & 1) == CONCAT31(extraout_var,uVar2)) {
      *code = (uint8_t)(uVar4 & 0x3f);
      BVar1 = SUCCESS;
      goto LAB_23054572;
    }
  }
  BVar1 = ERROR;
LAB_23054572:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Is_PowerOffset_Slot_Empty(uint8_t slot,uint8_t reload)

{
  byte bVar1;
  undefined3 in_register_00002029;
  int iVar2;
  undefined3 in_register_0000202d;
  byte bVar3;
  uint uVar4;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_0000202d,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (iVar2 == 0) {
    bVar3 = 1;
    uVar4 = _DAT_40007078 >> 0xf;
  }
  else {
    if (iVar2 == 1) {
      bVar3 = (byte)_DAT_4000700c;
      uVar4 = _DAT_40007074 & 0xffff;
    }
    else {
      if (iVar2 != 2) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return '\0';
      }
      uVar4 = _DAT_40007074 >> 0x10;
      bVar3 = (byte)(_DAT_4000700c >> 1);
    }
    bVar3 = ~bVar3 & 1;
  }
  bVar1 = 0;
  if (uVar4 == 0) {
    bVar1 = bVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)bVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type EF_Ctrl_Read_PowerOffset_Opt(uint8_t slot,int8_t *pwrOffset,uint8_t reload)

{
  uint uVar1;
  int iVar2;
  uint32_t val;
  uint8_t uVar3;
  BL_Err_Type BVar4;
  undefined3 in_register_00002029;
  undefined3 extraout_var;
  uint32_t uVar5;
  undefined3 in_register_00002031;
  byte bVar6;
  uint uVar7;
  
  iVar2 = CONCAT31(in_register_00002029,slot);
  EF_Ctrl_Sw_AHB_Clk_0();
  if (CONCAT31(in_register_00002031,reload) != 0) {
    EF_Ctrl_Load_Efuse_R0();
  }
  if (iVar2 == 0) {
    val = (_DAT_40007078 << 1) >> 0x11;
    uVar1 = _DAT_40007078 >> 0x1f;
    uVar7 = _DAT_40007078 >> 0xf;
LAB_230546a8:
    if (((uVar7 & 1) != 0) &&
       (uVar3 = EF_Ctrl_Get_Trim_Parity(val,'\x0f'), CONCAT31(extraout_var,uVar3) == uVar1)) {
      iVar2 = 0;
      do {
        uVar5 = val;
        __lshrdi3(val);
        bVar6 = (byte)uVar5 & 0x1f;
        if ((uVar5 & 0x10) != 0) {
          bVar6 = bVar6 - 0x20;
        }
        pwrOffset[iVar2] = bVar6;
        iVar2 = iVar2 + 1;
      } while (iVar2 != 3);
      BVar4 = SUCCESS;
      goto LAB_2305470c;
    }
  }
  else {
    if (iVar2 == 1) {
      val = _DAT_40007074 & 0x7fff;
      uVar1 = _DAT_40007074 >> 0xf & 1;
      uVar7 = _DAT_4000700c;
      goto LAB_230546a8;
    }
    if (iVar2 == 2) {
      val = (_DAT_40007074 << 1) >> 0x11;
      uVar1 = _DAT_40007074 >> 0x1f;
      uVar7 = _DAT_4000700c >> 1;
      goto LAB_230546a8;
    }
  }
  BVar4 = ERROR;
LAB_2305470c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar4;
}



int8_t mfg_media_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_xtal_capcode(capcode,reload);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_xtal_capcode(capcode,reload);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int8_t mfg_media_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_poweroffset(pwrOffset,reload);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_poweroffset(pwrOffset,reload);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int8_t mfg_media_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int8_t iVar1;
  
  if (rf_para_on_flash != '\0') {
    iVar1 = mfg_flash_read_macaddr(mac,reload);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  iVar1 = mfg_efuse_read_macaddr(mac,reload);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void bflb_platform_usart_dbg_send(uint8_t *data,uint32_t len)

{
  UART_SendData(UART0_ID,data,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bflb_platform_printf(char *fmt,...)

{
  size_t len;
  undefined4 in_a1;
  undefined4 in_a2;
  undefined4 in_a3;
  undefined4 in_a4;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list ap;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if (uart_dbg_disable == '\0') {
    uStack28 = in_a1;
    uStack24 = in_a2;
    uStack20 = in_a3;
    uStack16 = in_a4;
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    vsnprintf(bflb_platform_printf::print_buf,0x7f,fmt,&uStack28);
    len = strlen(bflb_platform_printf::print_buf);
    bflb_platform_usart_dbg_send((uint8_t *)bflb_platform_printf::print_buf,len);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



undefined8 Default_Handler_Stub(undefined4 param_1)

{
  undefined4 in_ft7;
  
  Default_Handler();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return CONCAT44(in_ft7,param_1);
}



int8_t mfg_efuse_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_CapCode_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0)) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_CapCode_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_CapCode_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_230548d4;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_230548ee;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_230548d4:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_CapCode_Opt((uint8_t)iVar1,capcode,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
LAB_230548ee:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (int8_t)-(iVar1 != 0);
}



int8_t mfg_efuse_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  int iVar4;
  int iVar5;
  char cStack36;
  char cStack35;
  char cStack34;
  int8_t pwrOffsetTmp [3];
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_PowerOffset_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_230549a8;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_23054aca;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_230549a8:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_PowerOffset_Opt((uint8_t)iVar1,&cStack36,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
  memset(pwrOffset,0,0xe);
  *pwrOffset = cStack36;
  pwrOffset[6] = cStack35;
  pwrOffset[0xc] = cStack34;
  iVar4 = (((int)cStack35 - (int)cStack36) * 100) / 6;
  pwrOffset[2] = (char)((iVar4 + 0x19) / 0x32) + cStack36;
  pwrOffset[3] = (char)((iVar4 * 3 + 0x32) / 100) + cStack36;
  pwrOffset[4] = (char)((iVar4 * 4 + 0x32) / 100) + cStack36;
  pwrOffset[1] = (char)((iVar4 + 0x32) / 100) + cStack36;
  iVar5 = (((int)cStack34 - (int)cStack35) * 100) / 6;
  pwrOffset[5] = (char)((iVar4 * 5 + 0x32) / 100) + cStack36;
  pwrOffset[8] = (char)((iVar5 + 0x19) / 0x32) + cStack35;
  pwrOffset[0xb] = (char)((iVar5 * 5 + 0x32) / 100) + cStack35;
  pwrOffset[9] = (char)((iVar5 * 3 + 0x32) / 100) + cStack35;
  pwrOffset[7] = (char)((iVar5 + 0x32) / 100) + cStack35;
  pwrOffset[10] = (char)((iVar5 * 4 + 0x32) / 100) + cStack35;
  pwrOffset[0xd] = (char)((iVar5 * 7 + 0x32) / 100) + cStack35;
LAB_23054aca:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (int8_t)-(iVar1 != 0);
}



int8_t mfg_efuse_read_macaddr(uint8_t *mac,uint8_t reload)

{
  int iVar1;
  uint8_t bclkDiv;
  uint8_t hclkDiv;
  uint8_t uVar2;
  BL_Err_Type BVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  
  bclkDiv = GLB_Get_BCLK_Div();
  hclkDiv = GLB_Get_HCLK_Div();
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_XTAL);
  if ((rf_cal_slots < 3) ||
     (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x02',reload), CONCAT31(extraout_var_00,uVar2) != 0
     )) {
    if ((rf_cal_slots < 2) ||
       (uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\x01',reload), CONCAT31(extraout_var,uVar2) != 0)
       ) {
      if (rf_cal_slots != '\0') {
        uVar2 = EF_Ctrl_Is_MAC_Address_Slot_Empty('\0',reload);
        iVar1 = CONCAT31(extraout_var_01,uVar2);
        if (iVar1 == 0) goto LAB_23054b82;
      }
      printf("No written slot found\r\n");
      iVar1 = 1;
      goto LAB_23054b9c;
    }
    iVar1 = 1;
  }
  else {
    iVar1 = 2;
  }
LAB_23054b82:
  printf("Read slot:%d\r\n",iVar1);
  BVar3 = EF_Ctrl_Read_MAC_Address_Opt((uint8_t)iVar1,mac,reload);
  iVar1 = CONCAT31(extraout_var_02,BVar3);
LAB_23054b9c:
  GLB_Set_System_CLK_Div(hclkDiv,bclkDiv);
  HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_PLL);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (int8_t)-(iVar1 != 0);
}



int8_t mfg_flash_read(void)

{
  BL_Err_Type BVar1;
  undefined3 extraout_var;
  int8_t iVar2;
  
  printf("mfg_flash_read\r\n");
  BVar1 = XIP_SFlash_Read_Need_Lock(pFlashCfg,rf_para_addr,(uint8_t *)&rf_para,0x18);
  iVar2 = '\0';
  if (CONCAT31(extraout_var,BVar1) != 0) {
    printf("Flash write error\r\n");
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int8_t mfg_flash_read_xtal_capcode(uint8_t *capcode,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) &&
      (uVar1 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
      (rf_para.capcode_valid == 'Z')))) {
    iVar2 = '\0';
    *capcode = rf_para.capcode;
  }
  else {
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int8_t mfg_flash_read_poweroffset(int8_t *pwrOffset,uint8_t reload)

{
  int8_t iVar1;
  int8_t iVar2;
  uint32_t uVar3;
  int8_t iVar4;
  undefined3 extraout_var;
  uint32_t uVar5;
  undefined3 in_register_0000202d;
  int iVar6;
  int iVar7;
  int iVar8;
  
  if ((((CONCAT31(in_register_0000202d,reload) == 0) ||
       (iVar4 = mfg_flash_read(), CONCAT31(extraout_var,iVar4) == 0)) &&
      (uVar3 = rf_para.crc32, rf_para.magic == 0x41)) &&
     ((uVar5 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar3 == uVar5 &&
      (rf_para.poweroffset_valid == 'Z')))) {
    memset(pwrOffset,0,0xe);
    iVar2 = rf_para.poweroffset[2];
    iVar1 = rf_para.poweroffset[1];
    iVar4 = rf_para.poweroffset[0];
    iVar8 = (int)rf_para.poweroffset[1];
    iVar6 = (int)rf_para.poweroffset[0];
    iVar7 = (int)rf_para.poweroffset[2];
    *pwrOffset = rf_para.poweroffset[0];
    pwrOffset[6] = iVar1;
    pwrOffset[0xc] = iVar2;
    iVar6 = ((iVar8 - iVar6) * 100) / 6;
    pwrOffset[2] = (char)((iVar6 + 0x19) / 0x32) + iVar4;
    pwrOffset[3] = (char)((iVar6 * 3 + 0x32) / 100) + iVar4;
    pwrOffset[4] = (char)((iVar6 * 4 + 0x32) / 100) + iVar4;
    pwrOffset[1] = (char)((iVar6 + 0x32) / 100) + iVar4;
    iVar7 = ((iVar7 - iVar8) * 100) / 6;
    pwrOffset[5] = iVar4 + (char)((iVar6 * 5 + 0x32) / 100);
    pwrOffset[8] = (char)((iVar7 + 0x19) / 0x32) + iVar1;
    pwrOffset[10] = (char)((iVar7 * 4 + 0x32) / 100) + iVar1;
    pwrOffset[7] = (char)((iVar7 + 0x32) / 100) + iVar1;
    pwrOffset[9] = (char)((iVar7 * 3 + 0x32) / 100) + iVar1;
    pwrOffset[0xb] = (char)((iVar7 * 5 + 0x32) / 100) + iVar1;
    iVar4 = '\0';
    pwrOffset[0xd] = (char)((iVar7 * 7 + 0x32) / 100) + iVar1;
  }
  else {
    iVar4 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int8_t mfg_flash_read_macaddr(uint8_t *mac,uint8_t reload)

{
  uint32_t uVar1;
  int8_t iVar2;
  undefined3 extraout_var;
  uint32_t uVar3;
  undefined3 in_register_0000202d;
  
  if ((CONCAT31(in_register_0000202d,reload) == 0) ||
     (iVar2 = mfg_flash_read(), CONCAT31(extraout_var,iVar2) == 0)) {
    uVar1 = rf_para.crc32;
    if ((rf_para.magic == 0x41) &&
       ((uVar3 = BFLB_Soft_CRC32(&rf_para.capcode_valid,0x10), uVar1 == uVar3 &&
        (rf_para.mac_valid == 'Z')))) {
      memcpy(mac,rf_para.mac,6);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return '\0';
    }
  }
  else {
    printf("mfg_flash_read fail\r\n");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void Bl_F(uchar *digest,uchar *digest1,char *password,uchar *ssid,int ssidlength,int iterations,
         int count,uchar *output)

{
  int iVar1;
  size_t key_len;
  byte *pbVar2;
  uchar *puVar3;
  byte *pbVar4;
  int iVar5;
  int iStack56;
  int tmpLen;
  uchar *pTemp;
  
  key_len = strlen(password);
  iStack56 = ssidlength + 4;
  tmpLen = (int)digest;
  memcpy(digest,ssid,ssidlength);
  puVar3 = digest + ssidlength;
  *puVar3 = (uchar)((uint)count >> 0x18);
  puVar3[1] = (uchar)((uint)count >> 0x10);
  puVar3[2] = (uchar)((uint)count >> 8);
  puVar3[3] = (uchar)count;
  Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest1,0x14);
  memcpy(output,digest1,0x14);
  iVar1 = 1;
  tmpLen = (int)digest1;
  while (iVar1 < iterations) {
    iStack56 = 0x14;
    Bl_hmac_sha1((uchar **)&tmpLen,&iStack56,1,(uchar *)password,key_len,digest,0x14);
    memcpy(digest1,digest,0x14);
    iVar5 = 0;
    do {
      pbVar2 = output + iVar5;
      pbVar4 = digest + iVar5;
      iVar5 = iVar5 + 1;
      *pbVar2 = *pbVar4 ^ *pbVar2;
    } while (iVar5 != 0x14);
    iVar1 = iVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int Bl_PasswordHash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [4];
  uchar digest1 [20];
  uchar digest [36];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(digest1 + 0x10,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl60x_fw_password_hash(char *password,uchar *ssid,int ssidlength,uchar *output)

{
  size_t sVar1;
  int iVar2;
  uchar auStack88 [20];
  uchar auStack68 [48];
  
  sVar1 = strlen(password);
  if (sVar1 < 0x40) {
    iVar2 = -1;
    if (ssidlength < 0x21) {
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,2,output);
      memcpy(output + 0x14,output,0xc);
      Bl_F(auStack68,auStack88,password,ssid,ssidlength,0x1000,1,output);
      iVar2 = 0;
    }
  }
  else {
    iVar2 = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int bl_mtd_open(char *name,bl_mtd_handle_t *handle,uint flags)

{
  char *__dest;
  int iVar1;
  uint32_t uStack40;
  uint32_t addr;
  uint32_t size;
  
  uStack40 = 0;
  addr = 0;
  __dest = (char *)pvPortMalloc(0x20);
  if (__dest == (char *)0x0) {
    iVar1 = -1;
  }
  else {
    memset(__dest,0,0x20);
    strncpy(__dest,name,0x10);
    if ((flags & 1) == 0) {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_active(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_active(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    else {
      if ((flags & 2) == 0) {
        *(undefined4 *)(__dest + 0x1c) = 0;
      }
      else {
        iVar1 = hal_boot2_partition_bus_addr_inactive(name,&uStack40,&addr);
        if ((iVar1 != 0) || (uStack40 == 0)) {
          printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
          printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        *(uint32_t *)(__dest + 0x1c) = uStack40;
      }
      iVar1 = hal_boot2_partition_addr_inactive(name,&uStack40,&addr);
      if ((iVar1 != 0) || (uStack40 == 0)) {
        printf("[MTD] [PART] [XIP] error when get %s partition %d\r\n",name,iVar1);
        printf("[MTD] [PART] [XIP] Dead Loop. Reason: no Valid %s partition found\r\n",name);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
    }
    *(uint32_t *)(__dest + 0x14) = uStack40;
    *(uint32_t *)(__dest + 0x18) = addr;
    puts("[MTD] >>>>>> Hanlde info Dump >>>>>>\r\n");
    printf("      name %s\r\n",__dest);
    printf("      id %d\r\n",*(undefined4 *)(__dest + 0x10));
    printf("      offset %p(%u)\r\n",*(undefined4 *)(__dest + 0x14));
    printf("      size %p(%uKbytes)\r\n",*(uint *)(__dest + 0x18),*(uint *)(__dest + 0x18) >> 10);
    printf("      xip_addr %p\r\n",*(undefined4 *)(__dest + 0x1c));
    puts("[MTD] <<<<<< Hanlde info End <<<<<<\r\n");
    iVar1 = 0;
    *handle = __dest;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int bl_mtd_close(bl_mtd_handle_t handle)

{
  vPortFree(handle);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_mtd_info(bl_mtd_handle_t handle,bl_mtd_info_t *info)

{
  strcpy((char *)info,(char *)handle);
  info->offset = *(uint *)((int)handle + 0x14);
  info->size = *(uint *)((int)handle + 0x18);
  info->xip_addr = *(void **)((int)handle + 0x1c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_mtd_erase(bl_mtd_handle_t handle,uint addr,uint size)

{
  bl_flash_erase(*(int *)((int)handle + 0x14) + addr,size);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_mtd_erase_all(bl_mtd_handle_t handle)

{
  bl_flash_erase(*(uint32_t *)((int)handle + 0x14),*(int *)((int)handle + 0x18));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_mtd_write(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  uint32_t addr_00;
  int iVar1;
  TickType_t TVar2;
  uint __n;
  uint8_t auStack96 [4];
  uint8_t buf_tmp [64];
  
  addr_00 = *(int *)((int)handle + 0x14) + addr;
  iVar1 = bl_sys_isxipaddr((uint32_t)data);
  if (iVar1 == 0) {
    bl_flash_write(addr_00,data,size);
  }
  else {
    if (TrapNetCounter == 0) {
      TVar2 = xTaskGetTickCount();
    }
    else {
      TVar2 = xTaskGetTickCountFromISR();
    }
    bl_printk("[%10u][%s: %s:%4d] addr@%p is xip flash, size %d\r\n",TVar2,&DAT_23081ce8,"bl_mtd.c",
              0xc9,data,size);
    while (size != 0) {
      __n = size;
      if (0x40 < size) {
        __n = 0x40;
      }
      memcpy(auStack96,data,__n);
      bl_flash_write(addr_00,auStack96,__n);
      addr_00 = addr_00 + __n;
      data = data + __n;
      size = size - __n;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bl_mtd_read(bl_mtd_handle_t handle,uint addr,uint size,uint8_t *data)

{
  bl_flash_read(*(int *)((int)handle + 0x14) + addr,data,size);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bloop_init(loop_ctx *loop)

{
  loop_evt_handler_statistic *list;
  loop_evt_handler_statistic *plVar1;
  
  memset(loop,0,0x4a0);
  list = (loop_evt_handler_statistic *)loop->list;
  do {
    plVar1 = (loop_evt_handler_statistic *)&list->time_accumulated;
    utils_list_init((utils_list *)list);
    list = plVar1;
  } while (plVar1 != loop->statistic);
  (loop->timer_dlist).next = (utils_dlist_s *)&loop->timer_dlist;
  (loop->timer_dlist).prev = (utils_dlist_s *)&loop->timer_dlist;
  (loop->timer_dued).next = (utils_dlist_s *)&loop->timer_dued;
  (loop->timer_dued).prev = (utils_dlist_s *)&loop->timer_dued;
  printf("=== %d task inited\r\n",0x20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int bloop_handler_register(loop_ctx *loop,loop_evt_handler *handler,int priority)

{
  if (((uint)priority < 0x20) && ((loop->evt_type_map_async + priority + -4)[0x104] == 0)) {
    (loop->evt_type_map_async + priority + -4)[0x104] = (uint32_t)handler;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



void bloop_timer_init(loop_timer *timer,int use_auto_free)

{
  memset(timer,0,0x24);
  (timer->dlist_item).prev = (utils_dlist_s *)timer;
  (timer->dlist_item).next = (utils_dlist_s *)timer;
  timer->flags = (use_auto_free != 0) << 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_timer_configure
               (loop_timer *timer,uint delay_ms,
               anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr *cb,void *arg,int idx_task,
               uint32_t evt_type_map)

{
  TickType_t TVar1;
  
  TVar1 = xTaskGetTickCount();
  timer->time_added = TVar1;
  timer->time_target = TVar1 + delay_ms;
  timer->cb = (anon_subr_void_loop_ctx_ptr_loop_timer_ptr_void_ptr_for_cb *)cb;
  timer->arg = arg;
  timer->idx_task = idx_task;
  timer->evt_type_map = evt_type_map;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_timer_repeat_enable(loop_timer *timer)

{
  timer->flags = timer->flags | 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_timer_repeat_reconfigure(loop_timer *timer)

{
  uint uVar1;
  uint uVar2;
  TickType_t TVar3;
  
  uVar1 = timer->time_target;
  uVar2 = timer->time_added;
  TVar3 = xTaskGetTickCount();
  timer->time_target = (uVar1 - uVar2) + TVar3;
  timer->time_added = TVar3;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_timer_register(loop_ctx *loop,loop_timer *timer)

{
  utils_dlist_s *puVar1;
  utils_dlist_s *puVar2;
  utils_dlist_s *puVar3;
  utils_dlist_s *puVar4;
  utils_dlist_s *puVar5;
  
  puVar2 = (loop->timer_dlist).next;
  puVar3 = (utils_dlist_s *)&loop->timer_dlist;
  if (puVar3 == puVar2) {
    (timer->dlist_item).next = puVar3;
    (timer->dlist_item).prev = puVar3;
    (loop->timer_dlist).next = (utils_dlist_s *)timer;
    (loop->timer_dlist).prev = (utils_dlist_s *)timer;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  puVar1 = puVar2;
  puVar5 = (utils_dlist_s *)0x0;
  do {
    puVar4 = puVar1;
    if (puVar3 == puVar4) {
LAB_230553be:
      puVar2 = puVar5->next;
      (timer->dlist_item).prev = puVar5;
      (timer->dlist_item).next = puVar2;
      puVar5->next = (utils_dlist_s *)timer;
      puVar2->prev = (utils_dlist_s *)timer;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return;
    }
    if ((int)(timer->time_target - (int)puVar4[2].prev) < 1) {
      if (puVar5 == (utils_dlist_s *)0x0) {
        (timer->dlist_item).next = puVar2;
        (timer->dlist_item).prev = puVar3;
        (loop->timer_dlist).next = (utils_dlist_s *)timer;
        puVar2->prev = (utils_dlist_s *)timer;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return;
      }
      goto LAB_230553be;
    }
    puVar1 = puVar4->next;
    puVar5 = puVar4;
  } while( true );
}



void bloop_wait_startup(loop_ctx *loop)

{
  while (loop->looper == (TaskHandle_t)0x0) {
    vTaskDelay(1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_evt_set_async(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x15a);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  vTaskEnterCritical();
  loop->bitmap_evt_async = loop->bitmap_evt_async | 1 << (evt & 0x1f);
  (loop->evt_type_map_async + (evt - 4))[4] = (loop->evt_type_map_async + (evt - 4))[4] | evt_map;
  vTaskExitCritical();
  xTaskGenericNotify(loop->looper,0,eIncrement,(uint32_t *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_evt_set_sync(loop_ctx *loop,uint evt,uint32_t evt_map)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x177);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = loop->bitmap_evt_sync | 1 << (evt & 0x1f);
  (loop->evt_type_map_async + (evt - 4))[4] = (loop->evt_type_map_async + (evt - 4))[4] | evt_map;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void bloop_evt_unset_sync(loop_ctx *loop,uint evt)

{
  if (0x1f < evt) {
    printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x17f);
    do {
                    // WARNING: Do nothing block with infinite loop
    } while( true );
  }
  loop->bitmap_evt_sync = ~(1 << (evt & 0x1f)) & loop->bitmap_evt_sync;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int bloop_run(loop_ctx *loop)

{
  loop_timer *plVar1;
  loop_timer *timer;
  TaskHandle_t ptVar2;
  TickType_t TVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  int iVar6;
  int iVar7;
  utils_list_hdr *puVar8;
  utils_dlist_s *puVar9;
  loop_evt_handler *plVar10;
  uint uVar11;
  uint uVar12;
  utils_dlist_t *puVar13;
  utils_dlist_s *puVar14;
  utils_dlist_s *puVar15;
  loop_ctx *plVar16;
  loop_timer *plVar17;
  utils_dlist_t *puVar18;
  
  ptVar2 = xTaskGetCurrentTaskHandle();
  loop->looper = ptVar2;
LAB_230554f2:
  do {
    puVar18 = &loop->timer_dlist;
    while( true ) {
      vTaskEnterCritical();
      uVar11 = loop->bitmap_evt_async;
      loop->bitmap_evt_async = 0;
      loop->bitmap_evt_sync = loop->bitmap_evt_sync | uVar11;
      vTaskExitCritical();
      if (loop->bitmap_evt_sync != 0) break;
      puVar13 = (utils_dlist_t *)(loop->timer_dlist).next;
      puVar9 = (utils_dlist_s *)0xffffffff;
      if (puVar13 != puVar18) {
        puVar9 = puVar13[2].prev;
        TVar3 = xTaskGetTickCount();
        puVar9 = (utils_dlist_s *)((int)puVar9 - TVar3);
        if ((int)puVar9 < 1) break;
      }
      ulTaskNotifyTake(1,(TickType_t)puVar9);
    }
    if ((utils_dlist_t *)(loop->timer_dlist).next != puVar18) {
      TVar3 = xTaskGetTickCount();
      puVar13 = (utils_dlist_t *)(loop->timer_dlist).next;
      puVar9 = (utils_dlist_s *)0x0;
      if (puVar13 != (utils_dlist_t *)0x0) {
        puVar9 = (&puVar13->prev)[1];
      }
      while ((puVar14 = puVar9, puVar13 != puVar18 && (-1 < (int)(TVar3 - (int)puVar13[2].prev)))) {
        bloop_evt_set_sync(loop,(uint)puVar13[2].next,(uint32_t)puVar13[3].prev);
        if (puVar13[3].next != (utils_dlist_s *)0x0) {
          (*(code *)puVar13[3].next)(loop,puVar13,puVar13[4].prev);
        }
        puVar15 = (&puVar13->prev)[1];
        puVar9 = puVar13->prev;
        puVar9->next = puVar15;
        puVar15->prev = puVar9;
        puVar9 = (loop->timer_dued).next;
        puVar13->prev = (utils_dlist_s *)(loop_timer *)&loop->timer_dued;
        (&puVar13->prev)[1] = puVar9;
        (loop->timer_dued).next = (utils_dlist_s *)puVar13;
        puVar9->prev = (utils_dlist_s *)puVar13;
        puVar13 = (utils_dlist_t *)puVar14;
        puVar9 = (utils_dlist_s *)0x0;
        if (puVar14 != (utils_dlist_s *)0x0) {
          puVar9 = (&puVar14->prev)[1];
        }
      }
      timer = (loop_timer *)(loop->timer_dued).next;
      plVar1 = (loop_timer *)0x0;
      if (timer != (loop_timer *)0x0) {
        plVar1 = (loop_timer *)(timer->dlist_item).next;
      }
      while (plVar17 = plVar1, timer != (loop_timer *)&loop->timer_dued) {
        puVar9 = (timer->dlist_item).prev;
        puVar14 = (timer->dlist_item).next;
        puVar9->next = puVar14;
        puVar14->prev = puVar9;
        if ((timer->flags & 2) == 0) {
          if ((timer->flags & 1) != 0) {
            if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
               (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
              if (TrapNetCounter == 0) {
                TVar3 = xTaskGetTickCount();
              }
              else {
                TVar3 = xTaskGetTickCountFromISR();
              }
              bl_printk("[%10u][%s: %s:%4d] Repeat timer\r\n",TVar3,"DEBUG ","bloop_base.c",0xbb);
            }
            bloop_timer_repeat_reconfigure(timer);
            bloop_timer_register(loop,timer);
          }
        }
        else {
          if ((_fsymc_level_bloop < BLOG_LEVEL_INFO) &&
             (_fsymf_level_bloopbloop_base < BLOG_LEVEL_INFO)) {
            if (TrapNetCounter == 0) {
              TVar3 = xTaskGetTickCount();
            }
            else {
              TVar3 = xTaskGetTickCountFromISR();
            }
            bl_printk("[%10u][%s: %s:%4d] Free now\r\n",TVar3,"DEBUG ","bloop_base.c",0xb8);
          }
          vPortFree(timer);
        }
        timer = plVar17;
        plVar1 = (loop_timer *)0x0;
        if (plVar17 != (loop_timer *)0x0) {
          plVar1 = (loop_timer *)(plVar17->dlist_item).next;
        }
      }
    }
    iVar6 = __clzsi2(loop->bitmap_evt_sync);
    iVar7 = __clzsi2(loop->bitmap_msg);
    if (iVar6 <= iVar7) {
      uVar11 = -iVar6 + 0x1f;
      if (uVar11 != 0xffffffff) {
        plVar16 = (loop_ctx *)(uVar11 * 4 + (int)loop);
        plVar10 = plVar16->handlers[0];
        if (plVar10 == (loop_evt_handler *)0x0) {
          printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x105);
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        vTaskEnterCritical();
        uVar12 = plVar16->evt_type_map_async[0];
        plVar16->evt_type_map_async[0] = 0;
        plVar16->evt_type_map_sync[0] = plVar16->evt_type_map_sync[0] | uVar12;
        vTaskExitCritical();
        uVar4 = bl_timer_now_us();
        (*plVar10->evt)(loop,plVar10,&loop->bitmap_evt_sync,
                        (uint32_t *)((-iVar6 + 0x43) * 4 + (int)loop));
        uVar5 = bl_timer_now_us();
        plVar16 = (loop_ctx *)(uVar11 * 0x10 + (int)loop);
        uVar12 = uVar5 - uVar4;
        plVar16->statistic[0].time_consumed = uVar12;
        plVar16->statistic[0].time_accumulated = plVar16->statistic[0].time_accumulated + uVar12;
        if (plVar16->statistic[0].time_max < uVar12) {
          plVar16->statistic[0].time_max = uVar12;
        }
        plVar16->statistic[0].count_triggered = plVar16->statistic[0].count_triggered + 1;
        bloop_evt_unset_sync(loop,uVar11);
        goto LAB_230554f2;
      }
    }
    if ((-iVar7 != -0x20) &&
       (puVar8 = utils_list_pop_front((utils_list *)((-iVar7 + 0x41) * 8 + (int)loop)),
       puVar8 == (utils_list_hdr *)0x0)) {
      printf("[ASSERT] [ERR] %s:%d\r\n","bloop_base.c",0x124);
      do {
                    // WARNING: Do nothing block with infinite loop
      } while( true );
    }
  } while( true );
}



int bloop_status_dump(loop_ctx *loop)

{
  loop_evt_handler_statistic *plVar1;
  utils_dlist_s *puVar2;
  uint32_t *puVar3;
  TickType_t TVar4;
  char *pcVar5;
  uint32_t uVar6;
  int iVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  
  puts("====== bloop dump ======\r\n");
  printf("  bitmap_evt %lx\r\n",loop->bitmap_evt_sync);
  printf("  bitmap_msg %lx\r\n",loop->bitmap_msg);
  TVar4 = xTaskGetTickCount();
  puts("--->>> timer list:\r\n");
  puVar2 = (loop->timer_dlist).next;
  iVar7 = 0;
  while ((utils_dlist_s *)&loop->timer_dlist != puVar2) {
    printf("    timer[%02d]: %u(diff %d)ms, \t\t task idx %02d, evt map %08lx, ptr %p\r\n",iVar7,
           puVar2[2].prev,TVar4 - (int)puVar2[2].prev,puVar2[2].next,puVar2[3].prev,puVar2[3].next);
    iVar7 = iVar7 + 1;
    puVar2 = puVar2->next;
  }
  puVar3 = loop->evt_type_map_async + 0x1f;
  printf("  %d task:\r\n",0x20);
  plVar1 = loop->statistic + 0x1f;
  iVar7 = 0x1f;
  do {
    pcVar5 = "empty";
    if ((char **)puVar3[0x100] != (char **)0x0) {
      pcVar5 = *(char **)puVar3[0x100];
    }
    printf("    task[%02d] : %s\r\n",iVar7,pcVar5);
    uVar8 = puVar3[0x100];
    if (uVar8 != 0) {
      uVar6 = puVar3[0x20];
      uVar9 = *puVar3;
      printf("      evt handler %p,",*(undefined4 *)(uVar8 + 4));
      printf(" msg handler %p,",*(undefined4 *)(uVar8 + 8));
      printf(" trigged cnt %u,",plVar1->count_triggered);
      printf(" bitmap async %lx sync %lx,",uVar9,uVar6);
      printf(" time consumed %dus acc %dms, max %uus\r\n",plVar1->time_consumed,
             plVar1->time_accumulated / 1000,plVar1->time_max);
    }
    iVar7 = iVar7 + -1;
    puVar3 = puVar3 + -1;
    plVar1 = plVar1 + -1;
  } while (iVar7 != -1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int loop_evt_entity_sys_handler(loop_ctx *loop,loop_evt_handler *handler,loop_msg *msg)

{
  printf(
         "[SYS] [MSG] called with msg info\r\n    priority %u\r\n    dst %u\r\n    msgid %u\r\n    src %u\r\n    arg1 %p\r\n    arg2 %p\r\n"
         ,(uint)*(byte *)&msg->u,(uint)*(byte *)((int)&msg->u + 1),(uint)*(byte *)((int)&msg->u + 2)
         ,(uint)*(byte *)((int)&msg->u + 3),msg->arg1,msg->arg2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int loop_evt_entity_sys_evt
              (loop_ctx *loop,loop_evt_handler *handler,uint32_t *bitmap_evt,uint32_t *evt_type_map)

{
  uint uVar1;
  
  uVar1 = *evt_type_map;
  printf("[SYS] [EVT] called with bitmap_evt %08lx, bitmap_task %08lx\r\n",*bitmap_evt,uVar1);
  do {
    if ((uVar1 & 1) == 0) {
      if (uVar1 != 0) {
        printf("[ASSERT] [ERR] %s:%d\r\n","bloop_handler_sys.c",0x2e);
        do {
                    // WARNING: Do nothing block with infinite loop
        } while( true );
      }
      break;
    }
    uVar1 = uVar1 & 0xfffffffe;
    bloop_status_dump(loop);
  } while (uVar1 != 0);
  *evt_type_map = 0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Removing unreachable block (ram,0x2305597c)

int * misaligned_load_trap(int *param_1,uint *param_2)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  undefined *puVar4;
  undefined *puVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  undefined *in_mtval;
  int local_8;
  
  if (((uint)param_2 & 2) == 0) {
    uVar3 = *param_2;
    if ((uVar3 & 3) != 3) {
      uVar3 = uVar3 & 0xffff;
    }
  }
  else {
    uVar3 = (uint)*(ushort *)param_2;
    if ((uVar3 & 3) == 3) {
      uVar3 = (uint)*(ushort *)param_2;
    }
  }
  iVar8 = 4;
  if ((uVar3 & 3) != 3) {
    iVar8 = 2;
  }
  uVar2 = uVar3 & 0x707f;
  if (uVar2 == 0x2003) {
LAB_23055a46:
    iVar6 = 4;
    bVar1 = false;
    iVar7 = 0;
  }
  else {
    if (uVar2 != 0x2007) {
      if (uVar2 == 0x1003) {
        iVar6 = 2;
        bVar1 = false;
        iVar7 = 0x10;
        goto LAB_230559d4;
      }
      if (uVar2 == 0x5003) {
        iVar6 = 2;
        bVar1 = false;
        iVar7 = 0;
        goto LAB_230559d4;
      }
      uVar2 = uVar3 & 0xe003;
      if (uVar2 == 0x4000) {
        uVar3 = ((uVar3 >> 2 & 7) + 8) * 0x80;
        iVar6 = 4;
        bVar1 = false;
        iVar7 = 0;
        goto LAB_230559d4;
      }
      if (uVar2 == 0x4002) {
        if ((uVar3 >> 7 & 0x1f) == 0) {
code_r0x230559ca:
          ebreak();
          do {
                    // WARNING: Do nothing block with infinite loop
          } while( true );
        }
        goto LAB_23055a46;
      }
      if (uVar2 == 0x6000) {
        uVar3 = ((uVar3 >> 2 & 7) + 8) * 0x80;
        iVar6 = 4;
        bVar1 = true;
        iVar7 = 0;
        goto LAB_230559d4;
      }
      if (uVar2 != 0x6002) goto code_r0x230559ca;
    }
    iVar6 = 4;
    bVar1 = true;
    iVar7 = 0;
  }
LAB_230559d4:
  local_8 = 0;
  puVar4 = in_mtval;
  do {
    puVar5 = puVar4 + 1;
    (puVar4 + -(int)in_mtval)[(int)&local_8] = *puVar4;
    puVar4 = puVar5;
  } while (in_mtval + iVar6 != puVar5);
  if (bVar1) {
    param_1[(uVar3 >> 7 & 0x1f) + 1] = local_8;
    *param_1 = iVar8 + (int)param_2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return param_1;
  }
  *(int *)((int)param_1 + (uVar3 >> 5 & 0x7c) + 0x7c) = (local_8 << iVar7) >> iVar7;
  *param_1 = iVar8 + (int)param_2;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1;
}



// WARNING: Removing unreachable block (ram,0x23055b40)

uint misaligned_store_trap(int *param_1,uint *param_2)

{
  byte bVar1;
  int *piVar2;
  uint uVar3;
  undefined4 *puVar4;
  int iVar5;
  uint uVar6;
  undefined4 *puVar7;
  int iVar8;
  int in_mtval;
  undefined4 local_8 [2];
  
  if (((uint)param_2 & 2) == 0) {
    uVar6 = *param_2;
    if ((uVar6 & 3) != 3) {
      uVar6 = uVar6 & 0xffff;
    }
  }
  else {
    uVar6 = (uint)*(ushort *)param_2;
    if ((uVar6 & 3) == 3) {
      uVar6 = CONCAT22(*(undefined2 *)((int)param_2 + 2),*(ushort *)param_2);
    }
  }
  iVar8 = 4;
  if ((uVar6 & 3) != 3) {
    iVar8 = 2;
  }
  piVar2 = param_1 + 0x1f;
  local_8[0] = *(undefined4 *)((uVar6 >> 0x12 & 0x7c) + (int)piVar2);
  uVar3 = uVar6 & 0x707f;
  iVar8 = iVar8 + (int)param_2;
  if (uVar3 == 0x2023) {
    iVar5 = 4;
  }
  else {
    if (uVar3 == 0x2027) {
      iVar5 = 4;
      local_8[0] = (*(get_f32_reg + (uVar6 >> 0x11 & 0xf8)))();
    }
    else {
      if (uVar3 == 0x1023) {
        iVar5 = 2;
      }
      else {
        uVar3 = uVar6 & 0xe003;
        if (uVar3 == 0xc000) {
          iVar5 = 4;
          local_8[0] = *(undefined4 *)((int)piVar2 + (uVar6 & 0x1c) + 0x20);
        }
        else {
          if (uVar3 == 0xc002) {
            if ((uVar6 >> 7 & 0x1f) == 0) {
code_r0x23055b28:
              ebreak();
              do {
                    // WARNING: Do nothing block with infinite loop
              } while( true );
            }
            iVar5 = 4;
            local_8[0] = *(undefined4 *)((uVar6 & 0x7c) + (int)piVar2);
          }
          else {
            if (uVar3 == 0xe000) {
              iVar5 = 4;
              local_8[0] = (*(get_f32_reg + ((uVar6 >> 2 & 7) + 8) * 8))();
            }
            else {
              if (uVar3 != 0xe002) goto code_r0x23055b28;
              iVar5 = 4;
              local_8[0] = (*(get_f32_reg + (uVar6 & 0x7c) * 2))();
            }
          }
        }
      }
    }
  }
  puVar7 = local_8;
  puVar4 = (undefined4 *)(iVar5 + (int)puVar7);
  iVar5 = in_mtval - (int)puVar7;
  do {
    bVar1 = *(byte *)puVar7;
    *(byte *)(iVar5 + (int)puVar7) = bVar1;
    puVar7 = (undefined4 *)((int)puVar7 + 1);
  } while (puVar4 != puVar7);
  *param_1 = iVar8;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)bVar1;
}



void get_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x23055bd2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void put_f32_reg(void)

{
  uint in_t0;
  
                    // WARNING: Could not recover jumptable at 0x23055cd2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(in_t0 & 0xfffffffe))();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int backtrace_riscv(anon_subr_int_char_ptr_varargs *print_func,uintptr_t *regs)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



// WARNING: Variable defined which should be unmapped: addr

void set_if(netif *netif,char *ip_addr,char *gw_addr,char *nm_addr)

{
  int iVar1;
  ip4_addr_t iStack20;
  ip4_addr_t addr;
  
  if ((ip_addr != (char *)0x0) && (iVar1 = ip4addr_aton(ip_addr,&iStack20), iVar1 != 0)) {
    netif_set_ipaddr(netif,&iStack20);
  }
  if ((gw_addr != (char *)0x0) && (iVar1 = ip4addr_aton(gw_addr,&iStack20), iVar1 != 0)) {
    netif_set_gw(netif,&iStack20);
  }
  if ((nm_addr != (char *)0x0) && (iVar1 = ip4addr_aton(nm_addr,&iStack20), iVar1 != 0)) {
    netif_set_netmask(netif,&iStack20);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: buf
// WARNING: Could not reconcile some variable overlaps

int block_cipher_df(uchar *output,uchar *data,size_t data_len)

{
  uchar *__dest;
  uchar *puVar1;
  byte *pbVar2;
  byte *pbVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint32_t *puVar8;
  byte local_338 [4];
  uchar chain [16];
  uchar key [32];
  uchar tmp [48];
  mbedtls_aes_context aes_ctx;
  uchar buf [416];
  
  if (data_len < 0x181) {
    memset(aes_ctx.buf + 0x43,0,0x1a0);
    mbedtls_aes_init((mbedtls_aes_context *)(tmp + 0x2c));
    buf._14_2_ = (ushort)(data_len << 8) | (ushort)(data_len >> 8) & 0xff;
    buf[19] = '0';
    buf._12_2_ = 0;
    memcpy(buf + 0x14,data,data_len);
    buf[data_len + 0x14] = -0x80;
    iVar4 = 0;
    do {
      chain[iVar4 + 0xc] = (uchar)iVar4;
      iVar4 = iVar4 + 1;
    } while (iVar4 != 0x20);
    mbedtls_aes_setkey_enc((mbedtls_aes_context *)(tmp + 0x2c),chain + 0xc,0x100);
    iVar4 = 0;
    do {
      memset(local_338,0,0x10);
      puVar8 = aes_ctx.buf + 0x43;
      uVar7 = data_len + 0x19;
      do {
        iVar5 = 0;
        pbVar3 = local_338;
        do {
          pbVar2 = (byte *)((int)puVar8 + iVar5);
          iVar5 = iVar5 + 1;
          *pbVar3 = *pbVar2 ^ *pbVar3;
          pbVar3 = pbVar3 + 1;
        } while (iVar5 != 0x10);
        puVar8 = puVar8 + 4;
        uVar6 = uVar7;
        if (0x10 < uVar7) {
          uVar6 = 0x10;
        }
        uVar7 = uVar7 - uVar6;
        mbedtls_aes_crypt_ecb((mbedtls_aes_context *)(tmp + 0x2c),1,local_338,local_338);
      } while (uVar7 != 0);
      memcpy(key + iVar4 + 0x1c,local_338,0x10);
      iVar4 = iVar4 + 0x10;
      aes_ctx.buf[67]._3_1_ = aes_ctx.buf[67]._3_1_ + '\x01';
    } while (iVar4 != 0x30);
    mbedtls_aes_setkey_enc((mbedtls_aes_context *)(tmp + 0x2c),key + 0x1c,0x100);
    __dest = output;
    do {
      mbedtls_aes_crypt_ecb((mbedtls_aes_context *)(tmp + 0x2c),1,tmp + 0x1c,tmp + 0x1c);
      puVar1 = __dest + 0x10;
      memcpy(__dest,tmp + 0x1c,0x10);
      __dest = puVar1;
    } while (output + 0x30 != puVar1);
    mbedtls_aes_free((mbedtls_aes_context *)(tmp + 0x2c));
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x38;
}



// WARNING: Variable defined which should be unmapped: tmp

int ctr_drbg_update_internal(mbedtls_ctr_drbg_context *ctx,uchar *data)

{
  bool bVar1;
  byte *pbVar2;
  mbedtls_ctr_drbg_context *pmVar3;
  byte *pbVar4;
  uchar uVar5;
  int iVar6;
  byte local_50 [4];
  uchar tmp [48];
  
  iVar6 = 0;
  memset(local_50,0,0x30);
  do {
    pbVar2 = local_50 + iVar6;
    pmVar3 = (mbedtls_ctr_drbg_context *)(ctx->counter + 0xf);
    do {
      uVar5 = pmVar3->counter[0] + '\x01';
      pmVar3->counter[0] = uVar5;
      if (uVar5 != '\0') break;
      bVar1 = ctx != pmVar3;
      pmVar3 = (mbedtls_ctr_drbg_context *)((int)&pmVar3[-1].p_entropy + 3);
    } while (bVar1);
    iVar6 = iVar6 + 0x10;
    mbedtls_aes_crypt_ecb(&ctx->aes_ctx,1,(uchar *)ctx,pbVar2);
    if (iVar6 == 0x30) {
      iVar6 = 0;
      pbVar2 = local_50;
      do {
        pbVar4 = data + iVar6;
        iVar6 = iVar6 + 1;
        *pbVar2 = *pbVar4 ^ *pbVar2;
        pbVar2 = pbVar2 + 1;
      } while (iVar6 != 0x30);
      mbedtls_aes_setkey_enc(&ctx->aes_ctx,local_50,0x100);
      memcpy(ctx,tmp + 0x1c,0x10);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
  } while( true );
}



void mbedtls_ctr_drbg_init(mbedtls_ctr_drbg_context *ctx)

{
  memset(ctx,0,0x140);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ctr_drbg_free(mbedtls_ctr_drbg_context *ctx)

{
  mbedtls_ctr_drbg_context *pmVar1;
  
  if (ctx != (mbedtls_ctr_drbg_context *)0x0) {
    mbedtls_aes_free(&ctx->aes_ctx);
    pmVar1 = ctx + 1;
    while (ctx != pmVar1) {
      ctx->counter[0] = '\0';
      ctx = (mbedtls_ctr_drbg_context *)(ctx->counter + 1);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ctr_drbg_reseed(mbedtls_ctr_drbg_context *ctx,uchar *additional,size_t len)

{
  int iVar1;
  size_t data_len;
  uchar auStack416 [4];
  uchar seed [384];
  
  iVar1 = -0x38;
  if ((ctx->entropy_len < 0x181) && (iVar1 = -0x38, len <= 0x180 - ctx->entropy_len)) {
    memset(auStack416,0,0x180);
    iVar1 = (*ctx->f_entropy)(ctx->p_entropy,auStack416,ctx->entropy_len);
    if (iVar1 == 0) {
      data_len = ctx->entropy_len;
      if ((additional != (uchar *)0x0) && (len != 0)) {
        memcpy(auStack416 + data_len,additional,len);
        data_len = data_len + len;
      }
      block_cipher_df(auStack416,auStack416,data_len);
      ctr_drbg_update_internal(ctx,auStack416);
      ctx->reseed_counter = 1;
    }
    else {
      iVar1 = -0x34;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ctr_drbg_seed_entropy_len
              (mbedtls_ctr_drbg_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_entropy,
              void *p_entropy,uchar *custom,size_t len,size_t entropy_len)

{
  int iVar1;
  uchar auStack64 [4];
  uchar key [32];
  
  memset(auStack64,0,0x20);
  mbedtls_aes_init(&ctx->aes_ctx);
  ctx->f_entropy = (mbedtls_ssl_recv_t *)f_entropy;
  ctx->p_entropy = p_entropy;
  ctx->entropy_len = entropy_len;
  ctx->reseed_interval = 10000;
  mbedtls_aes_setkey_enc(&ctx->aes_ctx,auStack64,0x100);
  iVar1 = mbedtls_ctr_drbg_reseed(ctx,custom,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ctr_drbg_seed
              (mbedtls_ctr_drbg_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_entropy,
              void *p_entropy,uchar *custom,size_t len)

{
  int iVar1;
  
  iVar1 = mbedtls_ctr_drbg_seed_entropy_len(ctx,f_entropy,p_entropy,custom,len,0x20);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: add_input

int mbedtls_ctr_drbg_random_with_add
              (void *p_rng,uchar *output,size_t output_len,uchar *additional,size_t add_len)

{
  bool bVar1;
  char cVar2;
  int iVar3;
  char *pcVar4;
  uint __n;
  uchar auStack96 [4];
  uchar tmp [16];
  uchar add_input [48];
  
  if (output_len < 0x401) {
    iVar3 = -0x38;
    if (add_len < 0x101) {
      memset(tmp + 0xc,0,0x30);
      if ((*(int *)((int)p_rng + 0x1c) < *(int *)((int)p_rng + 0x10)) ||
         (*(int *)((int)p_rng + 0x14) != 0)) {
        iVar3 = mbedtls_ctr_drbg_reseed((mbedtls_ctr_drbg_context *)p_rng,additional,add_len);
        if (iVar3 != 0) goto LAB_230561f0;
      }
      else {
        if (add_len != 0) {
          block_cipher_df(tmp + 0xc,additional,add_len);
          ctr_drbg_update_internal((mbedtls_ctr_drbg_context *)p_rng,tmp + 0xc);
        }
      }
      while (pcVar4 = (char *)((int)p_rng + 0xf), output_len != 0) {
        do {
          cVar2 = *pcVar4;
          *pcVar4 = cVar2 + '\x01';
          if ((char)(cVar2 + '\x01') != '\0') break;
          bVar1 = (char *)p_rng != pcVar4;
          pcVar4 = pcVar4 + -1;
        } while (bVar1);
        mbedtls_aes_crypt_ecb((mbedtls_aes_context *)((int)p_rng + 0x20),1,(uchar *)p_rng,auStack96)
        ;
        __n = output_len;
        if (0x10 < output_len) {
          __n = 0x10;
        }
        memcpy(output,auStack96,__n);
        output = output + __n;
        output_len = output_len - __n;
      }
      ctr_drbg_update_internal((mbedtls_ctr_drbg_context *)p_rng,tmp + 0xc);
      iVar3 = 0;
      *(int *)((int)p_rng + 0x10) = *(int *)((int)p_rng + 0x10) + 1;
    }
  }
  else {
    iVar3 = -0x36;
  }
LAB_230561f0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_ctr_drbg_random(void *p_rng,uchar *output,size_t output_len)

{
  int iVar1;
  
  iVar1 = mbedtls_ctr_drbg_random_with_add(p_rng,output,output_len,(uchar *)0x0,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int entropy_update(mbedtls_entropy_context *ctx,uchar source_id,uchar *data,size_t len)

{
  uchar uStack68;
  undefined uStack67;
  uchar header [2];
  uchar tmp [32];
  
  if (0x20 < len) {
    mbedtls_sha256(data,len,header,0);
    data = header;
    len = 0x20;
  }
  uStack67 = (undefined)len;
  uStack68 = source_id;
  mbedtls_sha256_update((mbedtls_sha256_context *)ctx,&uStack68,2);
  mbedtls_sha256_update((mbedtls_sha256_context *)ctx,data,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int entropy_gather_internal(mbedtls_entropy_context *ctx)

{
  bool bVar1;
  mbedtls_entropy_source_state *pmVar2;
  int iVar3;
  int iVar4;
  size_t local_a4;
  size_t olen;
  uchar buf [128];
  
  pmVar2 = ctx->source;
  bVar1 = false;
  iVar3 = 0;
  while( true ) {
    if (ctx->source_count <= iVar3) {
      iVar3 = 0;
      if (!bVar1) {
        iVar3 = -0x3d;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar3;
    }
    if (pmVar2->strong == 1) {
      bVar1 = true;
    }
    local_a4 = 0;
    iVar4 = (*pmVar2->f_source)(pmVar2->p_source,(uchar *)&olen,0x80,&local_a4);
    if (iVar4 != 0) break;
    if (local_a4 != 0) {
      entropy_update(ctx,(uchar)iVar3,(uchar *)&olen,local_a4);
      pmVar2->size = pmVar2->size + local_a4;
    }
    iVar3 = iVar3 + 1;
    pmVar2 = pmVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



void mbedtls_entropy_init(mbedtls_entropy_context *ctx)

{
  int iVar1;
  mbedtls_entropy_source_state *pmVar2;
  
  memset(ctx,0,0x208);
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,0);
  iVar1 = ctx->source_count;
  if (iVar1 < 0x14) {
    pmVar2 = ctx->source + iVar1 + -6;
    pmVar2[6].f_source = mbedtls_platform_entropy_poll;
    pmVar2[6].threshold = 0x20;
    pmVar2[6].p_source = (void *)0x0;
    pmVar2[6].strong = 1;
    ctx->source_count = iVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_entropy_free(mbedtls_entropy_context *ctx)

{
  mbedtls_entropy_context *pmVar1;
  
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)(ctx->accumulator).total = 0;
    ctx = (mbedtls_entropy_context *)((int)(ctx->accumulator).total + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_entropy_func(void *data,uchar *output,size_t len)

{
  bool bVar1;
  int iVar2;
  int iVar3;
  uint *puVar4;
  uint *puVar5;
  int iVar6;
  uchar auStack64 [4];
  uchar buf [32];
  
  if (len < 0x21) {
    iVar6 = 0x102;
    do {
      iVar6 = iVar6 + -1;
      if (iVar6 == 0) goto LAB_230563d2;
      if (*(int *)((int)data + 0x74) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x40;
      }
      iVar2 = entropy_gather_internal((mbedtls_entropy_context *)data);
      if (iVar2 != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
      puVar5 = (uint *)((int)data + 0x80);
      iVar3 = 0;
      bVar1 = true;
      puVar4 = puVar5;
      while (iVar3 < *(int *)((int)data + 0x74)) {
        if (*puVar4 < puVar4[1]) {
          bVar1 = false;
        }
        iVar3 = iVar3 + 1;
        puVar4 = puVar4 + 5;
      }
    } while (!bVar1);
    memset(auStack64,0,0x20);
    mbedtls_sha256_finish((mbedtls_sha256_context *)data,auStack64);
    memset(data,0,0x74);
    mbedtls_sha256_starts((mbedtls_sha256_context *)data,0);
    mbedtls_sha256_update((mbedtls_sha256_context *)data,auStack64,0x20);
    mbedtls_sha256(auStack64,0x20,auStack64,0);
    iVar6 = *(int *)((int)data + 0x74);
    iVar3 = 0;
    while (iVar3 < iVar6) {
      *puVar5 = 0;
      iVar3 = iVar3 + 1;
      puVar5 = puVar5 + 5;
    }
    memcpy(output,auStack64,len);
  }
  else {
LAB_230563d2:
    iVar2 = -0x3c;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_platform_entropy_poll(void *data,uchar *output,size_t len,size_t *olen)

{
  uint uVar1;
  uint uVar2;
  
  *olen = 0;
  uVar2 = 0;
  uVar1 = 0;
  while (uVar1 != len) {
    if ((uVar1 & 3) == 0) {
      uVar2 = bl_rand();
    }
    output[uVar1] = (uchar)uVar2;
    uVar1 = uVar1 + 1;
    uVar2 = uVar2 >> 8;
  }
  *olen = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void mbedtls_pk_init(mbedtls_pk_context *ctx)

{
  if (ctx != (mbedtls_pk_context *)0x0) {
    ctx->pk_info = (mbedtls_pk_info_t *)0x0;
    ctx->pk_ctx = (void *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_pk_free(mbedtls_pk_context *ctx)

{
  mbedtls_pk_context *pmVar1;
  
  if (ctx != (mbedtls_pk_context *)0x0) {
    if (ctx->pk_info != (mbedtls_pk_info_t *)0x0) {
      (*ctx->pk_info->ctx_free_func)(ctx->pk_ctx);
      pmVar1 = ctx + 1;
      while (ctx != pmVar1) {
        *(undefined *)&ctx->pk_info = 0;
        ctx = (mbedtls_pk_context *)((int)&ctx->pk_info + 1);
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mbedtls_pk_info_t * mbedtls_pk_info_from_type(mbedtls_pk_type_t pk_type)

{
  uint uVar1;
  
  uVar1 = pk_type - 1 & 0xff;
  if (uVar1 < 3) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(mbedtls_pk_info_t **)(&CSWTCH_5 + uVar1 * 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_pk_info_t *)0x0;
}



int mbedtls_pk_setup(mbedtls_pk_context *ctx,mbedtls_pk_info_t *info)

{
  void *pvVar1;
  int iVar2;
  
  if (((ctx != (mbedtls_pk_context *)0x0) && (info != (mbedtls_pk_info_t *)0x0)) &&
     (ctx->pk_info == (mbedtls_pk_info_t *)0x0)) {
    pvVar1 = (*info->ctx_alloc_func)(info->ctx_alloc_func);
    ctx->pk_ctx = pvVar1;
    if (pvVar1 == (void *)0x0) {
      iVar2 = -0x3f80;
    }
    else {
      ctx->pk_info = info;
      iVar2 = 0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -16000;
}



int mbedtls_pk_can_do(mbedtls_pk_context *ctx,mbedtls_pk_type_t type)

{
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23056572. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*ctx->pk_info->can_do)(type);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_pk_verify(mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,
                     uchar *sig,size_t sig_len)

{
  anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_for_verify_func
  *UNRECOVERED_JUMPTABLE;
  byte bVar1;
  mbedtls_md_info_t *md_info;
  int iVar2;
  
  if (ctx == (mbedtls_pk_context *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -16000;
  }
  if (ctx->pk_info == (mbedtls_pk_info_t *)0x0) {
LAB_23056582:
    iVar2 = -16000;
  }
  else {
    if (hash_len == 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_23056582;
      bVar1 = mbedtls_md_get_size(md_info);
      hash_len = (size_t)bVar1;
    }
    UNRECOVERED_JUMPTABLE = ctx->pk_info->verify_func;
    if (UNRECOVERED_JUMPTABLE !=
        (anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_for_verify_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x230565ce. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx,md_alg,hash,hash_len,sig,sig_len);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    iVar2 = -0x3f00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_pk_sign(mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,
                   uchar *sig,size_t *sig_len,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,
                   void *p_rng)

{
    
  anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_ptr_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_sign_func
  *UNRECOVERED_JUMPTABLE;
  byte bVar1;
  mbedtls_md_info_t *md_info;
  int iVar2;
  
  if (ctx == (mbedtls_pk_context *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -16000;
  }
  if (ctx->pk_info == (mbedtls_pk_info_t *)0x0) {
LAB_230565e2:
    iVar2 = -16000;
  }
  else {
    if (hash_len == 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_230565e2;
      bVar1 = mbedtls_md_get_size(md_info);
      hash_len = (size_t)bVar1;
    }
    UNRECOVERED_JUMPTABLE = ctx->pk_info->sign_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_mbedtls_md_type_t_uchar_ptr_size_t_uchar_ptr_size_t_ptr_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_sign_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23056636. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar2 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx,md_alg,hash,hash_len,sig,sig_len,f_rng,p_rng);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
    iVar2 = -0x3f00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_pk_decrypt(mbedtls_pk_context *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,
                      size_t osize,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
    
  anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_decrypt_func
  *UNRECOVERED_JUMPTABLE;
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    UNRECOVERED_JUMPTABLE = ctx->pk_info->decrypt_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_decrypt_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x23056654. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3f00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -16000;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_pk_encrypt(mbedtls_pk_context *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,
                      size_t osize,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
    
  anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_encrypt_func
  *UNRECOVERED_JUMPTABLE;
  int iVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    UNRECOVERED_JUMPTABLE = ctx->pk_info->encrypt_func;
    if (UNRECOVERED_JUMPTABLE !=
        (
         anon_subr_int_void_ptr_uchar_ptr_size_t_uchar_ptr_size_t_ptr_size_t_anon_subr_int_void_ptr_uchar_ptr_size_t_ptr_void_ptr_for_encrypt_func
         *)0x0) {
                    // WARNING: Could not recover jumptable at 0x2305667a. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->pk_ctx);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3f00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -16000;
}



size_t mbedtls_pk_get_bitlen(mbedtls_pk_context *ctx)

{
  size_t sVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x23056698. Too many branches
                    // WARNING: Treating indirect jump as call
    sVar1 = (*ctx->pk_info->get_bitlen)(ctx->pk_ctx);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return sVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_pk_verify_ext
              (mbedtls_pk_type_t type,void *options,mbedtls_pk_context *ctx,mbedtls_md_type_t md_alg
              ,uchar *hash,size_t hash_len,uchar *sig,size_t sig_len)

{
  undefined3 in_register_00002029;
  int iVar1;
  size_t sVar2;
  int in_fa0;
  uchar *in_fa1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    iVar1 = mbedtls_pk_can_do(ctx,type);
    if (iVar1 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x3f00;
    }
    if (CONCAT31(in_register_00002029,type) == 6) {
      if (options != (void *)0x0) {
        sVar2 = mbedtls_pk_get_bitlen(ctx);
        if (sig_len < sVar2 + 7 >> 3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x4380;
        }
                    // WARNING: Load size is inaccurate
        iVar1 = mbedtls_rsa_rsassa_pss_verify_ext
                          ((mbedtls_rsa_context *)ctx->pk_ctx,
                           (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0,0,md_alg,
                           hash_len,hash,*options,in_fa0,in_fa1);
        if (iVar1 != 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return iVar1;
        }
        sVar2 = mbedtls_pk_get_bitlen(ctx);
        if (sig_len <= sVar2 + 7 >> 3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x3900;
      }
    }
    else {
      if (options == (void *)0x0) {
        iVar1 = mbedtls_pk_verify(ctx,md_alg,hash,hash_len,sig,sig_len);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -16000;
}



int mbedtls_pk_debug(mbedtls_pk_context *ctx,mbedtls_pk_debug_item *items)

{
  anon_subr_void_void_ptr_mbedtls_pk_debug_item_ptr_for_debug_func *paVar1;
  
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    paVar1 = ctx->pk_info->debug_func;
    if (paVar1 != (anon_subr_void_void_ptr_mbedtls_pk_debug_item_ptr_for_debug_func *)0x0) {
      (*paVar1)(ctx->pk_ctx,items);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3f00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -16000;
}



char * mbedtls_pk_get_name(mbedtls_pk_context *ctx)

{
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ctx->pk_info->name;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return "invalid PK";
}



mbedtls_pk_type_t mbedtls_pk_get_type(mbedtls_pk_context *ctx)

{
  if ((ctx != (mbedtls_pk_context *)0x0) && (ctx->pk_info != (mbedtls_pk_info_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ctx->pk_info->type;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return MBEDTLS_PK_NONE;
}



int pk_use_ecparams(mbedtls_asn1_buf *params,mbedtls_ecp_group *grp)

{
  int iVar1;
  mbedtls_ecp_group_id local_11 [4];
  mbedtls_ecp_group_id grp_id;
  
  if (params->tag != 6) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3d00;
  }
  iVar1 = mbedtls_oid_get_ec_grp(params,local_11);
  if (iVar1 == 0) {
    if ((grp->id == MBEDTLS_ECP_DP_NONE) || (grp->id == local_11[0])) {
      iVar1 = mbedtls_ecp_group_load(grp,local_11[0]);
    }
    else {
      iVar1 = -0x3d00;
    }
  }
  else {
    iVar1 = -0x3a00;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int pk_parse_key_pkcs1_der(mbedtls_rsa_context *rsa,uchar *key,size_t keylen)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  uchar *end;
  size_t sStack40;
  size_t len;
  uchar *p;
  
  len = (size_t)key;
  iVar2 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,&sStack40,0x30);
  if (iVar2 == 0) {
    end = (uchar *)(len + sStack40);
    iVar2 = mbedtls_asn1_get_int((uchar **)&len,end,(int *)rsa);
    if (iVar2 == 0) {
      if (rsa->ver != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x3d80;
      }
      iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->N);
      if (((((iVar1 == 0) && (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->E), iVar1 == 0))
           && (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->D), iVar1 == 0)) &&
          ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->P), iVar1 == 0 &&
           (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->Q), iVar1 == 0)))) &&
         ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->DP), iVar1 == 0 &&
          ((iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->DQ), iVar1 == 0 &&
           (iVar1 = mbedtls_asn1_get_mpi((uchar **)&len,end,&rsa->QP), iVar1 == 0)))))) {
        sVar3 = mbedtls_mpi_size(&rsa->N);
        rsa->len = sVar3;
        if ((uchar *)len != end) {
          mbedtls_rsa_free(rsa);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x3d66;
        }
        iVar2 = mbedtls_rsa_check_privkey(rsa);
        if (iVar2 == 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        mbedtls_rsa_free(rsa);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
      mbedtls_rsa_free(rsa);
      iVar2 = -0x3d00;
      goto LAB_2305683a;
    }
  }
  iVar1 = -0x3d00;
LAB_2305683a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1 + iVar2;
}



int pk_parse_key_sec1_der(mbedtls_ecp_keypair *eck,uchar *key,size_t keylen)

{
  int iVar1;
  uchar *end;
  int iVar2;
  uchar *puVar3;
  mbedtls_mpi *X;
  int iStack56;
  int version;
  size_t len;
  uchar *p;
  mbedtls_asn1_buf params;
  
  len = (size_t)key;
  iVar2 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,(size_t *)&version,0x30);
  if (iVar2 == 0) {
    puVar3 = (uchar *)(len + version);
    iVar2 = mbedtls_asn1_get_int((uchar **)&len,puVar3,&iStack56);
    if (iVar2 != 0) goto LAB_23056948;
    if (iStack56 != 1) {
      iVar1 = -0x3d80;
      goto LAB_23056998;
    }
    iVar2 = mbedtls_asn1_get_tag((uchar **)&len,puVar3,(size_t *)&version,4);
    if (iVar2 != 0) goto LAB_23056948;
    X = &eck->d;
    iVar1 = mbedtls_mpi_read_binary(X,(uchar *)len,version);
    if (iVar1 == 0) {
      len = len + version;
      if ((uchar *)len == puVar3) {
LAB_23056a92:
        iVar1 = mbedtls_ecp_mul((mbedtls_ecp_group *)eck,&eck->Q,X,&(eck->grp).G,
                                (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
        if (iVar1 != 0) goto LAB_2305698a;
LAB_23056aac:
        iVar1 = mbedtls_ecp_check_privkey((mbedtls_ecp_group *)eck,X);
        if (iVar1 == 0) goto LAB_23056998;
      }
      else {
        iVar1 = mbedtls_asn1_get_tag((uchar **)&len,puVar3,(size_t *)&version,0xa0);
        if (iVar1 != 0) {
          if (iVar1 != -0x62) goto LAB_2305698a;
LAB_23056a2a:
          iVar1 = mbedtls_asn1_get_tag((uchar **)&len,puVar3,(size_t *)&version,0xa1);
          if (iVar1 != 0) {
            if (iVar1 != -0x62) goto LAB_2305698a;
            goto LAB_23056a92;
          }
          puVar3 = (uchar *)(len + version);
          iVar2 = mbedtls_asn1_get_bitstring_null((uchar **)&len,puVar3,(size_t *)&version);
          if (iVar2 != 0) goto LAB_23056948;
          if (puVar3 != (uchar *)(version + len)) {
            iVar1 = -0x3d66;
            goto LAB_23056998;
          }
          iVar2 = mbedtls_ecp_point_read_binary
                            ((mbedtls_ecp_group *)eck,&eck->Q,(uchar *)len,(size_t)(puVar3 + -len));
          if (iVar2 == 0) {
            iVar2 = mbedtls_ecp_check_pubkey((mbedtls_ecp_group *)eck,&eck->Q);
          }
          len = (size_t)puVar3;
          if (iVar2 != 0) {
            if (iVar2 != -0x4e80) {
              iVar1 = -0x3d00;
              goto LAB_23056998;
            }
            goto LAB_23056a92;
          }
          goto LAB_23056aac;
        }
        end = (uchar *)(version + len);
        p = (uchar *)(uint)*(byte *)len;
        if (p == (uchar *)0x6) {
          iVar1 = mbedtls_asn1_get_tag((uchar **)&len,end,(size_t *)&params,6);
          if (iVar1 == 0) {
            params.len = len;
            len = len + params.tag;
            if (end == (uchar *)len) goto LAB_230569f0;
            iVar1 = -0x3d66;
          }
          else {
            iVar1 = iVar1 + -0x3d00;
            if (iVar1 == 0) {
LAB_230569f0:
              iVar1 = pk_use_ecparams((mbedtls_asn1_buf *)&p,(mbedtls_ecp_group *)eck);
              if (iVar1 == 0) goto LAB_23056a2a;
            }
          }
        }
        else {
          iVar1 = -0x3d62;
        }
      }
      mbedtls_ecp_keypair_free(eck);
      goto LAB_23056998;
    }
LAB_2305698a:
    mbedtls_ecp_keypair_free(eck);
    iVar2 = -0x3d00;
  }
  else {
LAB_23056948:
    iVar1 = -0x3d00;
  }
  iVar1 = iVar1 + iVar2;
LAB_23056998:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int pk_get_pk_alg(uchar **p,uchar *end,mbedtls_pk_type_t *pk_alg,mbedtls_asn1_buf *params)

{
  int iVar1;
  undefined auStack44 [4];
  mbedtls_asn1_buf alg_oid;
  
  memset(params,0,0xc);
  iVar1 = mbedtls_asn1_get_alg(p,end,(mbedtls_asn1_buf *)auStack44,params);
  if (iVar1 == 0) {
    iVar1 = mbedtls_oid_get_pk_alg((mbedtls_asn1_buf *)auStack44,pk_alg);
    if (iVar1 == 0) {
      if ((*pk_alg == MBEDTLS_PK_RSA) &&
         (((params->tag != 5 && (params->tag != 0)) || (params->len != 0)))) {
        iVar1 = -0x3a80;
      }
    }
    else {
      iVar1 = -0x3c80;
    }
  }
  else {
    iVar1 = iVar1 + -0x3a80;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int pk_parse_key_pkcs8_unencrypted_der(mbedtls_pk_context *pk,uchar *key,size_t keylen)

{
  uchar *end;
  int iVar1;
  mbedtls_pk_info_t *info;
  mbedtls_pk_type_t mStack41;
  mbedtls_pk_type_t pk_alg;
  int iStack40;
  int version;
  size_t len;
  uchar *p;
  mbedtls_asn1_buf params;
  
  mStack41 = MBEDTLS_PK_NONE;
  len = (size_t)key;
  iVar1 = mbedtls_asn1_get_tag((uchar **)&len,key + keylen,(size_t *)&version,0x30);
  if (iVar1 != 0) {
LAB_23056b60:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1 + -0x3d00;
  }
  end = (uchar *)(len + version);
  iVar1 = mbedtls_asn1_get_int((uchar **)&len,end,(int *)&stack0xffffffd8);
  if (iVar1 != 0) goto LAB_23056b60;
  if (iStack40 != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3d80;
  }
  iVar1 = pk_get_pk_alg((uchar **)&len,end,&mStack41,(mbedtls_asn1_buf *)&p);
  if ((iVar1 != 0) ||
     (iVar1 = mbedtls_asn1_get_tag((uchar **)&len,end,(size_t *)&version,4), iVar1 != 0))
  goto LAB_23056b60;
  if (version == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3d60;
  }
  info = mbedtls_pk_info_from_type(mStack41);
  if (info == (mbedtls_pk_info_t *)0x0) {
LAB_23056b68:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x3c80;
  }
  iVar1 = mbedtls_pk_setup(pk,info);
  if (iVar1 != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (mStack41 == MBEDTLS_PK_RSA) {
    iVar1 = pk_parse_key_pkcs1_der((mbedtls_rsa_context *)pk->pk_ctx,(uchar *)len,version);
  }
  else {
    if (1 < (byte)(mStack41 + ~MBEDTLS_PK_RSA)) goto LAB_23056b68;
    iVar1 = pk_use_ecparams((mbedtls_asn1_buf *)&p,(mbedtls_ecp_group *)pk->pk_ctx);
    if (iVar1 != 0) goto LAB_23056be2;
    iVar1 = pk_parse_key_sec1_der((mbedtls_ecp_keypair *)pk->pk_ctx,(uchar *)len,version);
  }
  if (iVar1 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
LAB_23056be2:
  mbedtls_pk_free(pk);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_pk_load_file(char *path,uchar **buf,size_t *n)

{
  int fd;
  size_t sVar1;
  uchar *buf_00;
  char *pcVar2;
  undefined4 uVar3;
  
  printf("Open path %s\r\n",path);
  fd = aos_open(path,0);
  uVar3 = 0x7f;
  if (-1 < fd) {
    sVar1 = aos_lseek(fd,0,2);
    if (sVar1 != 0xffffffff) {
      aos_lseek(fd,0,0);
      *n = sVar1;
      printf("Cert size is %d\r\n",sVar1);
      if (*n != 0xffffffff) {
        buf_00 = (uchar *)mycalloc(1,*n + 1);
        *buf = buf_00;
        if (buf_00 != (uchar *)0x0) {
          sVar1 = aos_read(fd,buf_00,*n);
          if (sVar1 == *n) {
            aos_close(fd);
            (*buf)[*n] = '\0';
            pcVar2 = strstr((char *)*buf,"-----BEGIN ");
            if (pcVar2 == (char *)0x0) {
              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
              return 0;
            }
            *n = *n + 1;
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return 0;
          }
          aos_close(fd);
          vPortFree(*buf);
          uVar3 = 0x96;
          goto LAB_23056c6a;
        }
      }
      aos_close(fd);
      printf("%s:%d\r\n","mbedtls_pk_load_file",0x90);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x3f80;
    }
    aos_close(fd);
    uVar3 = 0x86;
  }
LAB_23056c6a:
  printf("%s:%d\r\n","mbedtls_pk_load_file",uVar3);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x3e00;
}



// WARNING: Variable defined which should be unmapped: alg_params

int mbedtls_pk_parse_subpubkey(uchar **p,uchar *end,mbedtls_pk_context *pk)

{
  mbedtls_rsa_context *ctx;
  int iVar1;
  mbedtls_pk_info_t *info;
  size_t sVar2;
  int iVar3;
  uchar *end_00;
  mbedtls_ecp_group *grp;
  mbedtls_ecp_point *pt;
  mbedtls_pk_type_t mStack53;
  mbedtls_pk_type_t pk_alg;
  size_t sStack52;
  size_t len;
  size_t len_1;
  mbedtls_asn1_buf alg_params;
  
  mStack53 = MBEDTLS_PK_NONE;
  iVar1 = mbedtls_asn1_get_tag(p,end,(size_t *)&stack0xffffffcc,0x30);
  if (iVar1 == 0) {
    end_00 = *p + sStack52;
    iVar1 = pk_get_pk_alg(p,end_00,&mStack53,(mbedtls_asn1_buf *)&len_1);
    if (iVar1 != 0) goto LAB_23056d70;
    iVar1 = mbedtls_asn1_get_bitstring_null(p,end_00,(size_t *)&stack0xffffffcc);
    if (iVar1 == 0) {
      if (end_00 != *p + sStack52) {
        iVar1 = -0x3b66;
        goto LAB_23056d70;
      }
      info = mbedtls_pk_info_from_type(mStack53);
      if (info == (mbedtls_pk_info_t *)0x0) {
        iVar1 = -0x3c80;
        goto LAB_23056d70;
      }
      iVar1 = mbedtls_pk_setup(pk,info);
      if (iVar1 != 0) goto LAB_23056d70;
      if (mStack53 == MBEDTLS_PK_RSA) {
        ctx = (mbedtls_rsa_context *)pk->pk_ctx;
        iVar3 = mbedtls_asn1_get_tag(p,end_00,&len,0x30);
        if (iVar3 == 0) {
          if (end_00 == *p + len) {
            iVar3 = mbedtls_asn1_get_mpi(p,end_00,&ctx->N);
            if ((iVar3 != 0) || (iVar3 = mbedtls_asn1_get_mpi(p,end_00,&ctx->E), iVar3 != 0))
            goto LAB_23056df6;
            if (end_00 != *p) goto LAB_23056e16;
            iVar3 = mbedtls_rsa_check_pubkey(ctx);
            if (iVar3 != 0) {
              iVar3 = -0x3b00;
              goto LAB_23056e00;
            }
            sVar2 = mbedtls_mpi_size(&ctx->N);
            ctx->len = sVar2;
            goto LAB_23056e52;
          }
        }
        else {
LAB_23056df6:
          iVar3 = iVar3 + -0x3b00;
          if (iVar3 != 0) goto LAB_23056e00;
LAB_23056e52:
          if (*p == end_00) goto LAB_23056d70;
        }
LAB_23056e16:
        iVar3 = -0x3b66;
      }
      else {
        if ((byte)(mStack53 + ~MBEDTLS_PK_RSA) < 2) {
          iVar3 = pk_use_ecparams((mbedtls_asn1_buf *)&len_1,(mbedtls_ecp_group *)pk->pk_ctx);
          if (iVar3 == 0) {
            grp = (mbedtls_ecp_group *)pk->pk_ctx;
            pt = (mbedtls_ecp_point *)&grp[1].P.p;
            iVar3 = mbedtls_ecp_point_read_binary(grp,pt,*p,(size_t)(end_00 + -(int)*p));
            if (iVar3 == 0) {
              iVar3 = mbedtls_ecp_check_pubkey(grp,pt);
            }
            *p = end_00;
            if (iVar3 == 0) goto LAB_23056d70;
          }
        }
        else {
          iVar3 = -0x3c80;
        }
      }
LAB_23056e00:
      mbedtls_pk_free(pk);
      iVar1 = iVar3;
      goto LAB_23056d70;
    }
    iVar3 = -0x3b00;
  }
  else {
    iVar3 = -0x3d00;
  }
  iVar1 = iVar1 + iVar3;
LAB_23056d70:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_pk_parse_key(mbedtls_pk_context *pk,uchar *key,size_t keylen,uchar *pwd,size_t pwdlen)

{
  int iVar1;
  mbedtls_pk_info_t *pmVar2;
  uchar *puVar3;
  size_t sStack64;
  size_t len;
  mbedtls_pem_context pem;
  
  mbedtls_pem_init((mbedtls_pem_context *)&len);
  if ((keylen == 0) || (puVar3 = key + (keylen - 1), *puVar3 != '\0')) {
LAB_23056eee:
    iVar1 = pk_parse_key_pkcs8_unencrypted_der(pk,key,keylen);
    if (iVar1 != 0) {
      mbedtls_pk_free(pk);
      pmVar2 = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);
      if (pmVar2 == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
      iVar1 = mbedtls_pk_setup(pk,pmVar2);
      if ((iVar1 == 0) &&
         (iVar1 = pk_parse_key_pkcs1_der((mbedtls_rsa_context *)pk->pk_ctx,key,keylen), iVar1 != 0))
      {
        mbedtls_pk_free(pk);
        pmVar2 = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
        if (pmVar2 == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
        iVar1 = mbedtls_pk_setup(pk,pmVar2);
        if ((iVar1 == 0) &&
           (iVar1 = pk_parse_key_sec1_der((mbedtls_ecp_keypair *)pk->pk_ctx,key,keylen), iVar1 != 0)
           ) {
          mbedtls_pk_free(pk);
          iVar1 = -0x3d00;
          goto LAB_23056f98;
        }
      }
    }
    iVar1 = 0;
  }
  else {
    iVar1 = mbedtls_pem_read_buffer
                      ((mbedtls_pem_context *)&len,"-----BEGIN RSA PRIVATE KEY-----",
                       "-----END RSA PRIVATE KEY-----",key,pwd,pwdlen,&sStack64);
    if (iVar1 != 0) {
      if (iVar1 == -0x1380) {
LAB_23056fe2:
        iVar1 = -0x3b80;
        goto LAB_23056f98;
      }
      if (iVar1 == -0x1300) {
LAB_23056ff2:
        iVar1 = -0x3c00;
        goto LAB_23056f98;
      }
      if (iVar1 != -0x1080) goto LAB_23056f98;
      if (*puVar3 == '\0') {
        iVar1 = mbedtls_pem_read_buffer
                          ((mbedtls_pem_context *)&len,"-----BEGIN EC PRIVATE KEY-----",
                           "-----END EC PRIVATE KEY-----",key,pwd,pwdlen,&sStack64);
        if (iVar1 == 0) {
          pmVar2 = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
          if (pmVar2 == (mbedtls_pk_info_t *)0x0) goto LAB_23056f92;
          iVar1 = mbedtls_pk_setup(pk,pmVar2);
          if (iVar1 != 0) goto LAB_23056fca;
          iVar1 = pk_parse_key_sec1_der
                            ((mbedtls_ecp_keypair *)pk->pk_ctx,(uchar *)len,(size_t)pem.buf);
LAB_23056fc6:
          if (iVar1 != 0) goto LAB_23056fca;
          goto LAB_23056fd0;
        }
        if (iVar1 == -0x1380) goto LAB_23056fe2;
        if (iVar1 == -0x1300) goto LAB_23056ff2;
        if (iVar1 != -0x1080) goto LAB_23056f98;
        if (*puVar3 == '\0') {
          iVar1 = mbedtls_pem_read_buffer
                            ((mbedtls_pem_context *)&len,"-----BEGIN PRIVATE KEY-----",
                             "-----END PRIVATE KEY-----",key,(uchar *)0x0,0,&sStack64);
          if (iVar1 == 0) {
            iVar1 = pk_parse_key_pkcs8_unencrypted_der(pk,(uchar *)len,(size_t)pem.buf);
            goto LAB_23056fc6;
          }
          if (iVar1 != -0x1080) goto LAB_23056f98;
        }
      }
      goto LAB_23056eee;
    }
    pmVar2 = mbedtls_pk_info_from_type(MBEDTLS_PK_RSA);
    if (pmVar2 != (mbedtls_pk_info_t *)0x0) {
      iVar1 = mbedtls_pk_setup(pk,pmVar2);
      if (iVar1 == 0) {
        iVar1 = pk_parse_key_pkcs1_der
                          ((mbedtls_rsa_context *)pk->pk_ctx,(uchar *)len,(size_t)pem.buf);
        goto LAB_23056fc6;
      }
LAB_23056fca:
      mbedtls_pk_free(pk);
LAB_23056fd0:
      mbedtls_pem_free((mbedtls_pem_context *)&len);
      goto LAB_23056f98;
    }
LAB_23056f92:
    iVar1 = -0x3c80;
  }
LAB_23056f98:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: buf

int mbedtls_pk_parse_keyfile(mbedtls_pk_context *ctx,char *path,char *pwd)

{
  size_t keylen;
  size_t key;
  int iVar1;
  size_t pwdlen;
  uchar *puVar2;
  size_t local_18;
  size_t n;
  uchar *buf;
  
  iVar1 = mbedtls_pk_load_file(path,(uchar **)&n,&local_18);
  key = n;
  keylen = local_18;
  if (iVar1 == 0) {
    if (pwd == (char *)0x0) {
      pwdlen = 0;
      pwd = (char *)0x0;
    }
    else {
      pwdlen = strlen(pwd);
    }
    iVar1 = mbedtls_pk_parse_key(ctx,(uchar *)key,keylen,(uchar *)pwd,pwdlen);
    puVar2 = (uchar *)n;
    while (puVar2 != (uchar *)(local_18 + n)) {
      *puVar2 = '\0';
      puVar2 = puVar2 + 1;
    }
    vPortFree((void *)n);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int rsa_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  if (CONCAT31(in_register_00002029,type) != 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uint)(CONCAT31(in_register_00002029,type) == 6);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



size_t rsa_get_bitlen(void *ctx)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return *(int *)((int)ctx + 4) << 3;
}



void rsa_debug(void *ctx,mbedtls_pk_debug_item *items)

{
  items->name = "rsa.N";
  items->value = (void *)((int)ctx + 8);
  items->type = MBEDTLS_PK_DEBUG_MPI;
  items[1].type = MBEDTLS_PK_DEBUG_MPI;
  items[1].name = "rsa.E";
  items[1].value = (void *)((int)ctx + 0x14);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int eckey_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(CONCAT31(in_register_00002029,type) - 2U < 3);
}



size_t eckey_get_bitlen(void *ctx)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return *(size_t *)((int)ctx + 0x58);
}



void eckey_debug(void *ctx,mbedtls_pk_debug_item *items)

{
  items->type = MBEDTLS_PK_DEBUG_ECP;
  items->name = "eckey.Q";
  items->value = (void *)((int)ctx + 0x88);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int eckeydh_can_do(mbedtls_pk_type_t type)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint)(CONCAT31(in_register_00002029,type) - 2U < 2);
}



void rsa_free_wrap(void *ctx)

{
  mbedtls_rsa_free((mbedtls_rsa_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * rsa_alloc_wrap(void)

{
  mbedtls_rsa_context *ctx;
  
  ctx = (mbedtls_rsa_context *)mycalloc(1,0xac);
  if (ctx != (mbedtls_rsa_context *)0x0) {
    mbedtls_rsa_init(ctx,0,0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



int rsa_check_pair_wrap(mbedtls_rsa_context *pub,mbedtls_rsa_context *prv)

{
  int iVar1;
  
  iVar1 = mbedtls_rsa_check_pubkey(pub);
  if ((((iVar1 != 0) || (iVar1 = mbedtls_rsa_check_privkey(prv), iVar1 != 0)) ||
      (iVar1 = mbedtls_mpi_cmp_mpi(&pub->N,&prv->N), iVar1 != 0)) ||
     (iVar1 = mbedtls_mpi_cmp_mpi(&pub->E,&prv->E), iVar1 != 0)) {
    iVar1 = -0x4200;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int rsa_encrypt_wrap(void *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,size_t osize,
                    anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = *(uint *)((int)ctx + 4);
  *olen = uVar2;
  if (uVar2 <= osize) {
    iVar1 = mbedtls_rsa_pkcs1_encrypt((mbedtls_rsa_context *)ctx,f_rng,p_rng,0,ilen,input,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4400;
}



int rsa_decrypt_wrap(void *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen,size_t osize,
                    anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  
  if (*(size_t *)((int)ctx + 4) == ilen) {
    iVar1 = mbedtls_rsa_pkcs1_decrypt
                      ((mbedtls_rsa_context *)ctx,f_rng,p_rng,1,olen,input,output,osize);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4080;
}



int rsa_sign_wrap(void *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,uchar *sig,
                 size_t *sig_len,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  int iVar1;
  
  *sig_len = *(size_t *)((int)ctx + 4);
  iVar1 = mbedtls_rsa_pkcs1_sign((mbedtls_rsa_context *)ctx,f_rng,p_rng,1,md_alg,hash_len,hash,sig);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int rsa_verify_wrap(void *ctx,mbedtls_md_type_t md_alg,uchar *hash,size_t hash_len,uchar *sig,
                   size_t sig_len)

{
  int iVar1;
  
  if (*(uint *)((int)ctx + 4) <= sig_len) {
    iVar1 = mbedtls_rsa_pkcs1_verify
                      ((mbedtls_rsa_context *)ctx,(anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,
                       (void *)0x0,0,md_alg,hash_len,hash,sig);
    if ((iVar1 == 0) && (*(uint *)((int)ctx + 4) < sig_len)) {
      iVar1 = -0x3900;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4380;
}



void eckey_free_wrap(void *ctx)

{
  mbedtls_ecp_keypair_free((mbedtls_ecp_keypair *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * eckey_alloc_wrap(void)

{
  mbedtls_ecp_keypair *key;
  
  key = (mbedtls_ecp_keypair *)mycalloc(1,0xac);
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_keypair_init(key);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return key;
}



int eckey_check_pair(mbedtls_ecp_keypair *pub,mbedtls_ecp_keypair *prv)

{
  mbedtls_ecp_group_id mVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *Y_00;
  mbedtls_ecp_point mStack192;
  mbedtls_ecp_group mStack156;
  
  mVar1 = (pub->grp).id;
  if ((mVar1 != MBEDTLS_ECP_DP_NONE) && ((prv->grp).id == mVar1)) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&pub->Q,(mbedtls_mpi *)&prv->Q);
    if (iVar2 == 0) {
      Y_00 = &(prv->Q).Y;
      iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Y,Y_00);
      if (iVar2 == 0) {
        Y = &(prv->Q).Z;
        iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Z,Y);
        if (iVar2 == 0) {
          mbedtls_ecp_point_init(&mStack192);
          memset(&mStack156,0,0x7c);
          mbedtls_ecp_group_copy(&mStack156,(mbedtls_ecp_group *)prv);
          iVar2 = mbedtls_ecp_mul(&mStack156,&mStack192,&prv->d,&(prv->grp).G,
                                  (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
          if ((iVar2 == 0) &&
             (((iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&mStack192,(mbedtls_mpi *)&prv->Q),
               iVar2 != 0 || (iVar2 = mbedtls_mpi_cmp_mpi(&mStack192.Y,Y_00), iVar2 != 0)) ||
              (iVar2 = mbedtls_mpi_cmp_mpi(&mStack192.Z,Y), iVar2 != 0)))) {
            iVar2 = -0x4f80;
          }
          mbedtls_ecp_point_free(&mStack192);
          mbedtls_ecp_group_free(&mStack156);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return iVar2;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4f80;
}



// WARNING: Variable defined which should be unmapped: mask

void mgf_mask(uchar *dst,size_t dlen,uchar *src,size_t slen,mbedtls_md_context_t *md_ctx)

{
  uchar uVar1;
  undefined3 extraout_var;
  byte *pbVar2;
  byte *pbVar3;
  uint uVar4;
  uint uVar5;
  uchar auStack68 [3];
  char cStack65;
  uchar counter [4];
  uchar mask [32];
  
  memset(counter,0,0x20);
  memset(auStack68,0,4);
  uVar1 = mbedtls_md_get_size(md_ctx->md_info);
  while (dlen != 0) {
    uVar5 = dlen;
    if (CONCAT31(extraout_var,uVar1) < dlen) {
      uVar5 = CONCAT31(extraout_var,uVar1);
    }
    mbedtls_md_starts(md_ctx);
    mbedtls_md_update(md_ctx,src,slen);
    mbedtls_md_update(md_ctx,auStack68,4);
    mbedtls_md_finish(md_ctx,counter);
    uVar4 = 0;
    while (pbVar3 = dst + uVar4, uVar4 != uVar5) {
      pbVar2 = counter + uVar4;
      uVar4 = uVar4 + 1;
      *pbVar3 = *pbVar2 ^ *pbVar3;
    }
    dlen = dlen - uVar4;
    cStack65 = cStack65 + '\x01';
    dst = pbVar3;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_rsa_init(mbedtls_rsa_context *ctx,int padding,int hash_id)

{
  memset(ctx,0,0xac);
  ctx->padding = padding;
  ctx->hash_id = hash_id;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_rsa_check_pubkey(mbedtls_rsa_context *ctx)

{
  mbedtls_mpi *X;
  size_t sVar1;
  int iVar2;
  mbedtls_mpi_uint *pmVar3;
  mbedtls_mpi_uint *pmVar4;
  
  pmVar4 = (ctx->N).p;
  if ((((pmVar4 != (mbedtls_mpi_uint *)0x0) &&
       (pmVar3 = (ctx->E).p, pmVar3 != (mbedtls_mpi_uint *)0x0)) && ((*pmVar4 & 1) != 0)) &&
     ((*pmVar3 & 1) != 0)) {
    X = &ctx->N;
    sVar1 = mbedtls_mpi_bitlen(X);
    if ((0x7f < sVar1) && (sVar1 = mbedtls_mpi_bitlen(X), sVar1 < 0x2001)) {
      sVar1 = mbedtls_mpi_bitlen(&ctx->E);
      if ((1 < sVar1) && (iVar2 = mbedtls_mpi_cmp_mpi(&ctx->E,X), iVar2 < 0)) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4200;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4200;
}



int mbedtls_rsa_check_privkey(mbedtls_rsa_context *ctx)

{
  int iVar1;
  mbedtls_mpi *B;
  mbedtls_mpi *A;
  mbedtls_mpi *A_00;
  undefined auStack188 [4];
  mbedtls_mpi PQ;
  mbedtls_mpi DE;
  mbedtls_mpi P1;
  mbedtls_mpi Q1;
  mbedtls_mpi H;
  mbedtls_mpi I;
  mbedtls_mpi G;
  mbedtls_mpi G2;
  mbedtls_mpi L1;
  mbedtls_mpi L2;
  mbedtls_mpi DP;
  mbedtls_mpi DQ;
  mbedtls_mpi QP;
  
  iVar1 = mbedtls_rsa_check_pubkey(ctx);
  if (iVar1 == 0) {
    iVar1 = -0x4200;
    if ((((ctx->P).p != (mbedtls_mpi_uint *)0x0) && ((ctx->Q).p != (mbedtls_mpi_uint *)0x0)) &&
       (iVar1 = -0x4200, (ctx->D).p != (mbedtls_mpi_uint *)0x0)) {
      mbedtls_mpi_init((mbedtls_mpi *)auStack188);
      mbedtls_mpi_init((mbedtls_mpi *)&PQ.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DE.p);
      mbedtls_mpi_init((mbedtls_mpi *)&P1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&Q1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&H.p);
      mbedtls_mpi_init((mbedtls_mpi *)&I.p);
      mbedtls_mpi_init((mbedtls_mpi *)&G.p);
      mbedtls_mpi_init((mbedtls_mpi *)&G2.p);
      mbedtls_mpi_init((mbedtls_mpi *)&L1.p);
      mbedtls_mpi_init((mbedtls_mpi *)&L2.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DP.p);
      mbedtls_mpi_init((mbedtls_mpi *)&DQ.p);
      A = &ctx->P;
      B = &ctx->Q;
      iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack188,A,B);
      if (iVar1 == 0) {
        A_00 = &ctx->D;
        iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&PQ.p,A_00,&ctx->E);
        if (((((iVar1 == 0) && (iVar1 = mbedtls_mpi_sub_int((mbedtls_mpi *)&DE.p,A,1), iVar1 == 0))
             && ((iVar1 = mbedtls_mpi_sub_int((mbedtls_mpi *)&P1.p,B,1), iVar1 == 0 &&
                 ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Q1.p,(mbedtls_mpi *)&DE.p,
                                               (mbedtls_mpi *)&P1.p), iVar1 == 0 &&
                  (iVar1 = mbedtls_mpi_gcd((mbedtls_mpi *)&I.p,&ctx->E,(mbedtls_mpi *)&Q1.p),
                  iVar1 == 0)))))) &&
            ((iVar1 = mbedtls_mpi_gcd((mbedtls_mpi *)&G.p,(mbedtls_mpi *)&DE.p,(mbedtls_mpi *)&P1.p)
             , iVar1 == 0 &&
             ((((iVar1 = mbedtls_mpi_div_mpi((mbedtls_mpi *)&G2.p,(mbedtls_mpi *)&L1.p,
                                             (mbedtls_mpi *)&Q1.p,(mbedtls_mpi *)&G.p), iVar1 == 0
                && (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&H.p,(mbedtls_mpi *)&PQ.p,
                                                (mbedtls_mpi *)&G2.p), iVar1 == 0)) &&
               (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&L2.p,A_00,(mbedtls_mpi *)&DE.p),
               iVar1 == 0)) &&
              ((iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&DP.p,A_00,(mbedtls_mpi *)&P1.p),
               iVar1 == 0 && (iVar1 = mbedtls_mpi_inv_mod((mbedtls_mpi *)&DQ.p,B,A), iVar1 == 0)))))
             ))) && ((((iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack188,&ctx->N), iVar1 != 0
                       || ((iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&L2.p,&ctx->DP), iVar1 != 0
                           || (iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&DP.p,&ctx->DQ),
                              iVar1 != 0)))) ||
                      (iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&DQ.p,&ctx->QP), iVar1 != 0)) ||
                     (((iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&L1.p,0), iVar1 != 0 ||
                       (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&H.p,1), iVar1 != 0)) ||
                      (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&I.p,1), iVar1 != 0)))))) {
          iVar1 = -0x4200;
        }
      }
      mbedtls_mpi_free((mbedtls_mpi *)auStack188);
      mbedtls_mpi_free((mbedtls_mpi *)&PQ.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DE.p);
      mbedtls_mpi_free((mbedtls_mpi *)&P1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&Q1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&H.p);
      mbedtls_mpi_free((mbedtls_mpi *)&I.p);
      mbedtls_mpi_free((mbedtls_mpi *)&G.p);
      mbedtls_mpi_free((mbedtls_mpi *)&G2.p);
      mbedtls_mpi_free((mbedtls_mpi *)&L1.p);
      mbedtls_mpi_free((mbedtls_mpi *)&L2.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DP.p);
      mbedtls_mpi_free((mbedtls_mpi *)&DQ.p);
      if ((iVar1 != -0x4200) && (iVar1 != 0)) {
        iVar1 = iVar1 + -0x4200;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_check_pub_priv(mbedtls_rsa_context *pub,mbedtls_rsa_context *prv)

{
  int iVar1;
  
  iVar1 = mbedtls_rsa_check_pubkey(pub);
  if ((((iVar1 != 0) || (iVar1 = mbedtls_rsa_check_privkey(prv), iVar1 != 0)) ||
      (iVar1 = mbedtls_mpi_cmp_mpi(&pub->N,&prv->N), iVar1 != 0)) ||
     (iVar1 = mbedtls_mpi_cmp_mpi(&pub->E,&prv->E), iVar1 != 0)) {
    iVar1 = -0x4200;
  }
  return iVar1;
}



int mbedtls_rsa_public(mbedtls_rsa_context *ctx,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  size_t buflen;
  undefined auStack44 [4];
  mbedtls_mpi T;
  
  mbedtls_mpi_init((mbedtls_mpi *)auStack44);
  iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)auStack44,input,ctx->len);
  if (iVar1 == 0) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack44,&ctx->N);
    iVar1 = -4;
    if (iVar2 < 0) {
      buflen = ctx->len;
      iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)auStack44,(mbedtls_mpi *)auStack44,&ctx->E,&ctx->N,
                                  &ctx->RN);
      if (iVar1 == 0) {
        iVar1 = mbedtls_mpi_write_binary((mbedtls_mpi *)auStack44,output,buflen);
      }
    }
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack44);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x4280;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_private(mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,
                       void *p_rng,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *pmVar3;
  mbedtls_mpi *X;
  undefined auStack84 [4];
  mbedtls_mpi T;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  
  if ((((ctx->P).p == (mbedtls_mpi_uint *)0x0) || ((ctx->Q).p == (mbedtls_mpi_uint *)0x0)) ||
     ((ctx->D).p == (mbedtls_mpi_uint *)0x0)) {
    iVar1 = -0x4080;
    goto LAB_2305783a;
  }
  mbedtls_mpi_init((mbedtls_mpi *)auStack84);
  mbedtls_mpi_init((mbedtls_mpi *)&T.p);
  mbedtls_mpi_init((mbedtls_mpi *)&T1.p);
  iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)auStack84,input,ctx->len);
  if (iVar1 == 0) {
    Y = &ctx->N;
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack84,Y);
    iVar1 = -4;
    if (iVar2 < 0) {
      if (f_rng == (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0) {
LAB_23057728:
        iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->DP,&ctx->P,
                                    &ctx->RP);
        if (iVar1 == 0) {
          iVar1 = mbedtls_mpi_exp_mod((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)auStack84,&ctx->DQ,&ctx->Q
                                      ,&ctx->RQ);
          if (((((iVar1 == 0) &&
                (iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T.p,
                                             (mbedtls_mpi *)&T1.p), iVar1 == 0)) &&
               ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->QP),
                iVar1 == 0 &&
                ((iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T.p,&ctx->P),
                 iVar1 == 0 &&
                 (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)auStack84,&ctx->Q),
                 iVar1 == 0)))))) &&
              (iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)&T1.p,
                                           (mbedtls_mpi *)&T.p), iVar1 == 0)) &&
             ((f_rng == (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0 ||
              ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,
                                            &ctx->Vf), iVar1 == 0 &&
               (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,Y),
               iVar1 == 0)))))) {
            iVar1 = mbedtls_mpi_write_binary((mbedtls_mpi *)auStack84,output,ctx->len);
          }
        }
      }
      else {
        if ((ctx->Vf).p == (mbedtls_mpi_uint *)0x0) {
          iVar2 = 0xc;
          X = &ctx->Vf;
          pmVar3 = &ctx->Vi;
          do {
            iVar2 = iVar2 + -1;
            if (iVar2 == 0) {
              iVar1 = -0x4480;
              goto cleanup;
            }
            iVar1 = mbedtls_mpi_fill_random(X,ctx->len - 1,f_rng,p_rng);
            if ((iVar1 != 0) || (iVar1 = mbedtls_mpi_gcd(pmVar3,X,Y), iVar1 != 0)) goto cleanup;
            iVar1 = mbedtls_mpi_cmp_int(pmVar3,1);
          } while (iVar1 != 0);
          iVar1 = mbedtls_mpi_inv_mod(pmVar3,X,Y);
          if (iVar1 == 0) {
            iVar1 = mbedtls_mpi_exp_mod(pmVar3,pmVar3,&ctx->E,Y,&ctx->RN);
LAB_230577fa:
            if (((iVar1 == 0) &&
                (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,
                                             &ctx->Vi), iVar1 == 0)) &&
               (iVar1 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,Y),
               iVar1 == 0)) goto LAB_23057728;
          }
        }
        else {
          pmVar3 = &ctx->Vi;
          iVar1 = mbedtls_mpi_mul_mpi(pmVar3,pmVar3,pmVar3);
          if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_mod_mpi(pmVar3,pmVar3,Y), iVar1 == 0)) {
            pmVar3 = &ctx->Vf;
            iVar1 = mbedtls_mpi_mul_mpi(pmVar3,pmVar3,pmVar3);
            if (iVar1 == 0) {
              iVar1 = mbedtls_mpi_mod_mpi(pmVar3,pmVar3,Y);
              goto LAB_230577fa;
            }
          }
        }
      }
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack84);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x4300;
  }
LAB_2305783a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsaes_oaep_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,uchar *label,size_t label_len,size_t ilen,uchar *input,uchar *output)

{
  uint __n;
  size_t dlen;
  uchar uVar1;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  uint uVar2;
  uchar *output_00;
  int iVar3;
  uchar *src;
  uchar *in_stack_00000000;
  undefined auStack76 [4];
  mbedtls_md_context_t md_ctx;
  size_t slen;
  
  if ((((mode != 1) || (ctx->padding == 1)) &&
      (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) &&
     (md_info = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id),
     md_info != (mbedtls_md_info_t *)0x0)) {
    __n = ctx->len;
    uVar1 = mbedtls_md_get_size(md_info);
    slen = CONCAT31(extraout_var,uVar1);
    uVar2 = ilen + 2 + slen * 2;
    if ((ilen <= uVar2) && (uVar2 <= __n)) {
      memset(in_stack_00000000,0,__n);
      src = in_stack_00000000 + 1;
      *in_stack_00000000 = '\0';
      iVar3 = (*f_rng)(p_rng,src,slen);
      if (iVar3 == 0) {
        output_00 = src + slen;
        mbedtls_md(md_info,label,label_len,output_00);
        output_00[((__n - ilen) + -2) - slen] = '\x01';
        memcpy(output_00 + (((__n - ilen) + -2) - slen) + 1,input,ilen);
        mbedtls_md_init((mbedtls_md_context_t *)auStack76);
        iVar3 = mbedtls_md_setup((mbedtls_md_context_t *)auStack76,md_info,0);
        if (iVar3 == 0) {
          dlen = (__n - 1) - slen;
          mgf_mask(in_stack_00000000 + slen + 1,dlen,src,slen,(mbedtls_md_context_t *)auStack76);
          mgf_mask(src,slen,in_stack_00000000 + slen + 1,dlen,(mbedtls_md_context_t *)auStack76);
          mbedtls_md_free((mbedtls_md_context_t *)auStack76);
          if (mode == 0) {
            iVar3 = mbedtls_rsa_public(ctx,in_stack_00000000,in_stack_00000000);
          }
          else {
            iVar3 = mbedtls_rsa_private(ctx,f_rng,p_rng,in_stack_00000000,in_stack_00000000);
          }
        }
        else {
          mbedtls_md_free((mbedtls_md_context_t *)auStack76);
        }
      }
      else {
        iVar3 = iVar3 + -0x4480;
      }
      goto LAB_23057914;
    }
  }
  iVar3 = -0x4080;
LAB_23057914:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_rsa_rsaes_pkcs1_v15_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t ilen,uchar *input,uchar *output)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  uchar *puVar4;
  
  if ((((mode == 1) && (ctx->padding != 0)) ||
      (f_rng == (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) ||
     ((input == (uchar *)0x0 || (output == (uchar *)0x0)))) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4080;
  }
  if ((0xfffffff4 < ilen) || (ctx->len < ilen + 0xb)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4080;
  }
  iVar1 = ctx->len - ilen;
  *output = '\0';
  iVar2 = iVar1 + -3;
  puVar4 = output + 2;
  if (mode == 0) {
    output[1] = '\x02';
    puVar3 = output + iVar1 + -1;
    while (puVar4 != puVar3) {
      iVar1 = 100;
      while (iVar2 = (*f_rng)(p_rng,puVar4,1), *puVar4 == '\0') {
        iVar1 = iVar1 + -1;
        if ((iVar1 == 0) || (iVar2 != 0)) goto LAB_23057aec;
      }
      if (iVar2 != 0) {
LAB_23057aec:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2 + -0x4480;
      }
      puVar4 = puVar4 + 1;
    }
  }
  else {
    output[1] = '\x01';
    puVar3 = output;
    while (output + iVar2 != puVar3) {
      puVar3[2] = -1;
      puVar3 = puVar3 + 1;
    }
    puVar3 = puVar4 + iVar2;
  }
  *puVar3 = '\0';
  memcpy(puVar3 + 1,input,ilen);
  if (mode != 0) {
    iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,output,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  iVar1 = mbedtls_rsa_public(ctx,output,output);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_pkcs1_encrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t ilen,uchar *input,uchar *output)

{
  int iVar1;
  uchar *in_fa0;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsaes_pkcs1_v15_encrypt(ctx,f_rng,p_rng,mode,ilen,input,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (ctx->padding != 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsaes_oaep_encrypt(ctx,f_rng,p_rng,mode,(uchar *)0x0,0,ilen,input,in_fa0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsaes_oaep_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,uchar *label,size_t label_len,size_t *olen,uchar *input,uchar *output,
              size_t output_max_len)

{
  uint uVar1;
  uchar uVar2;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  int iVar3;
  uchar *puVar4;
  uint uVar5;
  int iVar6;
  byte *pbVar7;
  uchar *output_00;
  int iVar8;
  size_t slen;
  void *in_stack_00000000;
  uint in_stack_00000004;
  undefined auStack1132 [4];
  mbedtls_md_context_t md_ctx;
  uchar lhash [32];
  uchar buf [1024];
  size_t dlen;
  
  if ((((mode != 1) || (ctx->padding == 1)) && (uVar1 = ctx->len, uVar1 - 0x10 < 0x3f1)) &&
     (md_info = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id),
     md_info != (mbedtls_md_info_t *)0x0)) {
    uVar2 = mbedtls_md_get_size(md_info);
    dlen = CONCAT31(extraout_var,uVar2);
    iVar8 = dlen + 1;
    if ((uint)(iVar8 * 2) <= uVar1) {
      output_00 = lhash + 0x1c;
      if (mode == 0) {
        iVar3 = mbedtls_rsa_public(ctx,input,output_00);
      }
      else {
        iVar3 = mbedtls_rsa_private(ctx,f_rng,p_rng,input,output_00);
      }
      if (iVar3 != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar3;
      }
      mbedtls_md_init((mbedtls_md_context_t *)auStack1132);
      iVar3 = mbedtls_md_setup((mbedtls_md_context_t *)auStack1132,md_info,0);
      if (iVar3 != 0) {
        mbedtls_md_free((mbedtls_md_context_t *)auStack1132);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar3;
      }
      mbedtls_md(md_info,label,label_len,(uchar *)&md_ctx.hmac_ctx);
      slen = (uVar1 - 1) - dlen;
      mgf_mask(lhash + 0x1d,dlen,output_00 + iVar8,slen,(mbedtls_md_context_t *)auStack1132);
      mgf_mask(output_00 + iVar8,slen,lhash + 0x1d,dlen,(mbedtls_md_context_t *)auStack1132);
      mbedtls_md_free((mbedtls_md_context_t *)auStack1132);
      uVar5 = 0;
      while (uVar5 < dlen) {
        iVar3 = uVar5 - 4;
        pbVar7 = lhash + dlen + 0x1d + uVar5;
        uVar5 = uVar5 + 1;
        lhash[28] = lhash[iVar3] ^ *pbVar7 | lhash[28];
      }
      puVar4 = lhash + dlen + 0x1d + dlen;
      uVar5 = 0;
      iVar6 = 0;
      iVar3 = 0;
      while (uVar1 + iVar8 * -2 != iVar3) {
        pbVar7 = puVar4 + iVar3;
        iVar3 = iVar3 + 1;
        uVar5 = uVar5 | *pbVar7;
        iVar6 = iVar6 + ((-uVar5 & 0xff | uVar5) >> 7 ^ 1);
      }
      if ((byte)(puVar4[iVar6] ^ 1 | lhash[28]) == 0) {
        uVar1 = uVar1 - (int)(puVar4 + iVar6 + 1 + -(int)output_00);
        if (uVar1 <= in_stack_00000004) {
          *olen = uVar1;
          memcpy(in_stack_00000000,puVar4 + iVar6 + 1,uVar1);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x4400;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x4100;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4080;
}



// WARNING: Variable defined which should be unmapped: buf

int mbedtls_rsa_rsaes_pkcs1_v15_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t *olen,uchar *input,uchar *output,size_t output_max_len)

{
  char *pcVar1;
  int iVar2;
  uint uVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  byte *pbVar7;
  size_t sVar8;
  byte local_420;
  byte bStack1055;
  byte abStack1054 [2];
  uchar buf [1024];
  
  pbVar7 = &local_420;
  pbVar4 = &local_420;
  if (((mode == 1) && (ctx->padding != 0)) || (sVar8 = ctx->len, 0x3f0 < sVar8 - 0x10)) {
    iVar2 = -0x4080;
  }
  else {
    if (mode == 0) {
      iVar2 = mbedtls_rsa_public(ctx,input,&local_420);
    }
    else {
      iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,input,&local_420);
    }
    if (iVar2 == 0) {
      if (mode == 1) {
        bStack1055 = bStack1055 ^ 2;
        uVar5 = 0;
        uVar3 = 0;
        uVar6 = 0;
        do {
          pbVar4 = pbVar7 + 2;
          uVar3 = uVar3 + 1;
          pbVar7 = pbVar7 + 1;
          uVar5 = uVar5 | ((uint)*pbVar4 | -(uint)*pbVar4 & 0xff) >> 7 ^ 1;
          uVar6 = uVar6 + ((-uVar5 & 0xff) >> 7 ^ 1);
        } while (uVar3 < sVar8 - 3);
      }
      else {
        bStack1055 = bStack1055 ^ 1;
        uVar5 = 0;
        uVar3 = 0;
        uVar6 = 0;
        do {
          pcVar1 = (char *)(pbVar4 + 2);
          uVar3 = uVar3 + 1;
          pbVar4 = pbVar4 + 1;
          uVar5 = *pcVar1 != -1 | uVar5;
          uVar6 = uVar6 + (uVar5 ^ 1);
        } while (uVar3 < sVar8 - 3);
      }
      if ((byte)(uVar6 < 8 | bStack1055 | local_420 | abStack1054[uVar6]) == 0) {
        uVar3 = sVar8 - (int)(abStack1054 + uVar6 + 1 + -(int)&local_420);
        if (output_max_len < uVar3) {
          iVar2 = -0x4400;
        }
        else {
          *olen = uVar3;
          memcpy(output,abStack1054 + uVar6 + 1,uVar3);
        }
      }
      else {
        iVar2 = -0x4100;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_rsa_pkcs1_decrypt
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,size_t *olen,uchar *input,uchar *output,size_t output_max_len)

{
  int iVar1;
  uchar *in_fa0;
  size_t in_fa1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsaes_pkcs1_v15_decrypt
                      (ctx,f_rng,p_rng,mode,olen,input,output,output_max_len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (ctx->padding != 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsaes_oaep_decrypt
                    (ctx,f_rng,p_rng,mode,(uchar *)0x0,0,olen,input,in_fa0,in_fa1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsassa_pss_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uint __n;
  int iVar1;
  uchar uVar2;
  mbedtls_md_info_t *pmVar3;
  undefined3 extraout_var;
  size_t __n_00;
  size_t sVar4;
  uint uVar5;
  undefined3 in_register_00002039;
  uchar *puVar6;
  undefined auStack108 [4];
  mbedtls_md_context_t md_ctx;
  uchar salt [32];
  undefined3 extraout_var_00;
  
  if (((mode != 1) || (ctx->padding == 1)) &&
     (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0)) {
    __n = ctx->len;
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      pmVar3 = mbedtls_md_info_from_type(md_alg);
      if (pmVar3 == (mbedtls_md_info_t *)0x0) goto LAB_23057f5c;
      uVar2 = mbedtls_md_get_size(pmVar3);
      hashlen = CONCAT31(extraout_var,uVar2);
    }
    pmVar3 = mbedtls_md_info_from_type(*(mbedtls_md_type_t *)&ctx->hash_id);
    if (pmVar3 != (mbedtls_md_info_t *)0x0) {
      uVar2 = mbedtls_md_get_size(pmVar3);
      __n_00 = CONCAT31(extraout_var_00,uVar2);
      if ((__n_00 + 1) * 2 <= __n) {
        memset(sig,0,__n);
        iVar1 = (*f_rng)(p_rng,(uchar *)&md_ctx.hmac_ctx,__n_00);
        if (iVar1 == 0) {
          sVar4 = mbedtls_mpi_bitlen(&ctx->N);
          puVar6 = sig + __n + (__n_00 + 1) * -2;
          *puVar6 = '\x01';
          memcpy(puVar6 + 1,&md_ctx.hmac_ctx,__n_00);
          mbedtls_md_init((mbedtls_md_context_t *)auStack108);
          iVar1 = mbedtls_md_setup((mbedtls_md_context_t *)auStack108,pmVar3,0);
          if (iVar1 == 0) {
            puVar6 = puVar6 + 1 + __n_00;
            mbedtls_md_starts((mbedtls_md_context_t *)auStack108);
            mbedtls_md_update((mbedtls_md_context_t *)auStack108,puVar6,8);
            mbedtls_md_update((mbedtls_md_context_t *)auStack108,hash,hashlen);
            mbedtls_md_update((mbedtls_md_context_t *)auStack108,(uchar *)&md_ctx.hmac_ctx,__n_00);
            mbedtls_md_finish((mbedtls_md_context_t *)auStack108,puVar6);
            uVar5 = (uint)((sVar4 - 1 & 7) == 0);
            mgf_mask(sig + uVar5,((__n - 1) - __n_00) - uVar5,puVar6,__n_00,
                     (mbedtls_md_context_t *)auStack108);
            mbedtls_md_free((mbedtls_md_context_t *)auStack108);
            sVar4 = mbedtls_mpi_bitlen(&ctx->N);
            *sig = (byte)(0xff >> ((__n * 8 + 1) - sVar4 & 0x1f)) & *sig;
            puVar6[__n_00] = -0x44;
            if (mode == 0) {
              iVar1 = mbedtls_rsa_public(ctx,sig,sig);
            }
            else {
              iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,sig);
            }
          }
          else {
            mbedtls_md_free((mbedtls_md_context_t *)auStack108);
          }
        }
        else {
          iVar1 = iVar1 + -0x4480;
        }
        goto LAB_23057f62;
      }
    }
  }
LAB_23057f5c:
  iVar1 = -0x4080;
LAB_23057f62:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsassa_pkcs1_v15_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uint uVar1;
  int iVar2;
  uint __n;
  uchar uVar3;
  mbedtls_md_info_t *md_info;
  int iVar4;
  undefined3 extraout_var;
  uchar *puVar5;
  uchar *output;
  byte *pbVar6;
  byte *pbVar7;
  byte bVar8;
  undefined3 in_register_00002039;
  size_t sVar9;
  uchar diff_no_optimize;
  size_t sStack56;
  size_t oid_size;
  char *oid;
  
  sStack56 = 0;
  oid_size = 0;
  if ((mode != 1) || (ctx->padding == 0)) {
    uVar1 = ctx->len;
    iVar2 = uVar1 - 3;
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      md_info = mbedtls_md_info_from_type(md_alg);
      if ((md_info == (mbedtls_md_info_t *)0x0) ||
         (iVar4 = mbedtls_oid_get_oid_by_md(md_alg,(char **)&oid_size,(size_t *)&stack0xffffffc8),
         iVar4 != 0)) goto LAB_230580fe;
      iVar2 = iVar2 - sStack56;
      uVar3 = mbedtls_md_get_size(md_info);
      hashlen = CONCAT31(extraout_var,uVar3);
      iVar2 = iVar2 + -10;
    }
    __n = iVar2 - hashlen;
    if ((7 < __n) && (__n <= uVar1)) {
      *sig = '\0';
      sig[1] = '\x01';
      memset(sig + 2,0xff,__n);
      puVar5 = sig + 2 + __n;
      *puVar5 = '\0';
      if (CONCAT31(in_register_00002039,md_alg) == 0) {
        puVar5 = puVar5 + 1;
      }
      else {
        uVar3 = (uchar)sStack56;
        puVar5[2] = uVar3 + '\b' + (uchar)hashlen;
        puVar5[4] = uVar3 + '\x04';
        puVar5[6] = uVar3;
        puVar5[1] = '0';
        puVar5[3] = '0';
        puVar5[5] = '\x06';
        memcpy(puVar5 + 7,(void *)oid_size,sStack56);
        puVar5 = puVar5 + 7 + sStack56;
        *puVar5 = '\x05';
        puVar5[1] = '\0';
        puVar5[2] = '\x04';
        puVar5[3] = (uchar)hashlen;
        puVar5 = puVar5 + 4;
      }
      memcpy(puVar5,hash,hashlen);
      if (mode == 0) {
        iVar2 = mbedtls_rsa_public(ctx,sig,sig);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
      iVar2 = -0x10;
      puVar5 = (uchar *)mycalloc(1,ctx->len);
      if (puVar5 == (uchar *)0x0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x10;
      }
      output = (uchar *)mycalloc(1,ctx->len);
      if (output != (uchar *)0x0) {
        iVar2 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,puVar5);
        if ((iVar2 == 0) && (iVar2 = mbedtls_rsa_public(ctx,puVar5,output), iVar2 == 0)) {
          bVar8 = 0;
          sVar9 = 0;
          while (ctx->len != sVar9) {
            pbVar7 = output + sVar9;
            pbVar6 = sig + sVar9;
            sVar9 = sVar9 + 1;
            bVar8 = bVar8 | *pbVar7 ^ *pbVar6;
          }
          if (bVar8 == 0) {
            memcpy(sig,puVar5,ctx->len);
          }
          else {
            iVar2 = -0x4300;
          }
        }
        vPortFree(puVar5);
        puVar5 = output;
      }
      vPortFree(puVar5);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
  }
LAB_230580fe:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4080;
}



int mbedtls_rsa_pkcs1_sign
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsassa_pkcs1_v15_sign(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (ctx->padding != 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_sign(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsassa_pss_verify_ext
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,
              mbedtls_md_type_t mgf1_hash_id,int expected_salt_len,uchar *sig)

{
  int iVar1;
  uchar *puVar2;
  uchar *puVar3;
  uchar uVar4;
  mbedtls_md_info_t *pmVar5;
  undefined3 extraout_var;
  uint slen;
  size_t sVar6;
  undefined3 in_register_00002039;
  size_t sVar7;
  size_t sVar8;
  uchar *output;
  size_t in_stack_00000000;
  uchar *in_stack_00000004;
  uchar auStack1124 [4];
  uchar zeros [8];
  mbedtls_md_context_t md_ctx;
  uchar result [32];
  uchar buf [1024];
  undefined3 extraout_var_00;
  
  if (((mode == 1) && (ctx->padding != 1)) || (sVar7 = ctx->len, 0x3f0 < sVar7 - 0x10))
  goto LAB_230582fa;
  output = result + 0x1c;
  if (mode == 0) {
    iVar1 = mbedtls_rsa_public(ctx,in_stack_00000004,output);
  }
  else {
    iVar1 = mbedtls_rsa_private(ctx,f_rng,p_rng,in_stack_00000004,output);
  }
  if (iVar1 != 0) goto LAB_23058300;
  if (result[sVar7 + 0x1b] == -0x44) {
    if (CONCAT31(in_register_00002039,md_alg) != 0) {
      pmVar5 = mbedtls_md_info_from_type(md_alg);
      if (pmVar5 == (mbedtls_md_info_t *)0x0) goto LAB_230582fa;
      uVar4 = mbedtls_md_get_size(pmVar5);
      hashlen = CONCAT31(extraout_var,uVar4);
    }
    pmVar5 = mbedtls_md_info_from_type(mgf1_hash_id);
    if (pmVar5 != (mbedtls_md_info_t *)0x0) {
      uVar4 = mbedtls_md_get_size(pmVar5);
      slen = CONCAT31(extraout_var_00,uVar4);
      memset(auStack1124,0,8);
      sVar6 = mbedtls_mpi_bitlen(&ctx->N);
      puVar2 = output;
      sVar8 = sVar7;
      if ((sVar6 - 1 & 7) == 0) {
        puVar2 = result + 0x1d;
        sVar8 = sVar7 - 1;
      }
      if ((int)(uint)result[28] >> (sVar8 * -8 + sVar6 + 7 & 0x1f) == 0) {
        mbedtls_md_init((mbedtls_md_context_t *)(zeros + 4));
        iVar1 = mbedtls_md_setup((mbedtls_md_context_t *)(zeros + 4),pmVar5,0);
        if (iVar1 != 0) {
          mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
          goto LAB_23058300;
        }
        mgf_mask(puVar2,~slen + sVar8,puVar2 + ~slen + sVar8,slen,
                 (mbedtls_md_context_t *)(zeros + 4));
        result[28] = (byte)(0xff >> (sVar8 * 8 - (sVar6 - 1) & 0x1f)) & result[28];
        do {
          puVar3 = puVar2;
          if (output + sVar8 <= puVar3) {
            if (output + sVar8 == puVar3) goto LAB_230584a6;
            break;
          }
          puVar2 = puVar3 + 1;
        } while (*puVar3 == '\0');
        puVar2 = puVar3 + 1;
        if ((*puVar3 == '\x01') &&
           ((sVar7 = ((sVar7 - 1) - slen) - (int)(puVar2 + -(int)output),
            in_stack_00000000 == 0xffffffff || (in_stack_00000000 == sVar7)))) {
          mbedtls_md_starts((mbedtls_md_context_t *)(zeros + 4));
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),auStack1124,8);
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),hash,hashlen);
          mbedtls_md_update((mbedtls_md_context_t *)(zeros + 4),puVar2,sVar7);
          mbedtls_md_finish((mbedtls_md_context_t *)(zeros + 4),(uchar *)&md_ctx.hmac_ctx);
          mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
          iVar1 = memcmp(puVar2 + sVar7,&md_ctx.hmac_ctx,slen);
          if (iVar1 != 0) {
            iVar1 = -0x4380;
          }
          goto LAB_23058300;
        }
LAB_230584a6:
        mbedtls_md_free((mbedtls_md_context_t *)(zeros + 4));
        goto LAB_230584ac;
      }
    }
LAB_230582fa:
    iVar1 = -0x4080;
  }
  else {
LAB_230584ac:
    iVar1 = -0x4100;
  }
LAB_23058300:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsassa_pss_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  mbedtls_md_type_t mgf1_hash_id;
  int in_fa0;
  uchar *in_fa1;
  
  mgf1_hash_id = (mbedtls_md_type_t)ctx->hash_id;
  if (ctx->hash_id == 0) {
    mgf1_hash_id = md_alg;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_verify_ext
                    (ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,mgf1_hash_id,in_fa0,in_fa1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_rsa_rsassa_pkcs1_v15_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  uchar **output;
  uint uVar1;
  uchar *end;
  uchar uVar2;
  int iVar3;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  undefined3 in_register_00002039;
  size_t sVar4;
  mbedtls_md_type_t mStack1077;
  mbedtls_md_type_t msg_md_alg;
  size_t sStack1076;
  size_t asn1_len;
  uchar *p;
  mbedtls_asn1_buf oid;
  uchar buf [1024];
  size_t __n;
  
  if ((mode == 1) && (ctx->padding != 0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4080;
  }
  sVar4 = ctx->len;
  if (sVar4 - 0x10 < 0x3f1) {
    output = &oid.p;
    if (mode == 0) {
      iVar3 = mbedtls_rsa_public(ctx,sig,(uchar *)output);
    }
    else {
      iVar3 = mbedtls_rsa_private(ctx,f_rng,p_rng,sig,(uchar *)output);
    }
    if (iVar3 != 0) goto LAB_230584f4;
    if (((char)oid.p != '\0') || (asn1_len = (int)&oid.p + 2, oid.p._1_1_ != '\x01')) {
LAB_23058558:
      iVar3 = -0x4100;
      goto LAB_230584f4;
    }
    while (*(uchar *)asn1_len != '\0') {
      if (((uchar *)((int)output + (sVar4 - 1)) <= asn1_len) || (*(uchar *)asn1_len != -1))
      goto LAB_23058558;
      asn1_len = asn1_len + 1;
    }
    asn1_len = asn1_len + 1;
    uVar1 = sVar4 - (int)(asn1_len + -(int)output);
    if ((uVar1 == hashlen) && (CONCAT31(in_register_00002039,md_alg) == 0)) {
      iVar3 = memcmp((void *)asn1_len,hash,hashlen);
      if (iVar3 == 0) goto LAB_230584f4;
    }
    else {
      md_info = mbedtls_md_info_from_type(md_alg);
      if (md_info == (mbedtls_md_info_t *)0x0) goto LAB_230584ee;
      uVar2 = mbedtls_md_get_size(md_info);
      __n = CONCAT31(extraout_var,uVar2);
      end = (uchar *)(asn1_len + uVar1);
      iVar3 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,0x30);
      if ((((iVar3 == 0) && (sStack1076 + 2 == uVar1)) &&
          (iVar3 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,0x30),
          iVar3 == 0)) &&
         ((sStack1076 + 6 + __n == uVar1 &&
          (iVar3 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&oid,6), iVar3 == 0)))) {
        oid.len = asn1_len;
        asn1_len = asn1_len + oid.tag;
        iVar3 = mbedtls_oid_get_md_alg((mbedtls_asn1_buf *)&p,&mStack1077);
        if (((iVar3 == 0) &&
            (((uint)mStack1077 == CONCAT31(in_register_00002039,md_alg) &&
             (iVar3 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,5),
             iVar3 == 0)))) &&
           ((iVar3 = mbedtls_asn1_get_tag((uchar **)&asn1_len,end,(size_t *)&stack0xfffffbcc,4),
            iVar3 == 0 &&
            (((sStack1076 == __n && (iVar3 = memcmp((void *)asn1_len,hash,__n), iVar3 == 0)) &&
             (end == (uchar *)(__n + asn1_len))))))) goto LAB_230584f4;
      }
    }
    iVar3 = -0x4380;
  }
  else {
LAB_230584ee:
    iVar3 = -0x4080;
  }
LAB_230584f4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_rsa_pkcs1_verify
              (mbedtls_rsa_context *ctx,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng,
              int mode,mbedtls_md_type_t md_alg,uint hashlen,uchar *hash,uchar *sig)

{
  int iVar1;
  
  if (ctx->padding == 0) {
    iVar1 = mbedtls_rsa_rsassa_pkcs1_v15_verify(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (ctx->padding != 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x4100;
  }
  iVar1 = mbedtls_rsa_rsassa_pss_verify(ctx,f_rng,p_rng,mode,md_alg,hashlen,hash,sig);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mbedtls_rsa_free(mbedtls_rsa_context *ctx)

{
  mbedtls_mpi_free(&ctx->Vi);
  mbedtls_mpi_free(&ctx->Vf);
  mbedtls_mpi_free(&ctx->RQ);
  mbedtls_mpi_free(&ctx->RP);
  mbedtls_mpi_free(&ctx->RN);
  mbedtls_mpi_free(&ctx->QP);
  mbedtls_mpi_free(&ctx->DQ);
  mbedtls_mpi_free(&ctx->DP);
  mbedtls_mpi_free(&ctx->Q);
  mbedtls_mpi_free(&ctx->P);
  mbedtls_mpi_free(&ctx->D);
  mbedtls_mpi_free(&ctx->E);
  mbedtls_mpi_free(&ctx->N);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha256_init(mbedtls_sha256_context *ctx)

{
  memset(ctx,0,0x74);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha256_free(mbedtls_sha256_context *ctx)

{
  mbedtls_sha256_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_sha256_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_sha256_context *)((int)ctx->total + 1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha256_clone(mbedtls_sha256_context *dst,mbedtls_sha256_context *src)

{
  memcpy(dst,src,0x74);
  return;
}



void mbedtls_sha256_starts(mbedtls_sha256_context *ctx,int is224)

{
  uint32_t uVar1;
  
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  if (is224 == 0) {
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    uVar1 = 0x5be0cd19;
  }
  else {
    ctx->state[0] = 0xc1059ed8;
    ctx->state[1] = 0x367cd507;
    ctx->state[2] = 0x3070dd17;
    ctx->state[3] = 0xf70e5939;
    ctx->state[4] = 0xffc00b31;
    ctx->state[5] = 0x68581511;
    ctx->state[6] = 0x64f98fa7;
    uVar1 = 0xbefa4fa4;
  }
  ctx->state[7] = uVar1;
  ctx->is224 = is224;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha256_process(mbedtls_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint *puVar9;
  uint32_t *puVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint32_t *puVar22;
  uint32_t *puVar23;
  uint uVar24;
  uint32_t uVar25;
  uint uVar26;
  uint32_t *puVar27;
  uint32_t uVar28;
  uint local_150;
  uint32_t A [8];
  uint32_t W [64];
  
  puVar18 = &local_150;
  puVar9 = &local_150;
  puVar10 = ctx->state;
  do {
    uVar7 = *puVar10;
    puVar10 = puVar10 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar10);
  puVar22 = A + 7;
  pbVar3 = data;
  puVar10 = puVar22;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar10 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
               (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar10 = puVar10 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar10 = K;
  puVar27 = puVar22;
  do {
    puVar23 = puVar10 + 8;
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + *puVar10 + *puVar27 +
                    ((A[5] ^ A[4]) & A[3] ^ A[5]);
    uVar12 = A[2] + iVar13;
    uVar14 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             A[5] + puVar10[1] + puVar27[1] + ((A[3] ^ A[4]) & uVar12 ^ A[4]);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) + ((uVar14 | local_150) & A[0] | uVar14 & local_150)
            + iVar13;
    uVar11 = A[1] + iVar13;
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             A[4] + puVar10[2] + puVar27[2] + ((uVar12 ^ A[3]) & uVar11 ^ A[3]);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & local_150 | uVar14 & uVar1) +
            iVar13;
    uVar8 = A[0] + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             A[3] + puVar10[3] + puVar27[3] + ((uVar12 ^ uVar11) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = local_150 + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar10[4] + puVar27[4] + ((uVar11 ^ uVar8) & uVar6 ^ uVar11);
    A[2] = ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
           (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) + iVar13
    ;
    A[6] = uVar14 + iVar13;
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             uVar11 + puVar10[5] + puVar27[5] + ((uVar8 ^ uVar6) & A[6] ^ uVar8);
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar16 | A[2]) & uVar5 | uVar16 & A[2]) + iVar13;
    A[5] = uVar1 + iVar13;
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             uVar8 + puVar10[6] + puVar27[6] + ((uVar6 ^ A[6]) & A[5] ^ uVar6);
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar16 | A[2] & A[1]) + iVar13;
    A[4] = uVar5 + iVar13;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar6 + puVar10[7] + puVar27[7] + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    A[3] = uVar16 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar10 = puVar23;
    puVar27 = puVar27 + 8;
  } while (puVar23 != K + 0x10);
  do {
    uVar19 = puVar22[0xe];
    uVar1 = puVar22[1];
    uVar20 = puVar22[0xf];
    uVar24 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar22[9] + *puVar22 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar11 = puVar22[3];
    iVar13 = A[6] + ((A[3] >> 6 | A[3] << 0x1a) ^ (A[3] >> 0xb | A[3] << 0x15) ^
                    (A[3] << 7 | A[3] >> 0x19)) + ((A[5] ^ A[4]) & A[3] ^ A[5]) + puVar2[0x10] +
                    uVar24;
    uVar16 = A[2] + iVar13;
    uVar15 = iVar13 + ((local_150 >> 2 | local_150 << 0x1e) ^ (local_150 >> 0xd | local_150 << 0x13)
                      ^ (local_150 << 10 | local_150 >> 0x16)) +
                      ((local_150 | A[0]) & A[1] | local_150 & A[0]);
    uVar6 = puVar22[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar22[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[3] ^ A[4]) & uVar16 ^ A[4]) + A[5] + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) + ((local_150 | uVar15) & A[0] | local_150 & uVar15)
            + iVar13;
    uVar14 = A[1] + iVar13;
    uVar6 = ((uVar24 * 0x8000 | uVar24 >> 0x11) ^ (uVar24 * 0x2000 | uVar24 >> 0x13) ^ uVar24 >> 10)
            + uVar6 + puVar22[0xb] +
            ((uVar11 >> 7 | uVar11 << 0x19) ^ (uVar11 << 0xe | uVar11 >> 0x12) ^ uVar11 >> 3);
    iVar13 = ((A[3] ^ uVar16) & uVar14 ^ A[3]) + A[4] + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar22[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & local_150 | uVar15 & uVar5) +
            iVar13;
    uVar12 = A[0] + iVar13;
    uVar26 = puVar22[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar11 + puVar22[0xc] +
            ((uVar26 >> 7 | uVar26 << 0x19) ^ (uVar26 << 0xe | uVar26 >> 0x12) ^ uVar26 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + A[3] + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar11 = local_150 + iVar13;
    puVar22[0x12] = uVar6;
    uVar21 = puVar22[5];
    uVar26 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar26 + puVar22[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar11 >> 6 | uVar11 * 0x4000000) ^ (uVar11 >> 0xb | uVar11 * 0x200000) ^
             (uVar11 * 0x80 | uVar11 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar11 ^ uVar14) + uVar16 + puVar2[0x14] + uVar26;
    A[2] = ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
           (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) + iVar13
    ;
    A[6] = uVar15 + iVar13;
    uVar6 = puVar22[6];
    puVar22[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((A[6] >> 6 | A[6] * 0x4000000) ^ (A[6] >> 0xb | A[6] * 0x200000) ^
             (A[6] * 0x80 | A[6] >> 0x19)) +
             ((uVar12 ^ uVar11) & A[6] ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    A[1] = ((A[2] >> 2 | A[2] * 0x40000000) ^ (A[2] >> 0xd | A[2] * 0x80000) ^
           (A[2] * 0x400 | A[2] >> 0x16)) + ((uVar17 | A[2]) & uVar8 | uVar17 & A[2]) + iVar13;
    A[5] = uVar5 + iVar13;
    uVar1 = puVar22[7];
    puVar22[0x14] = uVar26;
    uVar7 = uVar20 + uVar6 +
            ((uVar26 * 0x8000 | uVar26 >> 0x11) ^ (uVar26 * 0x2000 | uVar26 >> 0x13) ^ uVar26 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((A[5] >> 6 | A[5] * 0x4000000) ^ (A[5] >> 0xb | A[5] * 0x200000) ^
             (A[5] * 0x80 | A[5] >> 0x19)) +
             ((uVar11 ^ A[6]) & A[5] ^ uVar11) + uVar12 + puVar2[0x16] + uVar7;
    A[0] = ((A[1] >> 2 | A[1] * 0x40000000) ^ (A[1] >> 0xd | A[1] * 0x80000) ^
           (A[1] * 0x400 | A[1] >> 0x16)) + ((A[2] | A[1]) & uVar17 | A[2] & A[1]) + iVar13;
    A[4] = uVar8 + iVar13;
    uVar5 = puVar22[8];
    puVar22[0x15] = uVar16;
    puVar22[0x10] = uVar24;
    uVar28 = puVar2[0x17];
    uVar25 = uVar24 + uVar1 +
             ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10
             ) + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar22[0x17] = uVar25;
    iVar13 = ((A[4] >> 6 | A[4] * 0x4000000) ^ (A[4] >> 0xb | A[4] * 0x200000) ^
             (A[4] * 0x80 | A[4] >> 0x19)) +
             uVar11 + uVar28 + uVar25 + ((A[6] ^ A[5]) & A[4] ^ A[6]);
    puVar22[0x16] = uVar7;
    puVar22 = puVar22 + 8;
    A[3] = uVar17 + iVar13;
    local_150 = ((A[0] >> 2 | A[0] * 0x40000000) ^ (A[0] >> 0xd | A[0] * 0x80000) ^
                (A[0] * 0x400 | A[0] >> 0x16)) + ((A[1] | A[0]) & A[2] | A[1] & A[0]) + iVar13;
    puVar2 = puVar2 + 8;
  } while (W + 0x2f != puVar22);
  puVar10 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar22 = puVar10 + 1;
    puVar18 = (uint *)((int *)puVar18 + 1);
    *puVar10 = *puVar10 + iVar13;
    puVar10 = puVar22;
  } while ((uint32_t *)ctx->buffer != puVar22);
  return;
}



void mbedtls_sha256_update(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_sha256_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_sha256_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha256_update(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha256_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_sha256_finish(mbedtls_sha256_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha256_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  output[0x14] = *(uchar *)((int)ctx->state + 0x17);
  output[0x15] = (uchar)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uchar)(ctx->state[5] >> 8);
  output[0x17] = (uchar)ctx->state[5];
  output[0x18] = *(uchar *)((int)ctx->state + 0x1b);
  output[0x19] = (uchar)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uchar)(ctx->state[6] >> 8);
  output[0x1b] = (uchar)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uchar *)((int)ctx->state + 0x1f);
    output[0x1d] = (uchar)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uchar)(ctx->state[7] >> 8);
    output[0x1f] = (uchar)ctx->state[7];
  }
  return;
}



// WARNING: Variable defined which should be unmapped: ctx

void mbedtls_sha256(uchar *input,size_t ilen,uchar *output,int is224)

{
  undefined auStack132 [4];
  mbedtls_sha256_context ctx;
  
  mbedtls_sha256_init((mbedtls_sha256_context *)auStack132);
  mbedtls_sha256_starts((mbedtls_sha256_context *)auStack132,is224);
  mbedtls_sha256_update((mbedtls_sha256_context *)auStack132,input,ilen);
  mbedtls_sha256_finish((mbedtls_sha256_context *)auStack132,output);
  mbedtls_sha256_free((mbedtls_sha256_context *)auStack132);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mbedtls_x509_crt * mbedtls_ssl_own_cert(mbedtls_ssl_context *ssl)

{
  mbedtls_x509_crt *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = (mbedtls_x509_crt *)ssl->handshake->key_cert, pmVar1 != (mbedtls_x509_crt *)0x0)) ||
     (pmVar1 = (mbedtls_x509_crt *)ssl->conf->key_cert, pmVar1 != (mbedtls_x509_crt *)0x0)) {
    pmVar1 = (mbedtls_x509_crt *)(pmVar1->raw).tag;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar1;
}



void mbedtls_zeroize(void *v,size_t n)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)(n + (int)v);
  while ((undefined *)v != puVar1) {
    *(undefined *)v = 0;
    v = (void *)((int)v + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ssl_swap_epochs(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_transform *pmVar1;
  uchar *puVar2;
  undefined auStack24 [4];
  uchar tmp_out_ctr [8];
  
  if (ssl->transform_out == ssl->handshake->alt_transform_out) {
    mbedtls_debug_print_msg(ssl,3,"file1",0xa0a,"skip swap epochs");
  }
  else {
    mbedtls_debug_print_msg(ssl,3,"file1",0xa0e,"swap epochs");
    pmVar1 = ssl->transform_out;
    ssl->transform_out = ssl->handshake->alt_transform_out;
    ssl->handshake->alt_transform_out = pmVar1;
    memcpy(auStack24,ssl->out_ctr,8);
    memcpy(ssl->out_ctr,ssl->handshake->alt_out_ctr,8);
    memcpy(ssl->handshake->alt_out_ctr,auStack24,8);
    pmVar1 = ssl->transform_out;
    puVar2 = ssl->out_iv;
    if ((pmVar1 != (mbedtls_ssl_transform *)0x0) && (1 < ssl->minor_ver)) {
      puVar2 = puVar2 + (pmVar1->ivlen - pmVar1->fixed_ivlen);
    }
    ssl->out_msg = puVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ssl_calc_finished_tls_sha256(mbedtls_ssl_context *ssl,uchar *buf,int from)

{
  mbedtls_ssl_session *pmVar1;
  char *pcVar2;
  uchar auStack180 [4];
  uchar padbuf [32];
  mbedtls_sha256_context sha256;
  
  pmVar1 = ssl->session_negotiate;
  if (pmVar1 == (mbedtls_ssl_session *)0x0) {
    pmVar1 = ssl->session;
  }
  mbedtls_sha256_init((mbedtls_sha256_context *)(padbuf + 0x1c));
  mbedtls_debug_print_msg(ssl,2,"file1",0x1356,"=> calc  finished tls sha256");
  mbedtls_sha256_clone((mbedtls_sha256_context *)(padbuf + 0x1c),&ssl->handshake->fin_sha256);
  mbedtls_debug_print_buf
            (ssl,4,"file1",0x1362,"finished sha2 state",(uchar *)(sha256.total + 1),0x20);
  if (from == 0) {
    pcVar2 = "client finished";
  }
  else {
    pcVar2 = "server finished";
  }
  mbedtls_sha256_finish((mbedtls_sha256_context *)(padbuf + 0x1c),auStack180);
  (*ssl->handshake->tls_prf)(pmVar1->master,0x30,pcVar2,auStack180,0x20,buf,0xc);
  mbedtls_debug_print_buf(ssl,3,"file1",0x136e,"calc finished result",buf,0xc);
  mbedtls_sha256_free((mbedtls_sha256_context *)(padbuf + 0x1c));
  mbedtls_zeroize(auStack180,0x20);
  mbedtls_debug_print_msg(ssl,2,"file1",0x1374,"<= calc  finished");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: sha256

void ssl_calc_verify_tls_sha256(mbedtls_ssl_context *ssl,uchar *hash)

{
  undefined auStack132 [4];
  mbedtls_sha256_context sha256;
  
  mbedtls_sha256_init((mbedtls_sha256_context *)auStack132);
  mbedtls_debug_print_msg(ssl,2,"file1",0x42d,"=> calc verify sha256");
  mbedtls_sha256_clone((mbedtls_sha256_context *)auStack132,&ssl->handshake->fin_sha256);
  mbedtls_sha256_finish((mbedtls_sha256_context *)auStack132,hash);
  mbedtls_debug_print_buf(ssl,3,"file1",0x432,"calculated verify result",hash,0x20);
  mbedtls_debug_print_msg(ssl,2,"file1",0x433,"<= calc verify");
  mbedtls_sha256_free((mbedtls_sha256_context *)auStack132);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ssl_flight_free(mbedtls_ssl_flight_item *flight)

{
  mbedtls_ssl_flight_item *pmVar1;
  
  while (flight != (mbedtls_ssl_flight_item *)0x0) {
    pmVar1 = flight->next;
    vPortFree(flight->p);
    vPortFree(flight);
    flight = pmVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ssl_append_key_cert(mbedtls_ssl_key_cert **head,mbedtls_x509_crt *cert,mbedtls_pk_context *key)

{
  mbedtls_ssl_key_cert *pmVar1;
  int iVar2;
  mbedtls_ssl_key_cert *pmVar3;
  mbedtls_ssl_key_cert *pmVar4;
  
  pmVar1 = (mbedtls_ssl_key_cert *)mycalloc(1,0xc);
  if (pmVar1 == (mbedtls_ssl_key_cert *)0x0) {
    iVar2 = -0x7f00;
  }
  else {
    pmVar1->cert = cert;
    pmVar1->next = (mbedtls_ssl_key_cert *)0x0;
    pmVar1->key = key;
    pmVar3 = *head;
    if (*head == (mbedtls_ssl_key_cert *)0x0) {
      *head = pmVar1;
    }
    else {
      do {
        pmVar4 = pmVar3;
        pmVar3 = pmVar4->next;
      } while (pmVar3 != (mbedtls_ssl_key_cert *)0x0);
      pmVar4->next = pmVar1;
    }
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



void ssl_update_checksum_start(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  mbedtls_sha256_update(&ssl->handshake->fin_sha256,buf,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ssl_update_checksum_sha256(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  mbedtls_sha256_update(&ssl->handshake->fin_sha256,buf,len);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



size_t mbedtls_ssl_hdr_len(void)

{
  int in_a0;
  
  if ((*(ushort *)(in_a0 + 0x74) & 2) != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xd;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 5;
}



void ssl_set_timer(mbedtls_ssl_context *ssl,uint32_t millisecs)

{
  if (ssl->f_set_timer != (mbedtls_ssl_set_timer_t *)0x0) {
    mbedtls_debug_print_msg(ssl,3,"file1",0x52,"set_timer to %d ms",millisecs);
                    // WARNING: Could not recover jumptable at 0x230599f4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*ssl->f_set_timer)(ssl->p_timer,millisecs >> 2,millisecs);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ssl_check_timer(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if (ssl->f_get_timer == (mbedtls_ssl_get_timer_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  iVar1 = (*ssl->f_get_timer)(ssl->p_timer);
  if (iVar1 == 2) {
    mbedtls_debug_print_msg(ssl,3,"file1",0x60,"timer expired");
    iVar1 = -1;
  }
  else {
    iVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: tmp

int tls_prf_sha256(uchar *secret,size_t slen,char *label,uchar *random,size_t rlen,uchar *dstbuf,
                  size_t dlen)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uchar uVar4;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  size_t sVar5;
  int iVar6;
  size_t sVar7;
  size_t sVar8;
  uint uVar9;
  undefined auStack220 [4];
  mbedtls_md_context_t md_ctx;
  uchar h_i [32];
  uchar tmp [128];
  size_t ilen;
  
  mbedtls_md_init((mbedtls_md_context_t *)auStack220);
  md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
  if (md_info == (mbedtls_md_info_t *)0x0) {
    iVar6 = -0x6c00;
  }
  else {
    uVar4 = mbedtls_md_get_size(md_info);
    ilen = CONCAT31(extraout_var,uVar4);
    sVar5 = strlen(label);
    if (sVar5 + rlen + ilen < 0x81) {
      sVar5 = strlen(label);
      memcpy(h_i + ilen + 0x1c,label,sVar5);
      memcpy(h_i + ilen + sVar5 + 0x1c,random,rlen);
      iVar6 = mbedtls_md_setup((mbedtls_md_context_t *)auStack220,md_info,1);
      if (iVar6 == 0) {
        mbedtls_md_hmac_starts((mbedtls_md_context_t *)auStack220,secret,slen);
        mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + ilen + 0x1c,rlen + sVar5);
        mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,h_i + 0x1c);
        uVar3 = 0;
        while (uVar9 = uVar3, uVar9 < dlen) {
          mbedtls_md_hmac_reset((mbedtls_md_context_t *)auStack220);
          mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + 0x1c,rlen + sVar5 + ilen);
          mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,(uchar *)&md_ctx.hmac_ctx);
          mbedtls_md_hmac_reset((mbedtls_md_context_t *)auStack220);
          mbedtls_md_hmac_update((mbedtls_md_context_t *)auStack220,h_i + 0x1c,ilen);
          mbedtls_md_hmac_finish((mbedtls_md_context_t *)auStack220,h_i + 0x1c);
          sVar7 = ilen;
          if (dlen < ilen + uVar9) {
            sVar7 = dlen % ilen;
          }
          sVar8 = 0;
          while (uVar3 = ilen + uVar9, sVar8 != sVar7) {
            iVar2 = sVar8 - 4;
            iVar1 = sVar8 + uVar9;
            sVar8 = sVar8 + 1;
            dstbuf[iVar1] = h_i[iVar2];
          }
        }
        mbedtls_md_free((mbedtls_md_context_t *)auStack220);
        mbedtls_zeroize(h_i + 0x1c,0x80);
        mbedtls_zeroize(&md_ctx.hmac_ctx,0x20);
      }
    }
    else {
      iVar6 = -0x7100;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar6;
}



int mbedtls_ssl_derive_keys(mbedtls_ssl_context *ssl)

{
  mbedtls_cipher_type_t mVar1;
  size_t __n;
  mbedtls_ssl_transform *pmVar2;
  mbedtls_cipher_context_t *ctx;
  uchar uVar3;
  mbedtls_cipher_info_t *cipher_info;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  size_t sVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  size_t sVar9;
  mbedtls_ssl_handshake_params *pmVar10;
  uchar *puVar11;
  uchar *puVar12;
  mbedtls_cipher_context_t *ctx_00;
  uchar *puVar13;
  uchar *puVar14;
  mbedtls_ssl_session *pmVar15;
  undefined auStack384 [4];
  uchar tmp [64];
  uchar keyblk [256];
  
  pmVar2 = ssl->transform_negotiate;
  pmVar15 = ssl->session_negotiate;
  pmVar10 = ssl->handshake;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1f5,"=> derive keys");
  cipher_info = mbedtls_cipher_info_from_type(pmVar2->ciphersuite_info->cipher);
  if (cipher_info == (mbedtls_cipher_info_t *)0x0) {
    mVar1 = pmVar2->ciphersuite_info->cipher;
    pcVar8 = "cipher info for %d not found";
    iVar6 = 0x1fb;
  }
  else {
    md_info = mbedtls_md_info_from_type(pmVar2->ciphersuite_info->mac);
    if (md_info != (mbedtls_md_info_t *)0x0) {
      if (ssl->minor_ver == 3) {
        pmVar10->tls_prf = tls_prf_sha256;
        pmVar10->calc_verify = ssl_calc_verify_tls_sha256;
        pmVar10->calc_finished = ssl_calc_finished_tls_sha256;
        puVar13 = pmVar10->randbytes;
        puVar11 = pmVar15->master;
        if (pmVar10->resume == 0) {
          puVar12 = pmVar10->premaster;
          mbedtls_debug_print_buf(ssl,3,"file1",0x243,"premaster secret",puVar12,pmVar10->pmslen);
          iVar6 = (*pmVar10->tls_prf)(puVar12,pmVar10->pmslen,"master secret",puVar13,0x40,puVar11,
                                      0x30);
          if (iVar6 == 0) {
            mbedtls_zeroize(puVar12,0x30);
            goto LAB_23059d5a;
          }
          pcVar8 = "prf";
          iVar7 = 0x275;
        }
        else {
          mbedtls_debug_print_msg(ssl,3,"file1",0x27c,"no premaster (session resumed)");
LAB_23059d5a:
          memcpy(auStack384,puVar13,0x40);
          memcpy(puVar13,tmp + 0x1c,0x20);
          memcpy(pmVar10->randbytes + 0x20,auStack384,0x20);
          mbedtls_zeroize(auStack384,0x40);
          iVar6 = (*pmVar10->tls_prf)(puVar11,0x30,"key expansion",puVar13,0x40,tmp + 0x3c,0x100);
          if (iVar6 == 0) {
            pcVar8 = mbedtls_ssl_get_ciphersuite_name(pmVar15->ciphersuite);
            mbedtls_debug_print_msg(ssl,3,"file1",0x29b,"ciphersuite = %s",pcVar8);
            mbedtls_debug_print_buf(ssl,3,"file1",0x29c,"master secret",puVar11,0x30);
            mbedtls_debug_print_buf(ssl,4,"file1",0x29d,"random bytes",puVar13,0x40);
            mbedtls_debug_print_buf(ssl,4,"file1",0x29e,"key block",tmp + 0x3c,0x100);
            mbedtls_zeroize(puVar13,0x40);
            pmVar2->keylen = cipher_info->key_bitlen >> 3;
            if ((cipher_info->mode + ~MBEDTLS_MODE_CTR & 0xfd) == 0) {
              pmVar2->ivlen = 0xc;
              pmVar2->fixed_ivlen = 4;
              pmVar2->maclen = 0;
              iVar6 = 8;
              if ((pmVar2->ciphersuite_info->flags & 2) == 0) {
                iVar6 = 0x10;
              }
              sVar9 = iVar6 + 8;
LAB_23059e78:
              pmVar2->minlen = sVar9;
            }
            else {
              iVar6 = mbedtls_md_setup(&pmVar2->md_ctx_enc,md_info,1);
              if ((iVar6 != 0) ||
                 (iVar6 = mbedtls_md_setup(&pmVar2->md_ctx_dec,md_info,1), iVar6 != 0)) {
                pcVar8 = "mbedtls_md_setup";
                iVar7 = 699;
                goto LAB_23059d46;
              }
              uVar3 = mbedtls_md_get_size(md_info);
              uVar5 = CONCAT31(extraout_var,uVar3);
              pmVar2->maclen = uVar5;
              sVar9 = cipher_info->iv_size;
              pmVar2->ivlen = sVar9;
              if (cipher_info->mode != MBEDTLS_MODE_STREAM) {
                sVar4 = (uVar5 + cipher_info->block_size) - uVar5 % cipher_info->block_size;
                pmVar2->minlen = sVar4;
                if (1 < ssl->minor_ver - 2U) {
                  iVar6 = 0x2f7;
                  goto LAB_23059cde;
                }
                sVar9 = sVar9 + sVar4;
                goto LAB_23059e78;
              }
              pmVar2->minlen = uVar5;
            }
            mbedtls_debug_print_msg
                      (ssl,3,"file1",0x2ff,"keylen: %d, minlen: %d, ivlen: %d, maclen: %d",
                       pmVar2->keylen,pmVar2->minlen,pmVar2->ivlen);
            uVar5 = pmVar2->keylen;
            __n = pmVar2->fixed_ivlen;
            sVar9 = pmVar2->maclen;
            iVar6 = sVar9 * 2;
            if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
              puVar14 = tmp + 0x3c;
              puVar12 = puVar14 + iVar6;
              puVar11 = puVar14 + iVar6 + uVar5;
              puVar14 = puVar14 + sVar9;
              if (__n == 0) {
                __n = pmVar2->ivlen;
              }
              memcpy(pmVar2->iv_enc,puVar11 + uVar5,__n);
              memcpy(pmVar2->iv_dec,puVar11 + pmVar2->keylen + __n,__n);
              puVar13 = tmp + 0x3c;
            }
            else {
              puVar13 = tmp + 0x3c;
              puVar12 = puVar13 + iVar6 + uVar5;
              puVar11 = puVar13 + iVar6;
              puVar13 = puVar13 + sVar9;
              if (__n == 0) {
                __n = pmVar2->ivlen;
              }
              memcpy(pmVar2->iv_dec,puVar12 + uVar5,__n);
              memcpy(pmVar2->iv_enc,puVar12 + pmVar2->keylen + __n,__n);
              puVar14 = tmp + 0x3c;
            }
            if (ssl->minor_ver < 1) {
              iVar6 = 0x349;
              goto LAB_23059cde;
            }
            mbedtls_md_hmac_starts(&pmVar2->md_ctx_enc,puVar13,pmVar2->maclen);
            mbedtls_md_hmac_starts(&pmVar2->md_ctx_dec,puVar14,pmVar2->maclen);
            ctx_00 = &pmVar2->cipher_ctx_enc;
            iVar6 = mbedtls_cipher_setup(ctx_00,cipher_info);
            if (iVar6 == 0) {
              ctx = &pmVar2->cipher_ctx_dec;
              iVar6 = mbedtls_cipher_setup(ctx,cipher_info);
              if (iVar6 == 0) {
                iVar6 = mbedtls_cipher_setkey
                                  (ctx_00,puVar12,cipher_info->key_bitlen,MBEDTLS_ENCRYPT);
                if (iVar6 == 0) {
                  iVar6 = mbedtls_cipher_setkey(ctx,puVar11,cipher_info->key_bitlen,MBEDTLS_DECRYPT)
                  ;
                  if (iVar6 == 0) {
                    if (cipher_info->mode == MBEDTLS_MODE_CBC) {
                      iVar7 = mbedtls_cipher_set_padding_mode(ctx_00,MBEDTLS_PADDING_NONE);
                      if (iVar7 != 0) {
                        mbedtls_debug_print_ret
                                  (ssl,1,"file1",0x38e,"mbedtls_cipher_set_padding_mode",iVar7);
                        iVar6 = iVar7;
                        goto LAB_23059c1a;
                      }
                      iVar7 = mbedtls_cipher_set_padding_mode(ctx,MBEDTLS_PADDING_NONE);
                      if (iVar7 != 0) {
                        mbedtls_debug_print_ret
                                  (ssl,1,"file1",0x395,"mbedtls_cipher_set_padding_mode",iVar7);
                        iVar6 = iVar7;
                        goto LAB_23059c1a;
                      }
                    }
                    mbedtls_zeroize(tmp + 0x3c,0x100);
                    mbedtls_debug_print_msg(ssl,2,"file1",0x3bd,"<= derive keys");
                    goto LAB_23059c1a;
                  }
                  pcVar8 = "mbedtls_cipher_setkey";
                  iVar7 = 900;
                }
                else {
                  pcVar8 = "mbedtls_cipher_setkey";
                  iVar7 = 0x37c;
                }
              }
              else {
                pcVar8 = "mbedtls_cipher_setup";
                iVar7 = 0x374;
              }
            }
            else {
              pcVar8 = "mbedtls_cipher_setup";
              iVar7 = 0x36d;
            }
          }
          else {
            pcVar8 = "prf";
            iVar7 = 0x296;
          }
        }
LAB_23059d46:
        mbedtls_debug_print_ret(ssl,1,"file1",iVar7,pcVar8,iVar6);
      }
      else {
        iVar6 = 0x232;
LAB_23059cde:
        mbedtls_debug_print_msg(ssl,1,"file1",iVar6,"should never happen");
        iVar6 = -0x6c00;
      }
      goto LAB_23059c1a;
    }
    pcVar8 = "mbedtls_md info for %d not found";
    mVar1 = pmVar2->ciphersuite_info->mac;
    iVar6 = 0x203;
  }
  mbedtls_debug_print_msg(ssl,1,"file1",iVar6,pcVar8,(uint)mVar1);
  iVar6 = -0x7100;
LAB_23059c1a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar6;
}



int mbedtls_ssl_flush_output(mbedtls_ssl_context *ssl)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  uchar uVar4;
  size_t sVar5;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x98a,"=> flush output");
  if (ssl->f_send == (mbedtls_ssl_send_t *)0x0) {
    mbedtls_debug_print_msg
              (ssl,1,"file1",0x98f,"Bad usage of mbedtls_ssl_set_bio() or mbedtls_ssl_set_bio()");
    iVar1 = -0x7100;
  }
  else {
    if (ssl->out_left == 0) {
      iVar1 = 0x996;
    }
    else {
      while (sVar5 = ssl->out_left, sVar5 != 0) {
        sVar2 = mbedtls_ssl_hdr_len();
        mbedtls_debug_print_msg
                  (ssl,2,"file1",0x99d,"message length: %d, out_left: %d",ssl->out_msglen + sVar2,
                   sVar5);
        sVar5 = mbedtls_ssl_hdr_len();
        iVar1 = (*ssl->f_send)(ssl->p_bio,ssl->out_hdr + sVar5 + (ssl->out_msglen - ssl->out_left),
                               ssl->out_left);
        mbedtls_debug_print_ret(ssl,2,"file1",0x9a3,"ssl->f_send",iVar1);
        if (iVar1 < 1) goto LAB_2305a122;
        ssl->out_left = ssl->out_left - iVar1;
      }
      uVar3 = 8;
      while ((*(ushort *)&ssl->conf->field_0x74 & 2) < uVar3) {
        uVar4 = ssl->out_ctr[uVar3 - 1] + '\x01';
        ssl->out_ctr[uVar3 - 1] = uVar4;
        if (uVar4 != '\0') break;
        uVar3 = uVar3 - 1 & 0xff;
      }
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        sVar5 = 2;
      }
      if (uVar3 == sVar5) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x9b2,"outgoing message counter would wrap");
        iVar1 = -0x6b80;
        goto LAB_2305a122;
      }
      iVar1 = 0x9b6;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",iVar1,"<= flush output");
    iVar1 = 0;
  }
LAB_2305a122:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mbedtls_ssl_recv_flight_completed(mbedtls_ssl_context *ssl)

{
  ssl_flight_free(ssl->handshake->flight);
  ssl->handshake->flight = (mbedtls_ssl_flight_item *)0x0;
  ssl->handshake->cur_msg = (mbedtls_ssl_flight_item *)0x0;
  ssl->handshake->in_flight_start_seq = ssl->handshake->in_msg_seq;
  ssl_set_timer(ssl,0);
  if ((ssl->in_msgtype == 0x16) && (*ssl->in_msg == '\x14')) {
    ssl->handshake->retransmit_state = '\x03';
  }
  else {
    ssl->handshake->retransmit_state = '\0';
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_send_flight_completed(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  
  ssl->handshake->retransmit_timeout = ssl->conf->hs_timeout_min;
  mbedtls_debug_print_msg
            (ssl,3,"file1",0x87,"update timeout value to %d millisecs",
             ssl->handshake->retransmit_timeout);
  ssl_set_timer(ssl,ssl->handshake->retransmit_timeout);
  if ((ssl->in_msgtype == 0x16) && (*ssl->in_msg == '\x14')) {
    uVar1 = '\x03';
  }
  else {
    uVar1 = '\x02';
  }
  ssl->handshake->retransmit_state = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_update_handshake_status(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_handshake_params *pmVar1;
  
  if ((ssl->state != 0x10) && (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0)) {
    (*ssl->handshake->update_checksum)(ssl,ssl->in_msg,ssl->in_hslen);
  }
  if (((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
     (pmVar1 = ssl->handshake, pmVar1 != (mbedtls_ssl_handshake_params *)0x0)) {
    pmVar1->in_msg_seq = pmVar1->in_msg_seq + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_optimize_checksum
               (mbedtls_ssl_context *ssl,mbedtls_ssl_ciphersuite_t *ciphersuite_info)

{
  if (ciphersuite_info->mac != MBEDTLS_MD_SHA384) {
    ssl->handshake->update_checksum = ssl_update_checksum_sha256;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  mbedtls_debug_print_msg(ssl,1,"file1",0x122e,"should never happen");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_reset_checksum(mbedtls_ssl_context *ssl)

{
  mbedtls_sha256_starts(&ssl->handshake->fin_sha256,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_session_init(mbedtls_ssl_session *session)

{
  memset(session,0,0x74);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_init(mbedtls_ssl_context *ssl)

{
  memset(ssl,0,0xc0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_conf_authmode(mbedtls_ssl_config *conf,int authmode)

{
  *(ushort *)&conf->field_0x74 =
       *(ushort *)&conf->field_0x74 & 0xfff3 | (ushort)((authmode & 3U) << 2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_conf_verify
               (mbedtls_ssl_config *conf,
               anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,void *p_vrfy)

{
  conf->f_vrfy = (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr_for_f_vrfy *)f_vrfy;
  conf->p_vrfy = p_vrfy;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_conf_rng(mbedtls_ssl_config *conf,mbedtls_ssl_recv_t *f_rng,void *p_rng)

{
  conf->f_rng = f_rng;
  conf->p_rng = p_rng;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_set_bio(mbedtls_ssl_context *ssl,void *p_bio,mbedtls_ssl_send_t *f_send,
                        mbedtls_ssl_recv_t *f_recv,mbedtls_ssl_recv_timeout_t *f_recv_timeout)

{
  ssl->p_bio = p_bio;
  ssl->f_send = f_send;
  ssl->f_recv = f_recv;
  ssl->f_recv_timeout = f_recv_timeout;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_conf_read_timeout(mbedtls_ssl_config *conf,uint32_t timeout)

{
  conf->read_timeout = timeout;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ssl_conf_own_cert
              (mbedtls_ssl_config *conf,mbedtls_x509_crt *own_cert,mbedtls_pk_context *pk_key)

{
  int iVar1;
  
  iVar1 = ssl_append_key_cert(&conf->key_cert,own_cert,pk_key);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mbedtls_ssl_conf_ca_chain
               (mbedtls_ssl_config *conf,mbedtls_x509_crt *ca_chain,mbedtls_x509_crl *ca_crl)

{
  conf->ca_chain = ca_chain;
  conf->ca_crl = ca_crl;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ssl_set_hostname(mbedtls_ssl_context *ssl,char *hostname)

{
  size_t __n;
  char *__dest;
  int iVar1;
  
  if (hostname == (char *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x7100;
  }
  __n = strlen(hostname);
  if (__n < 0x100) {
    __dest = (char *)mycalloc(1,__n + 1);
    ssl->hostname = __dest;
    if (__dest == (char *)0x0) {
      iVar1 = -0x7f00;
    }
    else {
      memcpy(__dest,hostname,__n);
      iVar1 = 0;
      ssl->hostname[__n] = '\0';
    }
  }
  else {
    iVar1 = -0x7100;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_conf_alpn_protocols(mbedtls_ssl_config *conf,char **protos)

{
  char **ppcVar1;
  uint uVar2;
  size_t sVar3;
  
  uVar2 = 0;
  ppcVar1 = protos;
  while( true ) {
    if (*ppcVar1 == (char *)0x0) {
      conf->alpn_list = protos;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    sVar3 = strlen(*ppcVar1);
    uVar2 = uVar2 + sVar3;
    if ((0xfe < sVar3 - 1) || (0xffff < uVar2)) break;
    ppcVar1 = ppcVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x7100;
}



uint32_t mbedtls_ssl_get_verify_result(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_session *pmVar1;
  
  pmVar1 = ssl->session;
  if ((pmVar1 == (mbedtls_ssl_session *)0x0) &&
     (pmVar1 = ssl->session_negotiate, pmVar1 == (mbedtls_ssl_session *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xffffffff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar1->verify_result;
}



char * mbedtls_ssl_get_ciphersuite(mbedtls_ssl_context *ssl)

{
  char *pcVar1;
  
  if ((ssl != (mbedtls_ssl_context *)0x0) && (ssl->session != (mbedtls_ssl_session *)0x0)) {
    pcVar1 = mbedtls_ssl_get_ciphersuite_name(ssl->session->ciphersuite);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return pcVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (char *)0x0;
}



char * mbedtls_ssl_get_version(mbedtls_ssl_context *ssl)

{
  uint uVar1;
  
  uVar1 = ssl->minor_ver;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    if (uVar1 < 4) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return *(char **)(CSWTCH_34 + uVar1 * 4);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "unknown";
  }
  if (uVar1 != 2) {
    if (uVar1 != 3) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return "unknown (DTLS)";
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return "DTLSv1.2";
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return "DTLSv1.0";
}



int mbedtls_ssl_get_record_expansion(mbedtls_ssl_context *ssl)

{
  mbedtls_cipher_mode_t mVar1;
  size_t sVar2;
  size_t sVar3;
  mbedtls_cipher_info_t *pmVar4;
  mbedtls_ssl_transform *pmVar5;
  
  pmVar5 = ssl->transform_out;
  if (pmVar5 == (mbedtls_ssl_transform *)0x0) {
    sVar2 = mbedtls_ssl_hdr_len();
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return sVar2;
  }
  pmVar4 = (pmVar5->cipher_ctx_enc).cipher_info;
  if (pmVar4 == (mbedtls_cipher_info_t *)0x0) {
LAB_2305a542:
    mbedtls_debug_print_msg(ssl,1,"file1",0x18cf,"should never happen");
    sVar3 = 0xffff9400;
  }
  else {
    mVar1 = pmVar4->mode;
    if (mVar1 == MBEDTLS_MODE_CBC) {
      sVar2 = pmVar5->maclen + pmVar4->block_size;
    }
    else {
      if ((mVar1 < MBEDTLS_MODE_CBC) || (2 < (byte)(mVar1 + ~MBEDTLS_MODE_CTR))) goto LAB_2305a542;
      sVar2 = pmVar5->minlen;
    }
    sVar3 = mbedtls_ssl_hdr_len();
    sVar3 = sVar3 + sVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar3;
}



size_t mbedtls_ssl_get_max_frag_len(mbedtls_ssl_context *ssl)

{
  uint uVar1;
  
  uVar1 = *(uint *)((int)mfl_code_to_length + (*(uint *)&ssl->conf->field_0x74 >> 4 & 0x1c));
  if ((ssl->session_out != (mbedtls_ssl_session *)0x0) &&
     (mfl_code_to_length[ssl->session_out->mfl_code] < uVar1)) {
    uVar1 = mfl_code_to_length[ssl->session_out->mfl_code];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



mbedtls_x509_crt * mbedtls_ssl_get_peer_cert(mbedtls_ssl_context *ssl)

{
  if ((ssl != (mbedtls_ssl_context *)0x0) &&
     (ssl = (mbedtls_ssl_context *)ssl->session, (mbedtls_x509_crt *)ssl != (mbedtls_x509_crt *)0x0)
     ) {
    ssl = (mbedtls_ssl_context *)(((mbedtls_x509_crt *)ssl)->issuer).val.len;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_x509_crt *)ssl;
}



int mbedtls_ssl_handshake_step(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if (ssl == (mbedtls_ssl_context *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x7100;
  }
  if (ssl->conf == (mbedtls_ssl_config_conflict *)0x0) {
    iVar1 = -0x7100;
  }
  else {
    if (((*(ushort *)&ssl->conf->field_0x74 & 1) != 0) ||
       (iVar1 = mbedtls_ssl_handshake_client_step(ssl), (*(ushort *)&ssl->conf->field_0x74 & 1) != 0
       )) {
      iVar1 = mbedtls_ssl_handshake_server_step(ssl);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_handshake(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config_conflict *)0x0)) {
    iVar1 = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1926,"=> handshake");
    do {
      if (ssl->state == 0x10) {
        iVar1 = 0;
        break;
      }
      iVar1 = mbedtls_ssl_handshake_step(ssl);
    } while (iVar1 == 0);
    mbedtls_debug_print_msg(ssl,2,"file1",0x1930,"<= handshake");
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mbedtls_ssl_transform_free(mbedtls_ssl_transform *transform)

{
  if (transform != (mbedtls_ssl_transform *)0x0) {
    mbedtls_cipher_free(&transform->cipher_ctx_enc);
    mbedtls_cipher_free(&transform->cipher_ctx_dec);
    mbedtls_md_free(&transform->md_ctx_enc);
    mbedtls_md_free(&transform->md_ctx_dec);
    mbedtls_zeroize(transform,0xd0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_handshake_free(mbedtls_ssl_handshake_params *handshake)

{
  mbedtls_ssl_key_cert *pmVar1;
  mbedtls_ssl_key_cert *pv;
  
  if (handshake != (mbedtls_ssl_handshake_params *)0x0) {
    mbedtls_sha256_free(&handshake->fin_sha256);
    pv = handshake->sni_key_cert;
    while (pv != (mbedtls_ssl_key_cert *)0x0) {
      pmVar1 = pv->next;
      vPortFree(pv);
      pv = pmVar1;
    }
    vPortFree(handshake->verify_cookie);
    vPortFree(handshake->hs_msg);
    ssl_flight_free(handshake->flight);
    mbedtls_zeroize(handshake,0x15c);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void ssl_handshake_wrapup_free_hs_transform(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_transform *pmVar1;
  
  mbedtls_debug_print_msg(ssl,3,"file1",0x13af,"=> handshake wrapup: final free");
  mbedtls_ssl_handshake_free(ssl->handshake);
  vPortFree(ssl->handshake);
  ssl->handshake = (mbedtls_ssl_handshake_params *)0x0;
  if (ssl->transform != (mbedtls_ssl_transform *)0x0) {
    mbedtls_ssl_transform_free(ssl->transform);
    vPortFree(ssl->transform);
  }
  pmVar1 = ssl->transform_negotiate;
  ssl->transform_negotiate = (mbedtls_ssl_transform *)0x0;
  ssl->transform = pmVar1;
  mbedtls_debug_print_msg(ssl,3,"file1",0x13c3,"<= handshake wrapup: final free");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_session_free(mbedtls_ssl_session *session)

{
  if (session != (mbedtls_ssl_session *)0x0) {
    if (session->peer_cert != (mbedtls_x509_crt *)0x0) {
      mbedtls_x509_crt_free(session->peer_cert);
      vPortFree(session->peer_cert);
    }
    vPortFree(session->ticket);
    mbedtls_zeroize(session,0x74);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_handshake_wrapup(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_session *pmVar1;
  anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_set_cache *paVar2;
  int iVar3;
  
  iVar3 = ssl->handshake->resume;
  mbedtls_debug_print_msg(ssl,3,"file1",0x13ca,"=> handshake wrapup");
  if (ssl->session != (mbedtls_ssl_session *)0x0) {
    mbedtls_ssl_session_free(ssl->session);
    vPortFree(ssl->session);
  }
  pmVar1 = ssl->session_negotiate;
  ssl->session_negotiate = (mbedtls_ssl_session *)0x0;
  ssl->session = pmVar1;
  paVar2 = ssl->conf->f_set_cache;
  if ((((paVar2 != (anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_set_cache *)0x0) &&
       (pmVar1->id_len != 0)) && (iVar3 == 0)) &&
     (iVar3 = (*paVar2)(ssl->conf->p_cache,pmVar1), iVar3 != 0)) {
    mbedtls_debug_print_msg(ssl,1,"file1",0x13ed,"cache did not store session");
  }
  if (((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) ||
     (ssl->handshake->flight == (mbedtls_ssl_flight_item *)0x0)) {
    ssl_handshake_wrapup_free_hs_transform(ssl);
  }
  else {
    ssl_set_timer(ssl,0);
    mbedtls_debug_print_msg(ssl,3,"file1",0x13f9,"skip freeing handshake and transform");
  }
  ssl->state = ssl->state + 1;
  mbedtls_debug_print_msg(ssl,3,"file1",0x1401,"<= handshake wrapup");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int ssl_handshake_init(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_handshake_params *pmVar1;
  mbedtls_ssl_transform *pmVar2;
  mbedtls_ssl_session *pmVar3;
  int iVar4;
  
  if (ssl->transform_negotiate != (mbedtls_ssl_transform *)0x0) {
    mbedtls_ssl_transform_free(ssl->transform_negotiate);
  }
  if (ssl->session_negotiate != (mbedtls_ssl_session *)0x0) {
    mbedtls_ssl_session_free(ssl->session_negotiate);
  }
  if (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) {
    mbedtls_ssl_handshake_free(ssl->handshake);
  }
  if (ssl->transform_negotiate == (mbedtls_ssl_transform *)0x0) {
    pmVar2 = (mbedtls_ssl_transform *)mycalloc(1,0xd0);
    ssl->transform_negotiate = pmVar2;
  }
  if (ssl->session_negotiate == (mbedtls_ssl_session *)0x0) {
    pmVar3 = (mbedtls_ssl_session *)mycalloc(1,0x74);
    ssl->session_negotiate = pmVar3;
  }
  if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
    pmVar1 = (mbedtls_ssl_handshake_params *)mycalloc(1,0x15c);
    ssl->handshake = pmVar1;
    if (pmVar1 != (mbedtls_ssl_handshake_params *)0x0) goto LAB_2305a8a2;
  }
  else {
LAB_2305a8a2:
    if ((ssl->transform_negotiate != (mbedtls_ssl_transform *)0x0) &&
       (ssl->session_negotiate != (mbedtls_ssl_session *)0x0)) {
      mbedtls_ssl_session_init(ssl->session_negotiate);
      pmVar2 = ssl->transform_negotiate;
      memset(pmVar2,0,0xd0);
      mbedtls_cipher_init(&pmVar2->cipher_ctx_enc);
      mbedtls_cipher_init(&pmVar2->cipher_ctx_dec);
      mbedtls_md_init(&pmVar2->md_ctx_enc);
      mbedtls_md_init(&pmVar2->md_ctx_dec);
      pmVar1 = ssl->handshake;
      memset(pmVar1,0,0x15c);
      mbedtls_sha256_init(&pmVar1->fin_sha256);
      mbedtls_sha256_starts(&pmVar1->fin_sha256,0);
      pmVar1->update_checksum = ssl_update_checksum_start;
      pmVar1->sig_alg = 2;
      pmVar1->sni_authmode = 3;
      iVar4 = 0;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        ssl->handshake->alt_transform_out = ssl->transform_out;
        if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
          ssl->handshake->retransmit_state = '\0';
        }
        else {
          ssl->handshake->retransmit_state = '\x02';
        }
        ssl_set_timer(ssl,0);
        iVar4 = 0;
      }
      goto LAB_2305a8e8;
    }
  }
  mbedtls_debug_print_msg(ssl,1,"file1",0x152c,"alloc() of ssl sub-contexts failed");
  vPortFree(ssl->handshake);
  vPortFree(ssl->transform_negotiate);
  vPortFree(ssl->session_negotiate);
  ssl->handshake = (mbedtls_ssl_handshake_params *)0x0;
  ssl->transform_negotiate = (mbedtls_ssl_transform *)0x0;
  ssl->session_negotiate = (mbedtls_ssl_session *)0x0;
  iVar4 = -0x7f00;
LAB_2305a8e8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int mbedtls_ssl_setup(mbedtls_ssl_context *ssl,mbedtls_ssl_config_conflict *conf)

{
  uchar *puVar1;
  int iVar2;
  uchar *puVar3;
  uchar *puVar4;
  
  ssl->conf = conf;
  puVar1 = (uchar *)mycalloc(1,0x413d);
  ssl->in_buf = puVar1;
  if (puVar1 != (uchar *)0x0) {
    puVar1 = (uchar *)mycalloc(1,0x413d);
    ssl->out_buf = puVar1;
    if (puVar1 != (uchar *)0x0) {
      puVar4 = ssl->in_buf;
      puVar3 = puVar1 + 0xd;
      if ((*(ushort *)&conf->field_0x74 & 2) == 0) {
        ssl->out_ctr = puVar1;
        ssl->in_ctr = puVar4;
        ssl->out_hdr = puVar1 + 8;
        ssl->out_len = puVar1 + 0xb;
        ssl->out_iv = puVar3;
        ssl->out_msg = puVar3;
        ssl->in_hdr = puVar4 + 8;
      }
      else {
        ssl->out_hdr = puVar1;
        ssl->in_hdr = puVar4;
        ssl->out_ctr = puVar1 + 3;
        ssl->out_len = puVar1 + 0xb;
        ssl->out_iv = puVar3;
        ssl->out_msg = puVar3;
        ssl->in_ctr = puVar4 + 3;
      }
      ssl->in_len = puVar4 + 0xb;
      ssl->in_iv = puVar4 + 0xd;
      ssl->in_msg = puVar4 + 0xd;
      iVar2 = ssl_handshake_init(ssl);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
  }
  mbedtls_debug_print_msg(ssl,1,"file1",0x1585,"alloc(%d bytes) failed",0x413d);
  vPortFree(ssl->in_buf);
  ssl->in_buf = (uchar *)0x0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x7f00;
}



void mbedtls_ssl_free(mbedtls_ssl_context *ssl)

{
  size_t n;
  char *__s;
  
  if (ssl != (mbedtls_ssl_context *)0x0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1c0a,"=> free");
    if (ssl->out_buf != (uchar *)0x0) {
      mbedtls_zeroize(ssl->out_buf,0x413d);
      vPortFree(ssl->out_buf);
    }
    if (ssl->in_buf != (uchar *)0x0) {
      mbedtls_zeroize(ssl->in_buf,0x413d);
      vPortFree(ssl->in_buf);
    }
    if (ssl->transform != (mbedtls_ssl_transform *)0x0) {
      mbedtls_ssl_transform_free(ssl->transform);
      vPortFree(ssl->transform);
    }
    if (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) {
      mbedtls_ssl_handshake_free(ssl->handshake);
      mbedtls_ssl_transform_free(ssl->transform_negotiate);
      mbedtls_ssl_session_free(ssl->session_negotiate);
      vPortFree(ssl->handshake);
      vPortFree(ssl->transform_negotiate);
      vPortFree(ssl->session_negotiate);
    }
    if (ssl->session != (mbedtls_ssl_session *)0x0) {
      mbedtls_ssl_session_free(ssl->session);
      vPortFree(ssl->session);
    }
    __s = ssl->hostname;
    if (__s != (char *)0x0) {
      n = strlen(__s);
      mbedtls_zeroize(__s,n);
      vPortFree(ssl->hostname);
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0x1c4b,"<= free");
    mbedtls_zeroize(ssl,0xc0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ssl_config_init(mbedtls_ssl_config *conf)

{
  memset(conf,0,0x78);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ssl_config_defaults(mbedtls_ssl_config *conf,int endpoint,int transport,int preset)

{
  ushort uVar1;
  ushort uVar2;
  ushort uVar3;
  int *piVar4;
  mbedtls_ecp_group_id *pmVar5;
  
  uVar1 = *(ushort *)&conf->field_0x74;
  uVar3 = (ushort)endpoint & 1;
  uVar2 = (ushort)((transport & 1U) << 1);
  *(ushort *)&conf->field_0x74 = uVar1 & 0xfffc | uVar3 | uVar2;
  if (endpoint == 0) {
    *(ushort *)&conf->field_0x74 = uVar1 & 0xfdf0 | uVar3 | uVar2 | 0x208;
  }
  conf->hs_timeout_min = 1000;
  conf->hs_timeout_max = 60000;
  if (preset == 2) {
    *(undefined4 *)&conf->max_major_ver = 0x3030303;
    conf->ciphersuite_list[3] = ssl_preset_suiteb_ciphersuites;
    conf->ciphersuite_list[2] = ssl_preset_suiteb_ciphersuites;
    conf->ciphersuite_list[1] = ssl_preset_suiteb_ciphersuites;
    conf->ciphersuite_list[0] = ssl_preset_suiteb_ciphersuites;
    conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
    conf->sig_hashes = ssl_preset_suiteb_hashes;
    conf->curve_list = ssl_preset_suiteb_curves;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  *(undefined4 *)&conf->max_major_ver = 0x3030303;
  if (transport == 1) {
    conf->min_minor_ver = '\x02';
  }
  piVar4 = mbedtls_ssl_list_ciphersuites();
  conf->cert_profile = &mbedtls_x509_crt_profile_default;
  conf->ciphersuite_list[3] = piVar4;
  conf->ciphersuite_list[2] = piVar4;
  conf->ciphersuite_list[1] = piVar4;
  conf->ciphersuite_list[0] = piVar4;
  conf->sig_hashes = ssl_preset_default_hashes;
  pmVar5 = mbedtls_ecp_grp_id_list();
  conf->curve_list = pmVar5;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void mbedtls_ssl_config_free(mbedtls_ssl_config *conf)

{
  mbedtls_ssl_key_cert *pmVar1;
  mbedtls_ssl_key_cert *pv;
  
  pv = conf->key_cert;
  while (pv != (mbedtls_ssl_key_cert *)0x0) {
    pmVar1 = pv->next;
    vPortFree(pv);
    pv = pmVar1;
  }
  mbedtls_zeroize(conf,0x78);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



uchar mbedtls_ssl_sig_from_pk(mbedtls_pk_context *pk)

{
  int iVar1;
  
  iVar1 = mbedtls_pk_can_do(pk,MBEDTLS_PK_RSA);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uchar)(iVar1 != 0);
}



mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig(uchar sig)

{
  undefined3 in_register_00002029;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_pk_type_t)(CONCAT31(in_register_00002029,sig) == 1);
}



mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash(uchar hash)

{
  uint uVar1;
  
  uVar1 = hash - 1 & 0xff;
  if (uVar1 < 4) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(mbedtls_md_type_t *)((int)&CSWTCH_35 + uVar1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return MBEDTLS_MD_NONE;
}



uchar mbedtls_ssl_hash_from_md_alg(int md)

{
  if (md - 3U < 4) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(uchar *)((int)&CSWTCH_35 + md + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



int mbedtls_ssl_check_curve(mbedtls_ssl_context *ssl,mbedtls_ecp_group_id grp_id)

{
  undefined3 in_register_0000202d;
  mbedtls_ecp_group_id *pmVar1;
  
  pmVar1 = ssl->conf->curve_list;
  if (pmVar1 != (mbedtls_ecp_group_id *)0x0) {
    while (*pmVar1 != 0) {
      if ((uint)*pmVar1 == CONCAT31(in_register_0000202d,grp_id)) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      pmVar1 = pmVar1 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int mbedtls_ssl_check_cert_usage
              (mbedtls_x509_crt *cert,mbedtls_ssl_ciphersuite_t *ciphersuite,int cert_endpoint,
              uint32_t *flags)

{
  int iVar1;
  int iVar2;
  uint usage;
  char *usage_oid;
  uint uVar3;
  
  usage = 0x80;
  if (cert_endpoint == 1) {
    usage = 0;
    if (ciphersuite->key_exchange < 0xb) {
      uVar3 = 1 << (ciphersuite->key_exchange & 0x1f);
      usage = 0x20;
      if (((uVar3 & 0x82) == 0) && (usage = 8, (uVar3 & 0x600) == 0)) {
        usage = (uint)((uVar3 & 0x1c) != 0) << 7;
      }
    }
  }
  iVar1 = mbedtls_x509_crt_check_key_usage(cert,usage);
  if (iVar1 != 0) {
    *flags = *flags | 0x800;
    iVar1 = -1;
  }
  if (cert_endpoint == 1) {
    usage_oid = "+\x06\x01\x05\x05\a\x03\x01";
  }
  else {
    usage_oid = "+\x06\x01\x05\x05\a\x03\x02";
  }
  iVar2 = mbedtls_x509_crt_check_extended_key_usage(cert,usage_oid,8);
  if (iVar2 != 0) {
    iVar1 = -1;
    *flags = *flags | 0x1000;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mbedtls_ssl_write_version(int major,int minor,int transport,uchar *ver)

{
  if (transport == 1) {
    if (minor == 2) {
      minor = 1;
    }
    *ver = ~((uchar)major - 2);
    minor = -minor;
  }
  else {
    *ver = (uchar)major;
  }
  ver[1] = (uchar)minor;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: add_data

int mbedtls_ssl_write_record(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  mbedtls_cipher_mode_t mVar2;
  int iVar3;
  mbedtls_ssl_flight_item *pv;
  uchar *puVar4;
  size_t __n;
  int iVar5;
  char *pcVar6;
  mbedtls_ssl_flight_item *pmVar7;
  mbedtls_ssl_flight_item *pmVar8;
  mbedtls_cipher_info_t *pmVar9;
  mbedtls_ssl_transform *pmVar10;
  uint uVar11;
  byte *pbVar12;
  size_t sVar13;
  uint uVar14;
  size_t ilen;
  size_t *in_fa0;
  uchar *in_fa1;
  uchar *extraout_fa1;
  size_t in_fa2;
  size_t sStack52;
  size_t olen;
  uchar add_data [13];
  
  sVar13 = ssl->out_msglen;
  mbedtls_debug_print_msg(ssl,2,"file1",0xaa7,"=> write record");
  if (((((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) ||
       (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) ||
      (ssl->handshake->retransmit_state != '\x01')) && (ssl->out_msgtype == 0x16)) {
    uVar1 = *ssl->out_msg;
    if ((uVar1 != '\0') && (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xab9,"should never happen");
      iVar3 = -0x6c00;
      goto LAB_2305ae12;
    }
    __n = sVar13 - 4;
    ssl->out_msg[1] = (uchar)(__n >> 0x10);
    ssl->out_msg[2] = (uchar)(__n >> 8);
    ssl->out_msg[3] = (uchar)__n;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
      sVar13 = sVar13 + 8;
      memmove(ssl->out_msg + 0xc,ssl->out_msg + 4,__n);
      ssl->out_msglen = ssl->out_msglen + 8;
      if (uVar1 == '\0') {
        ssl->out_msg[4] = '\0';
        ssl->out_msg[5] = '\0';
      }
      else {
        ssl->out_msg[4] = (uchar)(ssl->handshake->out_msg_seq >> 8);
        ssl->out_msg[5] = (uchar)ssl->handshake->out_msg_seq;
        ssl->handshake->out_msg_seq = ssl->handshake->out_msg_seq + 1;
      }
      memset(ssl->out_msg + 6,0,3);
      memcpy(ssl->out_msg + 9,ssl->out_msg + 1,3);
    }
    if (uVar1 != '\0') {
      in_fa0 = (size_t *)(*ssl->handshake->update_checksum)(ssl,ssl->out_msg,sVar13);
      in_fa1 = extraout_fa1;
    }
  }
  if ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) &&
      (ssl->handshake != (mbedtls_ssl_handshake_params *)0x0)) &&
     ((ssl->handshake->retransmit_state != '\x01' && ((ssl->out_msgtype & 0xfffffffdU) == 0x14)))) {
    pv = (mbedtls_ssl_flight_item *)mycalloc(1,0x10);
    if (pv == (mbedtls_ssl_flight_item *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x9ca,"alloc %d bytes failed",0x10);
    }
    else {
      puVar4 = (uchar *)mycalloc(1,ssl->out_msglen);
      pv->p = puVar4;
      if (puVar4 != (uchar *)0x0) {
        memcpy(puVar4,ssl->out_msg,ssl->out_msglen);
        pv->len = ssl->out_msglen;
        iVar3 = ssl->out_msgtype;
        pv->next = (mbedtls_ssl_flight_item *)0x0;
        pv->type = (uchar)iVar3;
        pmVar7 = ssl->handshake->flight;
        if (pmVar7 == (mbedtls_ssl_flight_item *)0x0) {
          ssl->handshake->flight = pv;
        }
        else {
          do {
            pmVar8 = pmVar7;
            pmVar7 = pmVar8->next;
          } while (pmVar7 != (mbedtls_ssl_flight_item *)0x0);
          pmVar8->next = pv;
        }
        goto LAB_2305af98;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",0x9d0,"alloc %d bytes failed");
      vPortFree(pv);
    }
    mbedtls_debug_print_ret(ssl,1,"file1",0xaf1,"ssl_flight_append",-0x7f00);
    iVar3 = -0x7f00;
    goto LAB_2305ae12;
  }
LAB_2305af98:
  *ssl->out_hdr = (uchar)ssl->out_msgtype;
  mbedtls_ssl_write_version
            (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,ssl->out_hdr + 1
            );
  *ssl->out_len = (uchar)(sVar13 >> 8);
  ssl->out_len[1] = (uchar)sVar13;
  if (ssl->transform_out == (mbedtls_ssl_transform *)0x0) {
LAB_2305b3e0:
    sVar13 = mbedtls_ssl_hdr_len();
    ssl->out_left = sVar13 + ssl->out_msglen;
    pbVar12 = ssl->out_hdr;
    mbedtls_debug_print_msg
              (ssl,3,"file1",0xb30,"output record: msgtype = %d, version = [%d:%d], msglen = %d",
               (uint)*pbVar12,(uint)pbVar12[1],(uint)pbVar12[2]);
    sVar13 = mbedtls_ssl_hdr_len();
    mbedtls_debug_print_buf
              (ssl,4,"file1",0xb33,"output record sent to network",ssl->out_hdr,
               ssl->out_msglen + sVar13);
    iVar3 = mbedtls_ssl_flush_output(ssl);
    if (iVar3 == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0xb3c,"<= write record");
      goto LAB_2305ae12;
    }
    pcVar6 = "mbedtls_ssl_flush_output";
    iVar5 = 0xb38;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0x504,"=> encrypt buf");
    if ((ssl->session_out == (mbedtls_ssl_session *)0x0) ||
       (ssl->transform_out == (mbedtls_ssl_transform *)0x0)) {
      iVar3 = 0x508;
LAB_2305b000:
      mbedtls_debug_print_msg(ssl,1,"file1",iVar3,"should never happen");
      iVar3 = -0x6c00;
    }
    else {
      pmVar9 = (ssl->transform_out->cipher_ctx_enc).cipher_info;
      mVar2 = MBEDTLS_MODE_NONE;
      if (pmVar9 != (mbedtls_cipher_info_t *)0x0) {
        mVar2 = pmVar9->mode;
      }
      mbedtls_debug_print_buf
                (ssl,4,"file1",0x50f,"before encrypt: output payload",ssl->out_msg,ssl->out_msglen);
      if ((mVar2 == MBEDTLS_MODE_STREAM) || (iVar5 = 0, mVar2 == MBEDTLS_MODE_CBC)) {
        if (ssl->minor_ver < 1) {
          iVar3 = 0x536;
          goto LAB_2305b000;
        }
        mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_ctr,8);
        mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_hdr,3);
        mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_len,2);
        iVar5 = 1;
        mbedtls_md_hmac_update(&ssl->transform_out->md_ctx_enc,ssl->out_msg,ssl->out_msglen);
        mbedtls_md_hmac_finish(&ssl->transform_out->md_ctx_enc,ssl->out_msg + ssl->out_msglen);
        mbedtls_md_hmac_reset(&ssl->transform_out->md_ctx_enc);
        mbedtls_debug_print_buf
                  (ssl,4,"file1",0x53c,"computed mac",ssl->out_msg + ssl->out_msglen,
                   ssl->transform_out->maclen);
        ssl->out_msglen = ssl->out_msglen + ssl->transform_out->maclen;
      }
      if ((mVar2 + ~MBEDTLS_MODE_CTR & 0xfd) != 0) {
        if (mVar2 != MBEDTLS_MODE_CBC) {
          iVar3 = 0x627;
          goto LAB_2305b000;
        }
        olen = 0;
        uVar11 = ssl->transform_out->ivlen;
        uVar14 = uVar11 - (ssl->out_msglen + 1) % uVar11;
        if (uVar11 == uVar14) {
          uVar14 = 0;
        }
        uVar11 = 0;
        do {
          ssl->out_msg[ssl->out_msglen + uVar11] = (uchar)uVar14;
          uVar11 = uVar11 + 1;
        } while (uVar11 <= uVar14);
        sVar13 = ssl->out_msglen + 1 + uVar14;
        ssl->out_msglen = sVar13;
        if (1 < ssl->minor_ver) {
          iVar3 = (*ssl->conf->f_rng)(ssl->conf->p_rng,ssl->transform_out->iv_enc,
                                      ssl->transform_out->ivlen);
          if (iVar3 == 0) {
            memcpy(ssl->out_iv,ssl->transform_out->iv_enc,ssl->transform_out->ivlen);
            sVar13 = ssl->out_msglen;
            puVar4 = ssl->out_msg;
            ssl->out_msglen = ssl->transform_out->ivlen + sVar13;
            goto LAB_2305b304;
          }
          goto LAB_2305b246;
        }
        puVar4 = ssl->out_msg;
LAB_2305b304:
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x5e3,
                   "before encrypt: msglen = %d, including %d bytes of IV and %d bytes of padding",
                   ssl->out_msglen,ssl->transform_out->ivlen,uVar14 + 1);
        pmVar10 = ssl->transform_out;
        iVar3 = mbedtls_cipher_crypt
                          (&pmVar10->cipher_ctx_enc,pmVar10->iv_enc,pmVar10->ivlen,puVar4,sVar13,
                           puVar4,&olen);
        if (iVar3 != 0) {
          pcVar6 = "mbedtls_cipher_crypt";
          iVar5 = 0x5eb;
          goto LAB_2305b23a;
        }
        if (sVar13 == olen) goto LAB_2305b2a0;
        iVar3 = 0x5f1;
        goto LAB_2305b000;
      }
      sVar13 = 8;
      if ((ssl->transform_out->ciphersuite_info->flags & 2) == 0) {
        sVar13 = 0x10;
      }
      memcpy(&olen,ssl->out_ctr,8);
      add_data[4] = (uchar)ssl->out_msgtype;
      mbedtls_ssl_write_version
                (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,add_data + 5
                );
      add_data[7] = (uchar)(ssl->out_msglen >> 8);
      add_data[8] = (uchar)ssl->out_msglen;
      mbedtls_debug_print_buf
                (ssl,4,"file1",0x575,"additional data used for AEAD",(uchar *)&olen,0xd);
      pmVar10 = ssl->transform_out;
      if (pmVar10->ivlen - 8 != pmVar10->fixed_ivlen) {
        iVar3 = 0x57d;
        goto LAB_2305b000;
      }
      memcpy(pmVar10->iv_enc + pmVar10->fixed_ivlen,ssl->out_ctr,8);
      memcpy(ssl->out_iv,ssl->out_ctr,8);
      mbedtls_debug_print_buf
                (ssl,4,"file1",0x586,"IV used",ssl->out_iv,
                 ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen);
      ilen = ssl->out_msglen;
      puVar4 = ssl->out_msg;
      ssl->out_msglen = (ssl->transform_out->ivlen + ilen) - ssl->transform_out->fixed_ivlen;
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x592,"before encrypt: msglen = %d, including %d bytes of padding",0)
      ;
      pmVar10 = ssl->transform_out;
      iVar3 = mbedtls_cipher_auth_encrypt
                        (&pmVar10->cipher_ctx_enc,pmVar10->iv_enc,pmVar10->ivlen,(uchar *)&olen,0xd,
                         puVar4,ilen,puVar4,in_fa0,in_fa1,in_fa2);
      if (iVar3 == 0) {
        if (ilen != sStack52) {
          iVar3 = 0x5a5;
          goto LAB_2305b000;
        }
        ssl->out_msglen = ssl->out_msglen + sVar13;
        iVar5 = iVar5 + 1;
        mbedtls_debug_print_buf(ssl,4,"file1",0x5ac,"after encrypt: tag",puVar4 + ilen,sVar13);
LAB_2305b2a0:
        if (iVar5 == 1) {
          mbedtls_debug_print_msg(ssl,2,"file1",0x632,"<= encrypt buf");
          sVar13 = ssl->out_msglen;
          *ssl->out_len = (uchar)(sVar13 >> 8);
          ssl->out_len[1] = (uchar)sVar13;
          goto LAB_2305b3e0;
        }
        iVar3 = 0x62e;
        goto LAB_2305b000;
      }
      pcVar6 = "mbedtls_cipher_auth_encrypt";
      iVar5 = 0x59f;
LAB_2305b23a:
      mbedtls_debug_print_ret(ssl,1,"file1",iVar5,pcVar6,iVar3);
    }
LAB_2305b246:
    pcVar6 = "ssl_encrypt_buf";
    iVar5 = 0xb22;
  }
  mbedtls_debug_print_ret(ssl,1,"file1",iVar5,pcVar6,iVar3);
LAB_2305ae12:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_ssl_resend(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_flight_item *pmVar1;
  int ret;
  mbedtls_ssl_handshake_params *pmVar2;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0xa39,"=> mbedtls_ssl_resend");
  if (ssl->handshake->retransmit_state != '\x01') {
    mbedtls_debug_print_msg(ssl,2,"file1",0xa3d,"initialise resending");
    ssl->handshake->cur_msg = ssl->handshake->flight;
    ssl_swap_epochs(ssl);
    ssl->handshake->retransmit_state = '\x01';
  }
  do {
    pmVar2 = ssl->handshake;
    pmVar1 = pmVar2->cur_msg;
    if (pmVar1 == (mbedtls_ssl_flight_item *)0x0) {
      if (ssl->state == 0x10) {
        pmVar2->retransmit_state = '\x03';
      }
      else {
        pmVar2->retransmit_state = '\x02';
        ssl_set_timer(ssl,ssl->handshake->retransmit_timeout);
      }
      mbedtls_debug_print_msg(ssl,2,"file1",0xa6a,"<= mbedtls_ssl_resend");
      ret = 0;
      goto LAB_2305b5b0;
    }
    if ((pmVar1->type == '\x16') && (*pmVar1->p == '\x14')) {
      ssl_swap_epochs(ssl);
    }
    memcpy(ssl->out_msg,pmVar1->p,pmVar1->len);
    ssl->out_msglen = pmVar1->len;
    ssl->out_msgtype = (uint)pmVar1->type;
    ssl->handshake->cur_msg = pmVar1->next;
    mbedtls_debug_print_buf(ssl,3,"file1",0xa59,"resent handshake message header",ssl->out_msg,0xc);
    ret = mbedtls_ssl_write_record(ssl);
  } while (ret == 0);
  mbedtls_debug_print_ret(ssl,1,"file1",0xa5d,"mbedtls_ssl_write_record",ret);
LAB_2305b5b0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ret;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_ssl_fetch_input(mbedtls_ssl_context *ssl,size_t nb_want)

{
  size_t sVar1;
  void *pvVar2;
  int iVar3;
  uint uVar4;
  char *format;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x8ba,"=> fetch input");
  if ((ssl->f_recv == (mbedtls_ssl_recv_t *)0x0) &&
     (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t *)0x0)) {
    format = "Bad usage of mbedtls_ssl_set_bio() or mbedtls_ssl_set_bio()";
    iVar3 = 0x8bf;
  }
  else {
    if (nb_want <= 0x413dU - (int)(ssl->in_hdr + -(int)ssl->in_buf)) {
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x958,"in_left: %d, nb_want: %d",ssl->in_left,nb_want)
        ;
        while (uVar6 = ssl->in_left, uVar6 < nb_want) {
          iVar3 = ssl_check_timer(ssl);
          sVar1 = 0xffff9800;
          if (iVar3 == 0) {
            if (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t *)0x0) {
              sVar1 = (*ssl->f_recv)(ssl->f_recv);
            }
            else {
              sVar1 = (*ssl->f_recv_timeout)
                                (ssl->p_bio,ssl->in_hdr + ssl->in_left,nb_want - uVar6,
                                 ssl->conf->read_timeout);
            }
          }
          mbedtls_debug_print_msg
                    (ssl,2,"file1",0x970,"in_left: %d, nb_want: %d",ssl->in_left,nb_want);
          mbedtls_debug_print_ret(ssl,2,"file1",0x971,"ssl->f_recv(_timeout)",sVar1);
          if (sVar1 == 0) goto LAB_2305b7f0;
          if ((int)sVar1 < 0) goto LAB_2305b63a;
          ssl->in_left = sVar1 + ssl->in_left;
        }
LAB_2305b818:
        iVar3 = 0x97d;
LAB_2305b72e:
        mbedtls_debug_print_msg(ssl,2,"file1",iVar3,"<= fetch input");
        sVar1 = 0;
      }
      else {
        if ((ssl->f_set_timer == (mbedtls_ssl_set_timer_t *)0x0) ||
           (ssl->f_get_timer == (mbedtls_ssl_get_timer_t *)0x0)) {
          format = "You must use mbedtls_ssl_set_timer_cb() for DTLS";
          iVar3 = 0x8d2;
          goto LAB_2305b62c;
        }
        uVar6 = ssl->next_record_offset;
        if (uVar6 == 0) {
LAB_2305b6fe:
          mbedtls_debug_print_msg
                    (ssl,2,"file1",0x8f7,"in_left: %d, nb_want: %d",ssl->in_left,nb_want);
          if (nb_want <= ssl->in_left) {
            iVar3 = 0x8fe;
            goto LAB_2305b72e;
          }
          if (ssl->in_left == 0) {
            iVar3 = ssl_check_timer(ssl);
            if (iVar3 == 0) {
              pvVar2 = (void *)(0x413d - (int)(ssl->in_hdr + -(int)ssl->in_buf));
              if (ssl->state == 0x10) {
                uVar7 = ssl->conf->read_timeout;
              }
              else {
                uVar7 = ssl->handshake->retransmit_timeout;
              }
              mbedtls_debug_print_msg(ssl,3,"file1",0x91d,"f_recv_timeout: %u ms",uVar7);
              if (ssl->f_recv_timeout == (mbedtls_ssl_recv_timeout_t *)0x0) {
                sVar1 = (*ssl->f_recv)(pvVar2,(uchar *)ssl->f_recv);
              }
              else {
                sVar1 = (*ssl->f_recv_timeout)(ssl->p_bio,ssl->in_hdr,(size_t)pvVar2,uVar7);
              }
              mbedtls_debug_print_ret(ssl,2,"file1",0x925,"ssl->f_recv(_timeout)",sVar1);
              if (sVar1 == 0) {
LAB_2305b7f0:
                sVar1 = 0xffff8d80;
                goto LAB_2305b63a;
              }
              if (sVar1 != 0xffff9800) {
                if ((int)sVar1 < 0) goto LAB_2305b63a;
                ssl->in_left = sVar1;
                goto LAB_2305b818;
              }
            }
            mbedtls_debug_print_msg(ssl,2,"file1",0x92d,"timeout");
            ssl_set_timer(ssl,0);
            if (ssl->state != 0x10) {
              uVar4 = ssl->handshake->retransmit_timeout;
              uVar6 = ssl->conf->hs_timeout_max;
              if (uVar4 < uVar6) {
                uVar5 = uVar4 << 1;
                if ((uVar4 <= uVar5) && (uVar5 < uVar6)) {
                  uVar6 = uVar5;
                }
                ssl->handshake->retransmit_timeout = uVar6;
                mbedtls_debug_print_msg
                          (ssl,3,"file1",0x7e,"update timeout value to %d millisecs",
                           ssl->handshake->retransmit_timeout);
                sVar1 = mbedtls_ssl_resend(ssl);
                if (sVar1 == 0) {
                  sVar1 = 0xffff9700;
                }
                else {
                  mbedtls_debug_print_ret(ssl,1,"file1",0x93a,"mbedtls_ssl_resend",sVar1);
                }
                goto LAB_2305b63a;
              }
              mbedtls_debug_print_msg(ssl,1,"file1",0x934,"handshake timeout");
            }
            sVar1 = 0xffff9800;
            goto LAB_2305b63a;
          }
          iVar3 = 0x909;
        }
        else {
          if (uVar6 <= ssl->in_left) {
            sVar1 = ssl->in_left - uVar6;
            ssl->in_left = sVar1;
            if (sVar1 != 0) {
              mbedtls_debug_print_msg
                        (ssl,2,"file1",0x8ed,"next record in same datagram, offset: %d");
              memmove(ssl->in_hdr,ssl->in_hdr + ssl->next_record_offset,ssl->in_left);
            }
            ssl->next_record_offset = 0;
            goto LAB_2305b6fe;
          }
          iVar3 = 0x8e4;
        }
        mbedtls_debug_print_msg(ssl,1,"file1",iVar3,"should never happen");
        sVar1 = 0xffff9400;
      }
      goto LAB_2305b63a;
    }
    format = "requesting more data than fits";
    iVar3 = 0x8c5;
  }
LAB_2305b62c:
  mbedtls_debug_print_msg(ssl,1,"file1",iVar3,format);
  sVar1 = 0xffff8f00;
LAB_2305b63a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



int mbedtls_ssl_prepare_handshake_record(mbedtls_ssl_context *ssl)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  uchar *puVar4;
  size_t __n;
  uint uVar5;
  mbedtls_ssl_handshake_params *pmVar6;
  uint uVar7;
  int line;
  uint uVar8;
  byte *pbVar9;
  char *pcVar10;
  uint uVar11;
  size_t size;
  uint uVar12;
  uint uVar13;
  size_t sVar14;
  uchar *puVar15;
  uint uVar16;
  uchar *puVar17;
  
  uVar5 = 0xc;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    uVar5 = 4;
  }
  if (ssl->in_msglen < uVar5) {
    mbedtls_debug_print_msg(ssl,1,"file1",0xc20,"handshake message too short: %d");
    iVar3 = -0x7200;
    goto LAB_2305b992;
  }
  pbVar9 = ssl->in_msg;
  ssl->in_hslen = ((uint)pbVar9[1] << 0x10 | (uint)pbVar9[2] << 8 | (uint)pbVar9[3]) + uVar5;
  mbedtls_debug_print_msg
            (ssl,3,"file1",0xc2b,"handshake message: msglen = %d, type = %d, hslen = %d",
             (uint)*pbVar9);
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    if (ssl->in_msglen < ssl->in_hslen) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xc69,"TLS handshake fragmentation not supported");
      iVar3 = -0x7080;
      goto LAB_2305b992;
    }
LAB_2305bb18:
    iVar3 = 0;
    goto LAB_2305b992;
  }
  pmVar6 = ssl->handshake;
  puVar4 = ssl->in_msg;
  if (pmVar6 == (mbedtls_ssl_handshake_params *)0x0) {
LAB_2305ba92:
    if ((((ssl->in_hslen <= ssl->in_msglen) &&
         (iVar3 = memcmp(puVar4 + 6,&DAT_23088e44,3), iVar3 == 0)) &&
        (iVar3 = memcmp(ssl->in_msg + 9,ssl->in_msg + 1,3), iVar3 == 0)) &&
       ((ssl->handshake == (mbedtls_ssl_handshake_params *)0x0 ||
        (ssl->handshake->hs_msg == (uchar *)0x0)))) goto LAB_2305bb18;
    mbedtls_debug_print_msg(ssl,2,"file1",0xc5b,"found fragmented DTLS handshake message");
    sVar14 = ssl->in_hslen;
    uVar5 = sVar14 - 0xc;
    if (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0) {
      pcVar10 = "not supported outside handshake (for now)";
      iVar3 = 0xb8f;
LAB_2305bace:
      mbedtls_debug_print_msg(ssl,1,"file1",iVar3,pcVar10);
      iVar3 = -0x7080;
    }
    else {
      puVar4 = ssl->handshake->hs_msg;
      if (puVar4 != (uchar *)0x0) {
        iVar3 = memcmp(puVar4,ssl->in_msg,4);
        if (iVar3 == 0) goto LAB_2305bbca;
        mbedtls_debug_print_msg(ssl,1,"file1",0xbb9,"fragment header mismatch");
        goto LAB_2305bc4c;
      }
      mbedtls_debug_print_msg(ssl,2,"file1",0xb9b,"initialize reassembly, total length = %d",uVar5);
      if (0x4000 < ssl->in_hslen) {
        pcVar10 = "handshake message too large";
        iVar3 = 0xb9f;
        goto LAB_2305bace;
      }
      size = (uint)((uVar5 & 7) != 0) + (uVar5 >> 3) + sVar14;
      pmVar6 = ssl->handshake;
      puVar4 = (uchar *)mycalloc(1,size);
      pmVar6->hs_msg = puVar4;
      puVar4 = ssl->handshake->hs_msg;
      if (puVar4 == (uchar *)0x0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0xba9,"alloc failed (%d bytes)",size);
        iVar3 = -0x7f00;
        goto LAB_2305bae0;
      }
      memcpy(puVar4,ssl->in_msg,6);
      memset(ssl->handshake->hs_msg + 6,0,3);
      puVar4 = ssl->handshake->hs_msg;
      memcpy(puVar4 + 9,puVar4 + 1,3);
LAB_2305bbca:
      puVar17 = ssl->handshake->hs_msg;
      puVar4 = ssl->in_msg;
      puVar15 = puVar17 + sVar14;
      bVar1 = puVar4[8];
      uVar13 = (uint)puVar4[6] << 0x10 | (uint)puVar4[7] << 8 | (uint)bVar1;
      uVar7 = (uint)puVar4[9] << 0x10 | (uint)puVar4[10] << 8 | (uint)puVar4[0xb];
      if (uVar5 < uVar13 + uVar7) {
        mbedtls_debug_print_msg
                  (ssl,1,"file1",0xbce,"invalid fragment offset/len: %d + %d > %d",uVar13,uVar7,
                   uVar5);
      }
      else {
        uVar16 = uVar7 + 0xc;
        if (uVar16 <= ssl->in_msglen) {
          mbedtls_debug_print_msg
                    (ssl,2,"file1",0xbda,"adding fragment, offset = %d, length = %d",uVar13,uVar7);
          memcpy(puVar17 + uVar13 + 0xc,ssl->in_msg + 0xc,uVar7);
          uVar8 = bVar1 & 7;
          uVar12 = 8 - uVar8;
          if (uVar12 == 8) {
LAB_2305bd4a:
            uVar8 = uVar7 & 7;
            if (uVar8 != 0) {
              uVar11 = uVar7 + uVar13;
              uVar12 = (uint)puVar15[uVar11 >> 3];
              uVar7 = uVar7 - uVar8;
              uVar8 = 8 - uVar8;
              do {
                uVar2 = uVar8 & 0x1f;
                uVar8 = uVar8 + 1;
                uVar12 = uVar12 | 1 << uVar2 & 0xffU;
              } while (uVar8 != 8);
              puVar15[uVar11 >> 3] = (byte)uVar12;
            }
            memset(puVar15 + (uVar13 >> 3),0xff,uVar7 >> 3);
          }
          else {
            uVar11 = uVar13 >> 3;
            if (uVar12 < uVar7) {
              uVar7 = (uVar7 - 8) + uVar8;
              uVar8 = (uint)puVar15[uVar11];
              uVar13 = uVar13 + uVar12;
              do {
                uVar12 = uVar12 - 1;
                uVar8 = uVar8 | 1 << (uVar12 & 0x1f) & 0xffU;
              } while (uVar12 != 0);
              puVar15[uVar11] = (byte)uVar8;
              goto LAB_2305bd4a;
            }
            uVar7 = uVar12 - uVar7;
            while (uVar7 != uVar12) {
              uVar13 = uVar7 & 0x1f;
              uVar7 = uVar7 + 1;
              puVar15[uVar11] = (byte)(1 << uVar13) | puVar15[uVar11];
            }
          }
          uVar7 = 0;
          while (uVar7 != uVar5 >> 3) {
            if (puVar15[uVar7] != -1) goto LAB_2305be72;
            uVar7 = uVar7 + 1;
          }
          uVar13 = 0;
          while (uVar13 < (uVar5 & 7)) {
            if (((int)(uint)puVar15[uVar7] >> (7 - uVar13 & 0x1f) & 1U) == 0) goto LAB_2305be72;
            uVar13 = uVar13 + 1;
          }
          mbedtls_debug_print_msg(ssl,2,"file1",0xbe9,"handshake message completed");
          if (ssl->in_msglen <= uVar16) {
            uVar5 = ssl->next_record_offset;
            if (uVar5 < ssl->in_left) {
              puVar17 = ssl->in_hdr;
              __n = ssl->in_left - uVar5;
              puVar4 = ssl->in_msg + ssl->in_hslen;
              puVar15 = puVar4 + -(int)puVar17;
              ssl->next_record_offset = (size_t)puVar15;
              ssl->in_left = (size_t)(puVar15 + __n);
              if ((uchar *)(0x413d - (int)(puVar17 + -(int)ssl->in_buf)) < puVar15 + __n) {
                mbedtls_debug_print_msg
                          (ssl,1,"file1",0xc08,"reassembled message too large for buffer");
                iVar3 = -0x6a00;
                goto LAB_2305bae0;
              }
              memmove(puVar4,puVar17 + uVar5,__n);
            }
            memcpy(ssl->in_msg,ssl->handshake->hs_msg,ssl->in_hslen);
            vPortFree(ssl->handshake->hs_msg);
            ssl->handshake->hs_msg = (uchar *)0x0;
            mbedtls_debug_print_buf
                      (ssl,3,"file1",0xc15,"reassembled handshake message",ssl->in_msg,ssl->in_hslen
                      );
            goto LAB_2305bb18;
          }
          pcVar10 = "last fragment not alone in its record";
          iVar3 = 0xbf2;
          goto LAB_2305bace;
        }
        mbedtls_debug_print_msg(ssl,1,"file1",0xbd5,"invalid fragment length: %d + 12 > %d",uVar7);
      }
LAB_2305bc4c:
      iVar3 = -0x7200;
    }
    goto LAB_2305bae0;
  }
  uVar5 = (uint)(*(ushort *)(puVar4 + 4) >> 8) | (*(ushort *)(puVar4 + 4) & 0xff) << 8;
  if (pmVar6->in_msg_seq == uVar5) goto LAB_2305ba92;
  uVar7 = pmVar6->in_flight_start_seq - 1;
  if ((uVar7 != uVar5) || (*puVar4 == '\x03')) {
    mbedtls_debug_print_msg
              (ssl,2,"file1",0xc4d,
               "dropping out-of-sequence message: message_seq = %d, expected = %d",
               pmVar6->in_msg_seq);
LAB_2305ba8a:
    iVar3 = -0x6900;
    goto LAB_2305b992;
  }
  mbedtls_debug_print_msg
            (ssl,2,"file1",0xc40,
             "received message from last flight, message_seq = %d, start_of_flight = %d",uVar7);
  iVar3 = mbedtls_ssl_resend(ssl);
  if (iVar3 == 0) goto LAB_2305ba8a;
  pcVar10 = "mbedtls_ssl_resend";
  line = 0xc44;
LAB_2305ba60:
  mbedtls_debug_print_ret(ssl,1,"file1",line,pcVar10,iVar3);
LAB_2305b992:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
LAB_2305be72:
  mbedtls_debug_print_msg(ssl,2,"file1",0xbe5,"message is not complete yet");
  iVar3 = -0x6900;
LAB_2305bae0:
  pcVar10 = "ssl_reassemble_dtls_handshake";
  line = 0xc5f;
  goto LAB_2305ba60;
}



int mbedtls_ssl_handle_message_type(mbedtls_ssl_context *ssl)

{
  int iVar1;
  uchar *puVar2;
  
  if ((ssl->in_msgtype == 0x16) && (iVar1 = mbedtls_ssl_prepare_handshake_record(ssl), iVar1 != 0))
  {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (ssl->in_msgtype == 0x15) {
    mbedtls_debug_print_msg
              (ssl,2,"file1",0xf93,"got an alert message, type: [%d:%d]",(uint)*ssl->in_msg,
               (uint)ssl->in_msg[1]);
    puVar2 = ssl->in_msg;
    if (*puVar2 == '\x02') {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0xf9b,"is a fatal alert message (msg %d)",(uint)puVar2[1]);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x7780;
    }
    if (*puVar2 == '\x01') {
      if (puVar2[1] == '\0') {
        mbedtls_debug_print_msg(ssl,2,"file1",0xfa2,"is a close notify message");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x7880;
      }
      if (puVar2[1] == 'd') {
        mbedtls_debug_print_msg(ssl,2,"file1",0xfaa,"is a SSLv3 no_cert");
        goto LAB_2305beb0;
      }
    }
    iVar1 = -0x6680;
  }
  else {
LAB_2305beb0:
    iVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_send_alert_message(mbedtls_ssl_context *ssl,uchar level,uchar message)

{
  int ret;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config_conflict *)0x0)) {
    ret = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0xfda,"=> send alert message");
    ssl->out_msgtype = 0x15;
    ssl->out_msglen = 2;
    *ssl->out_msg = level;
    ssl->out_msg[1] = message;
    ret = mbedtls_ssl_write_record(ssl);
    if (ret == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0xfe7,"<= send alert message");
    }
    else {
      mbedtls_debug_print_ret(ssl,1,"file1",0xfe3,"mbedtls_ssl_write_record",ret);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ret;
}



int mbedtls_ssl_send_fatal_handshake_failure(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  iVar1 = mbedtls_ssl_send_alert_message(ssl,'\x02','(');
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_close_notify(mbedtls_ssl_context *ssl)

{
  int iVar1;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config_conflict *)0x0)) {
    iVar1 = -0x7100;
  }
  else {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1b68,"=> write close notify");
    if (ssl->out_left != 0) {
      iVar1 = mbedtls_ssl_flush_output(ssl);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    if ((ssl->state == 0x10) &&
       (iVar1 = mbedtls_ssl_send_alert_message(ssl,'\x01','\0'), iVar1 != 0)) {
      mbedtls_debug_print_ret(ssl,1,"file1",0x1b73,"mbedtls_ssl_send_alert_message",iVar1);
    }
    else {
      mbedtls_debug_print_msg(ssl,2,"file1",0x1b78,"<= write close notify");
      iVar1 = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_write_certificate(mbedtls_ssl_context *ssl)

{
  int iVar1;
  mbedtls_x509_crt *pmVar2;
  size_t sVar3;
  uint uVar4;
  mbedtls_ssl_ciphersuite_t *pmVar5;
  
  pmVar5 = ssl->transform_negotiate->ciphersuite_info;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1025,"=> write certificate");
  uVar4 = pmVar5->key_exchange - 5;
  if (((uVar4 & 0xff) < 7) && ((0x4bU >> (uVar4 & 0x1f) & 1) != 0)) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x102c,"<= skip write certificate");
    iVar1 = 0;
    ssl->state = ssl->state + 1;
  }
  else {
    if ((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) {
      if (ssl->client_auth == 0) {
        mbedtls_debug_print_msg(ssl,2,"file1",0x1036,"<= skip write certificate");
        ssl->state = ssl->state + 1;
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
    }
    else {
      pmVar2 = mbedtls_ssl_own_cert(ssl);
      if (pmVar2 == (mbedtls_x509_crt *)0x0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x1053,"got no certificate to send");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x7580;
      }
    }
    pmVar2 = mbedtls_ssl_own_cert(ssl);
    mbedtls_debug_print_crt(ssl,3,"file1",0x1059,"own certificate",pmVar2);
    pmVar2 = mbedtls_ssl_own_cert(ssl);
    sVar3 = 7;
    while (pmVar2 != (mbedtls_x509_crt *)0x0) {
      uVar4 = (pmVar2->raw).len;
      if (0x3ffd - sVar3 < uVar4) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x106d,"certificate too large, %d > %d",0x4000);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x7500;
      }
      ssl->out_msg[sVar3] = (uchar)(uVar4 >> 0x10);
      ssl->out_msg[sVar3 + 1] = (uchar)(uVar4 >> 8);
      ssl->out_msg[sVar3 + 2] = (uchar)uVar4;
      memcpy(ssl->out_msg + sVar3 + 3,(pmVar2->raw).p,uVar4);
      pmVar2 = pmVar2->next;
      sVar3 = sVar3 + 3 + uVar4;
    }
    iVar1 = sVar3 - 7;
    ssl->out_msg[4] = (uchar)((uint)iVar1 >> 0x10);
    ssl->out_msg[5] = (uchar)((uint)iVar1 >> 8);
    ssl->out_msg[6] = (uchar)iVar1;
    ssl->out_msgtype = 0x16;
    ssl->out_msglen = sVar3;
    *ssl->out_msg = '\v';
    ssl->state = ssl->state + 1;
    iVar1 = mbedtls_ssl_write_record(ssl);
    if (iVar1 == 0) {
      mbedtls_debug_print_msg(ssl,2,"file1",0x108d,"<= write certificate");
    }
    else {
      mbedtls_debug_print_ret(ssl,1,"file1",0x1089,"mbedtls_ssl_write_record",iVar1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ssl_write_change_cipher_spec(mbedtls_ssl_context *ssl)

{
  int ret;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x11b4,"=> write change cipher spec");
  ssl->out_msgtype = 0x14;
  ssl->out_msglen = 1;
  *ssl->out_msg = '\x01';
  ssl->state = ssl->state + 1;
  ret = mbedtls_ssl_write_record(ssl);
  if (ret == 0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x11c2,"<= write change cipher spec");
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x11be,"mbedtls_ssl_write_record",ret);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ret;
}



int mbedtls_ssl_write_finished(mbedtls_ssl_context *ssl)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1408,"=> write finished");
  puVar1 = ssl->out_iv;
  if (1 < ssl->minor_ver) {
    puVar1 = puVar1 + (ssl->transform_negotiate->ivlen - ssl->transform_negotiate->fixed_ivlen);
  }
  ssl->out_msg = puVar1;
  (*ssl->handshake->calc_finished)(ssl,puVar1 + 4,*(uint *)&ssl->conf->field_0x74 & 1);
  iVar3 = 0x24;
  if (ssl->minor_ver != 0) {
    iVar3 = 0xc;
  }
  ssl->out_msglen = iVar3 + 4;
  ssl->out_msgtype = 0x16;
  *ssl->out_msg = '\x14';
  if (ssl->handshake->resume == 0) {
    iVar3 = ssl->state + 1;
  }
  else {
    if (((*(ushort *)&ssl->conf->field_0x74 & 1) == 0) &&
       (ssl->state = 0xf, (*(ushort *)&ssl->conf->field_0x74 & 1) == 0)) goto LAB_2305c40a;
    iVar3 = 10;
  }
  ssl->state = iVar3;
LAB_2305c40a:
  mbedtls_debug_print_msg(ssl,3,"file1",0x143e,"switching to new transform spec for outbound data");
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
    memset(ssl->out_ctr,0,8);
  }
  else {
    ssl->handshake->alt_transform_out = ssl->transform_out;
    memcpy(ssl->handshake->alt_out_ctr,ssl->out_ctr,8);
    memset(ssl->out_ctr + 2,0,6);
    uVar2 = ssl->out_ctr[1] + '\x01';
    ssl->out_ctr[1] = uVar2;
    if ((uVar2 == '\0') && (uVar2 = *ssl->out_ctr + '\x01', *ssl->out_ctr = uVar2, uVar2 == '\0')) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x1454,"DTLS epoch would wrap");
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x6b80;
    }
  }
  ssl->transform_out = ssl->transform_negotiate;
  ssl->session_out = ssl->session_negotiate;
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
    mbedtls_ssl_send_flight_completed(ssl);
  }
  iVar3 = mbedtls_ssl_write_record(ssl);
  if (iVar3 == 0) {
    mbedtls_debug_print_msg(ssl,2,"file1",0x1475,"<= write finished");
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x1471,"mbedtls_ssl_write_record",iVar3);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_ssl_write(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  uint __n;
  size_t sVar1;
  uint uVar2;
  int iVar3;
  char *pcVar4;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1b3d,"=> write");
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config_conflict *)0x0)) {
    __n = 0xffff8f00;
    goto LAB_2305c580;
  }
  if ((ssl->state != 0x10) && (__n = mbedtls_ssl_handshake(ssl), __n != 0)) {
    mbedtls_debug_print_ret(ssl,1,"file1",0x1b4e,"mbedtls_ssl_handshake",__n);
    goto LAB_2305c580;
  }
  sVar1 = mbedtls_ssl_get_max_frag_len(ssl);
  __n = len;
  if ((sVar1 < len) && (__n = sVar1, (*(ushort *)&ssl->conf->field_0x74 & 2) != 0)) {
    pcVar4 = "fragment larger than the (negotiated) maximum fragment length: %d > %d";
    iVar3 = 0x1ae7;
    __n = len;
LAB_2305c5bc:
    mbedtls_debug_print_msg(ssl,1,"file1",iVar3,pcVar4,__n,sVar1);
    __n = 0xffff8f00;
  }
  else {
    if (ssl->out_left == 0) {
      sVar1 = 0x4130;
      if (0x4130 < __n) {
        pcVar4 = "input larger than the out msg maximum length: 0x%x > 0x%x";
        iVar3 = 0x1afe;
        goto LAB_2305c5bc;
      }
      ssl->out_msgtype = 0x17;
      ssl->out_msglen = __n;
      memcpy(ssl->out_msg,buf,__n);
      uVar2 = mbedtls_ssl_write_record(ssl);
      if (uVar2 != 0) {
        pcVar4 = "mbedtls_ssl_write_record";
        iVar3 = 0x1b08;
        __n = uVar2;
        goto LAB_2305c60c;
      }
    }
    else {
      uVar2 = mbedtls_ssl_flush_output(ssl);
      if (uVar2 != 0) {
        pcVar4 = "mbedtls_ssl_flush_output";
        iVar3 = 0x1af4;
        __n = uVar2;
LAB_2305c60c:
        mbedtls_debug_print_ret(ssl,1,"file1",iVar3,pcVar4,__n);
      }
    }
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0x1b59,"<= write");
LAB_2305c580:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __n;
}



void mbedtls_ssl_read_version(int *major,int *minor,int transport,uchar *ver)

{
  uint uVar1;
  
  if (transport == 1) {
    *major = 0x101 - (uint)*ver;
    uVar1 = 0x100 - ver[1];
    if (uVar1 == 1) {
      uVar1 = 2;
    }
  }
  else {
    *major = (uint)*ver;
    uVar1 = (uint)ver[1];
  }
  *minor = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ssl_read_record_layer(mbedtls_ssl_context *ssl)

{
  bool bVar1;
  size_t sVar2;
  size_t sVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  size_t __n;
  uint uVar7;
  int iVar8;
  mbedtls_cipher_info_t *pmVar9;
  mbedtls_cipher_mode_t mVar10;
  byte bVar11;
  char *pcVar12;
  uchar uVar13;
  mbedtls_ssl_transform *pmVar14;
  uint uVar15;
  byte *pbVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uchar *puVar20;
  uint uVar21;
  size_t *in_fa0;
  uchar *in_fa1;
  size_t in_fa2;
  size_t sStack116;
  int major_ver;
  int minor_ver;
  undefined uStack104;
  uchar auStack103 [2];
  undefined uStack101;
  undefined uStack100;
  
  uVar6 = ssl->in_hslen;
  if ((uVar6 == 0) || (ssl->in_msglen <= uVar6)) {
    ssl->in_hslen = 0;
    while( true ) {
      sVar2 = mbedtls_ssl_hdr_len();
      uVar6 = mbedtls_ssl_fetch_input(ssl,sVar2);
      if (uVar6 != 0) break;
      sVar2 = mbedtls_ssl_hdr_len();
      mbedtls_debug_print_buf(ssl,4,"file1",0xdb1,"input record header",ssl->in_hdr,sVar2);
      ssl->in_msgtype = (uint)*ssl->in_hdr;
      ssl->in_msglen = (uint)(*(ushort *)ssl->in_len >> 8) | (*(ushort *)ssl->in_len & 0xff) << 8;
      mbedtls_ssl_read_version
                ((int *)&sStack116,&major_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,
                 ssl->in_hdr + 1);
      mbedtls_debug_print_msg
                (ssl,3,"file1",0xdba,"input record: msgtype = %d, version = [%d:%d], msglen = %d",
                 ssl->in_msgtype,sStack116,major_ver);
      iVar8 = ssl->in_msgtype;
      if (iVar8 - 0x14U < 4) {
        if (ssl->major_ver != sStack116) {
          pcVar12 = "major version mismatch";
          iVar8 = 0xdd1;
LAB_2305c86e:
          mbedtls_debug_print_msg(ssl,1,"file1",iVar8,pcVar12);
          goto LAB_2305c81a;
        }
        if ((int)(uint)ssl->conf->max_minor_ver < major_ver) {
          pcVar12 = "minor version mismatch";
          iVar8 = 0xdd7;
          goto LAB_2305c86e;
        }
        uVar6 = ssl->in_msglen;
        if (0x413dU - (int)(ssl->in_msg + -(int)ssl->in_buf) < uVar6) {
          pcVar12 = "bad message length";
          iVar8 = 0xddf;
          goto LAB_2305c86e;
        }
        if (ssl->transform_in != (mbedtls_ssl_transform *)0x0) {
          uVar15 = ssl->transform_in->minlen;
          if (uVar6 < uVar15) {
            pcVar12 = "bad message length";
            iVar8 = 0xdf1;
          }
          else {
            if ((ssl->minor_ver < 1) || (uVar6 <= uVar15 + 0x4100)) goto LAB_2305c902;
            pcVar12 = "bad message length";
            iVar8 = 0xe06;
          }
          goto LAB_2305c86e;
        }
        if (0x3fff < uVar6 - 1) {
          pcVar12 = "bad message length";
          iVar8 = 0xde9;
          goto LAB_2305c86e;
        }
LAB_2305c902:
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
          if (iVar8 == 0x14) {
            if ((ssl->state - 10U & 0xfffffffd) == 0) goto LAB_2305c978;
            pcVar12 = "dropping unexpected ChangeCipherSpec";
            iVar8 = 0xe1c;
LAB_2305c948:
            mbedtls_debug_print_msg(ssl,1,"file1",iVar8,pcVar12);
          }
          else {
            if ((iVar8 == 0x17) && (ssl->state != 0x10)) {
              pcVar12 = "dropping unexpected ApplicationData";
              iVar8 = 0xe2a;
              goto LAB_2305c948;
            }
LAB_2305c978:
            if (((*(ushort *)ssl->in_ctr & 0xff) << 8 | (uint)(*(ushort *)ssl->in_ctr >> 8)) ==
                (uint)ssl->in_epoch) goto LAB_2305c99c;
            mbedtls_debug_print_msg
                      (ssl,1,"file1",0xe33,"record from another epoch: expected %d, received %d");
          }
          uVar6 = 0xffff9900;
          goto LAB_2305c820;
        }
LAB_2305c99c:
        sVar2 = mbedtls_ssl_hdr_len();
        uVar6 = mbedtls_ssl_fetch_input(ssl,sVar2 + uVar6);
        if (uVar6 != 0) {
          pcVar12 = "mbedtls_ssl_fetch_input";
          iVar8 = 0xf11;
          goto LAB_2305c75a;
        }
        sVar2 = ssl->in_msglen;
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          ssl->in_left = 0;
        }
        else {
          sVar3 = mbedtls_ssl_hdr_len();
          ssl->next_record_offset = sVar3 + sVar2;
        }
        sVar3 = mbedtls_ssl_hdr_len();
        mbedtls_debug_print_buf
                  (ssl,4,"file1",0xe63,"input record from network",ssl->in_hdr,sVar3 + sVar2);
        if (ssl->transform_in == (mbedtls_ssl_transform *)0x0) {
LAB_2305d038:
          if ((((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) ||
              (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) || (ssl->state != 0x10))
          goto LAB_2305c700;
          if ((ssl->in_msgtype != 0x16) || (*ssl->in_msg != '\x14')) {
            ssl_handshake_wrapup_free_hs_transform(ssl);
            goto LAB_2305c700;
          }
          mbedtls_debug_print_msg(ssl,2,"file1",0xf6d,"received retransmit of last flight");
          uVar6 = mbedtls_ssl_resend(ssl);
          if (uVar6 == 0) {
            uVar6 = 0xffff9700;
            goto LAB_2305c700;
          }
          pcVar12 = "mbedtls_ssl_resend";
          iVar8 = 0xf71;
          goto LAB_2305c75a;
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0x642,"=> decrypt buf");
        if ((ssl->session_in == (mbedtls_ssl_session *)0x0) ||
           (pmVar14 = ssl->transform_in, pmVar14 == (mbedtls_ssl_transform *)0x0)) {
          iVar8 = 0x646;
LAB_2305ca46:
          mbedtls_debug_print_msg(ssl,1,"file1",iVar8,"should never happen");
          uVar19 = 0xffff9400;
LAB_2305ce16:
          mbedtls_debug_print_ret(ssl,1,"file1",0xe79,"ssl_decrypt_buf",uVar19);
        }
        else {
          pmVar9 = (pmVar14->cipher_ctx_dec).cipher_info;
          mVar10 = MBEDTLS_MODE_NONE;
          if (pmVar9 != (mbedtls_cipher_info_t *)0x0) {
            mVar10 = pmVar9->mode;
          }
          sVar2 = ssl->in_msglen;
          if (sVar2 < pmVar14->minlen) {
            pcVar12 = "in_msglen (%d) < minlen (%d)";
            iVar8 = 0x64f;
LAB_2305ca86:
            mbedtls_debug_print_msg(ssl,1,"file1",iVar8,pcVar12,sVar2);
LAB_2305cbe4:
            uVar19 = 0xffff8e80;
            goto LAB_2305ce16;
          }
          if ((mVar10 + ~MBEDTLS_MODE_CTR & 0xfd) != 0) {
            if (mVar10 == MBEDTLS_MODE_CBC) {
              major_ver = 0;
              uVar19 = pmVar14->ivlen;
              uVar15 = uVar19;
              if (ssl->minor_ver < 2) {
                uVar15 = 0;
              }
              if ((sVar2 < uVar15 + uVar19) || (sVar2 < pmVar14->maclen + 1 + uVar15)) {
                pcVar12 = "msglen (%d) < max( ivlen(%d), maclen (%d) + 1 ) ( + expl IV )";
                iVar8 = 0x6d2;
                goto LAB_2305cacc;
              }
              uVar15 = sVar2 % uVar19;
              if (uVar15 != 0) {
                pcVar12 = "msglen (%d) %% ivlen (%d) != 0";
                iVar8 = 0x70b;
                goto LAB_2305ca86;
              }
              puVar20 = ssl->in_msg;
              if (1 < ssl->minor_ver) {
                sVar2 = sVar2 - uVar19;
                ssl->in_msglen = sVar2;
                uVar19 = 0;
                while (uVar19 < ssl->transform_in->ivlen) {
                  ssl->transform_in->iv_dec[uVar19] = ssl->in_iv[uVar19];
                  uVar19 = uVar19 + 1;
                }
              }
              pmVar14 = ssl->transform_in;
              uVar19 = mbedtls_cipher_crypt
                                 (&pmVar14->cipher_ctx_dec,pmVar14->iv_dec,pmVar14->ivlen,puVar20,
                                  sVar2,puVar20,(size_t *)&major_ver);
              if (uVar19 != 0) {
                mbedtls_debug_print_ret(ssl,1,"file1",0x723,"mbedtls_cipher_crypt",uVar19);
                goto LAB_2305ce16;
              }
              if (sVar2 == major_ver) {
                uVar7 = ssl->in_msglen;
                sVar2 = ssl->transform_in->maclen;
                uVar18 = ssl->in_msg[uVar7 - 1] + 1;
                bVar1 = uVar18 + sVar2 <= uVar7;
                if (!bVar1) {
                  uVar18 = 0;
                }
                if (0 < ssl->minor_ver) {
                  uVar4 = (uVar7 - 1) - uVar18;
                  uVar17 = (uVar7 < uVar18 + 1 ^ 1) & (uint)(uVar4 < sVar2 + 0x4000) & (uint)bVar1;
                  uVar21 = 1;
                  uVar5 = 1;
                  do {
                    uVar21 = uVar21 & (uVar18 < uVar5 ^ 1);
                    iVar8 = uVar4 * uVar17 + uVar5;
                    uVar5 = uVar5 + 1;
                    uVar15 = uVar15 + ((uint)ssl->in_msg[iVar8] == uVar18 - 1) * uVar21;
                  } while (uVar5 != 0x101);
                  uVar17 = uVar18 == uVar15 & uVar17;
                  uVar18 = uVar17 * 0x1ff & uVar18;
                  ssl->in_msglen = uVar7 - uVar18;
                  goto LAB_2305cc06;
                }
                iVar8 = 0x783;
              }
              else {
                iVar8 = 0x729;
              }
            }
            else {
              iVar8 = 0x78d;
            }
            goto LAB_2305ca46;
          }
          sVar3 = 8;
          if ((pmVar14->ciphersuite_info->flags & 2) == 0) {
            sVar3 = 0x10;
          }
          if (sVar2 < (pmVar14->ivlen - pmVar14->fixed_ivlen) + sVar3) {
            pcVar12 = "msglen (%d) < explicit_iv_len (%d) + taglen (%d)";
            iVar8 = 0x67f;
LAB_2305cacc:
            mbedtls_debug_print_msg(ssl,1,"file1",iVar8,pcVar12,sVar2);
            goto LAB_2305cbe4;
          }
          sVar2 = ((sVar2 + pmVar14->fixed_ivlen) - pmVar14->ivlen) - sVar3;
          ssl->in_msglen = sVar2;
          puVar20 = ssl->in_msg;
          memcpy(&major_ver,ssl->in_ctr,8);
          uStack104 = (undefined)ssl->in_msgtype;
          mbedtls_ssl_write_version
                    (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,
                     auStack103);
          uStack101 = (undefined)(ssl->in_msglen >> 8);
          uStack100 = (undefined)ssl->in_msglen;
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x690,"additional data used for AEAD",(uchar *)&major_ver,0xd);
          pmVar14 = ssl->transform_in;
          memcpy(pmVar14->iv_dec + pmVar14->fixed_ivlen,ssl->in_iv,
                 pmVar14->ivlen - pmVar14->fixed_ivlen);
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x697,"IV used",ssl->transform_in->iv_dec,
                     ssl->transform_in->ivlen);
          mbedtls_debug_print_buf(ssl,4,"file1",0x698,"TAG used",puVar20 + sVar2,sVar3);
          pmVar14 = ssl->transform_in;
          uVar19 = mbedtls_cipher_auth_decrypt
                             (&pmVar14->cipher_ctx_dec,pmVar14->iv_dec,pmVar14->ivlen,
                              (uchar *)&major_ver,0xd,puVar20,sVar2,puVar20,in_fa0,in_fa1,in_fa2);
          if (uVar19 != 0) {
            mbedtls_debug_print_ret(ssl,1,"file1",0x6a5,"mbedtls_cipher_auth_decrypt",uVar19);
            if (uVar19 == 0xffff9d00) goto LAB_2305cbe4;
            goto LAB_2305ce16;
          }
          if (sVar2 != sStack116) {
            iVar8 = 0x6b0;
            goto LAB_2305ca46;
          }
          uVar17 = 1;
          uVar18 = 0;
          uVar19 = 1;
LAB_2305cc06:
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0x792,"raw buffer after decryption",ssl->in_msg,ssl->in_msglen);
          if (uVar19 == 0) {
            sVar2 = ssl->in_msglen - ssl->transform_in->maclen;
            ssl->in_msglen = sVar2;
            *ssl->in_len = (uchar)(sVar2 >> 8);
            ssl->in_len[1] = (uchar)ssl->in_msglen;
            memcpy(&major_ver,ssl->in_msg + ssl->in_msglen,ssl->transform_in->maclen);
            if (ssl->minor_ver < 1) {
              iVar8 = 0x7d6;
              goto LAB_2305ca46;
            }
            uVar15 = ssl->in_msglen + 0x15;
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_ctr,8);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_hdr,3);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_len,2);
            mbedtls_md_hmac_update(&ssl->transform_in->md_ctx_dec,ssl->in_msg,ssl->in_msglen);
            mbedtls_md_hmac_finish(&ssl->transform_in->md_ctx_dec,ssl->in_msg + ssl->in_msglen);
            uVar19 = 0;
            do {
              mbedtls_md_process(&ssl->transform_in->md_ctx_dec,ssl->in_msg);
              uVar19 = uVar19 + 1;
            } while (uVar19 < (uVar17 * 0xff & (uVar18 + uVar15 >> 6) - (uVar15 >> 6)) + 1);
            mbedtls_md_hmac_reset(&ssl->transform_in->md_ctx_dec);
            mbedtls_debug_print_buf
                      (ssl,4,"file1",0x7da,"message  mac",(uchar *)&major_ver,
                       ssl->transform_in->maclen);
            mbedtls_debug_print_buf
                      (ssl,4,"file1",0x7dc,"computed mac",ssl->in_msg + ssl->in_msglen,
                       ssl->transform_in->maclen);
            bVar11 = 0;
            sVar2 = 0;
            while (ssl->transform_in->maclen != sVar2) {
              iVar8 = ssl->in_msglen + sVar2;
              pbVar16 = (byte *)((int)&major_ver + sVar2);
              sVar2 = sVar2 + 1;
              bVar11 = bVar11 | ssl->in_msg[iVar8] ^ *pbVar16;
            }
            if ((bVar11 != 0) || (uVar17 == 0)) goto LAB_2305cbe4;
          }
          if (ssl->in_msglen == 0) {
            iVar8 = ssl->nb_zero + 1;
            ssl->nb_zero = iVar8;
            if (3 < iVar8) {
              mbedtls_debug_print_msg
                        (ssl,1,"file1",0x802,
                         "received four consecutive empty messages, possible DoS attack");
              goto LAB_2305cbe4;
            }
          }
          else {
            ssl->nb_zero = 0;
          }
          uVar15 = 8;
          if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
            do {
              uVar19 = uVar15;
              if (uVar19 <= (*(ushort *)&ssl->conf->field_0x74 & 2)) break;
              uVar13 = ssl->in_ctr[uVar19 - 1] + '\x01';
              ssl->in_ctr[uVar19 - 1] = uVar13;
              uVar15 = uVar19 - 1;
            } while (uVar13 == '\0');
            if (uVar19 == (*(ushort *)&ssl->conf->field_0x74 & 2)) {
              mbedtls_debug_print_msg(ssl,1,"file1",0x818,"incoming message counter would wrap");
              uVar19 = 0xffff9480;
              goto LAB_2305ce16;
            }
          }
          mbedtls_debug_print_msg(ssl,2,"file1",0x81d,"<= decrypt buf");
          mbedtls_debug_print_buf
                    (ssl,4,"file1",0xe7e,"input payload after decrypt",ssl->in_msg,ssl->in_msglen);
          if (ssl->in_msglen < 0x4001) goto LAB_2305d038;
          mbedtls_debug_print_msg(ssl,1,"file1",0xe82,"bad message length");
          uVar19 = 0xffff8e00;
        }
        uVar6 = uVar19;
        if ((((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) || ((uVar19 & 0xffffff7f) != 0xffff8e00)
            ) || ((ssl->state - 0xbU & 0xfffffffd) == 0)) goto LAB_2305c700;
        pcVar12 = "discarding invalid record (mac)";
        iVar8 = 0xf40;
      }
      else {
        mbedtls_debug_print_msg(ssl,1,"file1",0xdc2,"unknown record type");
        uVar6 = mbedtls_ssl_send_alert_message(ssl,'\x02','\n');
        if (uVar6 == 0) {
LAB_2305c81a:
          uVar6 = 0xffff8e00;
        }
LAB_2305c820:
        if (((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) || (uVar6 == 0xffff9880))
        goto LAB_2305c700;
        if (uVar6 == 0xffff9900) {
          sVar2 = mbedtls_ssl_hdr_len();
          pcVar12 = "discarding unexpected record (header)";
          ssl->next_record_offset = sVar2 + ssl->in_msglen;
          iVar8 = 0xef8;
        }
        else {
          ssl->next_record_offset = 0;
          ssl->in_left = 0;
          pcVar12 = "discarding invalid record (header)";
          iVar8 = 0xf01;
        }
      }
      mbedtls_debug_print_msg(ssl,1,"file1",iVar8,pcVar12);
    }
    pcVar12 = "mbedtls_ssl_fetch_input";
    iVar8 = 0xee7;
LAB_2305c75a:
    mbedtls_debug_print_ret(ssl,1,"file1",iVar8,pcVar12,uVar6);
  }
  else {
    __n = ssl->in_msglen - uVar6;
    ssl->in_msglen = __n;
    memmove(ssl->in_msg,ssl->in_msg + uVar6,__n);
    mbedtls_debug_print_buf
              (ssl,4,"file1",0xed7,"remaining content in record",ssl->in_msg,ssl->in_msglen);
    uVar6 = 0;
  }
LAB_2305c700:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar6;
}



int mbedtls_ssl_read_record(mbedtls_ssl_context *ssl)

{
  int ret;
  int line;
  char *text;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0xeaa,"=> read record");
  do {
    ret = mbedtls_ssl_read_record_layer(ssl);
    if (ret != 0) {
      text = "mbedtls_ssl_read_record_layer";
      line = 0xeb0;
      goto LAB_2305d0fa;
    }
    ret = mbedtls_ssl_handle_message_type(ssl);
  } while (ret == -0x6680);
  if (ret == 0) {
    if (ssl->in_msgtype == 0x16) {
      mbedtls_ssl_update_handshake_status(ssl);
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0xec3,"<= read record");
  }
  else {
    text = "mbedtls_ssl_handle_message_type";
    line = 0xeba;
LAB_2305d0fa:
    mbedtls_debug_print_ret(ssl,1,"file1",line,text,ret);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ret;
}



int mbedtls_ssl_parse_certificate(mbedtls_ssl_context *ssl)

{
  ushort uVar1;
  uint uVar2;
  mbedtls_ssl_session *pmVar3;
  mbedtls_x509_crt *pmVar4;
  mbedtls_x509_crl *ca_crl;
  uint uVar5;
  int iVar6;
  int iVar7;
  mbedtls_ssl_config_conflict *pmVar8;
  char *text;
  uchar *puVar9;
  uint uVar10;
  mbedtls_ssl_ciphersuite_t *ciphersuite;
  
  ciphersuite = ssl->transform_negotiate->ciphersuite_info;
  uVar2 = *(uint *)&ssl->conf->field_0x74;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1099,"=> parse certificate");
  uVar5 = (uint)ciphersuite->key_exchange;
  uVar10 = uVar5 - 5;
  if (((uVar10 & 0xff) < 7) && ((0x4bU >> (uVar10 & 0x1f) & 1) != 0)) {
    iVar6 = 0x10a0;
  }
  else {
    uVar1 = *(ushort *)&ssl->conf->field_0x74;
    if (((uVar1 & 1) == 0) || (uVar5 != 7)) {
      uVar5 = ssl->handshake->sni_authmode;
      if (uVar5 == 3) {
        uVar5 = uVar2 >> 2 & 3;
      }
      if (((uVar1 & 1) == 0) || (uVar5 != 0)) {
        iVar6 = mbedtls_ssl_read_record(ssl);
        if (iVar6 != 0) {
          text = "mbedtls_ssl_read_record";
          iVar7 = 0x10bf;
LAB_2305d262:
          mbedtls_debug_print_ret(ssl,1,"file1",iVar7,text,iVar6);
          goto LAB_2305d1e0;
        }
        ssl->state = ssl->state + 1;
        uVar1 = *(ushort *)&ssl->conf->field_0x74;
        if (((uVar1 & 1) == 0) || (ssl->minor_ver == 0)) {
LAB_2305d314:
          if (ssl->in_msgtype == 0x16) {
LAB_2305d31c:
            if (*ssl->in_msg == '\v') {
              iVar6 = 4;
              if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
                iVar6 = 0xc;
              }
              if (ssl->in_hslen < iVar6 + 6U) goto LAB_2305d342;
              puVar9 = ssl->in_msg + iVar6;
              if ((*puVar9 == '\0') &&
                 (uVar2 = iVar6 + 3, ssl->in_hslen == CONCAT11(puVar9[1],puVar9[2]) + uVar2)) {
                pmVar4 = ssl->session_negotiate->peer_cert;
                if (pmVar4 != (mbedtls_x509_crt *)0x0) {
                  mbedtls_x509_crt_free(pmVar4);
                  vPortFree(ssl->session_negotiate->peer_cert);
                }
                pmVar3 = ssl->session_negotiate;
                pmVar4 = (mbedtls_x509_crt *)mycalloc(1,0x134);
                pmVar3->peer_cert = pmVar4;
                if (pmVar4 == (mbedtls_x509_crt *)0x0) {
                  mbedtls_debug_print_msg(ssl,1,"file1",0x111a,"alloc(%d bytes) failed",0x134);
                  iVar6 = -0x7f00;
                  goto LAB_2305d1e0;
                }
                iVar6 = 0;
                mbedtls_x509_crt_init(ssl->session_negotiate->peer_cert);
                do {
                  if (ssl->in_hslen <= uVar2) {
                    mbedtls_debug_print_crt
                              (ssl,3,"file1",0x113f,"peer certificate",
                               ssl->session_negotiate->peer_cert);
                    if (uVar5 != 0) {
                      pmVar8 = ssl->conf;
                      pmVar4 = ssl->handshake->sni_ca_chain;
                      if (pmVar4 == (mbedtls_x509_crt *)0x0) {
                        pmVar4 = pmVar8->ca_chain;
                        ca_crl = pmVar8->ca_crl;
                        if (pmVar4 == (mbedtls_x509_crt *)0x0) {
                          mbedtls_debug_print_msg(ssl,1,"file1",0x116f,"got no CA chain");
                          iVar6 = -0x7680;
                          goto LAB_2305d1e0;
                        }
                      }
                      else {
                        ca_crl = ssl->handshake->sni_ca_crl;
                      }
                      iVar6 = mbedtls_x509_crt_verify_with_profile
                                        (ssl->session_negotiate->peer_cert,pmVar4,ca_crl,
                                         pmVar8->cert_profile,ssl->hostname,
                                         &ssl->session_negotiate->verify_result,
                                         (
                                          anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr
                                          *)pmVar8->f_vrfy,pmVar8->p_vrfy);
                      if (iVar6 != 0) {
                        mbedtls_debug_print_ret(ssl,1,"file1",0x1180,"x509_verify_cert",iVar6);
                      }
                      pmVar4 = ssl->session_negotiate->peer_cert;
                      iVar7 = mbedtls_pk_can_do(&pmVar4->pk,MBEDTLS_PK_ECKEY);
                      if (((iVar7 != 0) &&
                          (iVar7 = mbedtls_ssl_check_curve(ssl,*(pmVar4->pk).pk_ctx), iVar7 != 0
                    // WARNING: Load size is inaccurate)) &&
                         (mbedtls_debug_print_msg
                                    (ssl,1,"file1",0x118f,"bad certificate (EC key curve)"),
                         iVar6 == 0)) {
                        iVar6 = -0x7a00;
                      }
                      iVar7 = mbedtls_ssl_check_cert_usage
                                        (ssl->session_negotiate->peer_cert,ciphersuite,
                                         ~(uint)*(ushort *)&ssl->conf->field_0x74 & 1,
                                         &ssl->session_negotiate->verify_result);
                      if ((iVar7 != 0) &&
                         (mbedtls_debug_print_msg
                                    (ssl,1,"file1",0x119b,"bad certificate (usage extensions)"),
                         iVar6 == 0)) {
                        iVar6 = -0x7a00;
                      }
                      if (uVar5 == 1) {
                        iVar6 = 0;
                      }
                    }
                    mbedtls_debug_print_msg(ssl,2,"file1",0x11a4,"<= parse certificate");
                    goto LAB_2305d1e0;
                  }
                  puVar9 = ssl->in_msg + uVar2;
                  if (*puVar9 != '\0') {
                    iVar6 = 0x1126;
                    goto LAB_2305d350;
                  }
                  uVar10 = (uint)CONCAT11(puVar9[1],puVar9[2]);
                  iVar6 = uVar2 + 3;
                  if ((uVar10 < 0x80) || (uVar2 = uVar10 + iVar6, ssl->in_hslen < uVar2)) {
                    iVar6 = 0x1130;
                    goto LAB_2305d350;
                  }
                  iVar6 = mbedtls_x509_crt_parse_der
                                    (ssl->session_negotiate->peer_cert,ssl->in_msg + iVar6,uVar10);
                } while ((iVar6 == 0) || (iVar6 == -0x262e));
                text = " mbedtls_x509_crt_parse_der";
                iVar7 = 0x1138;
                goto LAB_2305d262;
              }
              iVar6 = 0x110b;
            }
            else {
LAB_2305d342:
              iVar6 = 0x10fd;
            }
LAB_2305d350:
            mbedtls_debug_print_msg(ssl,1,"file1",iVar6,"bad certificate message");
            iVar6 = -0x7a00;
            goto LAB_2305d1e0;
          }
        }
        else {
          iVar6 = 4;
          if ((uVar1 & 2) != 0) {
            iVar6 = 0xc;
          }
          if (ssl->in_hslen != iVar6 + 3U) goto LAB_2305d314;
          if (ssl->in_msgtype == 0x16) {
            if (*ssl->in_msg == '\v') {
              iVar6 = memcmp(ssl->in_msg + iVar6,&DAT_23088e44,3);
              if (iVar6 == 0) {
                mbedtls_debug_print_msg(ssl,1,"file1",0x10e7,"TLSv1 client has no certificate");
                ssl->session_negotiate->verify_result = 0x40;
                if (uVar5 != 1) {
                  iVar6 = -0x7480;
                }
                goto LAB_2305d1e0;
              }
              goto LAB_2305d314;
            }
            goto LAB_2305d31c;
          }
        }
        mbedtls_debug_print_msg(ssl,1,"file1",0x10f6,"bad certificate message");
        iVar6 = -0x7700;
        goto LAB_2305d1e0;
      }
      ssl->session_negotiate->verify_result = 0x80;
      iVar6 = 0x10b7;
    }
    else {
      iVar6 = 0x10a9;
    }
  }
  mbedtls_debug_print_msg(ssl,2,"file1",iVar6,"<= skip parse certificate");
  iVar6 = 0;
  ssl->state = ssl->state + 1;
LAB_2305d1e0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar6;
}



int mbedtls_ssl_parse_change_cipher_spec(mbedtls_ssl_context *ssl)

{
  int ret;
  uint16_t uVar1;
  uchar *puVar2;
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x11cb,"=> parse change cipher spec");
  ret = mbedtls_ssl_read_record(ssl);
  if (ret == 0) {
    if (ssl->in_msgtype == 0x14) {
      if ((ssl->in_msglen == 1) && (*ssl->in_msg == '\x01')) {
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x11e3,"switching to new transform spec for inbound data");
        ssl->transform_in = ssl->transform_negotiate;
        ssl->session_in = ssl->session_negotiate;
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
          memset(ssl->in_ctr,0,8);
        }
        else {
          uVar1 = ssl->in_epoch + 1;
          ssl->in_epoch = uVar1;
          if (uVar1 == 0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0x11f1,"DTLS epoch would wrap");
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -0x6b80;
          }
        }
        puVar2 = ssl->in_iv;
        if (1 < ssl->minor_ver) {
          puVar2 = puVar2 + (ssl->transform_negotiate->ivlen - ssl->transform_negotiate->fixed_ivlen
                            );
        }
        ssl->in_msg = puVar2;
        ssl->state = ssl->state + 1;
        mbedtls_debug_print_msg(ssl,2,"file1",0x1211,"<= parse change cipher spec");
      }
      else {
        mbedtls_debug_print_msg(ssl,1,"file1",0x11db,"bad change cipher spec message");
        ret = -0x7e00;
      }
    }
    else {
      mbedtls_debug_print_msg(ssl,1,"file1",0x11d5,"bad change cipher spec message");
      ret = -0x7700;
    }
  }
  else {
    mbedtls_debug_print_ret(ssl,1,"file1",0x11cf,"mbedtls_ssl_read_record",ret);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ret;
}



int mbedtls_ssl_parse_finished(mbedtls_ssl_context *ssl)

{
  byte *pbVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  mbedtls_ssl_config_conflict *pmVar5;
  int iVar6;
  byte local_2c [4];
  uchar buf [12];
  
  mbedtls_debug_print_msg(ssl,2,"file1",0x1486,"=> parse finished");
  (*ssl->handshake->calc_finished)(ssl,local_2c,*(uint *)&ssl->conf->field_0x74 & 1 ^ 1);
  iVar2 = mbedtls_ssl_read_record(ssl);
  if (iVar2 != 0) {
    mbedtls_debug_print_ret(ssl,1,"file1",0x148c,"mbedtls_ssl_read_record",iVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  if (ssl->in_msgtype != 0x16) {
    mbedtls_debug_print_msg(ssl,1,"file1",0x1492,"bad finished message");
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x7700;
  }
  if (*ssl->in_msg == '\x14') {
    pmVar5 = ssl->conf;
    iVar2 = 4;
    if ((*(ushort *)&pmVar5->field_0x74 & 2) != 0) {
      iVar2 = 0xc;
    }
    bVar4 = 0;
    iVar6 = 0;
    if (ssl->in_hslen == iVar2 + 0xcU) {
      do {
        iVar3 = iVar2 + iVar6;
        pbVar1 = local_2c + iVar6;
        iVar6 = iVar6 + 1;
        bVar4 = bVar4 | ssl->in_msg[iVar3] ^ *pbVar1;
      } while (iVar6 != 0xc);
      if (bVar4 == 0) {
        if (ssl->handshake->resume == 0) {
          iVar2 = ssl->state + 1;
        }
        else {
          if (((*(ushort *)&pmVar5->field_0x74 & 1) == 0) &&
             (ssl->state = 10, (*(ushort *)&pmVar5->field_0x74 & 1) == 0)) goto LAB_2305d838;
          iVar2 = 0xf;
        }
        ssl->state = iVar2;
LAB_2305d838:
        if ((*(ushort *)&pmVar5->field_0x74 & 2) != 0) {
          mbedtls_ssl_recv_flight_completed(ssl);
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0x14c4,"<= parse finished");
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      iVar2 = 0x14a8;
      goto LAB_2305d7d4;
    }
  }
  iVar2 = 0x14a1;
LAB_2305d7d4:
  mbedtls_debug_print_msg(ssl,1,"file1",iVar2,"bad finished message");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x7e80;
}



int mbedtls_ssl_read(mbedtls_ssl_context *ssl,uchar *buf,size_t len)

{
  bool bVar1;
  uint __n;
  size_t sVar2;
  int iVar3;
  char *text;
  size_t sVar4;
  uchar *puVar5;
  
  if ((ssl == (mbedtls_ssl_context *)0x0) || (ssl->conf == (mbedtls_ssl_config_conflict *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xffff8f00;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0x19e0,"=> read");
  if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
    sVar2 = mbedtls_ssl_flush_output(ssl);
    if (sVar2 != 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return sVar2;
    }
    if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
        (ssl->handshake->retransmit_state == '\x01')) &&
       (sVar2 = mbedtls_ssl_resend(ssl), sVar2 != 0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return sVar2;
    }
  }
  if (ssl->state == 0x10) {
LAB_2305d91a:
    bVar1 = false;
  }
  else {
    sVar2 = mbedtls_ssl_handshake(ssl);
    if (sVar2 != 0xffff9500) {
      if (sVar2 != 0) {
        text = "mbedtls_ssl_handshake";
        iVar3 = 0x1a02;
        goto LAB_2305d8d8;
      }
      goto LAB_2305d91a;
    }
    bVar1 = true;
  }
  if (ssl->in_offt == (uchar *)0x0) {
    if ((ssl->f_get_timer != (mbedtls_ssl_get_timer_t *)0x0) &&
       (iVar3 = (*ssl->f_get_timer)(ssl->p_timer), iVar3 == -1)) {
      ssl_set_timer(ssl,ssl->conf->read_timeout);
    }
    if ((bVar1) || (sVar2 = mbedtls_ssl_read_record(ssl), sVar2 == 0)) {
      if ((ssl->in_msglen != 0) ||
         ((ssl->in_msgtype != 0x17 || (sVar2 = mbedtls_ssl_read_record(ssl), sVar2 == 0)))) {
        if (ssl->in_msgtype == 0x15) {
          mbedtls_debug_print_msg(ssl,2,"file1",0x1aa0,"ignoring non-fatal non-closure alert");
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0xffff9700;
        }
        if (ssl->in_msgtype != 0x17) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x1aa6,"bad application data message");
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0xffff8900;
        }
        ssl->in_offt = ssl->in_msg;
        if (ssl->state == 0x10) {
          ssl_set_timer(ssl,0);
        }
        goto LAB_2305da00;
      }
      if (sVar2 == 0xffff8d80) goto LAB_2305d908;
      text = "mbedtls_ssl_read_record";
      iVar3 = 0x1a27;
    }
    else {
      if (sVar2 == 0xffff8d80) {
LAB_2305d908:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return 0;
      }
      text = "mbedtls_ssl_read_record";
      iVar3 = 0x1a17;
    }
LAB_2305d8d8:
    mbedtls_debug_print_ret(ssl,1,"file1",iVar3,text,sVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return sVar2;
  }
LAB_2305da00:
  __n = ssl->in_msglen;
  if (len < ssl->in_msglen) {
    __n = len;
  }
  memcpy(buf,ssl->in_offt,__n);
  puVar5 = (uchar *)0x0;
  sVar4 = ssl->in_msglen - __n;
  ssl->in_msglen = sVar4;
  if (sVar4 != 0) {
    puVar5 = ssl->in_offt + __n;
  }
  ssl->in_offt = puVar5;
  mbedtls_debug_print_msg(ssl,2,"file1",0x1ad0,"<= read");
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __n;
}



int mbedtls_ssl_set_calc_verify_md(mbedtls_ssl_context *ssl,int md)

{
  if ((ssl->minor_ver == 3) && (md == 4)) {
    ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6600;
}



void mbedtls_zeroize(void *v,size_t n)

{
  undefined *puVar1;
  
  puVar1 = (undefined *)(n + (int)v);
  while ((undefined *)v != puVar1) {
    *(undefined *)v = 0;
    v = (void *)((int)v + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int x509_memcasecmp(void *s1,void *s2,size_t len)

{
  byte bVar1;
  size_t sVar2;
  
  sVar2 = 0;
  while( true ) {
    if (sVar2 == len) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    bVar1 = *(byte *)((int)s1 + sVar2);
    if ((bVar1 != *(byte *)((int)s2 + sVar2)) &&
       (((bVar1 ^ *(byte *)((int)s2 + sVar2)) != 0x20 || (0x19 < (byte)((bVar1 & 0xdf) + 0xbf)))))
    break;
    sVar2 = sVar2 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -1;
}



int x509_name_cmp(mbedtls_x509_name *a,mbedtls_x509_name *b)

{
  int iVar1;
  size_t sVar2;
  size_t len;
  
  do {
    if (a == (mbedtls_x509_name *)0x0) {
      iVar1 = -(uint)(b != (mbedtls_x509_name *)0x0);
LAB_2305dae6:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    if ((((((b == (mbedtls_x509_name *)0x0) || ((a->oid).tag != (b->oid).tag)) ||
          (sVar2 = (a->oid).len, sVar2 != (b->oid).len)) ||
         (iVar1 = memcmp((a->oid).p,(b->oid).p,sVar2), iVar1 != 0)) ||
        (((((a->val).tag != (b->val).tag || (sVar2 = (a->val).len, sVar2 != (b->val).len)) ||
          (iVar1 = memcmp((a->val).p,(b->val).p,sVar2), iVar1 != 0)) &&
         (((iVar1 = (a->val).tag, iVar1 != 0xc && (iVar1 != 0x13)) ||
          (((iVar1 = (b->val).tag, iVar1 != 0xc && (iVar1 != 0x13)) ||
           ((len = (a->val).len, len != (b->val).len ||
            (iVar1 = x509_memcasecmp((a->val).p,(b->val).p,len), iVar1 != 0)))))))))) ||
       (a->next_merged != b->next_merged)) {
      iVar1 = -1;
      goto LAB_2305dae6;
    }
    a = (mbedtls_x509_name *)a->next;
    b = (mbedtls_x509_name *)b->next;
  } while( true );
}



int x509_check_wildcard(char *cn,mbedtls_x509_buf *name)

{
  size_t sVar1;
  size_t sVar2;
  uchar *puVar3;
  int iVar4;
  
  sVar1 = strlen(cn);
  if (name->len < 3) {
    iVar4 = 0;
  }
  else {
    puVar3 = name->p;
    iVar4 = 0;
    if ((*puVar3 == '*') && (puVar3[1] == '.')) {
      sVar2 = 0;
      while (sVar2 != sVar1) {
        if (cn[sVar2] == '.') {
          if (sVar2 == 0) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -1;
          }
          if (sVar1 - sVar2 != name->len - 1) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -1;
          }
          iVar4 = x509_memcasecmp(puVar3 + 1,cn + sVar2,sVar1 - sVar2);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -(uint)(iVar4 != 0);
        }
        sVar2 = sVar2 + 1;
      }
      iVar4 = -1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int x509_profile_check_key
              (mbedtls_x509_crt_profile *profile,mbedtls_pk_type_t pk_alg,mbedtls_pk_context *pk)

{
  bool bVar1;
  size_t sVar2;
  undefined3 in_register_0000202d;
  int iVar3;
  
  iVar3 = CONCAT31(in_register_0000202d,pk_alg);
  if ((iVar3 == 1) || (iVar3 == 6)) {
    sVar2 = mbedtls_pk_get_bitlen(pk);
    bVar1 = sVar2 < profile->rsa_min_bitlen;
  }
  else {
    if (2 < (iVar3 - 2U & 0xff)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -1;
    }
                    // WARNING: Load size is inaccurate
    bVar1 = (1 << (*pk->pk_ctx - 1 & 0x1f) & profile->allowed_curves) == 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -(uint)bVar1;
}



// WARNING: Variable defined which should be unmapped: key_size_str

int mbedtls_x509_crt_info(char *buf,size_t size,char *prefix,mbedtls_x509_crt *crt)

{
  byte bVar1;
  uint uVar2;
  char *pcVar3;
  uchar *buffer;
  uint uVar4;
  char *name;
  uint uVar5;
  size_t sVar6;
  uchar *puVar7;
  int iVar8;
  undefined *puVar9;
  uchar *puVar10;
  int iVar11;
  mbedtls_x509_sequence *pmVar12;
  char *pcStack56;
  char *desc;
  char key_size_str [18];
  
  if (crt == (mbedtls_x509_crt *)0x0) {
    uVar4 = snprintf(buf,size,"\nCertificate is uninitialised!\n");
    if ((-1 < (int)uVar4) && (uVar4 < size)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return uVar4;
    }
  }
  else {
    uVar4 = snprintf(buf,size,"%scert. version     : %d\r\n",prefix,crt->version);
    if ((-1 < (int)uVar4) && (uVar4 < size)) {
      uVar2 = size - uVar4;
      pcVar3 = buf + uVar4;
      uVar4 = snprintf(pcVar3,uVar2,"%sserial number     : ",prefix);
      if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
        uVar2 = uVar2 - uVar4;
        pcVar3 = pcVar3 + uVar4;
        uVar4 = mbedtls_x509_serial_gets(pcVar3,uVar2,&crt->serial);
        if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
          uVar2 = uVar2 - uVar4;
          pcVar3 = pcVar3 + uVar4;
          uVar4 = snprintf(pcVar3,uVar2,"\r\n%sissuer name       : ",prefix);
          if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
            uVar2 = uVar2 - uVar4;
            pcVar3 = pcVar3 + uVar4;
            uVar4 = mbedtls_x509_dn_gets(pcVar3,uVar2,&crt->issuer);
            if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
              uVar2 = uVar2 - uVar4;
              pcVar3 = pcVar3 + uVar4;
              uVar4 = snprintf(pcVar3,uVar2,"\r\n%ssubject name      : ",prefix);
              if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                uVar2 = uVar2 - uVar4;
                pcVar3 = pcVar3 + uVar4;
                uVar4 = mbedtls_x509_dn_gets(pcVar3,uVar2,&crt->subject);
                if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                  uVar2 = uVar2 - uVar4;
                  pcVar3 = pcVar3 + uVar4;
                  uVar4 = snprintf(pcVar3,uVar2,
                                   "\r\n%sissued  on        : %04d-%02d-%02d %02d:%02d:%02d",prefix,
                                   (crt->valid_from).year,(crt->valid_from).mon,
                                   (crt->valid_from).day,(crt->valid_from).hour);
                  if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                    uVar2 = uVar2 - uVar4;
                    pcVar3 = pcVar3 + uVar4;
                    uVar4 = snprintf(pcVar3,uVar2,
                                     "\r\n%sexpires on        : %04d-%02d-%02d %02d:%02d:%02d",
                                     prefix,(crt->valid_to).year,(crt->valid_to).mon,
                                     (crt->valid_to).day,(crt->valid_to).hour);
                    if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                      uVar2 = uVar2 - uVar4;
                      pcVar3 = pcVar3 + uVar4;
                      uVar4 = snprintf(pcVar3,uVar2,"\r\n%ssigned using      : ",prefix);
                      if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                        uVar2 = uVar2 - uVar4;
                        pcVar3 = pcVar3 + uVar4;
                        uVar4 = mbedtls_x509_sig_alg_gets
                                          (pcVar3,uVar2,&crt->sig_oid,crt->sig_pk,crt->sig_md,
                                           crt->sig_opts);
                        if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                          name = mbedtls_pk_get_name(&crt->pk);
                          uVar5 = mbedtls_x509_key_size_helper((char *)&desc,0x12,name);
                          if (uVar5 != 0) {
                            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                            return uVar5;
                          }
                          sVar6 = mbedtls_pk_get_bitlen(&crt->pk);
                          uVar2 = uVar2 - uVar4;
                          uVar5 = snprintf(pcVar3 + uVar4,uVar2,"\r\n%s%-18s: %d bits",prefix,&desc,
                                           sVar6);
                          if ((-1 < (int)uVar5) && (uVar5 < uVar2)) {
                            uVar2 = uVar2 - uVar5;
                            buffer = (uchar *)(pcVar3 + uVar4 + uVar5);
                            if ((crt->ext_types & 0x100U) != 0) {
                              if (crt->ca_istrue == 0) {
                                pcVar3 = "false";
                              }
                              else {
                                pcVar3 = "true";
                              }
                              uVar4 = snprintf((char *)buffer,uVar2,
                                               "\r\n%sbasic constraints : CA=%s",prefix,pcVar3);
                              if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                              uVar2 = uVar2 - uVar4;
                              buffer = buffer + uVar4;
                              if (0 < crt->max_pathlen) {
                                uVar4 = snprintf((char *)buffer,uVar2,", max_pathlen=%d",
                                                 crt->max_pathlen + -1);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                              }
                            }
                            if ((crt->ext_types & 0x20U) != 0) {
                              uVar4 = snprintf((char *)buffer,uVar2,"\r\n%ssubject alt name  : ",
                                               prefix);
                              if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                              uVar2 = uVar2 - uVar4;
                              buffer = buffer + uVar4;
                              pmVar12 = &crt->subject_alt_names;
                              iVar8 = 0;
                              puVar9 = &DAT_23088e60;
                              do {
                                uVar4 = (pmVar12->buf).len + iVar8;
                                if (uVar2 <= uVar4) {
                                  *buffer = '\0';
                                  goto LAB_2305dc66;
                                }
                                uVar2 = uVar2 - uVar4;
                                iVar11 = 0;
                                while (puVar7 = buffer + iVar11, iVar11 != iVar8) {
                                  puVar10 = puVar9 + iVar11;
                                  iVar11 = iVar11 + 1;
                                  *puVar7 = *puVar10;
                                }
                                uVar4 = 0;
                                while (buffer = puVar7 + uVar4, uVar4 < (pmVar12->buf).len) {
                                  puVar10 = (pmVar12->buf).p + uVar4;
                                  uVar4 = uVar4 + 1;
                                  *buffer = *puVar10;
                                }
                                pmVar12 = (mbedtls_x509_sequence *)pmVar12->next;
                                iVar8 = 2;
                                puVar9 = &DAT_23080648;
                              } while (pmVar12 != (mbedtls_x509_sequence *)0x0);
                              *buffer = '\0';
                            }
                            if (crt->ext_types << 0xf < 0) {
                              uVar4 = snprintf((char *)buffer,uVar2,"\r\n%scert. type        : ",
                                               prefix);
                              if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                              bVar1 = crt->ns_cert_type;
                              uVar2 = uVar2 - uVar4;
                              buffer = buffer + uVar4;
                              puVar9 = &DAT_23088e60;
                              if ((char)bVar1 < '\0') {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sSSL Client",&DAT_23088e60);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x40) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sSSL Server",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x20) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sEmail",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 0x10) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sObject Signing",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 8) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sReserved",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 4) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sSSL CA",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 2) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sEmail CA",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((bVar1 & 1) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sObject Signing CA",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                              }
                            }
                            if ((crt->ext_types & 4U) != 0) {
                              uVar4 = snprintf((char *)buffer,uVar2,"\r\n%skey usage         : ",
                                               prefix);
                              if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                              uVar5 = crt->key_usage;
                              uVar2 = uVar2 - uVar4;
                              buffer = buffer + uVar4;
                              puVar9 = &DAT_23088e60;
                              if ((uVar5 & 0x80) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sDigital Signature",
                                                 &DAT_23088e60);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x40) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sNon Repudiation",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x20) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sKey Encipherment",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 0x10) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sData Encipherment",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 8) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sKey Agreement",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 4) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sKey Cert Sign",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 2) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sCRL Sign",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((uVar5 & 1) != 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sEncipher Only",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              }
                              if ((int)(uVar5 << 0x10) < 0) {
                                uVar4 = snprintf((char *)buffer,uVar2,"%sDecipher Only",puVar9);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                              }
                            }
                            if (crt->ext_types << 0x14 < 0) {
                              uVar4 = snprintf((char *)buffer,uVar2,"\r\n%sext key usage     : ",
                                               prefix);
                              if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                              uVar2 = uVar2 - uVar4;
                              buffer = buffer + uVar4;
                              pmVar12 = &crt->ext_key_usage;
                              puVar9 = &DAT_23088e60;
                              do {
                                iVar8 = mbedtls_oid_get_extended_key_usage
                                                  ((mbedtls_asn1_buf *)pmVar12,&pcStack56);
                                if (iVar8 != 0) {
                                  pcStack56 = "???";
                                }
                                uVar4 = snprintf((char *)buffer,uVar2,"%s%s",puVar9,pcStack56);
                                if (((int)uVar4 < 0) || (uVar2 <= uVar4)) goto LAB_2305dc66;
                                pmVar12 = (mbedtls_x509_sequence *)pmVar12->next;
                                uVar2 = uVar2 - uVar4;
                                buffer = buffer + uVar4;
                                puVar9 = &DAT_23080648;
                              } while (pmVar12 != (mbedtls_x509_sequence *)0x0);
                            }
                            uVar4 = snprintf((char *)buffer,uVar2,"\r\n");
                            if ((-1 < (int)uVar4) && (uVar4 < uVar2)) {
                              gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
                              return (uVar4 - uVar2) + size;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LAB_2305dc66:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0xffffd680;
}



int mbedtls_x509_crt_verify_info(char *buf,size_t size,char *prefix,uint32_t flags)

{
  size_t n;
  uint uVar1;
  x509_crt_verify_string *pxVar2;
  
  pxVar2 = x509_crt_verify_strings;
  n = size;
  while (pxVar2->string != (char *)0x0) {
    if ((flags & pxVar2->code) != 0) {
      uVar1 = snprintf(buf,n,"%s%s\n",prefix);
      if (((int)uVar1 < 0) || (n <= uVar1)) goto LAB_2305e36e;
      n = n - uVar1;
      buf = buf + uVar1;
      flags = flags ^ pxVar2->code;
    }
    pxVar2 = pxVar2 + 1;
  }
  if (flags != 0) {
    uVar1 = snprintf(buf,n,"%sUnknown reason (this should not happen)\n",prefix);
    if (((int)uVar1 < 0) || (n <= uVar1)) {
LAB_2305e36e:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2980;
    }
    n = n - uVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return size - n;
}



int mbedtls_x509_crt_check_key_usage(mbedtls_x509_crt *crt,uint usage)

{
  uint uVar1;
  
  uVar1 = crt->ext_types & 4;
  if ((uVar1 != 0) &&
     (((usage & 0xffff7ffe) != (usage & 0xffff7ffe & crt->key_usage) ||
      (uVar1 = 0, (usage & 0x8001) != ((usage | crt->key_usage) & 0x8001))))) {
    uVar1 = 0xffffd800;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int x509_crt_check_parent(mbedtls_x509_crt *child,mbedtls_x509_crt *parent,int top,int bottom)

{
  int iVar1;
  int iVar2;
  size_t __n;
  int iVar3;
  
  iVar1 = x509_name_cmp(&child->issuer,&parent->subject);
  if (iVar1 == 0) {
    if ((top != 0) &&
       ((((iVar3 = parent->version, bottom != 0 &&
          (__n = (child->raw).len, __n == (parent->raw).len)) &&
         (iVar2 = memcmp((child->raw).p,(parent->raw).p,__n), iVar2 == 0)) || (iVar3 < 3))))
    goto LAB_2305e3f4;
    if (parent->ca_istrue != 0) {
      iVar1 = mbedtls_x509_crt_check_key_usage(parent,4);
      iVar1 = -(uint)(iVar1 != 0);
      goto LAB_2305e3f4;
    }
  }
  iVar1 = -1;
LAB_2305e3f4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int x509_crt_verify_top(mbedtls_x509_crt *child,mbedtls_x509_crt *trust_ca,
                       mbedtls_x509_crt_profile *profile,int path_cnt,int self_cnt,uint32_t *flags,
                       anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,
                       void *p_vrfy)

{
  mbedtls_pk_type_t type;
  mbedtls_md_type_t md_alg;
  uchar uVar1;
  int iVar2;
  mbedtls_md_info_t *md_info;
  int iVar3;
  undefined3 extraout_var;
  void *options;
  mbedtls_x509_crt *pmVar4;
  uint uStack100;
  uint32_t ca_flags;
  uchar hash [32];
  
  uStack100 = 0;
  iVar2 = mbedtls_x509_time_is_past(&child->valid_to);
  if (iVar2 != 0) {
    *flags = *flags | 1;
  }
  iVar2 = mbedtls_x509_time_is_future();
  if (iVar2 != 0) {
    *flags = *flags | 0x200;
  }
  if ((1 << (child->sig_md - 1 & 0x1f) & profile->allowed_mds) == 0) {
    *flags = *flags | 0x4000;
  }
  if ((1 << (child->sig_pk - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  *flags = *flags | 8;
  md_info = mbedtls_md_info_from_type(child->sig_md);
  if (md_info == (mbedtls_md_info_t *)0x0) {
LAB_2305e504:
    if (f_vrfy != (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0) {
LAB_2305e634:
      iVar2 = (*f_vrfy)(p_vrfy,child,path_cnt,flags);
      if (iVar2 != 0) goto LAB_2305e608;
    }
  }
  else {
    pmVar4 = (mbedtls_x509_crt *)0x0;
    mbedtls_md(md_info,(child->tbs).p,(child->tbs).len,(uchar *)&ca_flags);
    while (trust_ca != (mbedtls_x509_crt *)0x0) {
      iVar2 = x509_crt_check_parent(child,trust_ca,1,(uint)(path_cnt == 0));
      if (iVar2 == 0) {
        iVar2 = path_cnt + 1;
        if (((child->subject_raw).len == (trust_ca->subject_raw).len) &&
           (iVar3 = memcmp((child->subject_raw).p,(trust_ca->subject_raw).p,(child->issuer_raw).len)
           , iVar3 == 0)) {
          iVar2 = path_cnt;
        }
        if ((trust_ca->max_pathlen < 1) || (iVar2 - self_cnt <= trust_ca->max_pathlen)) {
          type = child->sig_pk;
          options = child->sig_opts;
          md_alg = child->sig_md;
          uVar1 = mbedtls_md_get_size(md_info);
          iVar2 = mbedtls_pk_verify_ext
                            (type,options,&trust_ca->pk,md_alg,(uchar *)&ca_flags,
                             CONCAT31(extraout_var,uVar1),(child->sig).p,(child->sig).len);
          if (iVar2 == 0) {
            iVar2 = mbedtls_x509_time_is_past(&trust_ca->valid_to);
            if ((iVar2 == 0) && (iVar2 = mbedtls_x509_time_is_future(), iVar2 == 0))
            goto LAB_2305e5a0;
            if (pmVar4 == (mbedtls_x509_crt *)0x0) {
              pmVar4 = trust_ca;
            }
          }
        }
      }
      trust_ca = trust_ca->next;
    }
    trust_ca = pmVar4;
    if (pmVar4 == (mbedtls_x509_crt *)0x0) goto LAB_2305e504;
LAB_2305e5a0:
    *flags = *flags & 0xfffffff7;
    iVar2 = x509_profile_check_key(profile,child->sig_pk,&trust_ca->pk);
    if (iVar2 != 0) {
      *flags = *flags | 0x10000;
    }
    if (((child->subject_raw).len == (trust_ca->subject_raw).len) &&
       (iVar2 = memcmp((child->subject_raw).p,(trust_ca->subject_raw).p,(child->issuer_raw).len),
       iVar2 == 0)) goto LAB_2305e504;
    iVar2 = mbedtls_x509_time_is_past(&trust_ca->valid_to);
    if (iVar2 != 0) {
      uStack100 = uStack100 | 1;
    }
    iVar2 = mbedtls_x509_time_is_future();
    if (iVar2 != 0) {
      uStack100 = uStack100 | 0x200;
    }
    if (f_vrfy != (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0) {
      iVar2 = (*f_vrfy)(p_vrfy,trust_ca,path_cnt + 1,&uStack100);
      if (iVar2 != 0) goto LAB_2305e608;
      goto LAB_2305e634;
    }
  }
  iVar2 = 0;
  *flags = *flags | uStack100;
LAB_2305e608:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int x509_crt_verify_child
              (mbedtls_x509_crt *child,mbedtls_x509_crt *parent,mbedtls_x509_crt *trust_ca,
              mbedtls_x509_crl *ca_crl,mbedtls_x509_crt_profile *profile,int path_cnt,int self_cnt,
              uint32_t *flags,anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,
              void *p_vrfy)

{
  mbedtls_pk_type_t type;
  mbedtls_md_type_t md_alg;
  uchar uVar1;
  int iVar2;
  mbedtls_md_info_t *md_info;
  undefined3 extraout_var;
  void *options;
  mbedtls_x509_crt *parent_00;
  mbedtls_x509_crt *parent_01;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *in_stack_00000000;
  void *in_stack_00000004;
  uint uStack100;
  uint32_t parent_flags;
  uchar hash [32];
  
  uStack100 = 0;
  if (path_cnt != 0) {
    iVar2 = x509_name_cmp(&child->issuer,&child->subject);
    if (iVar2 == 0) {
      self_cnt = self_cnt + 1;
    }
    if (path_cnt == 8) {
      iVar2 = -0x2700;
      *flags = *flags | 8;
      goto LAB_2305e69a;
    }
  }
  iVar2 = mbedtls_x509_time_is_past(&child->valid_to);
  if (iVar2 != 0) {
    *flags = *flags | 1;
  }
  iVar2 = mbedtls_x509_time_is_future();
  if (iVar2 != 0) {
    *flags = *flags | 0x200;
  }
  if ((1 << (child->sig_md - 1 & 0x1f) & profile->allowed_mds) == 0) {
    *flags = *flags | 0x4000;
  }
  if ((1 << (child->sig_pk - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  md_info = mbedtls_md_info_from_type(child->sig_md);
  if (md_info == (mbedtls_md_info_t *)0x0) {
LAB_2305e724:
    *flags = *flags | 8;
  }
  else {
    mbedtls_md(md_info,(child->tbs).p,(child->tbs).len,(uchar *)&parent_flags);
    iVar2 = x509_profile_check_key(profile,child->sig_pk,&parent->pk);
    if (iVar2 != 0) {
      *flags = *flags | 0x10000;
    }
    type = child->sig_pk;
    options = child->sig_opts;
    md_alg = child->sig_md;
    uVar1 = mbedtls_md_get_size(md_info);
    iVar2 = mbedtls_pk_verify_ext
                      (type,options,&parent->pk,md_alg,(uchar *)&parent_flags,
                       CONCAT31(extraout_var,uVar1),(child->sig).p,(child->sig).len);
    if (iVar2 != 0) goto LAB_2305e724;
  }
  parent_01 = trust_ca;
  while (parent_01 != (mbedtls_x509_crt *)0x0) {
    iVar2 = x509_crt_check_parent(parent,parent_01,0,(uint)(path_cnt == 0));
    if (iVar2 == 0) goto LAB_2305e7da;
    parent_01 = parent_01->next;
  }
  parent_00 = parent->next;
  while (parent_01 = trust_ca, parent_00 != (mbedtls_x509_crt *)0x0) {
    if (((parent_00->max_pathlen < 1) || ((path_cnt + 2) - self_cnt <= parent_00->max_pathlen)) &&
       (iVar2 = x509_crt_check_parent(parent,parent_00,0,(uint)(path_cnt == 0)), iVar2 == 0)) {
      iVar2 = x509_crt_verify_child
                        (parent,parent_00,trust_ca,ca_crl,profile,path_cnt + 1,self_cnt,&uStack100,
                         f_vrfy,p_vrfy);
      goto LAB_2305e80e;
    }
    parent_00 = parent_00->next;
  }
LAB_2305e7da:
  iVar2 = x509_crt_verify_top(parent,parent_01,profile,path_cnt + 1,self_cnt,&uStack100,
                              in_stack_00000000,in_stack_00000004);
LAB_2305e80e:
  if ((iVar2 == 0) &&
     ((in_stack_00000000 == (anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *)0x0 ||
      (iVar2 = (*in_stack_00000000)(in_stack_00000004,child,path_cnt,flags), iVar2 == 0)))) {
    iVar2 = 0;
    *flags = *flags | uStack100;
  }
LAB_2305e69a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_x509_crt_check_extended_key_usage
              (mbedtls_x509_crt *crt,char *usage_oid,size_t usage_len)

{
  mbedtls_x509_sequence *pmVar1;
  int iVar2;
  
  if (-1 < crt->ext_types << 0x14) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  pmVar1 = &crt->ext_key_usage;
  while ((((pmVar1->buf).len != usage_len ||
          (iVar2 = memcmp((pmVar1->buf).p,usage_oid,usage_len), iVar2 != 0)) &&
         (((pmVar1->buf).len != 4 || (iVar2 = memcmp(&DAT_2308a3ac,(pmVar1->buf).p,4), iVar2 != 0)))
         )) {
    pmVar1 = (mbedtls_x509_sequence *)pmVar1->next;
    if (pmVar1 == (mbedtls_x509_sequence *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2800;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_x509_crt_verify_with_profile
              (mbedtls_x509_crt *crt,mbedtls_x509_crt *trust_ca,mbedtls_x509_crl *ca_crl,
              mbedtls_x509_crt_profile *profile,char *cn,uint32_t *flags,
              anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *f_vrfy,void *p_vrfy)

{
  mbedtls_pk_type_t pk_alg;
  size_t len;
  int iVar1;
  mbedtls_x509_crt *parent;
  uint uVar2;
  mbedtls_x509_crt *parent_00;
  mbedtls_x509_name *pmVar3;
  mbedtls_x509_sequence *name;
  anon_subr_int_void_ptr_mbedtls_x509_crt_ptr_int_uint32_t_ptr *in_fa0;
  void *in_fa1;
  
  if (profile == (mbedtls_x509_crt_profile *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2800;
  }
  *flags = 0;
  if (cn != (char *)0x0) {
    len = strlen(cn);
    if ((crt->ext_types & 0x20U) == 0) {
      pmVar3 = &crt->subject;
      do {
        if ((((pmVar3->oid).len == 3) &&
            (iVar1 = memcmp(&DAT_2308a724,(pmVar3->oid).p,3), iVar1 == 0)) &&
           (((uVar2 = (pmVar3->val).len, uVar2 == len &&
             (iVar1 = x509_memcasecmp((pmVar3->val).p,cn,len), iVar1 == 0)) ||
            (((2 < uVar2 && (iVar1 = memcmp((pmVar3->val).p,&DAT_2308a720,2), iVar1 == 0)) &&
             (iVar1 = x509_check_wildcard(cn,(mbedtls_x509_buf *)&pmVar3->val), iVar1 == 0))))))
        goto LAB_2305e96c;
        pmVar3 = (mbedtls_x509_name *)pmVar3->next;
      } while (pmVar3 != (mbedtls_x509_name *)0x0);
    }
    else {
      name = &crt->subject_alt_names;
      do {
        uVar2 = (name->buf).len;
        if (((uVar2 == len) && (iVar1 = x509_memcasecmp(cn,(name->buf).p,len), iVar1 == 0)) ||
           ((2 < uVar2 &&
            ((iVar1 = memcmp((name->buf).p,&DAT_2308a720,2), iVar1 == 0 &&
             (iVar1 = x509_check_wildcard(cn,(mbedtls_x509_buf *)name), iVar1 == 0))))))
        goto LAB_2305e96c;
        name = (mbedtls_x509_sequence *)name->next;
      } while (name != (mbedtls_x509_sequence *)0x0);
    }
    *flags = *flags | 4;
  }
LAB_2305e96c:
  pk_alg = mbedtls_pk_get_type(&crt->pk);
  if ((1 << (pk_alg - 1 & 0x1f) & profile->allowed_pks) == 0) {
    *flags = *flags | 0x8000;
  }
  iVar1 = x509_profile_check_key(profile,pk_alg,&crt->pk);
  parent = trust_ca;
  if (iVar1 != 0) {
    *flags = *flags | 0x10000;
  }
  while (parent != (mbedtls_x509_crt *)0x0) {
    iVar1 = x509_crt_check_parent(crt,parent,0,1);
    if (iVar1 == 0) goto LAB_2305ea38;
    parent = parent->next;
  }
  parent_00 = crt->next;
  do {
    parent = trust_ca;
    if (parent_00 == (mbedtls_x509_crt *)0x0) {
LAB_2305ea38:
      iVar1 = x509_crt_verify_top(crt,parent,profile,0,0,flags,f_vrfy,p_vrfy);
LAB_2305ea60:
      if ((iVar1 == 0) && (iVar1 = 0, *flags != 0)) {
        iVar1 = -0x2700;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    iVar1 = x509_crt_check_parent(crt,parent_00,0,1);
    if (iVar1 == 0) {
      iVar1 = x509_crt_verify_child(crt,parent_00,trust_ca,ca_crl,profile,0,0,flags,in_fa0,in_fa1);
      goto LAB_2305ea60;
    }
    parent_00 = parent_00->next;
  } while( true );
}



void mbedtls_x509_crt_init(mbedtls_x509_crt *crt)

{
  memset(crt,0,0x134);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_x509_crt_free(mbedtls_x509_crt *crt)

{
  mbedtls_x509_crt **ppmVar1;
  mbedtls_x509_crt *v;
  uchar *v_00;
  mbedtls_asn1_named_data *pmVar2;
  mbedtls_asn1_sequence *pmVar3;
  mbedtls_x509_crt *pmVar4;
  mbedtls_asn1_named_data *pmVar5;
  mbedtls_asn1_sequence *pmVar6;
  
  pmVar4 = crt;
  if (crt == (mbedtls_x509_crt *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  do {
    mbedtls_pk_free(&pmVar4->pk);
    pmVar2 = (pmVar4->issuer).next;
    while (pmVar2 != (mbedtls_asn1_named_data *)0x0) {
      pmVar5 = pmVar2->next;
      mbedtls_zeroize(pmVar2,0x20);
      vPortFree(pmVar2);
      pmVar2 = pmVar5;
    }
    pmVar2 = (pmVar4->subject).next;
    while (pmVar2 != (mbedtls_asn1_named_data *)0x0) {
      pmVar5 = pmVar2->next;
      mbedtls_zeroize(pmVar2,0x20);
      vPortFree(pmVar2);
      pmVar2 = pmVar5;
    }
    pmVar3 = (pmVar4->ext_key_usage).next;
    while (pmVar3 != (mbedtls_asn1_sequence *)0x0) {
      pmVar6 = pmVar3->next;
      mbedtls_zeroize(pmVar3,0x10);
      vPortFree(pmVar3);
      pmVar3 = pmVar6;
    }
    pmVar3 = (pmVar4->subject_alt_names).next;
    while (pmVar3 != (mbedtls_asn1_sequence *)0x0) {
      pmVar6 = pmVar3->next;
      mbedtls_zeroize(pmVar3,0x10);
      vPortFree(pmVar3);
      pmVar3 = pmVar6;
    }
    v_00 = (pmVar4->raw).p;
    if (v_00 != (uchar *)0x0) {
      mbedtls_zeroize(v_00,(pmVar4->raw).len);
      vPortFree((pmVar4->raw).p);
    }
    ppmVar1 = &pmVar4->next;
    v = crt;
    pmVar4 = *ppmVar1;
  } while (*ppmVar1 != (mbedtls_x509_crt *)0x0);
  do {
    pmVar4 = v->next;
    mbedtls_zeroize(v,0x134);
    if (crt != v) {
      vPortFree(v);
    }
    v = pmVar4;
  } while (pmVar4 != (mbedtls_x509_crt *)0x0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_x509_crt_parse_der(mbedtls_x509_crt *chain,uchar *buf,size_t buflen)

{
  uchar uVar1;
  int iVar2;
  uchar *end;
  mbedtls_x509_crt *pmVar3;
  mbedtls_x509_crt *pmVar4;
  mbedtls_x509_sequence *pmVar5;
  size_t __n;
  size_t sVar6;
  uchar *puVar7;
  byte *pbVar8;
  byte *pbVar9;
  uchar *end_00;
  mbedtls_x509_crt *pmVar10;
  uchar *puVar11;
  mbedtls_x509_sequence *pmVar12;
  uchar *puStack132;
  size_t len;
  uchar *p;
  size_t len_2;
  int is_critical;
  int ext_type;
  size_t len_3;
  mbedtls_x509_buf sig_params1;
  mbedtls_x509_buf sig_params2;
  mbedtls_x509_buf sig_oid2;
  mbedtls_x509_buf extn_oid;
  size_t len_1;
  
  if ((chain == (mbedtls_x509_crt *)0x0) || (buf == (uchar *)0x0)) {
    iVar2 = -0x2800;
    goto LAB_2305eca2;
  }
  pmVar4 = chain;
  pmVar10 = (mbedtls_x509_crt *)0x0;
  do {
    pmVar3 = pmVar4;
    if (pmVar3->version == 0) goto LAB_2305ebe0;
    pmVar4 = pmVar3->next;
    pmVar10 = pmVar3;
  } while (pmVar3->next != (mbedtls_x509_crt *)0x0);
  pmVar4 = (mbedtls_x509_crt *)mycalloc(1,0x134);
  pmVar3->next = pmVar4;
  if (pmVar4 == (mbedtls_x509_crt *)0x0) {
    iVar2 = -0x2880;
    goto LAB_2305eca2;
  }
  mbedtls_x509_crt_init(pmVar4);
  pmVar3 = pmVar3->next;
LAB_2305ebe0:
  memset(&len_3,0,0xc);
  memset(&sig_params1.p,0,0xc);
  memset(&sig_params2.p,0,0xc);
  if (pmVar3 == (mbedtls_x509_crt *)0x0) {
    iVar2 = -0x2800;
    if (pmVar10 != (mbedtls_x509_crt *)0x0) goto LAB_2305ec28;
  }
  else {
    puStack132 = (uchar *)buflen;
    len = (size_t)buf;
    iVar2 = mbedtls_asn1_get_tag((uchar **)&len,buf + buflen,(size_t *)&puStack132,0x30);
    if (iVar2 == 0) {
      if (buf + buflen + -len < puStack132) goto LAB_2305ec3c;
      (pmVar3->raw).len = (size_t)(puStack132 + (int)(len - (int)buf));
      len = (size_t)mycalloc(1,(size_t)(puStack132 + (int)(len - (int)buf)));
      (pmVar3->raw).p = (uchar *)len;
      if ((uchar *)len == (uchar *)0x0) {
        iVar2 = -0x2880;
      }
      else {
        memcpy((void *)len,buf,(pmVar3->raw).len);
        sVar6 = (pmVar3->raw).len;
        puVar7 = (uchar *)((sVar6 - (int)puStack132) + len);
        end_00 = (uchar *)(len + sVar6);
        (pmVar3->tbs).p = puVar7;
        len = (size_t)puVar7;
        iVar2 = mbedtls_asn1_get_tag((uchar **)&len,end_00,(size_t *)&puStack132,0x30);
        if (iVar2 == 0) {
          puVar7 = puStack132 + len;
          (pmVar3->tbs).len = (size_t)(puVar7 + -(int)(pmVar3->tbs).p);
          iVar2 = mbedtls_asn1_get_tag((uchar **)&len,puVar7,(size_t *)&extn_oid.p,0xa0);
          if (iVar2 == 0) {
            puVar11 = extn_oid.p + len;
            iVar2 = mbedtls_asn1_get_int((uchar **)&len,puVar11,&pmVar3->version);
            if (iVar2 == 0) {
              if (puVar11 == (uchar *)len) goto LAB_2305ecea;
              iVar2 = -0x2266;
            }
            else {
              iVar2 = iVar2 + -0x2200;
              if (iVar2 == 0) {
LAB_2305ecea:
                iVar2 = mbedtls_x509_get_serial((uchar **)&len,puVar7,&pmVar3->serial);
                if (iVar2 == 0) {
                  iVar2 = mbedtls_x509_get_alg
                                    ((uchar **)&len,puVar7,&pmVar3->sig_oid,
                                     (mbedtls_x509_buf *)&len_3);
                  if (iVar2 == 0) {
                    iVar2 = pmVar3->version + 1;
                    pmVar3->version = iVar2;
                    if (3 < iVar2) {
                      mbedtls_x509_crt_free(pmVar3);
                      iVar2 = -0x2580;
                      goto LAB_2305ec24;
                    }
                    iVar2 = mbedtls_x509_get_sig_alg
                                      (&pmVar3->sig_oid,(mbedtls_x509_buf *)&len_3,&pmVar3->sig_md,
                                       &pmVar3->sig_pk,&pmVar3->sig_opts);
                    if (iVar2 == 0) {
                      (pmVar3->issuer_raw).p = (uchar *)len;
                      iVar2 = mbedtls_asn1_get_tag((uchar **)&len,puVar7,(size_t *)&puStack132,0x30)
                      ;
                      if (iVar2 != 0) goto LAB_2305ec92;
                      iVar2 = mbedtls_x509_get_name((uchar **)&len,puStack132 + len,&pmVar3->issuer)
                      ;
                      if (iVar2 == 0) {
                        (pmVar3->issuer_raw).len = (size_t)(len - (int)(pmVar3->issuer_raw).p);
                        iVar2 = mbedtls_asn1_get_tag
                                          ((uchar **)&len,puVar7,(size_t *)&extn_oid.p,0x30);
                        if (iVar2 == 0) {
                          len = (size_t)(extn_oid.p + len);
                        }
                        else {
                          if (iVar2 != -0x62) goto LAB_2305ed46;
                        }
                        (pmVar3->subject_raw).p = (uchar *)len;
                        iVar2 = mbedtls_asn1_get_tag
                                          ((uchar **)&len,puVar7,(size_t *)&puStack132,0x30);
                        if (iVar2 != 0) goto LAB_2305ec92;
                        if ((puStack132 == (uchar *)0x0) ||
                           (iVar2 = mbedtls_x509_get_name
                                              ((uchar **)&len,puStack132 + len,&pmVar3->subject),
                           iVar2 == 0)) {
                          (pmVar3->subject_raw).len = (size_t)(len - (int)(pmVar3->subject_raw).p);
                          iVar2 = mbedtls_pk_parse_subpubkey((uchar **)&len,puVar7,&pmVar3->pk);
                          if (iVar2 == 0) {
                            if (pmVar3->version - 2U < 2) {
                              if (puVar7 != (uchar *)len) {
                                (pmVar3->issuer_id).tag = (uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,puVar7,&(pmVar3->issuer_id).len,
                                                   0xa1);
                                if (iVar2 == 0) {
                                  (pmVar3->issuer_id).p = (uchar *)len;
                                  len = len + (pmVar3->issuer_id).len;
                                }
                                else {
                                  if (iVar2 != -0x62) goto LAB_2305ed46;
                                }
                                if (1 < pmVar3->version - 2U) goto LAB_2305ee1e;
                              }
                              if (puVar7 != (uchar *)len) {
                                (pmVar3->subject_id).tag = (uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,puVar7,&(pmVar3->subject_id).len,
                                                   0xa2);
                                if (iVar2 == 0) {
                                  (pmVar3->subject_id).p = (uchar *)len;
                                  len = len + (pmVar3->subject_id).len;
                                }
                                else {
                                  if (iVar2 != -0x62) goto LAB_2305ed46;
                                }
                              }
                            }
LAB_2305ee1e:
                            if (pmVar3->version == 3) {
                              iVar2 = mbedtls_x509_get_ext((uchar **)&len,puVar7,&pmVar3->v3_ext,3);
                              if (iVar2 == 0) {
LAB_2305ee3e:
                                if (puVar7 <= len) {
                                  if (puVar7 == (uchar *)len) goto LAB_2305ee48;
LAB_2305f11c:
                                  iVar2 = -0x2566;
                                  goto LAB_2305ed46;
                                }
                                sig_oid2.p = (uchar *)0x0;
                                extn_oid.tag = 0;
                                extn_oid.len = 0;
                                len_2 = 0;
                                is_critical = 0;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,puVar7,(size_t *)&p,0x30);
                                if (iVar2 != 0) {
LAB_2305ef1a:
                                  iVar2 = iVar2 + -0x2500;
                                  if (iVar2 != 0) goto LAB_2305ed46;
                                  goto LAB_2305eef8;
                                }
                                puVar11 = p + len;
                                sig_oid2.p = (uchar *)(uint)*(byte *)len;
                                iVar2 = mbedtls_asn1_get_tag
                                                  ((uchar **)&len,puVar7,(size_t *)&extn_oid,6);
                                if (iVar2 != 0) goto LAB_2305ef1a;
                                extn_oid.len = len;
                                len = len + extn_oid.tag;
                                if ((int)(puVar7 + -len) < 1) {
LAB_2305f1e4:
                                  iVar2 = -0x2560;
                                  goto LAB_2305ed46;
                                }
                                iVar2 = mbedtls_asn1_get_bool((uchar **)&len,puVar11,(int *)&len_2);
                                if (((iVar2 != 0) && (iVar2 != -0x62)) ||
                                   (iVar2 = mbedtls_asn1_get_tag
                                                      ((uchar **)&len,puVar11,(size_t *)&p,4),
                                   iVar2 != 0)) goto LAB_2305ef1a;
                                end = p + len;
                                if (puVar11 != end) goto LAB_2305f11c;
                                iVar2 = mbedtls_oid_get_x509_ext_type
                                                  ((mbedtls_asn1_buf *)&sig_oid2.p,&is_critical);
                                if (iVar2 != 0) {
                                  len = (size_t)puVar11;
                                  if (len_2 != 0) goto LAB_2305ef90;
                                  goto LAB_2305ee3e;
                                }
                                if ((pmVar3->ext_types & is_critical) != 0) {
LAB_2305f1ec:
                                  iVar2 = -0x2500;
                                  goto LAB_2305ed46;
                                }
                                pmVar3->ext_types = pmVar3->ext_types | is_critical;
                                if (is_critical == 0x100) {
                                  pmVar3->ca_istrue = 0;
                                  pmVar3->max_pathlen = 0;
                                  iVar2 = mbedtls_asn1_get_tag
                                                    ((uchar **)&len,puVar11,(size_t *)&extn_oid.p,
                                                     0x30);
                                  if (iVar2 == 0) {
                                    if (end == (uchar *)len) goto LAB_2305ee3e;
                                    iVar2 = mbedtls_asn1_get_bool
                                                      ((uchar **)&len,end,&pmVar3->ca_istrue);
                                    if (iVar2 != 0) {
                                      if ((iVar2 != -0x62) ||
                                         (iVar2 = mbedtls_asn1_get_int
                                                            ((uchar **)&len,end,&pmVar3->ca_istrue),
                                         iVar2 != 0)) goto LAB_2305f01c;
                                      if (pmVar3->ca_istrue != 0) {
                                        pmVar3->ca_istrue = 1;
                                      }
                                    }
                                    if (end == (uchar *)len) goto LAB_2305ee3e;
                                    iVar2 = mbedtls_asn1_get_int
                                                      ((uchar **)&len,end,&pmVar3->max_pathlen);
                                    if (iVar2 == 0) {
                                      if (end != (uchar *)len) goto LAB_2305f11c;
                                      pmVar3->max_pathlen = pmVar3->max_pathlen + 1;
                                      goto LAB_2305ee3e;
                                    }
                                  }
                                }
                                else {
                                  if (is_critical < 0x101) {
                                    if (is_critical == 4) {
                                      extn_oid.p = (uchar *)0x0;
                                      iVar2 = mbedtls_asn1_get_bitstring
                                                        ((uchar **)&len,puVar11,
                                                         (mbedtls_asn1_bitstring *)&extn_oid.p);
                                      if (iVar2 == 0) {
                                        if (extn_oid.p == (uchar *)0x0) goto LAB_2305f09a;
                                        pmVar3->key_usage = 0;
                                        pbVar8 = (byte *)0x0;
                                        do {
                                          pbVar9 = pbVar8 + 1;
                                          pmVar3->key_usage =
                                               pmVar3->key_usage |
                                               (uint)*pbVar8 << (((uint)pbVar8 & 3) << 3);
                                          if (extn_oid.p == pbVar9) break;
                                          pbVar8 = pbVar9;
                                        } while (pbVar9 != &DAT_00000004);
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                    else {
                                      if (is_critical != 0x20) {
LAB_2305efc6:
                                        iVar2 = -0x2080;
                                        goto LAB_2305ed46;
                                      }
                                      iVar2 = mbedtls_asn1_get_tag
                                                        ((uchar **)&len,puVar11,(size_t *)&ext_type,
                                                         0x30);
                                      if (iVar2 == 0) {
                                        if (end != (uchar *)(len + ext_type)) goto LAB_2305f11c;
                                        pmVar12 = &pmVar3->subject_alt_names;
                                        while (len < end) {
                                          if ((int)(end + -len) < 1) goto LAB_2305f1e4;
                                          uVar1 = *(uchar *)len;
                                          len = len + 1;
                                          iVar2 = mbedtls_asn1_get_len
                                                            ((uchar **)&len,end,
                                                             (size_t *)&extn_oid.p);
                                          if (iVar2 != 0) goto LAB_2305f01c;
                                          if (-1 < (char)uVar1) goto LAB_2305ef90;
                                          if (uVar1 == -0x7e) {
                                            pmVar5 = pmVar12;
                                            if ((pmVar12->buf).p != (uchar *)0x0) {
                                              if (pmVar12->next != (mbedtls_asn1_sequence *)0x0)
                                              goto LAB_2305f1ec;
                                              pmVar5 = (mbedtls_x509_sequence *)mycalloc(1,0x10);
                                              pmVar12->next = (mbedtls_asn1_sequence *)pmVar5;
                                              if (pmVar5 == (mbedtls_x509_sequence *)0x0) {
                                                iVar2 = -0x256a;
                                                goto LAB_2305ed46;
                                              }
                                            }
                                            (pmVar5->buf).tag = 0x82;
                                            (pmVar5->buf).p = (uchar *)len;
                                            (pmVar5->buf).len = (size_t)extn_oid.p;
                                            pmVar12 = pmVar5;
                                          }
                                          len = len + (int)extn_oid.p;
                                        }
                                        pmVar12->next = (mbedtls_asn1_sequence *)0x0;
                                        if (end == (uchar *)len) goto LAB_2305ee3e;
                                        goto LAB_2305f11c;
                                      }
                                    }
                                  }
                                  else {
                                    if (is_critical == 0x800) {
                                      iVar2 = mbedtls_asn1_get_sequence_of
                                                        ((uchar **)&len,puVar11,
                                                         (mbedtls_asn1_sequence *)
                                                         &pmVar3->ext_key_usage,6);
                                      if (iVar2 == 0) {
                                        if ((pmVar3->ext_key_usage).buf.p == (uchar *)0x0) {
LAB_2305f09a:
                                          iVar2 = -0x2564;
                                          goto LAB_2305ed46;
                                        }
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                    else {
                                      if (is_critical != 0x10000) goto LAB_2305efc6;
                                      extn_oid.p = (uchar *)0x0;
                                      iVar2 = mbedtls_asn1_get_bitstring
                                                        ((uchar **)&len,puVar11,
                                                         (mbedtls_asn1_bitstring *)&extn_oid.p);
                                      if (iVar2 == 0) {
                                        if (extn_oid.p != (uchar *)0x1) goto LAB_2305f09a;
                                        pmVar3->ns_cert_type = __EM_SIZE;
                                        goto LAB_2305ee3e;
                                      }
                                    }
                                  }
                                }
LAB_2305f01c:
                                iVar2 = iVar2 + -0x2500;
                                if (iVar2 != 0) goto LAB_2305ed46;
                                goto LAB_2305ee3e;
                              }
                              if (iVar2 != -0x62) goto LAB_2305ed46;
                            }
LAB_2305eef8:
                            if (puVar7 != (uchar *)len) {
LAB_2305ec3c:
                              mbedtls_x509_crt_free(pmVar3);
                              iVar2 = -0x21e6;
                              goto LAB_2305ec24;
                            }
LAB_2305ee48:
                            iVar2 = mbedtls_x509_get_alg
                                              ((uchar **)&len,end_00,
                                               (mbedtls_x509_buf *)&sig_params2.p,
                                               (mbedtls_x509_buf *)&sig_params1.p);
                            if (iVar2 == 0) {
                              __n = (pmVar3->sig_oid).len;
                              if (((__n != sig_oid2.tag) ||
                                  (iVar2 = memcmp((pmVar3->sig_oid).p,(void *)sig_oid2.len,__n),
                                  iVar2 != 0)) ||
                                 ((sig_params1.tag != sig_params2.tag ||
                                  ((sig_params1.tag != 0 &&
                                   (iVar2 = memcmp((void *)sig_params1.len,(void *)sig_params2.len,
                                                   sig_params1.tag), iVar2 != 0)))))) {
                                mbedtls_x509_crt_free(pmVar3);
                                iVar2 = -0x2680;
                                goto LAB_2305ec24;
                              }
                              iVar2 = mbedtls_x509_get_sig((uchar **)&len,end_00,&pmVar3->sig);
                              if (iVar2 == 0) {
                                if (end_00 == (uchar *)len) goto LAB_2305eca2;
                                goto LAB_2305ec3c;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else {
            if (iVar2 == -0x62) {
              pmVar3->version = 0;
              goto LAB_2305ecea;
            }
          }
LAB_2305ed46:
          mbedtls_x509_crt_free(pmVar3);
        }
        else {
LAB_2305ec92:
          mbedtls_x509_crt_free(pmVar3);
          iVar2 = iVar2 + -0x2180;
          if (iVar2 == 0) goto LAB_2305eca2;
        }
      }
    }
    else {
      mbedtls_x509_crt_free(pmVar3);
      iVar2 = -0x2180;
    }
LAB_2305ec24:
    if (pmVar10 != (mbedtls_x509_crt *)0x0) {
LAB_2305ec28:
      pmVar10->next = (mbedtls_x509_crt *)0x0;
    }
    if (chain == pmVar3) goto LAB_2305eca2;
  }
  vPortFree(pmVar3);
LAB_2305eca2:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
LAB_2305ef90:
  iVar2 = -0x2562;
  goto LAB_2305ed46;
}



int mbedtls_x509_crt_parse(mbedtls_x509_crt *chain,uchar *buf,size_t buflen)

{
  bool bVar1;
  int iVar2;
  char *pcVar3;
  int iVar4;
  int iVar5;
  size_t local_50;
  size_t use_len;
  mbedtls_pem_context pem;
  
  if ((chain == (mbedtls_x509_crt *)0x0) || (buf == (uchar *)0x0)) {
    iVar4 = -0x2800;
  }
  else {
    if (((buflen != 0) && (buf[buflen - 1] == '\0')) &&
       (pcVar3 = strstr((char *)buf,"-----BEGIN CERTIFICATE-----"), pcVar3 != (char *)0x0)) {
      iVar5 = 0;
      iVar2 = 0;
      bVar1 = false;
LAB_2305f2c4:
      do {
        if (buflen < 2) goto LAB_2305f2ca;
        mbedtls_pem_init((mbedtls_pem_context *)&use_len);
        iVar4 = mbedtls_pem_read_buffer
                          ((mbedtls_pem_context *)&use_len,"-----BEGIN CERTIFICATE-----",
                           "-----END CERTIFICATE-----",buf,(uchar *)0x0,0,&local_50);
        if (iVar4 == 0) {
          buflen = buflen - local_50;
          buf = buf + local_50;
          iVar4 = mbedtls_x509_crt_parse_der(chain,(uchar *)use_len,(size_t)pem.buf);
          mbedtls_pem_free((mbedtls_pem_context *)&use_len);
          if (iVar4 == 0) {
            bVar1 = true;
            goto LAB_2305f2c4;
          }
          if (iVar4 == -0x2880) goto LAB_2305f246;
        }
        else {
          if (iVar4 == -0x1480) goto LAB_2305f246;
          if (iVar4 == -0x1080) goto LAB_2305f2ca;
          mbedtls_pem_free((mbedtls_pem_context *)&use_len);
          buflen = buflen - local_50;
          buf = buf + local_50;
        }
        if (iVar2 == 0) {
          iVar2 = iVar4;
        }
        iVar5 = iVar5 + 1;
      } while( true );
    }
    iVar4 = mbedtls_x509_crt_parse_der(chain,buf,buflen);
  }
LAB_2305f246:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
LAB_2305f2ca:
  iVar4 = iVar5;
  if ((!bVar1) && (iVar4 = iVar2, iVar2 == 0)) {
    iVar4 = -0x2780;
  }
  goto LAB_2305f246;
}



int mbedtls_x509_crt_parse_file(mbedtls_x509_crt *chain,char *path)

{
  int iVar1;
  size_t local_18;
  size_t n;
  uchar *buf;
  
  iVar1 = mbedtls_pk_load_file(path,(uchar **)&n,&local_18);
  if (iVar1 == 0) {
    iVar1 = mbedtls_x509_crt_parse(chain,(uchar *)n,local_18);
    mbedtls_zeroize((void *)n,local_18);
    vPortFree((void *)n);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int net_would_block(void)

{
  int in_a0;
  uint uVar1;
  
  uVar1 = lwip_fcntl(in_a0,3,0);
  uVar1 = uVar1 & 1;
  if (uVar1 != 0) {
    uVar1 = (uint)(errno == 0xb);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



void mbedtls_net_init(mbedtls_net_context *ctx)

{
  ctx->fd = -1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_net_connect(mbedtls_net_context *ctx,char *host,char *port,int proto)

{
  addrinfo *paVar1;
  int iVar2;
  addrinfo *paStack68;
  addrinfo *addr_list;
  addrinfo hints;
  
  memset(&addr_list,0,0x20);
  hints.ai_flags = 0;
  hints.ai_family = 1;
  if (proto == 1) {
    hints.ai_family = 2;
  }
  hints.ai_socktype = 0x11;
  if (proto != 1) {
    hints.ai_socktype = 6;
  }
  iVar2 = lwip_getaddrinfo(host,port,(addrinfo *)&addr_list,&paStack68);
  if (iVar2 == 0) {
    iVar2 = -0x52;
    paVar1 = paStack68;
    while (paVar1 != (addrinfo *)0x0) {
      iVar2 = lwip_socket(paVar1->ai_family,paVar1->ai_socktype,paVar1->ai_protocol);
      ctx->fd = iVar2;
      if (iVar2 < 0) {
        iVar2 = -0x42;
      }
      else {
        do {
          iVar2 = lwip_connect(ctx->fd,paVar1->ai_addr,paVar1->ai_addrlen);
          if (iVar2 == 0) goto _out;
        } while (errno == 4);
        iVar2 = -0x44;
        lwip_close(ctx->fd);
      }
      paVar1 = paVar1->ai_next;
    }
_out:
    lwip_freeaddrinfo(paStack68);
  }
  else {
    printf("%s %d: getaddrinfo fail- errno: %d\n","mbedtls_net_connect",0xf6,errno);
    iVar2 = -0x52;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_net_set_block(mbedtls_net_context *ctx)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = lwip_fcntl(ctx->fd,3,0);
  iVar2 = lwip_fcntl(ctx->fd,4,uVar1 & 0xfffffffe);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_net_recv(void *ctx,uchar *buf,size_t len)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  if (*ctx < 0) {
    printf("%s %d: invalid socket fd\n","mbedtls_net_recv",0x141);
    iVar1 = -0x45;
  }
  else {
    iVar1 = lwip_read(*ctx,buf,len);
    if (iVar1 < 0) {
      iVar1 = net_would_block();
      if (iVar1 == 0) {
        if ((errno == 0x20) || (errno == 0x68)) {
          printf("%s %d: net reset - errno: %d\n","mbedtls_net_recv",0x14d);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x50;
        }
        if (errno != 4) {
          printf("%s %d: net recv failed - errno: %d\n","mbedtls_net_recv",0x155);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x4c;
        }
      }
      iVar1 = -0x6900;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_net_send(void *ctx,uchar *buf,size_t len)

{
  ssize_t sVar1;
  int iVar2;
  
                    // WARNING: Load size is inaccurate
  if (*ctx < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x45;
  }
  sVar1 = lwip_write(*ctx,buf,len);
  if (sVar1 < 0) {
    iVar2 = net_would_block();
    if (iVar2 == 0) {
      if ((errno == 0x20) || (errno == 0x68)) {
        printf("%s %d: net reset - errno: %d\n","mbedtls_net_send",0x16d);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x50;
      }
      if (errno != 4) {
        printf("%s %d: net send failed - errno: %d\n","mbedtls_net_send",0x175);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x4e;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x6880;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1;
}



// WARNING: Variable defined which should be unmapped: tv

int mbedtls_net_recv_timeout(void *ctx,uchar *buf,size_t len,uint32_t timeout)

{
  int iVar1;
  timeval *timeout_00;
  uint uVar2;
  undefined local_28 [4];
  _types_fd_set read_fds;
  timeval tv;
  
                    // WARNING: Load size is inaccurate
  uVar2 = *ctx;
  if (-1 < (int)uVar2) {
    iVar1 = 0;
    do {
      local_28[iVar1] = 0;
      iVar1 = iVar1 + 1;
    } while (iVar1 != 8);
    iVar1 = (uVar2 >> 5) * 4;
    *(uint *)(local_28 + iVar1) = 1 << (uVar2 & 0x1f) | *(uint *)(local_28 + iVar1);
    read_fds.fds_bits[1] = timeout / 1000;
    timeout_00 = (timeval *)(read_fds.fds_bits + 1);
    if (timeout == 0) {
      timeout_00 = (timeval *)0x0;
    }
    iVar1 = lwip_select(uVar2 + 1,(_types_fd_set *)local_28,(_types_fd_set *)0x0,
                        (_types_fd_set *)0x0,timeout_00);
    if (iVar1 == 0) {
      iVar1 = -0x6800;
    }
    else {
      if (iVar1 < 0) {
        iVar1 = -0x4c;
        if (errno == 4) {
          iVar1 = -0x6900;
        }
      }
      else {
        iVar1 = mbedtls_net_recv(ctx,buf,len);
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x45;
}



void mbedtls_net_free(mbedtls_net_context *ctx)

{
  if (ctx->fd != -1) {
    lwip_shutdown(ctx->fd,2);
    lwip_close(ctx->fd);
    ctx->fd = -1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * mycalloc(size_t numitems,size_t size)

{
  void *__s;
  
  __s = pvPortMalloc(numitems * size);
  memset(__s,0,numitems * size);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



void aes_gen_tables(void)

{
  int *piVar1;
  uint uVar2;
  uchar *puVar3;
  uint *puVar4;
  uchar *puVar5;
  int iVar6;
  uint32_t *puVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  uint local_820;
  int pow [256];
  int log [256];
  
  puVar4 = &local_820;
  uVar8 = 1;
  iVar6 = 0;
  do {
    pow[uVar8 + 0xff] = iVar6;
    *puVar4 = uVar8;
    uVar2 = uVar8 & 0x80;
    if (uVar2 != 0) {
      uVar2 = 0x1b;
    }
    iVar6 = iVar6 + 1;
    uVar8 = (uVar8 ^ uVar8 << 1 ^ uVar2) & 0xff;
    puVar4 = puVar4 + 1;
  } while (iVar6 != 0x100);
  puVar7 = RCON;
  uVar8 = 1;
  do {
    *puVar7 = uVar8;
    uVar2 = uVar8 & 0x80;
    if (uVar2 != 0) {
      uVar2 = 0x1b;
    }
    puVar7 = puVar7 + 1;
    uVar8 = (uVar2 ^ uVar8 << 1) & 0xff;
  } while (puVar7 != (uint32_t *)RSb);
  FSb[0] = 'c';
  RSb[99] = '\0';
  piVar1 = pow + 0xff;
  iVar6 = 1;
  puVar3 = FSb;
  puVar5 = RSb;
  do {
    uVar12 = pow[0xfe - piVar1[1]];
    piVar1 = piVar1 + 1;
    uVar8 = uVar12 << 1 | (int)uVar12 >> 7;
    uVar11 = uVar8 & 0xff;
    uVar9 = (int)uVar11 >> 7;
    uVar8 = (uVar8 & 0x7f) << 1;
    uVar10 = (int)(uVar8 | uVar9) >> 7;
    uVar2 = (uVar8 & 0x7f | uVar9) << 1 | uVar10;
    uVar8 = ((int)uVar2 >> 7 | ((uVar8 & 0x3f | uVar9) << 1 | uVar10) << 1) ^ uVar12 ^ uVar11 ^
            (uVar8 | uVar9) ^ uVar2 ^ 99;
    FSb[iVar6] = (uchar)uVar8;
    RSb[uVar8] = (uchar)iVar6;
    iVar6 = iVar6 + 1;
  } while (iVar6 != 0x100);
  iVar6 = 0;
  do {
    uVar8 = (uint)*puVar3;
    uVar10 = (uVar8 << 1 ^ (int)(char)*puVar3 >> 0x1f & 0x1bU) & 0xff;
    uVar2 = uVar8 << 8 ^ uVar8 << 0x10 ^ uVar10;
    uVar9 = uVar2 ^ (uVar8 ^ uVar10) << 0x18;
    *(uint *)((int)FT0 + iVar6) = uVar9;
    *(uint *)((int)FT1 + iVar6) = uVar2 << 8 | uVar8 ^ uVar10;
    *(uint *)((int)FT2 + iVar6) = uVar2 << 0x10 | uVar9 >> 0x10;
    *(uint *)((int)FT3 + iVar6) = uVar10 << 0x18 | uVar9 >> 8;
    uVar8 = (uint)*puVar5;
    if (uVar8 == 0) {
      uVar2 = 0;
      uVar9 = 0;
    }
    else {
      uVar2 = pow[(log[13] + pow[uVar8 + 0xff]) % 0xff + -1];
      uVar9 = pow[(pow[uVar8 + 0xff] + log[8]) % 0xff + -1] << 8;
    }
    uVar10 = 0;
    if (uVar8 != 0) {
      uVar10 = pow[(pow[uVar8 + 0xff] + log[12]) % 0xff + -1] << 0x10;
    }
    uVar10 = uVar9 ^ uVar2 ^ uVar10;
    uVar11 = 0;
    if (uVar8 != 0) {
      uVar11 = pow[(pow[uVar8 + 0xff] + log[10]) % 0xff + -1] << 0x18;
    }
    uVar11 = uVar10 ^ uVar11;
    *(uint *)((int)RT0 + iVar6) = uVar11;
    *(uint *)((int)RT1 + iVar6) = uVar10 << 8 | uVar11 >> 0x18;
    *(uint *)((int)RT2 + iVar6) = (uVar9 ^ uVar2) << 0x10 | uVar11 >> 0x10;
    *(uint *)((int)RT3 + iVar6) = uVar2 << 0x18 | uVar11 >> 8;
    iVar6 = iVar6 + 4;
    puVar3 = puVar3 + 1;
    puVar5 = puVar5 + 1;
  } while (iVar6 != 0x400);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_aes_init(mbedtls_aes_context *ctx)

{
  memset(ctx,0,0x118);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_aes_free(mbedtls_aes_context *ctx)

{
  mbedtls_aes_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_aes_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)&ctx->nr = 0;
      ctx = (mbedtls_aes_context *)((int)&ctx->nr + 1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  int iVar1;
  byte *pbVar2;
  uint32_t *puVar3;
  uint uVar4;
  int iVar5;
  uint32_t *puVar6;
  uint32_t *puVar7;
  uint uVar8;
  
  if (aes_init_done == 0) {
    aes_gen_tables();
    aes_init_done = 1;
  }
  if (keybits == 0xc0) {
    iVar1 = 0xc;
  }
  else {
    if (keybits == 0x100) {
      iVar1 = 0xe;
    }
    else {
      iVar1 = -0x20;
      if (keybits != 0x80) goto LAB_2305fa9e;
      iVar1 = 10;
    }
  }
  ctx->nr = iVar1;
  puVar6 = ctx->buf;
  ctx->rk = puVar6;
  pbVar2 = key;
  puVar3 = puVar6;
  while (key + (keybits >> 5) * 4 != pbVar2) {
    *puVar3 = (uint)pbVar2[1] << 8 | (uint)pbVar2[2] << 0x10 | (uint)*pbVar2 |
              (uint)pbVar2[3] << 0x18;
    pbVar2 = pbVar2 + 4;
    puVar3 = puVar3 + 1;
  }
  iVar5 = ctx->nr;
  if (iVar5 == 0xc) {
    puVar3 = RCON;
    do {
      uVar4 = puVar6[5];
      uVar8 = *puVar3;
      puVar7 = puVar6 + 6;
      puVar3 = puVar3 + 1;
      uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
              (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
      *puVar7 = uVar8;
      uVar8 = uVar8 ^ puVar6[1];
      puVar6[7] = uVar8;
      uVar8 = uVar8 ^ puVar6[2];
      puVar6[8] = uVar8;
      uVar8 = uVar8 ^ puVar6[3];
      puVar6[9] = uVar8;
      uVar8 = uVar8 ^ puVar6[4];
      puVar6[10] = uVar8;
      puVar6[0xb] = uVar8 ^ uVar4;
      puVar6 = puVar7;
    } while (puVar7 != ctx->buf + 0x30);
  }
  else {
    if (iVar5 == 0xe) {
      puVar3 = RCON;
      do {
        uVar4 = puVar6[7];
        uVar8 = *puVar3;
        puVar7 = puVar6 + 8;
        puVar3 = puVar3 + 1;
        uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
                (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
        *puVar7 = uVar8;
        uVar8 = uVar8 ^ puVar6[1];
        puVar6[9] = uVar8;
        uVar8 = uVar8 ^ puVar6[2];
        puVar6[10] = uVar8;
        uVar8 = uVar8 ^ puVar6[3];
        puVar6[0xb] = uVar8;
        uVar8 = (uint)FSb[uVar8 >> 0x10 & 0xff] << 0x10 ^
                (uint)FSb[uVar8 & 0xff] ^ puVar6[4] ^ (uint)FSb[uVar8 >> 0x18] << 0x18 ^
                (uint)FSb[uVar8 >> 8 & 0xff] << 8;
        puVar6[0xc] = uVar8;
        uVar8 = uVar8 ^ puVar6[5];
        puVar6[0xd] = uVar8;
        uVar8 = uVar8 ^ puVar6[6];
        puVar6[0xe] = uVar8;
        puVar6[0xf] = uVar8 ^ uVar4;
        puVar6 = puVar7;
      } while (puVar7 != ctx->buf + 0x38);
    }
    else {
      iVar1 = 0;
      if (iVar5 != 10) goto LAB_2305fa9e;
      puVar3 = RCON;
      do {
        uVar4 = puVar6[3];
        uVar8 = *puVar3;
        puVar7 = puVar6 + 4;
        puVar3 = puVar3 + 1;
        uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
                (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
        *puVar7 = uVar8;
        uVar8 = uVar8 ^ puVar6[1];
        puVar6[5] = uVar8;
        uVar8 = uVar8 ^ puVar6[2];
        puVar6[6] = uVar8;
        puVar6[7] = uVar8 ^ uVar4;
        puVar6 = puVar7;
      } while (puVar7 != ctx->buf + 0x28);
    }
  }
  iVar1 = 0;
LAB_2305fa9e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  uint *puVar1;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint32_t *puVar5;
  uint32_t *puVar6;
  int iVar7;
  undefined auStack296 [4];
  mbedtls_aes_context cty;
  
  mbedtls_aes_init((mbedtls_aes_context *)auStack296);
  ctx->rk = ctx->buf;
  iVar2 = mbedtls_aes_setkey_enc((mbedtls_aes_context *)auStack296,key,keybits);
  if (iVar2 == 0) {
    ctx->nr = auStack296;
    puVar5 = (uint32_t *)(cty.nr + auStack296 * 0x10);
    ctx->buf[0] = *puVar5;
    ctx->buf[1] = puVar5[1];
    puVar3 = ctx->buf;
    ctx->buf[2] = puVar5[2];
    ctx->buf[3] = puVar5[3];
    while( true ) {
      puVar3 = puVar3 + 4;
      puVar6 = puVar5 + -4;
      auStack296 = auStack296 + -1;
      if (auStack296 < 1) break;
      iVar7 = 0;
      do {
        uVar4 = *(uint *)((int)puVar6 + iVar7);
        puVar1 = (uint *)((int)puVar3 + iVar7);
        iVar7 = iVar7 + 4;
        *puVar1 = RT2[FSb[uVar4 >> 0x10 & 0xff]] ^
                  RT0[FSb[uVar4 & 0xff]] ^ RT3[FSb[uVar4 >> 0x18]] ^ RT1[FSb[uVar4 >> 8 & 0xff]];
        puVar5 = puVar6;
      } while (iVar7 != 0x10);
    }
    *puVar3 = *puVar6;
    puVar3[1] = puVar5[-3];
    puVar3[2] = puVar5[-2];
    puVar3[3] = puVar5[-1];
  }
  mbedtls_aes_free((mbedtls_aes_context *)auStack296);
  return iVar2;
}



void mbedtls_aes_encrypt(mbedtls_aes_context *ctx,uchar *input,uchar *output)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint32_t *puVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  int iVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  uint uVar32;
  uint uVar33;
  uint32_t *puVar34;
  
  puVar21 = ctx->rk;
  puVar34 = puVar21 + 4;
  uVar23 = *(uint *)input ^ *puVar21;
  uVar30 = *(uint *)(input + 4) ^ puVar21[1];
  uVar28 = *(uint *)(input + 8) ^ puVar21[2];
  iVar25 = ctx->nr >> 1;
  uVar26 = *(uint *)(input + 0xc) ^ puVar21[3];
  while( true ) {
    iVar25 = iVar25 + -1;
    uVar17 = FT0[uVar23 & 0xff] ^ FT3[uVar26 >> 0x18] ^ *puVar34 ^
             *(uint *)((int)FT1 + (uVar30 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar28 >> 0xe & 0x3fc));
    uVar31 = puVar34[4];
    uVar19 = FT0[uVar30 & 0xff] ^ FT3[uVar23 >> 0x18] ^ puVar34[1] ^
             *(uint *)((int)FT1 + (uVar28 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar26 >> 0xe & 0x3fc));
    uVar16 = FT0[uVar28 & 0xff] ^ FT3[uVar30 >> 0x18] ^ puVar34[2] ^
             *(uint *)((int)FT1 + (uVar26 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar23 >> 0xe & 0x3fc));
    uVar22 = FT0[uVar26 & 0xff] ^ FT3[uVar28 >> 0x18] ^ puVar34[3] ^
             *(uint *)((int)FT1 + (uVar23 >> 6 & 0x3fc)) ^
             *(uint *)((int)FT2 + (uVar30 >> 0xe & 0x3fc));
    uVar33 = uVar19 >> 8 & 0xff;
    uVar23 = uVar16 >> 0x10 & 0xff;
    uVar30 = puVar34[5];
    uVar32 = uVar16 >> 8 & 0xff;
    uVar26 = uVar22 >> 0x10 & 0xff;
    uVar29 = puVar34[6];
    uVar24 = uVar22 >> 8 & 0xff;
    uVar28 = uVar17 >> 0x10 & 0xff;
    uVar27 = puVar34[7];
    uVar18 = uVar17 >> 8 & 0xff;
    uVar20 = uVar19 >> 0x10 & 0xff;
    if (iVar25 < 1) break;
    uVar23 = FT0[uVar17 & 0xff] ^ FT3[uVar22 >> 0x18] ^ uVar31 ^ FT1[uVar33] ^ FT2[uVar23];
    uVar30 = FT0[uVar19 & 0xff] ^ FT3[uVar17 >> 0x18] ^ uVar30 ^ FT1[uVar32] ^ FT2[uVar26];
    uVar28 = FT0[uVar16 & 0xff] ^ FT3[uVar19 >> 0x18] ^ uVar29 ^ FT1[uVar24] ^ FT2[uVar28];
    puVar34 = puVar34 + 8;
    uVar26 = FT0[uVar22 & 0xff] ^ FT3[uVar16 >> 0x18] ^ uVar27 ^ FT1[uVar18] ^ FT2[uVar20];
  }
  bVar1 = FSb[uVar33];
  bVar2 = FSb[uVar23];
  bVar3 = FSb[uVar22 >> 0x18];
  bVar4 = FSb[uVar32];
  bVar5 = FSb[uVar19 & 0xff];
  bVar6 = FSb[uVar26];
  bVar7 = FSb[uVar17 >> 0x18];
  bVar8 = FSb[uVar24];
  bVar9 = FSb[uVar16 & 0xff];
  bVar10 = FSb[uVar28];
  bVar11 = FSb[uVar19 >> 0x18];
  bVar12 = FSb[uVar22 & 0xff];
  bVar13 = FSb[uVar18];
  bVar14 = FSb[uVar20];
  bVar15 = FSb[uVar16 >> 0x18];
  *output = FSb[uVar17 & 0xff] ^ (byte)uVar31;
  output[4] = bVar5 ^ (byte)uVar30;
  output[1] = bVar1 ^ (byte)(uVar31 >> 8);
  output[2] = (byte)(uVar31 >> 0x10) ^ bVar2;
  output[5] = bVar4 ^ (byte)(uVar30 >> 8);
  output[6] = (byte)(uVar30 >> 0x10) ^ bVar6;
  output[9] = bVar8 ^ (byte)(uVar29 >> 8);
  output[10] = (byte)(uVar29 >> 0x10) ^ bVar10;
  output[8] = bVar9 ^ (byte)uVar29;
  output[0xc] = bVar12 ^ (byte)uVar27;
  output[0xd] = (byte)(uVar27 >> 8) ^ bVar13;
  output[3] = (byte)(uVar31 >> 0x18) ^ bVar3;
  output[7] = (byte)(uVar30 >> 0x18) ^ bVar7;
  output[0xb] = (byte)(uVar29 >> 0x18) ^ bVar11;
  output[0xf] = (byte)(uVar27 >> 0x18) ^ bVar15;
  output[0xe] = (byte)(uVar27 >> 0x10) ^ bVar14;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_aes_decrypt(mbedtls_aes_context *ctx,uchar *input,uchar *output)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  byte bVar7;
  byte bVar8;
  byte bVar9;
  byte bVar10;
  byte bVar11;
  byte bVar12;
  byte bVar13;
  byte bVar14;
  byte bVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint32_t *puVar21;
  uint uVar22;
  uint uVar23;
  int iVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  uint uVar29;
  uint uVar30;
  uint uVar31;
  uint uVar32;
  uint uVar33;
  uint32_t *puVar34;
  
  puVar21 = ctx->rk;
  uVar29 = *(uint *)(input + 4) ^ puVar21[1];
  puVar34 = puVar21 + 4;
  uVar27 = *(uint *)(input + 8) ^ puVar21[2];
  iVar24 = ctx->nr >> 1;
  uVar23 = *(uint *)input ^ *puVar21;
  uVar25 = *(uint *)(input + 0xc) ^ puVar21[3];
  while( true ) {
    iVar24 = iVar24 + -1;
    uVar17 = RT0[uVar23 & 0xff] ^ RT3[uVar29 >> 0x18] ^ *puVar34 ^
             *(uint *)((int)RT1 + (uVar25 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar27 >> 0xe & 0x3fc));
    uVar31 = puVar34[4];
    uVar16 = uVar17 >> 8 & 0xff;
    uVar22 = RT0[uVar25 & 0xff] ^ RT3[uVar23 >> 0x18] ^ puVar34[3] ^
             *(uint *)((int)RT1 + (uVar27 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar29 >> 0xe & 0x3fc));
    uVar18 = RT0[uVar27 & 0xff] ^ RT3[uVar25 >> 0x18] ^ puVar34[2] ^
             *(uint *)((int)RT1 + (uVar29 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar23 >> 0xe & 0x3fc));
    uVar23 = RT0[uVar29 & 0xff] ^ RT3[uVar27 >> 0x18] ^ puVar34[1] ^
             *(uint *)((int)RT1 + (uVar23 >> 6 & 0x3fc)) ^
             *(uint *)((int)RT2 + (uVar25 >> 0xe & 0x3fc));
    uVar33 = uVar22 >> 8 & 0xff;
    uVar32 = uVar18 >> 0x10 & 0xff;
    uVar30 = puVar34[5];
    uVar29 = uVar22 >> 0x10 & 0xff;
    uVar28 = puVar34[6];
    uVar27 = uVar23 >> 8 & 0xff;
    uVar25 = uVar17 >> 0x10 & 0xff;
    uVar26 = puVar34[7];
    uVar19 = uVar18 >> 8 & 0xff;
    uVar20 = uVar23 >> 0x10 & 0xff;
    if (iVar24 < 1) break;
    uVar29 = RT0[uVar23 & 0xff] ^ RT3[uVar18 >> 0x18] ^ uVar30 ^ RT1[uVar16] ^ RT2[uVar29];
    uVar23 = RT0[uVar17 & 0xff] ^ RT3[uVar23 >> 0x18] ^ uVar31 ^ RT1[uVar33] ^ RT2[uVar32];
    uVar27 = RT0[uVar18 & 0xff] ^ RT3[uVar22 >> 0x18] ^ uVar28 ^ RT1[uVar27] ^ RT2[uVar25];
    puVar34 = puVar34 + 8;
    uVar25 = RT0[uVar22 & 0xff] ^ RT3[uVar17 >> 0x18] ^ uVar26 ^ RT1[uVar19] ^ RT2[uVar20];
  }
  bVar1 = RSb[uVar17 & 0xff];
  bVar2 = RSb[uVar32];
  bVar3 = RSb[uVar23 >> 0x18];
  bVar4 = RSb[uVar22 & 0xff];
  bVar5 = RSb[uVar16];
  bVar6 = RSb[uVar23 & 0xff];
  bVar7 = RSb[uVar29];
  bVar8 = RSb[uVar19];
  bVar9 = RSb[uVar18 >> 0x18];
  bVar10 = RSb[uVar20];
  bVar11 = RSb[uVar27];
  bVar12 = RSb[uVar18 & 0xff];
  bVar13 = RSb[uVar25];
  bVar14 = RSb[uVar17 >> 0x18];
  bVar15 = RSb[uVar22 >> 0x18];
  output[1] = RSb[uVar33] ^ (byte)(uVar31 >> 8);
  output[2] = (byte)(uVar31 >> 0x10) ^ bVar2;
  output[5] = bVar5 ^ (byte)(uVar30 >> 8);
  output[6] = (byte)(uVar30 >> 0x10) ^ bVar7;
  output[9] = bVar11 ^ (byte)(uVar28 >> 8);
  output[10] = (byte)(uVar28 >> 0x10) ^ bVar13;
  *output = bVar1 ^ (byte)uVar31;
  output[4] = bVar6 ^ (byte)uVar30;
  output[8] = bVar12 ^ (byte)uVar28;
  output[0xc] = bVar4 ^ (byte)uVar26;
  output[0xd] = (byte)(uVar26 >> 8) ^ bVar8;
  output[3] = (byte)(uVar31 >> 0x18) ^ bVar3;
  output[7] = (byte)(uVar30 >> 0x18) ^ bVar9;
  output[0xb] = (byte)(uVar28 >> 0x18) ^ bVar15;
  output[0xf] = (byte)(uVar26 >> 0x18) ^ bVar14;
  output[0xe] = (byte)(uVar26 >> 0x10) ^ bVar10;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,int mode,uchar *input,uchar *output)

{
  if (mode == 1) {
    mbedtls_aes_encrypt(ctx,input,output);
  }
  else {
    mbedtls_aes_decrypt(ctx,input,output);
  }
  return 0;
}



int mbedtls_aes_crypt_cbc
              (mbedtls_aes_context *ctx,int mode,size_t length,uchar *iv,uchar *input,uchar *output)

{
  uint uVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *puVar6;
  undefined auStack64 [4];
  uchar temp [16];
  
  uVar1 = length & 0xf;
  if (uVar1 == 0) {
    if (mode == 0) {
      while( true ) {
        puVar6 = output + -uVar1;
        if (uVar1 + length == 0) break;
        memcpy(auStack64,input + -uVar1,0x10);
        mbedtls_aes_decrypt(ctx,input + -uVar1,puVar6);
        iVar2 = 0;
        do {
          pbVar3 = puVar6 + iVar2;
          pbVar4 = iv + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar3 = *pbVar4 ^ *pbVar3;
        } while (iVar2 != 0x10);
        memcpy(iv,auStack64,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    else {
      while( true ) {
        puVar6 = output + -uVar1;
        if (length + uVar1 == 0) break;
        iVar2 = 0;
        do {
          pbVar5 = input + -uVar1 + iVar2;
          pbVar3 = iv + iVar2;
          pbVar4 = puVar6 + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar4 = *pbVar5 ^ *pbVar3;
        } while (iVar2 != 0x10);
        mbedtls_aes_crypt_ecb(ctx,mode,puVar6,puVar6);
        memcpy(iv,puVar6,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -0x22;
  }
  return iVar2;
}



int mbedtls_aes_crypt_cfb128
              (mbedtls_aes_context *ctx,int mode,size_t length,size_t *iv_off,uchar *iv,uchar *input
              ,uchar *output)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  
  uVar1 = *iv_off;
  pbVar2 = output;
  if (mode == 0) {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = *input;
      *pbVar2 = iv[uVar1] ^ bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  else {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = iv[uVar1] ^ *input;
      *pbVar2 = bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  *iv_off = uVar1;
  return 0;
}



int mbedtls_aes_crypt_ctr
              (mbedtls_aes_context *ctx,size_t length,size_t *nc_off,uchar *nonce_counter,
              uchar *stream_block,uchar *input,uchar *output)

{
  bool bVar1;
  uchar uVar2;
  uint uVar3;
  uchar *puVar4;
  byte *pbVar5;
  
  uVar3 = *nc_off;
  pbVar5 = output;
  do {
    if (pbVar5 == output + length) {
      *nc_off = uVar3;
      return 0;
    }
    if (uVar3 == 0) {
      mbedtls_aes_encrypt(ctx,nonce_counter,stream_block);
      puVar4 = nonce_counter + 0xf;
      do {
        uVar2 = *puVar4;
        *puVar4 = uVar2 + '\x01';
        if ((uchar)(uVar2 + '\x01') != '\0') break;
        bVar1 = nonce_counter != puVar4;
        puVar4 = puVar4 + -1;
      } while (bVar1);
    }
    *pbVar5 = stream_block[uVar3] ^ *input;
    uVar3 = uVar3 + 1 & 0xf;
    input = input + 1;
    pbVar5 = pbVar5 + 1;
  } while( true );
}



int mbedtls_asn1_get_len(uchar **p,uchar *end,size_t *len)

{
  uchar *puVar1;
  byte bVar2;
  byte *pbVar3;
  
  pbVar3 = *p;
  puVar1 = end + -(int)pbVar3;
  if ((int)puVar1 < 1) goto LAB_2306084e;
  if ((char)*pbVar3 < '\0') {
    bVar2 = *pbVar3 & 0x7f;
    if (bVar2 == 2) {
      if ((int)puVar1 < 3) goto LAB_2306084e;
      *len = (uint)(*(ushort *)(pbVar3 + 1) >> 8) | (*(ushort *)(pbVar3 + 1) & 0xff) << 8;
      puVar1 = *p + 3;
    }
    else {
      if (bVar2 < 3) {
        if (bVar2 != 1) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -100;
        }
        if (puVar1 == (uchar *)0x1) goto LAB_2306084e;
        *len = (uint)pbVar3[1];
        puVar1 = *p + 2;
      }
      else {
        if (bVar2 == 3) {
          if ((int)puVar1 < 4) goto LAB_2306084e;
          *len = (uint)pbVar3[3] | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[2] << 8;
          puVar1 = *p + 4;
        }
        else {
          if (bVar2 != 4) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return -100;
          }
          if ((int)puVar1 < 5) goto LAB_2306084e;
          *len = (uint)pbVar3[3] << 8 |
                 (uint)pbVar3[1] << 0x18 | (uint)pbVar3[2] << 0x10 | (uint)pbVar3[4];
          puVar1 = *p + 5;
        }
      }
    }
    *p = puVar1;
  }
  else {
    *p = pbVar3 + 1;
    *len = (uint)*pbVar3;
  }
  if ((uchar *)*len <= end + -(int)*p) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
LAB_2306084e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x60;
}



int mbedtls_asn1_get_tag(uchar **p,uchar *end,size_t *len,int tag)

{
  int iVar1;
  byte *pbVar2;
  
  pbVar2 = *p;
  if ((int)(end + -(int)pbVar2) < 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x60;
  }
  if ((uint)*pbVar2 == tag) {
    *p = pbVar2 + 1;
    iVar1 = mbedtls_asn1_get_len(p,end,len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x62;
}



int mbedtls_asn1_get_bool(uchar **p,uchar *end,int *val)

{
  int iVar1;
  size_t sStack20;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack20,1);
  if (iVar1 == 0) {
    if (sStack20 == 1) {
      *val = (uint)(**p != '\0');
      *p = *p + 1;
    }
    else {
      iVar1 = -100;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_asn1_get_int(uchar **p,uchar *end,int *val)

{
  int iVar1;
  size_t sStack20;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack20,2);
  if (iVar1 == 0) {
    if ((sStack20 - 1 < 4) && (-1 < (char)**p)) {
      *val = 0;
      while (sStack20 != 0) {
        *val = *val << 8 | (uint)**p;
        *p = *p + 1;
        sStack20 = sStack20 - 1;
      }
    }
    else {
      iVar1 = -100;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_asn1_get_mpi(uchar **p,uchar *end,mbedtls_mpi *X)

{
  int iVar1;
  size_t local_14;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&local_14,2);
  if (iVar1 == 0) {
    iVar1 = mbedtls_mpi_read_binary(X,*p,local_14);
    *p = *p + local_14;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_asn1_get_bitstring(uchar **p,uchar *end,mbedtls_asn1_bitstring *bs)

{
  byte bVar1;
  int iVar2;
  size_t sVar3;
  uchar *puVar4;
  
  iVar2 = mbedtls_asn1_get_tag(p,end,(size_t *)bs,3);
  if (iVar2 == 0) {
    if (bs->len == 0) {
      iVar2 = -0x60;
    }
    else {
      bs->len = bs->len - 1;
      bVar1 = **p;
      bs->unused_bits = bVar1;
      if (bVar1 < 8) {
        puVar4 = *p + 1;
        *p = puVar4;
        sVar3 = bs->len;
        bs->p = puVar4;
        *p = puVar4 + sVar3;
        if (puVar4 + sVar3 != end) {
          iVar2 = -0x66;
        }
      }
      else {
        iVar2 = -100;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_asn1_get_bitstring_null(uchar **p,uchar *end,size_t *len)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,len,3);
  if ((iVar1 == 0) &&
     ((uVar2 = *len, *len = uVar2 - 1, uVar2 < 2 || (puVar3 = *p, *p = puVar3 + 1, *puVar3 != '\0'))
     )) {
    iVar1 = -0x68;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_asn1_get_sequence_of(uchar **p,uchar *end,mbedtls_asn1_sequence *cur,int tag)

{
  int iVar1;
  int iVar2;
  mbedtls_asn1_sequence *pmVar3;
  uchar *puVar4;
  size_t sStack36;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack36,0x30);
  iVar2 = iVar1;
  if (iVar1 == 0) {
    if (end == *p + sStack36) {
      do {
        do {
          if (end <= *p) {
            cur->next = (mbedtls_asn1_sequence *)0x0;
            iVar2 = iVar1;
            if (*p != end) goto LAB_23060ab6;
            goto LAB_23060b00;
          }
          (cur->buf).tag = (uint)**p;
          iVar2 = mbedtls_asn1_get_tag(p,end,&(cur->buf).len,tag);
          if (iVar2 != 0) goto LAB_23060b00;
          puVar4 = *p;
          (cur->buf).p = puVar4;
          puVar4 = puVar4 + (cur->buf).len;
          *p = puVar4;
        } while (end <= puVar4);
        pmVar3 = (mbedtls_asn1_sequence *)mycalloc(1,0x10);
        cur->next = pmVar3;
        cur = pmVar3;
      } while (pmVar3 != (mbedtls_asn1_sequence *)0x0);
      iVar2 = -0x6a;
    }
    else {
LAB_23060ab6:
      iVar2 = -0x66;
    }
  }
LAB_23060b00:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_asn1_get_alg(uchar **p,uchar *end,mbedtls_asn1_buf *alg,mbedtls_asn1_buf *params)

{
  int iVar1;
  int iVar2;
  uchar *puVar3;
  byte *pbVar4;
  mbedtls_asn1_buf *pmVar5;
  byte *end_00;
  size_t sStack36;
  size_t len;
  
  iVar1 = mbedtls_asn1_get_tag(p,end,&sStack36,0x30);
  if (iVar1 == 0) {
    iVar1 = -0x60;
    if (0 < (int)(end + -(int)*p)) {
      alg->tag = (uint)**p;
      end_00 = *p + sStack36;
      iVar2 = mbedtls_asn1_get_tag(p,end_00,&alg->len,6);
      iVar1 = iVar2;
      if (iVar2 == 0) {
        puVar3 = *p;
        alg->p = puVar3;
        pbVar4 = puVar3 + alg->len;
        *p = pbVar4;
        if (pbVar4 == end_00) {
          pmVar5 = params + 1;
          while (params != pmVar5) {
            *(undefined *)&params->tag = 0;
            params = (mbedtls_asn1_buf *)((int)&params->tag + 1);
          }
        }
        else {
          params->tag = (uint)*pbVar4;
          *p = *p + 1;
          iVar1 = mbedtls_asn1_get_len(p,end_00,&params->len);
          if (iVar1 == 0) {
            puVar3 = *p;
            params->p = puVar3;
            pbVar4 = puVar3 + params->len;
            *p = pbVar4;
            iVar1 = iVar2;
            if (pbVar4 != end_00) {
              iVar1 = -0x66;
            }
          }
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void mpi_sub_hlp(size_t n,mbedtls_mpi_uint *s,mbedtls_mpi_uint *d)

{
  mbedtls_mpi_uint *pmVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  mbedtls_mpi_uint *pmVar5;
  uint uVar6;
  size_t sVar7;
  
  uVar4 = 0;
  sVar7 = 0;
  pmVar1 = d;
  while (sVar7 != n) {
    uVar3 = *pmVar1;
    pmVar5 = s + sVar7;
    sVar7 = sVar7 + 1;
    uVar2 = uVar3 - uVar4;
    *pmVar1 = uVar2;
    uVar6 = *pmVar5;
    *pmVar1 = uVar2 - uVar6;
    uVar4 = (uint)(uVar2 < uVar6) + (uint)(uVar3 < uVar4);
    pmVar1 = pmVar1 + 1;
  }
  pmVar1 = d + sVar7;
  while (uVar4 != 0) {
    uVar3 = *pmVar1;
    *pmVar1 = uVar3 - uVar4;
    uVar4 = (uint)(uVar3 < uVar4);
    pmVar1 = pmVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mpi_mul_hlp(size_t i,mbedtls_mpi_uint *s,mbedtls_mpi_uint *d,mbedtls_mpi_uint b)

{
  size_t sVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  mbedtls_mpi_uint *pmVar5;
  uint uVar6;
  uint uVar7;
  mbedtls_mpi_uint mVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  mbedtls_mpi_uint *pmVar12;
  uint uVar13;
  
  uVar9 = 0;
  sVar1 = i;
  pmVar5 = d;
  pmVar12 = s;
  while (uVar11 = *pmVar5, 0xf < sVar1) {
    uVar10 = *pmVar12;
    sVar1 = sVar1 - 0x10;
    uVar6 = b * uVar10 + uVar9;
    uVar7 = uVar6 + uVar11;
    *pmVar5 = uVar7;
    uVar2 = pmVar12[1];
    uVar11 = (uint)(uVar7 < uVar11) +
             (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20) + (uint)(uVar6 < uVar9);
    uVar6 = b * uVar2 + uVar11;
    uVar9 = pmVar5[1];
    uVar7 = uVar6 + uVar9;
    pmVar5[1] = uVar7;
    uVar9 = (uint)(uVar7 < uVar9) +
            (uint)(uVar6 < uVar11) + (int)((ulonglong)b * (ulonglong)uVar2 >> 0x20);
    uVar11 = pmVar12[2];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[2];
    uVar7 = uVar6 + uVar2;
    pmVar5[2] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[3];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[3];
    uVar7 = uVar6 + uVar11;
    pmVar5[3] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[4];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[4];
    uVar7 = uVar6 + uVar2;
    pmVar5[4] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[5];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[5];
    uVar7 = uVar6 + uVar11;
    pmVar5[5] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[6];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[6];
    uVar7 = uVar6 + uVar2;
    pmVar5[6] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[7];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[7];
    uVar7 = uVar6 + uVar11;
    pmVar5[7] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[8];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[8];
    uVar7 = uVar6 + uVar2;
    pmVar5[8] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[9];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[9];
    uVar7 = uVar6 + uVar11;
    pmVar5[9] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[10];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[10];
    uVar7 = uVar6 + uVar2;
    pmVar5[10] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[0xb];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[0xb];
    uVar7 = uVar6 + uVar11;
    pmVar5[0xb] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[0xc];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[0xc];
    uVar7 = uVar6 + uVar2;
    pmVar5[0xc] = uVar7;
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = pmVar12[0xd];
    uVar6 = b * uVar9 + uVar2;
    uVar11 = pmVar5[0xd];
    uVar7 = uVar6 + uVar11;
    pmVar5[0xd] = uVar7;
    uVar9 = (uint)(uVar7 < uVar11) +
            (uint)(uVar6 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar11 = pmVar12[0xe];
    uVar6 = b * uVar11 + uVar9;
    uVar2 = pmVar5[0xe];
    uVar7 = uVar6 + uVar2;
    pmVar5[0xe] = uVar7;
    uVar10 = pmVar12[0xf];
    uVar2 = (uint)(uVar7 < uVar2) +
            (uint)(uVar6 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar11 >> 0x20);
    uVar9 = b * uVar10 + uVar2;
    uVar6 = pmVar5[0xf];
    uVar11 = uVar9 + uVar6;
    pmVar5[0xf] = uVar11;
    uVar9 = (uint)(uVar11 < uVar6) +
            (uint)(uVar9 < uVar2) + (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20);
    pmVar5 = pmVar5 + 0x10;
    pmVar12 = pmVar12 + 0x10;
  }
  puVar4 = s + (i & 0xfffffff0);
  pmVar12 = d + (i & 0xfffffff0);
  uVar2 = i + (i >> 4) * -0x10;
  puVar3 = puVar4;
  pmVar5 = pmVar12;
  if (7 < uVar2) {
    uVar13 = *puVar4;
    uVar2 = uVar2 - 8;
    pmVar5 = pmVar12 + 8;
    puVar3 = puVar4 + 8;
    uVar6 = b * uVar13 + uVar9;
    uVar7 = uVar6 + uVar11;
    *pmVar12 = uVar7;
    uVar10 = puVar4[1];
    uVar13 = (uint)(uVar7 < uVar11) +
             (int)((ulonglong)b * (ulonglong)uVar13 >> 0x20) + (uint)(uVar6 < uVar9);
    uVar9 = b * uVar10 + uVar13;
    uVar7 = pmVar12[1];
    uVar11 = uVar9 + uVar7;
    pmVar12[1] = uVar11;
    uVar6 = puVar4[2];
    uVar7 = (uint)(uVar9 < uVar13) + (int)((ulonglong)b * (ulonglong)uVar10 >> 0x20) +
            (uint)(uVar11 < uVar7);
    uVar9 = b * uVar6 + uVar7;
    uVar10 = pmVar12[2];
    uVar11 = uVar9 + uVar10;
    pmVar12[2] = uVar11;
    uVar7 = (uint)(uVar11 < uVar10) +
            (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20) + (uint)(uVar9 < uVar7);
    uVar9 = puVar4[3];
    uVar10 = b * uVar9 + uVar7;
    uVar11 = pmVar12[3];
    uVar13 = uVar10 + uVar11;
    pmVar12[3] = uVar13;
    uVar6 = puVar4[4];
    uVar9 = (uint)(uVar13 < uVar11) +
            (uint)(uVar10 < uVar7) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar10 = b * uVar6 + uVar9;
    uVar11 = pmVar12[4];
    uVar13 = uVar10 + uVar11;
    pmVar12[4] = uVar13;
    uVar7 = puVar4[5];
    uVar11 = (uint)(uVar13 < uVar11) +
             (uint)(uVar10 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20);
    uVar10 = b * uVar7 + uVar11;
    uVar6 = pmVar12[5];
    uVar13 = uVar10 + uVar6;
    pmVar12[5] = uVar13;
    uVar9 = puVar4[6];
    uVar7 = (uint)(uVar13 < uVar6) +
            (uint)(uVar10 < uVar11) + (int)((ulonglong)b * (ulonglong)uVar7 >> 0x20);
    uVar10 = b * uVar9 + uVar7;
    uVar11 = pmVar12[6];
    uVar13 = uVar10 + uVar11;
    pmVar12[6] = uVar13;
    uVar6 = puVar4[7];
    uVar9 = (uint)(uVar13 < uVar11) +
            (uint)(uVar10 < uVar7) + (int)((ulonglong)b * (ulonglong)uVar9 >> 0x20);
    uVar7 = b * uVar6 + uVar9;
    uVar11 = pmVar12[7];
    uVar10 = uVar7 + uVar11;
    pmVar12[7] = uVar10;
    uVar9 = (uint)(uVar10 < uVar11) +
            (uint)(uVar7 < uVar9) + (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20);
  }
  puVar4 = puVar3;
  pmVar12 = pmVar5;
  while( true ) {
    uVar11 = *pmVar12;
    if (puVar4 == puVar3 + uVar2) break;
    uVar6 = *puVar4;
    uVar7 = b * uVar6 + uVar9;
    uVar10 = uVar7 + uVar11;
    *pmVar12 = uVar10;
    uVar9 = (uint)(uVar10 < uVar11) +
            (int)((ulonglong)b * (ulonglong)uVar6 >> 0x20) + (uint)(uVar7 < uVar9);
    puVar4 = puVar4 + 1;
    pmVar12 = pmVar12 + 1;
  }
  pmVar5 = pmVar5 + uVar2;
  while( true ) {
    mVar8 = *pmVar5;
    *pmVar5 = mVar8 + uVar9;
    if (uVar9 <= mVar8 + uVar9) break;
    uVar9 = 1;
    pmVar5 = pmVar5 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_mpi_init(mbedtls_mpi *X)

{
  if (X != (mbedtls_mpi *)0x0) {
    X->s = 1;
    X->n = 0;
    X->p = (mbedtls_mpi_uint *)0x0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_mpi_free(mbedtls_mpi *X)

{
  size_t sVar1;
  mbedtls_mpi_uint *pmVar2;
  
  if (X != (mbedtls_mpi *)0x0) {
    pmVar2 = X->p;
    if (pmVar2 != (mbedtls_mpi_uint *)0x0) {
      sVar1 = X->n;
      while (sVar1 = sVar1 - 1, sVar1 != 0xffffffff) {
        *pmVar2 = 0;
        pmVar2 = pmVar2 + 1;
      }
      vPortFree(X->p);
    }
    X->s = 1;
    X->n = 0;
    X->p = (mbedtls_mpi_uint *)0x0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_mpi_grow(mbedtls_mpi *X,size_t nblimbs)

{
  mbedtls_mpi_uint *__dest;
  int iVar1;
  mbedtls_mpi_uint *pmVar2;
  size_t sVar3;
  
  if (10000 < nblimbs) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x10;
  }
  iVar1 = 0;
  if (X->n < nblimbs) {
    __dest = (mbedtls_mpi_uint *)mycalloc(nblimbs,4);
    if (__dest == (mbedtls_mpi_uint *)0x0) {
      iVar1 = -0x10;
    }
    else {
      if (X->p != (mbedtls_mpi_uint *)0x0) {
        memcpy(__dest,X->p,X->n << 2);
        pmVar2 = X->p;
        sVar3 = X->n;
        while (sVar3 = sVar3 - 1, sVar3 != 0xffffffff) {
          *pmVar2 = 0;
          pmVar2 = pmVar2 + 1;
        }
        vPortFree(X->p);
      }
      X->n = nblimbs;
      X->p = __dest;
      iVar1 = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_shrink(mbedtls_mpi *X,size_t nblimbs)

{
  uint uVar1;
  int iVar2;
  mbedtls_mpi_uint *__dest;
  mbedtls_mpi_uint *pmVar3;
  size_t sVar4;
  uint uVar5;
  
  uVar5 = X->n;
  if (X->n <= nblimbs) {
    iVar2 = mbedtls_mpi_grow(X,nblimbs);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  do {
    uVar1 = uVar5;
    uVar5 = uVar1 - 1;
    if (uVar5 == 0) break;
  } while (X->p[uVar5] == 0);
  if (nblimbs < uVar1) {
    nblimbs = uVar1;
  }
  __dest = (mbedtls_mpi_uint *)mycalloc(nblimbs,4);
  iVar2 = -0x10;
  if (__dest != (mbedtls_mpi_uint *)0x0) {
    if (X->p != (mbedtls_mpi_uint *)0x0) {
      memcpy(__dest,X->p,nblimbs << 2);
      pmVar3 = X->p;
      sVar4 = X->n;
      while (sVar4 = sVar4 - 1, sVar4 != 0xffffffff) {
        *pmVar3 = 0;
        pmVar3 = pmVar3 + 1;
      }
      vPortFree(X->p);
    }
    X->n = nblimbs;
    X->p = __dest;
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_mpi_copy(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  int iVar1;
  size_t sVar2;
  size_t nblimbs;
  
  if (X != Y) {
    if (Y->p != (mbedtls_mpi_uint *)0x0) {
      sVar2 = Y->n;
      do {
        nblimbs = sVar2;
        sVar2 = nblimbs - 1;
        if (sVar2 == 0) break;
      } while (Y->p[sVar2] == 0);
      X->s = Y->s;
      iVar1 = mbedtls_mpi_grow(X,nblimbs);
      if (iVar1 != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1;
      }
      memset(X->p,0,X->n << 2);
      memcpy(X->p,Y->p,nblimbs << 2);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    mbedtls_mpi_free(X);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_mpi_safe_cond_assign(mbedtls_mpi *X,mbedtls_mpi *Y,uchar assign)

{
  int iVar1;
  mbedtls_mpi_uint *pmVar2;
  uint uVar3;
  mbedtls_mpi_uint *pmVar4;
  int iVar5;
  uint uVar6;
  
  iVar1 = mbedtls_mpi_grow(X,Y->n);
  if (iVar1 == 0) {
    uVar3 = ((uint)assign | -(uint)assign & 0xff) >> 7;
    iVar5 = 1 - uVar3;
    X->s = iVar5 * X->s + uVar3 * Y->s;
    uVar6 = 0;
    while (uVar6 < Y->n) {
      pmVar2 = X->p + uVar6;
      pmVar4 = Y->p + uVar6;
      uVar6 = uVar6 + 1;
      *pmVar2 = uVar3 * *pmVar4 + iVar5 * *pmVar2;
    }
    while (uVar6 < X->n) {
      X->p[uVar6] = X->p[uVar6] * iVar5;
      uVar6 = uVar6 + 1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_lset(mbedtls_mpi *X,mbedtls_mpi_sint z)

{
  int iVar1;
  int iVar2;
  
  iVar1 = mbedtls_mpi_grow(X,1);
  if (iVar1 == 0) {
    memset(X->p,0,X->n << 2);
    *X->p = (z >> 0x1f ^ z) - (z >> 0x1f);
    iVar2 = -1;
    if (-1 < z) {
      iVar2 = 1;
    }
    X->s = iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_get_bit(mbedtls_mpi *X,size_t pos)

{
  if (pos < X->n << 5) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return X->p[pos >> 5] >> (pos & 0x1f) & 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



size_t mbedtls_mpi_lsb(mbedtls_mpi *X)

{
  int iVar1;
  size_t sVar2;
  uint uVar3;
  
  sVar2 = 0;
  iVar1 = 0;
  do {
    if (X->n == sVar2) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    uVar3 = 0;
    do {
      if ((X->p[sVar2] >> (uVar3 & 0x1f) & 1) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar1 + uVar3;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 != 0x20);
    sVar2 = sVar2 + 1;
    iVar1 = iVar1 + uVar3;
  } while( true );
}



size_t mbedtls_mpi_bitlen(mbedtls_mpi *X)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  size_t sVar4;
  
  sVar3 = X->n;
  if (sVar3 != 0) {
    do {
      sVar4 = sVar3;
      sVar3 = sVar4 - 1;
      if (sVar3 == 0) break;
    } while (X->p[sVar3] == 0);
    iVar1 = 0;
    uVar2 = 0x80000000;
    do {
      if ((X->p[sVar3] & uVar2) != 0) break;
      iVar1 = iVar1 + 1;
      uVar2 = uVar2 >> 1;
    } while (iVar1 != 0x20);
    sVar3 = sVar4 * 0x20 - iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar3;
}



size_t mbedtls_mpi_size(mbedtls_mpi *X)

{
  size_t sVar1;
  
  sVar1 = mbedtls_mpi_bitlen(X);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return sVar1 + 7 >> 3;
}



int mbedtls_mpi_read_binary(mbedtls_mpi *X,uchar *buf,size_t buflen)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar2 = 0;
  while ((uVar2 != buflen && (buf[uVar2] == '\0'))) {
    uVar2 = uVar2 + 1;
  }
  iVar3 = mbedtls_mpi_grow(X,(uint)((buflen - uVar2 & 3) != 0) + (buflen - uVar2 >> 2));
  if (iVar3 == 0) {
    iVar3 = mbedtls_mpi_lset(X,0);
    uVar5 = 0;
    if (iVar3 == 0) {
      while (uVar2 < buflen) {
        buflen = buflen - 1;
        puVar4 = (uint *)((int)X->p + (uVar5 & 0xfffffffc));
        uVar1 = uVar5 & 3;
        uVar5 = uVar5 + 1;
        *puVar4 = *puVar4 | (uint)buf[buflen] << (uVar1 << 3);
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_mpi_write_binary(mbedtls_mpi *X,uchar *buf,size_t buflen)

{
  uint uVar1;
  size_t sVar2;
  int iVar3;
  uchar *puVar4;
  uint uVar5;
  uint uVar6;
  
  sVar2 = mbedtls_mpi_size(X);
  if (buflen < sVar2) {
    iVar3 = -8;
  }
  else {
    memset(buf,0,buflen);
    puVar4 = buf + buflen;
    uVar6 = 0;
    while (puVar4 = puVar4 + -1, uVar6 != sVar2) {
      uVar5 = uVar6 & 0xfffffffc;
      uVar1 = uVar6 & 3;
      uVar6 = uVar6 + 1;
      *puVar4 = (uchar)(*(uint *)((int)X->p + uVar5) >> (uVar1 << 3));
    }
    iVar3 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_mpi_shift_l(mbedtls_mpi *X,size_t count)

{
  uint uVar1;
  size_t sVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  
  uVar1 = count >> 5;
  uVar6 = count & 0x1f;
  sVar2 = mbedtls_mpi_bitlen(X);
  uVar3 = sVar2 + count;
  if ((uVar3 <= X->n << 5) ||
     (iVar4 = mbedtls_mpi_grow(X,(uint)((uVar3 & 0x1f) != 0) + (uVar3 >> 5)), iVar4 == 0)) {
    if (0x1f < count) {
      uVar3 = X->n;
      iVar4 = uVar3 << 2;
      while (iVar4 = iVar4 + -4, uVar1 < uVar3) {
        uVar3 = uVar3 - 1;
        *(undefined4 *)((int)X->p + iVar4) = *(undefined4 *)((int)X->p + iVar4 + uVar1 * -4);
      }
      iVar4 = uVar3 << 2;
      while (iVar4 = iVar4 + -4, iVar4 != -4) {
        *(undefined4 *)((int)X->p + iVar4) = 0;
      }
    }
    if (uVar6 != 0) {
      uVar3 = 0;
      while (uVar1 < X->n) {
        uVar5 = X->p[uVar1];
        X->p[uVar1] = uVar5 << uVar6;
        X->p[uVar1] = X->p[uVar1] | uVar3;
        uVar3 = uVar5 >> (0x20 - uVar6 & 0x1f);
        uVar1 = uVar1 + 1;
      }
    }
    iVar4 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int mbedtls_mpi_shift_r(mbedtls_mpi *X,size_t count)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  size_t sVar5;
  mbedtls_mpi_uint *pmVar6;
  
  uVar3 = count >> 5;
  uVar4 = count & 0x1f;
  if (X->n < uVar3) {
LAB_230614f4:
    iVar1 = mbedtls_mpi_lset(X,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (X->n == uVar3) {
    if (uVar4 != 0) goto LAB_230614f4;
    if (count < 0x20) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    uVar2 = 0;
  }
  else {
    if (count < 0x20) goto LAB_23061514;
    iVar1 = uVar3 << 2;
    uVar2 = 0;
    while (uVar2 < X->n - uVar3) {
      pmVar6 = (mbedtls_mpi_uint *)((int)X->p + iVar1);
      iVar1 = iVar1 + 4;
      X->p[uVar2] = *pmVar6;
      uVar2 = uVar2 + 1;
    }
  }
  while (uVar2 < X->n) {
    X->p[uVar2] = 0;
    uVar2 = uVar2 + 1;
  }
LAB_23061514:
  if (uVar4 != 0) {
    sVar5 = X->n;
    uVar3 = 0;
    while (sVar5 = sVar5 - 1, sVar5 != 0xffffffff) {
      uVar2 = X->p[sVar5];
      X->p[sVar5] = uVar2 >> uVar4;
      X->p[sVar5] = X->p[sVar5] | uVar3;
      uVar3 = uVar2 << (0x20 - uVar4 & 0x1f);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_mpi_cmp_abs(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar3 = X->n;
  while ((uVar3 != 0 && (X->p[uVar3 - 1] == 0))) {
    uVar3 = uVar3 - 1;
  }
  uVar1 = Y->n;
  while (uVar1 != 0) {
    if (Y->p[uVar1 - 1] != 0) {
      uVar2 = 1;
      if ((uVar1 < uVar3) || (uVar2 = 0xffffffff, uVar3 < uVar1)) goto LAB_230615d0;
      goto LAB_230615ca;
    }
    uVar1 = uVar1 - 1;
  }
  uVar2 = (uint)(uVar3 != 0);
  goto LAB_230615d0;
  while (uVar1 <= X->p[uVar3]) {
LAB_230615ca:
    uVar3 = uVar3 - 1;
    if (uVar3 == 0xffffffff) {
      uVar2 = 0;
      goto LAB_230615d0;
    }
    uVar1 = Y->p[uVar3];
    if (uVar1 < X->p[uVar3]) {
      uVar2 = 1;
      goto LAB_230615d0;
    }
  }
  uVar2 = 0xffffffff;
LAB_230615d0:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



int mpi_montmul(mbedtls_mpi *A,mbedtls_mpi *B,mbedtls_mpi *N,mbedtls_mpi_uint mm,mbedtls_mpi *T)

{
  int iVar1;
  mbedtls_mpi_uint *pmVar2;
  mbedtls_mpi_uint mVar3;
  mbedtls_mpi_uint *pmVar4;
  mbedtls_mpi_uint mVar5;
  size_t n;
  uint i;
  uint i_00;
  mbedtls_mpi_uint b;
  
  if ((N->n + 1 <= T->n) && (T->p != (mbedtls_mpi_uint *)0x0)) {
    memset(T->p,0,T->n << 2);
    i = N->n;
    pmVar4 = T->p;
    i_00 = B->n;
    if (i < B->n) {
      i_00 = i;
    }
    n = 0;
    pmVar2 = pmVar4;
    while (n != i) {
      b = A->p[n];
      mVar5 = *B->p;
      mVar3 = *pmVar2;
      n = n + 1;
      mpi_mul_hlp(i_00,B->p,pmVar2,b);
      mpi_mul_hlp(i,N->p,pmVar2,(b * mVar5 + mVar3) * mm);
      *pmVar2 = b;
      (pmVar2 + 1)[i + 1] = 0;
      pmVar2 = pmVar2 + 1;
    }
    memcpy(A->p,pmVar4 + i,(i + 1) * 4);
    iVar1 = mbedtls_mpi_cmp_abs(A,N);
    if (iVar1 < 0) {
      pmVar2 = T->p;
      pmVar4 = A->p;
    }
    else {
      pmVar4 = N->p;
      pmVar2 = A->p;
    }
    mpi_sub_hlp(n,pmVar4,pmVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -4;
}



int mbedtls_mpi_cmp_mpi(mbedtls_mpi *X,mbedtls_mpi *Y)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  
  uVar4 = X->n;
  while ((uVar4 != 0 && (X->p[uVar4 - 1] == 0))) {
    uVar4 = uVar4 - 1;
  }
  uVar2 = Y->n;
  while (uVar2 != 0) {
    if (Y->p[uVar2 - 1] != 0) {
      if (uVar2 < uVar4) goto LAB_23061736;
      iVar1 = Y->s;
      if (uVar4 < uVar2) {
        iVar3 = -iVar1;
        goto LAB_23061738;
      }
      iVar3 = X->s;
      if (iVar3 < 1) {
        if ((iVar1 < 1) || (iVar3 == 0)) goto LAB_23061782;
        iVar3 = -1;
      }
      else {
        if (-1 < iVar1) goto LAB_23061782;
        iVar3 = 1;
      }
      goto LAB_23061738;
    }
    uVar2 = uVar2 - 1;
  }
  iVar3 = 0;
  if (uVar4 != 0) {
LAB_23061736:
    iVar3 = X->s;
  }
  goto LAB_23061738;
  while( true ) {
    uVar2 = Y->p[uVar4];
    if (uVar2 < X->p[uVar4]) goto LAB_23061738;
    if (X->p[uVar4] < uVar2) break;
LAB_23061782:
    uVar4 = uVar4 - 1;
    if (uVar4 == 0xffffffff) {
      iVar3 = 0;
      goto LAB_23061738;
    }
  }
  iVar3 = -iVar3;
LAB_23061738:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_mpi_cmp_int(mbedtls_mpi *X,mbedtls_mpi_sint z)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi Y;
  
  p = 1;
  if (z < 0) {
    p = 0xffffffff;
  }
  iVar1 = mbedtls_mpi_cmp_mpi(X,(mbedtls_mpi *)p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_add_abs(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  size_t nblimbs;
  mbedtls_mpi *pmVar1;
  uint uVar2;
  int iVar3;
  mbedtls_mpi_uint *pmVar4;
  int iVar5;
  uint uVar6;
  mbedtls_mpi_uint *pmVar7;
  size_t sVar8;
  mbedtls_mpi_uint mVar9;
  uint uVar10;
  mbedtls_mpi_uint *pmVar11;
  
  pmVar1 = A;
  if (((X == B) || (pmVar1 = B, X == A)) || (iVar5 = mbedtls_mpi_copy(X,A), iVar5 == 0)) {
    X->s = 1;
    nblimbs = pmVar1->n;
    while ((nblimbs != 0 && (pmVar1->p[nblimbs - 1] == 0))) {
      nblimbs = nblimbs - 1;
    }
    iVar3 = mbedtls_mpi_grow(X,nblimbs);
    iVar5 = iVar3;
    if (iVar3 == 0) {
      pmVar11 = X->p;
      pmVar4 = pmVar1->p;
      sVar8 = 0;
      uVar2 = 0;
      pmVar7 = pmVar11;
      while (nblimbs != sVar8) {
        uVar6 = pmVar4[sVar8];
        mVar9 = *pmVar7;
        sVar8 = sVar8 + 1;
        uVar10 = mVar9 + uVar2 + uVar6;
        *pmVar7 = uVar10;
        uVar2 = (uint)(mVar9 + uVar2 < uVar2) + (uint)(uVar10 < uVar6);
        pmVar7 = pmVar7 + 1;
      }
      pmVar7 = pmVar11 + nblimbs;
      while (iVar5 = iVar3, uVar2 != 0) {
        if (X->n <= nblimbs) {
          iVar5 = mbedtls_mpi_grow(X,nblimbs + 1);
          if (iVar5 != 0) break;
          pmVar7 = X->p + nblimbs;
        }
        mVar9 = *pmVar7;
        *pmVar7 = mVar9 + uVar2;
        uVar2 = (uint)(mVar9 + uVar2 < uVar2);
        nblimbs = nblimbs + 1;
        pmVar7 = pmVar7 + 1;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar5;
}



int mbedtls_mpi_sub_abs(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  size_t n;
  undefined auStack44 [4];
  mbedtls_mpi TB;
  
  iVar1 = mbedtls_mpi_cmp_abs(A,B);
  if (iVar1 < 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -10;
  }
  auStack44 = 1;
  TB.s = 0;
  TB.n = 0;
  if (B == X) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)auStack44,B);
    if (iVar1 != 0) goto cleanup;
    B = (mbedtls_mpi *)auStack44;
  }
  if ((A == X) || (iVar1 = mbedtls_mpi_copy(X,A), iVar1 == 0)) {
    X->s = 1;
    n = B->n;
    while ((n != 0 && (B->p[n - 1] == 0))) {
      n = n - 1;
    }
    iVar1 = 0;
    mpi_sub_hlp(n,B->p,X->p);
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack44);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_add_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  
  iVar1 = A->s;
  if (iVar1 * B->s < 0) {
    iVar2 = mbedtls_mpi_cmp_abs(A,B);
    if (iVar2 < 0) {
      iVar2 = mbedtls_mpi_sub_abs(X,B,A);
      iVar1 = -iVar1;
    }
    else {
      iVar2 = mbedtls_mpi_sub_abs(X,A,B);
    }
  }
  else {
    iVar2 = mbedtls_mpi_add_abs(X,A,B);
  }
  if (iVar2 == 0) {
    X->s = iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_mpi_sub_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  
  iVar1 = A->s;
  if (iVar1 * B->s < 1) {
    iVar2 = mbedtls_mpi_add_abs(X,A,B);
  }
  else {
    iVar2 = mbedtls_mpi_cmp_abs(A,B);
    if (iVar2 < 0) {
      iVar2 = mbedtls_mpi_sub_abs(X,B,A);
      iVar1 = -iVar1;
    }
    else {
      iVar2 = mbedtls_mpi_sub_abs(X,A,B);
    }
  }
  if (iVar2 == 0) {
    X->s = iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_mpi_sub_int(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi_sint b)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi _B;
  
  p = 1;
  if (b < 0) {
    p = 0xffffffff;
  }
  iVar1 = mbedtls_mpi_sub_mpi(X,A,(mbedtls_mpi *)p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Variable defined which should be unmapped: TB

int mbedtls_mpi_mul_mpi(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  size_t sVar2;
  size_t i;
  undefined local_38 [4];
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  
  local_38 = 1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  if (X == A) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)local_38,A);
    A = (mbedtls_mpi *)local_38;
    if (iVar1 != 0) goto cleanup;
  }
  if (X == B) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,X);
    if (iVar1 != 0) goto cleanup;
    B = (mbedtls_mpi *)&TA.p;
  }
  i = A->n;
  while ((i != 0 && (A->p[i - 1] == 0))) {
    i = i - 1;
  }
  sVar2 = B->n;
  while ((sVar2 != 0 && (B->p[sVar2 - 1] == 0))) {
    sVar2 = sVar2 - 1;
  }
  iVar1 = mbedtls_mpi_grow(X,i + sVar2);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_lset(X,0), iVar1 == 0)) {
    while (sVar2 = sVar2 - 1, sVar2 != 0xffffffff) {
      mpi_mul_hlp(i,A->p,X->p + sVar2,B->p[sVar2]);
    }
    X->s = A->s * B->s;
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  mbedtls_mpi_free((mbedtls_mpi *)local_38);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_mul_int(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi_uint b)

{
  int iVar1;
  mbedtls_mpi_uint p [1];
  mbedtls_mpi _B;
  
  p = 1;
  iVar1 = mbedtls_mpi_mul_mpi(X,A,(mbedtls_mpi *)p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mbedtls_mpi_div_mpi(mbedtls_mpi *Q,mbedtls_mpi *R,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  int iVar3;
  size_t sVar4;
  undefined4 uVar5;
  uint uVar6;
  uint uVar7;
  undefined4 uVar8;
  int *piVar9;
  size_t count;
  uint uVar10;
  int iVar11;
  uint uVar12;
  int iVar13;
  undefined4 *puVar14;
  undefined auStack124 [4];
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  
  iVar3 = mbedtls_mpi_cmp_int(B,0);
  iVar13 = -0xc;
  if (iVar3 == 0) goto LAB_23061b5e;
  auStack124 = 1;
  X.s = 0;
  X.n = 0;
  X.p = (mbedtls_mpi_uint *)0x1;
  Y.s = 0;
  Y.n = 0;
  Y.p = (mbedtls_mpi_uint *)0x1;
  Z.s = 0;
  Z.n = 0;
  Z.p = (mbedtls_mpi_uint *)0x1;
  T1.s = 0;
  T1.n = 0;
  T1.p = (mbedtls_mpi_uint *)0x1;
  iVar13 = mbedtls_mpi_cmp_abs(A,B);
  if (iVar13 < 0) {
    if (((Q == (mbedtls_mpi *)0x0) || (iVar13 = mbedtls_mpi_lset(Q,0), iVar13 == 0)) &&
       ((R == (mbedtls_mpi *)0x0 || (iVar13 = mbedtls_mpi_copy(R,A), iVar13 == 0)))) {
      iVar13 = 0;
      goto LAB_23061b5e;
    }
  }
  else {
    iVar13 = mbedtls_mpi_copy((mbedtls_mpi *)auStack124,A);
    if ((iVar13 == 0) && (iVar13 = mbedtls_mpi_copy((mbedtls_mpi *)&X.p,B), iVar13 == 0)) {
      X.p = (mbedtls_mpi_uint *)0x1;
      auStack124 = 1;
      iVar13 = mbedtls_mpi_grow((mbedtls_mpi *)&Y.p,A->n + 2);
      if ((iVar13 == 0) &&
         (((iVar13 = mbedtls_mpi_lset((mbedtls_mpi *)&Y.p,0), iVar13 == 0 &&
           (iVar13 = mbedtls_mpi_grow((mbedtls_mpi *)&Z.p,2), iVar13 == 0)) &&
          (iVar13 = mbedtls_mpi_grow((mbedtls_mpi *)&T1.p,3), iVar13 == 0)))) {
        sVar4 = mbedtls_mpi_bitlen((mbedtls_mpi *)&X.p);
        if ((sVar4 & 0x1f) == 0x1f) {
          sVar4 = 0;
        }
        else {
          sVar4 = 0x1f - (sVar4 & 0x1f);
          iVar13 = mbedtls_mpi_shift_l((mbedtls_mpi *)auStack124,sVar4);
          if ((iVar13 != 0) ||
             (iVar13 = mbedtls_mpi_shift_l((mbedtls_mpi *)&X.p,sVar4), iVar13 != 0)) goto cleanup;
        }
        iVar3 = Y.s;
        uVar10 = X.s;
        iVar1 = X.s - Y.s;
        count = iVar1 * 0x20;
        iVar13 = mbedtls_mpi_shift_l((mbedtls_mpi *)&X.p,count);
        while (iVar13 == 0) {
          iVar13 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack124,(mbedtls_mpi *)&X.p);
          if (iVar13 < 0) {
            iVar1 = mbedtls_mpi_shift_r((mbedtls_mpi *)&X.p,count);
            iVar13 = iVar1;
            if (iVar1 == 0) {
              uVar12 = iVar3 - 1;
              iVar2 = ((uVar10 + 0x3fffffff) - iVar3) * 4;
              goto LAB_23061c8a;
            }
            break;
          }
          piVar9 = (int *)(Z.n + iVar1 * 4);
          *piVar9 = *piVar9 + 1;
          iVar13 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack124,(mbedtls_mpi *)auStack124,
                                       (mbedtls_mpi *)&X.p);
        }
      }
    }
  }
  goto cleanup;
LAB_23061c8a:
  uVar10 = uVar10 - 1;
  if (uVar10 <= uVar12) goto code_r0x23061c8e;
  iVar11 = uVar10 * 4;
  uVar6 = *(uint *)(X.n + iVar11);
  uVar7 = *(uint *)(Y.n + uVar12 * 4);
  puVar14 = (undefined4 *)(Z.n + iVar2);
  if (uVar6 < uVar7) {
    uVar5 = *(undefined4 *)(X.n + iVar11 + -4);
    uVar8 = 0xffffffff;
    if ((uVar7 != 0) && (__udivdi3(), uVar8 = uVar5, uVar6 != 0)) {
      uVar8 = 0xffffffff;
    }
    *puVar14 = uVar8;
  }
  else {
    *puVar14 = 0xffffffff;
  }
  *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + 1;
  do {
    *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + -1;
    iVar13 = mbedtls_mpi_lset((mbedtls_mpi *)&Z.p,0);
    if (iVar13 != 0) goto cleanup;
    uVar8 = 0;
    if (uVar12 != 0) {
      uVar8 = *(undefined4 *)(Y.n + iVar3 * 4 + -8);
    }
    *(undefined4 *)T1.n = uVar8;
    *(undefined4 *)(T1.n + 4) = *(undefined4 *)(Y.n + uVar12 * 4);
    iVar13 = mbedtls_mpi_mul_int((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&Z.p,
                                 *(mbedtls_mpi_uint *)(Z.n + iVar2));
    if ((iVar13 != 0) || (iVar13 = mbedtls_mpi_lset((mbedtls_mpi *)&T1.p,0), iVar13 != 0))
    goto cleanup;
    ___EM_SIZE = 0;
    if (uVar10 != 1) {
      ___EM_SIZE = *(undefined4 *)(X.n + iVar11 + -8);
    }
    _DAT_00000004 = *(undefined4 *)(X.n + iVar11 + -4);
    _DAT_00000008 = *(mbedtls_mpi_uint *)(X.n + iVar11);
    iVar13 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&T1.p);
  } while (0 < iVar13);
  iVar13 = mbedtls_mpi_mul_int((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&X.p,
                               *(mbedtls_mpi_uint *)(Z.n + iVar2));
  if (iVar13 != 0) goto cleanup;
  iVar13 = mbedtls_mpi_shift_l((mbedtls_mpi *)&Z.p,iVar2 << 3);
  if ((iVar13 != 0) ||
     (iVar13 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack124,(mbedtls_mpi *)auStack124,
                                   (mbedtls_mpi *)&Z.p), iVar13 != 0)) goto cleanup;
  iVar13 = mbedtls_mpi_cmp_int((mbedtls_mpi *)auStack124,0);
  if (iVar13 < 0) {
    iVar13 = mbedtls_mpi_copy((mbedtls_mpi *)&Z.p,(mbedtls_mpi *)&X.p);
    if (((iVar13 != 0) ||
        (iVar13 = mbedtls_mpi_shift_l((mbedtls_mpi *)&Z.p,iVar2 << 3), iVar13 != 0)) ||
       (iVar13 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack124,(mbedtls_mpi *)auStack124,
                                     (mbedtls_mpi *)&Z.p), iVar13 != 0)) goto cleanup;
    *(int *)(Z.n + iVar2) = *(int *)(Z.n + iVar2) + -1;
  }
  iVar2 = iVar2 + -4;
  goto LAB_23061c8a;
code_r0x23061c8e:
  if (Q != (mbedtls_mpi *)0x0) {
    iVar13 = mbedtls_mpi_copy(Q,(mbedtls_mpi *)&Y.p);
    if (iVar13 != 0) goto cleanup;
    Q->s = A->s * B->s;
  }
  iVar13 = iVar1;
  if ((R != (mbedtls_mpi *)0x0) &&
     (iVar13 = mbedtls_mpi_shift_r((mbedtls_mpi *)auStack124,sVar4), iVar13 == 0)) {
    auStack124 = A->s;
    iVar13 = mbedtls_mpi_copy(R,(mbedtls_mpi *)auStack124);
    if ((iVar13 == 0) && (iVar3 = mbedtls_mpi_cmp_int(R,0), iVar13 = iVar1, iVar3 == 0)) {
      R->s = 1;
      iVar13 = 0;
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack124);
  mbedtls_mpi_free((mbedtls_mpi *)&X.p);
  mbedtls_mpi_free((mbedtls_mpi *)&Y.p);
  mbedtls_mpi_free((mbedtls_mpi *)&Z.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
LAB_23061b5e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar13;
}



int mbedtls_mpi_mod_mpi(mbedtls_mpi *R,mbedtls_mpi *A,mbedtls_mpi *B)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar1 = mbedtls_mpi_cmp_int(B,0);
  if (iVar1 < 0) {
    iVar1 = -10;
  }
  else {
    iVar2 = mbedtls_mpi_div_mpi((mbedtls_mpi *)0x0,R,A,B);
    iVar1 = iVar2;
    while (iVar1 == 0) {
      iVar1 = mbedtls_mpi_cmp_int(R,0);
      if (-1 < iVar1) goto LAB_23061e8e;
      iVar1 = mbedtls_mpi_add_mpi(R,R,B);
    }
  }
  goto LAB_23061e68;
  while (iVar1 = mbedtls_mpi_sub_mpi(R,R,B), iVar1 == 0) {
LAB_23061e8e:
    iVar3 = mbedtls_mpi_cmp_mpi(R,B);
    iVar1 = iVar2;
    if (iVar3 < 0) break;
  }
LAB_23061e68:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_mpi_exp_mod(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *E,mbedtls_mpi *N,mbedtls_mpi *_RR
                       )

{
  uint uVar1;
  int iVar2;
  mbedtls_mpi_uint mm;
  int iVar3;
  size_t sVar4;
  mbedtls_mpi *pmVar5;
  mbedtls_mpi *pmVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  size_t sVar13;
  mbedtls_mpi_uint mStack1652;
  mbedtls_mpi_uint z;
  mbedtls_mpi RR;
  mbedtls_mpi T;
  mbedtls_mpi Apos;
  mbedtls_mpi U;
  mbedtls_mpi W [128];
  
  iVar3 = mbedtls_mpi_cmp_int(N,0);
  iVar2 = -4;
  if (iVar3 < 0) goto LAB_23062284;
  iVar2 = -4;
  uVar9 = *N->p;
  uVar12 = uVar9 & 1;
  if ((uVar12 == 0) || (iVar3 = mbedtls_mpi_cmp_int(E,0), iVar3 < 0)) goto LAB_23062284;
  iVar3 = ((uVar9 + 2) * 2 & 8) + uVar9;
  iVar2 = 3;
  do {
    iVar2 = iVar2 + -1;
    iVar3 = iVar3 * (2 - uVar9 * iVar3);
  } while (iVar2 != 0);
  z = 1;
  RR.p = (mbedtls_mpi_uint *)0x1;
  T.p = (mbedtls_mpi_uint *)0x1;
  RR.s = 0;
  RR.n = 0;
  T.s = 0;
  T.n = 0;
  Apos.s = 0;
  Apos.n = 0;
  memset(&U.p,0,0x600);
  sVar4 = mbedtls_mpi_bitlen(E);
  uVar9 = 6;
  if ((((sVar4 < 0x2a0) && (uVar9 = 5, sVar4 < 0xf0)) && (uVar9 = 4, sVar4 < 0x50)) &&
     (uVar9 = 3, sVar4 < 0x18)) {
    uVar9 = uVar12;
  }
  sVar4 = N->n + 1;
  iVar2 = mbedtls_mpi_grow(X,sVar4);
  if (((iVar2 == 0) && (iVar2 = mbedtls_mpi_grow((mbedtls_mpi *)&W[0].p,sVar4), iVar2 == 0)) &&
     (iVar2 = mbedtls_mpi_grow((mbedtls_mpi *)&RR.p,sVar4 * 2), iVar2 == 0)) {
    iVar8 = A->s;
    if (iVar8 == -1) {
      iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&T.p,A);
      if (iVar2 != 0) goto cleanup;
      T.p = (mbedtls_mpi_uint *)0x1;
      A = (mbedtls_mpi *)&T.p;
    }
    if ((_RR == (mbedtls_mpi *)0x0) || (_RR->p == (mbedtls_mpi_uint *)0x0)) {
      iVar2 = mbedtls_mpi_lset((mbedtls_mpi *)&z,1);
      if ((iVar2 != 0) ||
         ((iVar2 = mbedtls_mpi_shift_l((mbedtls_mpi *)&z,N->n << 6), iVar2 != 0 ||
          (iVar2 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&z,(mbedtls_mpi *)&z,N), iVar2 != 0))))
      goto cleanup;
      if (_RR != (mbedtls_mpi *)0x0) {
        pmVar5 = _RR;
        pmVar6 = (mbedtls_mpi *)&z;
        goto LAB_23062022;
      }
    }
    else {
      pmVar5 = (mbedtls_mpi *)&z;
      pmVar6 = _RR;
LAB_23062022:
      memcpy(pmVar5,pmVar6,0xc);
    }
    iVar2 = mbedtls_mpi_cmp_mpi(A,N);
    if (iVar2 < 0) {
      iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&W[0].p,A);
    }
    else {
      iVar2 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&W[0].p,A,N);
    }
    if (iVar2 == 0) {
      mm = -iVar3;
      iVar2 = mpi_montmul((mbedtls_mpi *)&W[0].p,(mbedtls_mpi *)&z,N,mm,(mbedtls_mpi *)&RR.p);
      if ((iVar2 == 0) && (iVar2 = mbedtls_mpi_copy(X,(mbedtls_mpi *)&z), iVar2 == 0)) {
        U.n = (size_t)&mStack1652;
        mStack1652 = 1;
        Apos.p = (mbedtls_mpi_uint *)0x1;
        U.s = 1;
        iVar2 = mpi_montmul(X,(mbedtls_mpi *)&Apos.p,N,mm,(mbedtls_mpi *)&RR.p);
        if (iVar2 == 0) {
          if (uVar9 == 1) {
LAB_2306208c:
            sVar4 = E->n;
            uVar10 = 0;
            uVar1 = 0;
            do {
              sVar13 = 0;
              uVar11 = 0;
LAB_23062182:
              do {
                if (uVar10 == 0) {
                  if (sVar4 == 0) {
                    goto LAB_23062190;
                  }
                  sVar4 = sVar4 - 1;
                  uVar10 = 0x20;
                }
                uVar10 = uVar10 - 1;
                uVar7 = E->p[sVar4] >> (uVar10 & 0x1f) & 1;
                if (uVar7 == 0) {
                  if (uVar1 == 0) goto LAB_23062182;
                  if (uVar1 == 1) {
                    iVar2 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
                    if (iVar2 != 0) goto cleanup;
                    goto LAB_23062182;
                  }
                }
                sVar13 = sVar13 + 1;
                uVar11 = uVar11 | uVar7 << (uVar9 - sVar13 & 0x1f);
                uVar1 = 2;
              } while (uVar9 != sVar13);
              uVar1 = 0;
              do {
                iVar2 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
                if (iVar2 != 0) goto cleanup;
                uVar1 = uVar1 + 1;
              } while (uVar1 < sVar13);
              iVar2 = mpi_montmul(X,(mbedtls_mpi *)&W[uVar11 - 1].p,N,mm,(mbedtls_mpi *)&RR.p);
              uVar1 = uVar12;
            } while (iVar2 == 0);
          }
          else {
            uVar10 = uVar9 - 1;
            pmVar5 = (mbedtls_mpi *)((int)W + (0xc << (uVar10 & 0x1f)) + -4);
            iVar2 = mbedtls_mpi_grow(pmVar5,N->n + 1);
            uVar1 = 1 << (uVar10 & 0x1f);
            if ((iVar2 == 0) &&
               (iVar2 = mbedtls_mpi_copy(pmVar5,(mbedtls_mpi *)&W[0].p), iVar2 == 0)) {
              uVar11 = 0;
              do {
                iVar2 = mpi_montmul(pmVar5,pmVar5,N,mm,(mbedtls_mpi *)&RR.p);
                if (iVar2 != 0) goto cleanup;
                uVar11 = uVar11 + 1;
              } while (uVar11 < uVar10);
              do {
                uVar1 = uVar1 + 1;
                if ((uint)(1 << uVar9) <= uVar1) goto LAB_2306208c;
                pmVar6 = pmVar5 + 1;
                iVar2 = mbedtls_mpi_grow(pmVar6,N->n + 1);
              } while (((iVar2 == 0) && (iVar2 = mbedtls_mpi_copy(pmVar6,pmVar5), iVar2 == 0)) &&
                      (iVar2 = mpi_montmul(pmVar6,(mbedtls_mpi *)&W[0].p,N,mm,(mbedtls_mpi *)&RR.p),
                      pmVar5 = pmVar6, iVar2 == 0));
            }
          }
        }
      }
    }
  }
cleanup:
  uVar12 = 1 << (uVar9 - 1 & 0x1f);
  while (uVar12 < (uint)(1 << uVar9)) {
    mbedtls_mpi_free((mbedtls_mpi *)&W[uVar12 - 1].p);
    uVar12 = uVar12 + 1;
  }
  mbedtls_mpi_free((mbedtls_mpi *)&W[0].p);
  mbedtls_mpi_free((mbedtls_mpi *)&RR.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  if ((_RR == (mbedtls_mpi *)0x0) || (_RR->p == (mbedtls_mpi_uint *)0x0)) {
    mbedtls_mpi_free((mbedtls_mpi *)&z);
  }
LAB_23062284:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
LAB_23062190:
  if (sVar4 == sVar13) goto code_r0x23062194;
  iVar2 = mpi_montmul(X,X,N,mm,(mbedtls_mpi *)&RR.p);
  if ((iVar2 != 0) ||
     ((uVar11 = uVar11 << 1, (1 << uVar9 & uVar11) != 0 &&
      (iVar2 = mpi_montmul(X,(mbedtls_mpi *)&W[0].p,N,mm,(mbedtls_mpi *)&RR.p), iVar2 != 0))))
  goto cleanup;
  sVar4 = sVar4 + 1;
  goto LAB_23062190;
code_r0x23062194:
  mStack1652 = 1;
  Apos.p = (mbedtls_mpi_uint *)0x1;
  U.s = 1;
  U.n = (size_t)&mStack1652;
  iVar2 = mpi_montmul(X,(mbedtls_mpi *)&Apos.p,N,mm,(mbedtls_mpi *)&RR.p);
  if ((iVar2 == 0) && (iVar8 == -1)) {
    X->s = -1;
    iVar2 = mbedtls_mpi_add_mpi(X,N,X);
  }
  goto cleanup;
}



// WARNING: Variable defined which should be unmapped: TB

int mbedtls_mpi_gcd(mbedtls_mpi *G,mbedtls_mpi *A,mbedtls_mpi *B)

{
  mbedtls_mpi *pmVar1;
  int iVar2;
  size_t count;
  size_t sVar3;
  undefined auStack52 [4];
  mbedtls_mpi TG;
  mbedtls_mpi TA;
  mbedtls_mpi TB;
  
  auStack52 = 1;
  TG.s = 0;
  TG.n = 0;
  TG.p = (mbedtls_mpi_uint *)0x1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&TG.p,A);
  if ((iVar2 == 0) && (iVar2 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,B), iVar2 == 0)) {
    count = mbedtls_mpi_lsb((mbedtls_mpi *)&TG.p);
    sVar3 = mbedtls_mpi_lsb((mbedtls_mpi *)&TA.p);
    if (sVar3 < count) {
      count = sVar3;
    }
    iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TG.p,count);
    if ((iVar2 == 0) && (iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,count), iVar2 == 0)) {
      TA.p = (mbedtls_mpi_uint *)0x1;
      TG.p = (mbedtls_mpi_uint *)0x1;
      do {
        iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TG.p,0);
        if (iVar2 == 0) {
          iVar2 = mbedtls_mpi_shift_l((mbedtls_mpi *)&TA.p,count);
          if (iVar2 == 0) {
            iVar2 = mbedtls_mpi_copy(G,(mbedtls_mpi *)&TA.p);
          }
          break;
        }
        sVar3 = mbedtls_mpi_lsb((mbedtls_mpi *)&TG.p);
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TG.p,sVar3);
        if (iVar2 != 0) break;
        sVar3 = mbedtls_mpi_lsb((mbedtls_mpi *)&TA.p);
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,sVar3);
        if (iVar2 != 0) break;
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TA.p);
        if (iVar2 < 0) {
          iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TG.p
                                     );
          if (iVar2 != 0) break;
          pmVar1 = &TA;
        }
        else {
          iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TG.p,(mbedtls_mpi *)&TA.p
                                     );
          if (iVar2 != 0) break;
          pmVar1 = &TG;
        }
        iVar2 = mbedtls_mpi_shift_r((mbedtls_mpi *)&pmVar1->p,1);
      } while (iVar2 == 0);
    }
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack52);
  mbedtls_mpi_free((mbedtls_mpi *)&TG.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_mpi_fill_random
              (mbedtls_mpi *X,size_t size,anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng
              )

{
  int iVar1;
  uchar auStack1040 [4];
  uchar buf [1024];
  
  if (size < 0x401) {
    iVar1 = (*f_rng)(p_rng,auStack1040,size);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_read_binary(X,auStack1040,size);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int mbedtls_mpi_inv_mod(mbedtls_mpi *X,mbedtls_mpi *A,mbedtls_mpi *N)

{
  mbedtls_mpi *pmVar1;
  mbedtls_mpi *pmVar2;
  int iVar3;
  int iVar4;
  undefined auStack140 [4];
  mbedtls_mpi G;
  mbedtls_mpi TA;
  mbedtls_mpi TU;
  mbedtls_mpi U1;
  mbedtls_mpi U2;
  mbedtls_mpi TB;
  mbedtls_mpi TV;
  mbedtls_mpi V1;
  mbedtls_mpi V2;
  
  iVar4 = mbedtls_mpi_cmp_int(N,0);
  iVar3 = -4;
  if (iVar4 < 1) goto LAB_230625d8;
  G.p = (mbedtls_mpi_uint *)0x1;
  TA.s = 0;
  TA.n = 0;
  TA.p = (mbedtls_mpi_uint *)0x1;
  TU.s = 0;
  TU.n = 0;
  TU.p = (mbedtls_mpi_uint *)0x1;
  U1.s = 0;
  U1.n = 0;
  U1.p = (mbedtls_mpi_uint *)0x1;
  U2.s = 0;
  U2.n = 0;
  auStack140 = 1;
  G.s = 0;
  G.n = 0;
  U2.p = (mbedtls_mpi_uint *)0x1;
  TB.s = 0;
  TB.n = 0;
  TB.p = (mbedtls_mpi_uint *)0x1;
  TV.s = 0;
  TV.n = 0;
  TV.p = (mbedtls_mpi_uint *)0x1;
  V1.s = 0;
  V1.n = 0;
  V1.p = (mbedtls_mpi_uint *)0x1;
  iVar3 = mbedtls_mpi_gcd((mbedtls_mpi *)auStack140,A,N);
  if (iVar3 == 0) {
    iVar4 = mbedtls_mpi_cmp_int((mbedtls_mpi *)auStack140,1);
    iVar3 = -0xe;
    if (((((iVar4 == 0) && (iVar3 = mbedtls_mpi_mod_mpi((mbedtls_mpi *)&G.p,A,N), iVar3 == 0)) &&
         (iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&G.p), iVar3 == 0)) &&
        ((iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&U2.p,N), iVar3 == 0 &&
         (iVar3 = mbedtls_mpi_copy((mbedtls_mpi *)&TB.p,N), iVar3 == 0)))) &&
       ((iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&TU.p,1), iVar3 == 0 &&
        ((iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&U1.p,0), iVar3 == 0 &&
         (iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&TV.p,0), iVar3 == 0)))))) {
      iVar3 = mbedtls_mpi_lset((mbedtls_mpi *)&V1.p,1);
      while (iVar3 == 0) {
        while ((*(uint *)TU.n & 1) != 0) {
          while ((*(uint *)TV.n & 1) == 0) {
            iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TB.p,1);
            if ((iVar3 != 0) ||
               (((((*(uint *)V1.n & 1) != 0 || ((___EM_SIZE & 1) != 0)) &&
                 ((iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,
                                               (mbedtls_mpi *)&U2.p), iVar3 != 0 ||
                  (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&V1.p,(mbedtls_mpi *)&V1.p,
                                               (mbedtls_mpi *)&G.p), iVar3 != 0)))) ||
                ((iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TV.p,1), iVar3 != 0 ||
                 (iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&V1.p,1), iVar3 != 0))))))
            goto cleanup;
          }
          iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TB.p);
          if (iVar3 < 0) {
            iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TB.p,(mbedtls_mpi *)&TB.p,
                                        (mbedtls_mpi *)&TA.p);
            if ((iVar3 != 0) ||
               (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,
                                            (mbedtls_mpi *)&TU.p), iVar3 != 0)) goto cleanup;
            pmVar1 = &U1;
            pmVar2 = &V1;
          }
          else {
            iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TA.p,(mbedtls_mpi *)&TA.p,
                                        (mbedtls_mpi *)&TB.p);
            if ((iVar3 != 0) ||
               (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TU.p,(mbedtls_mpi *)&TU.p,
                                            (mbedtls_mpi *)&TV.p), iVar3 != 0)) goto cleanup;
            pmVar1 = &V1;
            pmVar2 = &U1;
          }
          iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&pmVar2->p,(mbedtls_mpi *)&pmVar2->p,
                                      (mbedtls_mpi *)&pmVar1->p);
          if (iVar3 != 0) goto cleanup;
          iVar3 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TA.p,0);
          if (iVar3 == 0) goto LAB_23062556;
        }
        iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TA.p,1);
        if (((iVar3 != 0) ||
            ((((*(uint *)U1.n & 1) != 0 || ((*(uint *)U2.n & 1) != 0)) &&
             ((iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TU.p,(mbedtls_mpi *)&TU.p,
                                           (mbedtls_mpi *)&U2.p), iVar3 != 0 ||
              (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&U1.p,(mbedtls_mpi *)&U1.p,
                                           (mbedtls_mpi *)&G.p), iVar3 != 0)))))) ||
           (iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&TU.p,1), iVar3 != 0)) break;
        iVar3 = mbedtls_mpi_shift_r((mbedtls_mpi *)&U1.p,1);
      }
    }
  }
  goto cleanup;
  while (iVar3 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,N), iVar3 == 0) {
LAB_23062556:
    iVar3 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&TV.p,0);
    if (-1 < iVar3) goto LAB_23062562;
  }
  goto cleanup;
  while (iVar3 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&TV.p,(mbedtls_mpi *)&TV.p,N), iVar3 == 0) {
LAB_23062562:
    iVar3 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&TV.p,N);
    if (iVar3 < 0) {
      iVar3 = mbedtls_mpi_copy(X,(mbedtls_mpi *)&TV.p);
      break;
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)&G.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TA.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TU.p);
  mbedtls_mpi_free((mbedtls_mpi *)&U1.p);
  mbedtls_mpi_free((mbedtls_mpi *)auStack140);
  mbedtls_mpi_free((mbedtls_mpi *)&U2.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TB.p);
  mbedtls_mpi_free((mbedtls_mpi *)&TV.p);
  mbedtls_mpi_free((mbedtls_mpi *)&V1.p);
LAB_230625d8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



uint mbedtls_cipher_get_block_size(mbedtls_cipher_context_t *ctx)

{
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info != (mbedtls_cipher_info_t *)0x0)
     ) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ctx->cipher_info->block_size;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void add_pkcs_padding(uchar *output,size_t output_len,size_t data_len)

{
  uint uVar1;
  
  uVar1 = 0;
  while (uVar1 < output_len - data_len) {
    output[data_len + uVar1] = (uchar)(output_len - data_len);
    uVar1 = uVar1 + 1 & 0xff;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int get_pkcs_padding(uchar *input,size_t input_len,size_t *data_len)

{
  byte bVar1;
  bool bVar2;
  byte *pbVar3;
  uint uVar4;
  byte bVar5;
  uint uVar6;
  
  if ((input == (uchar *)0x0) || (data_len == (size_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x6100;
  }
  bVar1 = input[input_len - 1];
  uVar6 = (uint)bVar1;
  bVar5 = input_len < uVar6 || uVar6 == 0;
  *data_len = input_len - uVar6;
  uVar4 = 0;
  while (uVar4 != input_len) {
    pbVar3 = input + uVar4;
    bVar2 = input_len - uVar6 <= uVar4;
    uVar4 = uVar4 + 1;
    bVar5 = bVar5 | bVar2 * (bVar1 ^ *pbVar3);
  }
  if (bVar5 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6200;
}



void add_zeros_padding(uchar *output,size_t output_len,size_t data_len)

{
  if (output_len <= data_len) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  output[data_len] = '\0';
  add_zeros_padding(output,output_len,data_len + 1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int get_no_padding(uchar *input,size_t input_len,size_t *data_len)

{
  if ((input != (uchar *)0x0) && (data_len != (size_t *)0x0)) {
    *data_len = input_len;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



int get_zeros_padding(uchar *input,size_t input_len,size_t *data_len)

{
  uint uVar1;
  uint uVar2;
  
  if ((input != (uchar *)0x0) && (data_len != (size_t *)0x0)) {
    *data_len = 0;
    uVar2 = 0;
    while (input_len != 0) {
      uVar1 = input[input_len - 1] != '\0' | uVar2;
      *data_len = (uVar2 ^ uVar1) * input_len | *data_len;
      input_len = input_len - 1;
      uVar2 = uVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



mbedtls_cipher_info_t * mbedtls_cipher_info_from_type(mbedtls_cipher_type_t cipher_type)

{
  undefined3 in_register_00002029;
  mbedtls_cipher_definition_t *pmVar1;
  
  pmVar1 = mbedtls_cipher_definitions;
  while ((pmVar1->info != (mbedtls_cipher_info_t *)0x0 &&
         ((uint)pmVar1->type != CONCAT31(in_register_00002029,cipher_type)))) {
    pmVar1 = pmVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar1->info;
}



mbedtls_cipher_info_t *
mbedtls_cipher_info_from_values
          (mbedtls_cipher_id_t cipher_id,int key_bitlen,mbedtls_cipher_mode_t mode)

{
  undefined3 in_register_00002029;
  undefined3 in_register_00002031;
  mbedtls_cipher_definition_t *pmVar1;
  mbedtls_cipher_info_t *pmVar2;
  
  pmVar1 = mbedtls_cipher_definitions;
  while ((pmVar2 = pmVar1->info, pmVar2 != (mbedtls_cipher_info_t *)0x0 &&
         ((((uint)pmVar2->base->cipher != CONCAT31(in_register_00002029,cipher_id) ||
           (pmVar2->key_bitlen != key_bitlen)) ||
          ((uint)pmVar2->mode != CONCAT31(in_register_00002031,mode)))))) {
    pmVar1 = pmVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar2;
}



void mbedtls_cipher_init(mbedtls_cipher_context_t *ctx)

{
  memset(ctx,0,0x40);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_cipher_free(mbedtls_cipher_context_t *ctx)

{
  mbedtls_cipher_context_t *pmVar1;
  
  if (ctx != (mbedtls_cipher_context_t *)0x0) {
    if (ctx->cipher_ctx != (void *)0x0) {
      (*ctx->cipher_info->base->ctx_free_func)(ctx->cipher_ctx);
    }
    pmVar1 = ctx + 1;
    while (ctx != pmVar1) {
      *(undefined *)&ctx->cipher_info = 0;
      ctx = (mbedtls_cipher_context_t *)((int)&ctx->cipher_info + 1);
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Exceeded maximum restarts with more pending

int mbedtls_cipher_setkey
              (mbedtls_cipher_context_t *ctx,uchar *key,int key_bitlen,mbedtls_operation_t operation
              )

{
  anon_subr_int_void_ptr_uchar_ptr_uint_for_setkey_enc_func *UNRECOVERED_JUMPTABLE;
  int iVar1;
  undefined3 in_register_00002035;
  mbedtls_cipher_info_t *pmVar2;
  
  if (((ctx != (mbedtls_cipher_context_t *)0x0) &&
      (pmVar2 = ctx->cipher_info, pmVar2 != (mbedtls_cipher_info_t *)0x0)) &&
     (((pmVar2->flags & 2U) != 0 || (pmVar2->key_bitlen == key_bitlen)))) {
    ctx->key_bitlen = key_bitlen;
    ctx->operation = operation;
    if ((CONCAT31(in_register_00002035,operation) == 1) ||
       ((pmVar2->mode + ~MBEDTLS_MODE_CBC & 0xfd) == 0)) {
      UNRECOVERED_JUMPTABLE = pmVar2->base->setkey_enc_func;
    }
    else {
      if (CONCAT31(in_register_00002035,operation) != 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x6100;
      }
      UNRECOVERED_JUMPTABLE =
           (anon_subr_int_void_ptr_uchar_ptr_uint_for_setkey_enc_func *)
           pmVar2->base->setkey_dec_func;
    }
                    // WARNING: Could not recover jumptable at 0x2306284c. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*UNRECOVERED_JUMPTABLE)(ctx->cipher_ctx);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



int mbedtls_cipher_set_iv(mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len)

{
  int iVar1;
  mbedtls_cipher_info_t *pmVar2;
  size_t __n;
  
  if (ctx == (mbedtls_cipher_context_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x6100;
  }
  pmVar2 = ctx->cipher_info;
  if ((pmVar2 != (mbedtls_cipher_info_t *)0x0) && (iv != (uchar *)0x0)) {
    if (0x10 < iv_len) {
      iVar1 = -0x6080;
      goto LAB_23062896;
    }
    __n = iv_len;
    if (((pmVar2->flags & 1U) != 0) || (__n = pmVar2->iv_size, __n <= iv_len)) {
      memcpy(ctx->iv,iv,__n);
      iVar1 = 0;
      ctx->iv_size = __n;
      goto LAB_23062896;
    }
  }
  iVar1 = -0x6100;
LAB_23062896:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_cipher_reset(mbedtls_cipher_context_t *ctx)

{
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info != (mbedtls_cipher_info_t *)0x0)
     ) {
    ctx->unprocessed_len = 0;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



int mbedtls_cipher_update
              (mbedtls_cipher_context_t *ctx,uchar *input,size_t ilen,uchar *output,size_t *olen)

{
  mbedtls_cipher_mode_t mVar1;
  uint uVar2;
  int iVar3;
  mbedtls_cipher_info_t *pmVar4;
  size_t sVar5;
  uint __n;
  
  if (ctx == (mbedtls_cipher_context_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x6100;
  }
  if ((ctx->cipher_info == (mbedtls_cipher_info_t *)0x0) || (olen == (size_t *)0x0)) {
LAB_230628d8:
    iVar3 = -0x6100;
    goto LAB_230628de;
  }
  *olen = 0;
  uVar2 = mbedtls_cipher_get_block_size(ctx);
  pmVar4 = ctx->cipher_info;
  mVar1 = pmVar4->mode;
  if (mVar1 == MBEDTLS_MODE_ECB) {
    if (uVar2 == ilen) {
      *olen = uVar2;
                    // WARNING: Could not recover jumptable at 0x2306295c. Too many branches
                    // WARNING: Treating indirect jump as call
      iVar3 = (*ctx->cipher_info->base->ecb_func)(ctx->cipher_ctx,ctx->operation,input,output);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar3;
    }
    iVar3 = -0x6280;
    goto LAB_230628de;
  }
  if (mVar1 == MBEDTLS_MODE_GCM) {
    *olen = ilen;
    iVar3 = mbedtls_gcm_update((mbedtls_gcm_context *)ctx->cipher_ctx,ilen,input,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar3;
  }
  if (uVar2 == 0) {
    iVar3 = -0x6380;
    goto LAB_230628de;
  }
  if ((input == output) && ((ctx->unprocessed_len != 0 || (ilen % uVar2 != 0)))) goto LAB_230628d8;
  if (mVar1 == MBEDTLS_MODE_CBC) {
    sVar5 = ctx->unprocessed_len;
    if (ctx->operation == MBEDTLS_DECRYPT) {
      if (uVar2 - sVar5 < ilen) goto LAB_230629d8;
LAB_230629b2:
      memcpy(ctx->unprocessed_data + sVar5,input,ilen);
      ctx->unprocessed_len = ilen + ctx->unprocessed_len;
    }
    else {
      if ((ctx->operation == MBEDTLS_ENCRYPT) && (ilen < uVar2 - sVar5)) goto LAB_230629b2;
LAB_230629d8:
      if (sVar5 != 0) {
        memcpy(ctx->unprocessed_data + sVar5,input,uVar2 - sVar5);
        iVar3 = (*ctx->cipher_info->base->cbc_func)
                          (ctx->cipher_ctx,ctx->operation,uVar2,ctx->iv,ctx->unprocessed_data,output
                          );
        if (iVar3 != 0) goto LAB_230628de;
        output = output + uVar2;
        *olen = *olen + uVar2;
        ctx->unprocessed_len = 0;
        input = input + (uVar2 - sVar5);
        ilen = (ilen + sVar5) - uVar2;
      }
      if (ilen != 0) {
        __n = ilen % uVar2;
        if ((__n == 0) && (ctx->operation == MBEDTLS_DECRYPT)) {
          __n = uVar2;
        }
        sVar5 = ilen - __n;
        memcpy(ctx->unprocessed_data,input + sVar5,__n);
        ctx->unprocessed_len = __n + ctx->unprocessed_len;
        if (sVar5 != 0) {
          iVar3 = (*ctx->cipher_info->base->cbc_func)
                            (ctx->cipher_ctx,ctx->operation,sVar5,ctx->iv,input,output);
          if (iVar3 != 0) goto LAB_230628de;
          ilen = sVar5 + *olen;
          goto LAB_23062a78;
        }
      }
    }
    iVar3 = 0;
  }
  else {
    if (mVar1 == MBEDTLS_MODE_CFB) {
      iVar3 = (*pmVar4->base->cfb_func)
                        (ctx->cipher_ctx,ctx->operation,ilen,&ctx->unprocessed_len,ctx->iv,input,
                         output);
    }
    else {
      if (mVar1 != MBEDTLS_MODE_CTR) {
        iVar3 = -0x6080;
        goto LAB_230628de;
      }
      iVar3 = (*pmVar4->base->ctr_func)
                        (ctx->cipher_ctx,ilen,&ctx->unprocessed_len,ctx->iv,ctx->unprocessed_data,
                         input,output);
    }
    if (iVar3 != 0) goto LAB_230628de;
LAB_23062a78:
    *olen = ilen;
  }
LAB_230628de:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_cipher_finish(mbedtls_cipher_context_t *ctx,uchar *output,size_t *olen)

{
  mbedtls_cipher_mode_t mVar1;
  int iVar2;
  uint uVar3;
  size_t sVar4;
  size_t sVar5;
  
  if (((ctx == (mbedtls_cipher_context_t *)0x0) ||
      (ctx->cipher_info == (mbedtls_cipher_info_t *)0x0)) || (olen == (size_t *)0x0)) {
    iVar2 = -0x6100;
    goto LAB_23062b4a;
  }
  *olen = 0;
  mVar1 = ctx->cipher_info->mode;
  if ((mVar1 == MBEDTLS_MODE_CFB) || ((byte)(mVar1 + ~MBEDTLS_MODE_OFB) < 3)) {
LAB_23062bc4:
    iVar2 = 0;
    goto LAB_23062b4a;
  }
  if (mVar1 == MBEDTLS_MODE_ECB) {
    sVar5 = ctx->unprocessed_len;
joined_r0x23062b46:
    iVar2 = 0;
    if (sVar5 == 0) goto LAB_23062b4a;
LAB_23062b24:
    iVar2 = -0x6280;
  }
  else {
    if (mVar1 != MBEDTLS_MODE_CBC) {
      iVar2 = -0x6080;
      goto LAB_23062b4a;
    }
    sVar5 = ctx->unprocessed_len;
    if (ctx->operation == MBEDTLS_ENCRYPT) {
      if (ctx->add_padding == (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0)
      goto joined_r0x23062b46;
      sVar4 = ctx->iv_size;
      if (sVar4 == 0) {
        sVar4 = ctx->cipher_info->iv_size;
      }
      (*ctx->add_padding)(ctx->unprocessed_data,sVar4,sVar5);
    }
    else {
      uVar3 = mbedtls_cipher_get_block_size(ctx);
      if (uVar3 != sVar5) {
        if ((ctx->add_padding == (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0) &&
           (sVar5 == 0)) goto LAB_23062bc4;
        goto LAB_23062b24;
      }
    }
    uVar3 = mbedtls_cipher_get_block_size(ctx);
    iVar2 = (*ctx->cipher_info->base->cbc_func)
                      (ctx->cipher_ctx,ctx->operation,uVar3,ctx->iv,ctx->unprocessed_data,output);
    if (iVar2 == 0) {
      uVar3 = mbedtls_cipher_get_block_size(ctx);
      if (ctx->operation == MBEDTLS_DECRYPT) {
                    // WARNING: Could not recover jumptable at 0x23062bb2. Too many branches
                    // WARNING: Treating indirect jump as call
        iVar2 = (*ctx->get_padding)(output,uVar3,olen);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return iVar2;
      }
      *olen = uVar3;
    }
  }
LAB_23062b4a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_cipher_set_padding_mode(mbedtls_cipher_context_t *ctx,mbedtls_cipher_padding_t mode)

{
  undefined3 in_register_0000202d;
  int iVar1;
  code *pcVar2;
  
  iVar1 = CONCAT31(in_register_0000202d,mode);
  if ((ctx != (mbedtls_cipher_context_t *)0x0) && (ctx->cipher_info->mode == MBEDTLS_MODE_CBC)) {
    if (iVar1 == 3) {
      ctx->add_padding = add_zeros_padding;
      pcVar2 = get_zeros_padding;
    }
    else {
      if (iVar1 == 4) {
        ctx->add_padding = (anon_subr_void_uchar_ptr_size_t_size_t_for_add_padding *)0x0;
        pcVar2 = get_no_padding;
      }
      else {
        if (iVar1 != 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return -0x6080;
        }
        ctx->add_padding = add_pkcs_padding;
        pcVar2 = get_pkcs_padding;
      }
    }
    ctx->get_padding = pcVar2;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



int mbedtls_cipher_setup(mbedtls_cipher_context_t *ctx,mbedtls_cipher_info_t *cipher_info)

{
  void *pvVar1;
  int iVar2;
  anon_subr_void_ptr_for_ctx_alloc_func *paVar3;
  
  if (cipher_info != (mbedtls_cipher_info_t *)0x0) {
    if (ctx == (mbedtls_cipher_context_t *)0x0) {
      iVar2 = -0x6100;
    }
    else {
      memset(ctx,0,0x40);
      paVar3 = cipher_info->base->ctx_alloc_func;
      pvVar1 = (*paVar3)(paVar3);
      ctx->cipher_ctx = pvVar1;
      if (pvVar1 == (void *)0x0) {
        iVar2 = -0x6180;
      }
      else {
        ctx->cipher_info = cipher_info;
        mbedtls_cipher_set_padding_mode(ctx,MBEDTLS_PADDING_PKCS7);
        iVar2 = 0;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6100;
}



int mbedtls_cipher_crypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *input,size_t ilen,
              uchar *output,size_t *olen)

{
  int iVar1;
  size_t sStack36;
  size_t finish_olen;
  
  iVar1 = mbedtls_cipher_set_iv(ctx,iv,iv_len);
  if ((((iVar1 == 0) && (iVar1 = mbedtls_cipher_reset(ctx), iVar1 == 0)) &&
      (iVar1 = mbedtls_cipher_update(ctx,input,ilen,output,olen), iVar1 == 0)) &&
     (iVar1 = mbedtls_cipher_finish(ctx,output + *olen,&sStack36), iVar1 == 0)) {
    *olen = *olen + sStack36;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_cipher_auth_encrypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *ad,size_t ad_len,
              uchar *input,size_t ilen,uchar *output,size_t *olen,uchar *tag,size_t tag_len)

{
  int iVar1;
  size_t *in_stack_00000000;
  
  if (ctx->cipher_info->mode == MBEDTLS_MODE_GCM) {
    *in_stack_00000000 = ilen;
    iVar1 = mbedtls_gcm_crypt_and_tag
                      ((mbedtls_gcm_context *)ctx->cipher_ctx,1,ilen,iv,iv_len,ad,ad_len,input,
                       (uchar *)olen,(size_t)tag,(uchar *)tag_len);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6080;
}



int mbedtls_cipher_auth_decrypt
              (mbedtls_cipher_context_t *ctx,uchar *iv,size_t iv_len,uchar *ad,size_t ad_len,
              uchar *input,size_t ilen,uchar *output,size_t *olen,uchar *tag,size_t tag_len)

{
  int iVar1;
  size_t *in_stack_00000000;
  uchar *in_stack_00000004;
  size_t in_stack_00000008;
  
  if (ctx->cipher_info->mode == MBEDTLS_MODE_GCM) {
    *in_stack_00000000 = ilen;
    iVar1 = mbedtls_gcm_auth_decrypt
                      ((mbedtls_gcm_context *)ctx->cipher_ctx,ilen,iv,iv_len,ad,ad_len,
                       in_stack_00000004,in_stack_00000008,(uchar *)olen,tag);
    if (iVar1 == -0x12) {
      iVar1 = -0x6300;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x6080;
}



void gcm_ctx_free(void *ctx)

{
  mbedtls_gcm_free((mbedtls_gcm_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * gcm_ctx_alloc(void)

{
  mbedtls_gcm_context *ctx;
  
  ctx = (mbedtls_gcm_context *)mycalloc(1,0x188);
  if (ctx != (mbedtls_gcm_context *)0x0) {
    mbedtls_gcm_init(ctx);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



int gcm_aes_setkey_wrap(void *ctx,uchar *key,uint key_bitlen)

{
  int iVar1;
  
  iVar1 = mbedtls_gcm_setkey((mbedtls_gcm_context *)ctx,MBEDTLS_CIPHER_ID_AES,key,key_bitlen);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void aes_ctx_free(void *ctx)

{
  mbedtls_aes_free((mbedtls_aes_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * aes_ctx_alloc(void)

{
  mbedtls_aes_context *ctx;
  
  ctx = (mbedtls_aes_context *)mycalloc(1,0x118);
  if (ctx != (mbedtls_aes_context *)0x0) {
    mbedtls_aes_init(ctx);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



int aes_setkey_dec_wrap(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  uint *puVar1;
  int iVar2;
  uint32_t *puVar3;
  uint uVar4;
  uint32_t *puVar5;
  int iVar6;
  mbedtls_aes_context mStack296;
  
  mbedtls_aes_init(&mStack296);
  ctx->rk = ctx->buf;
  iVar2 = mbedtls_aes_setkey_enc(&mStack296,key,keybits);
  if (iVar2 == 0) {
    ctx->nr = mStack296.nr;
    mStack296.rk = mStack296.rk + mStack296.nr * 4;
    ctx->buf[0] = *mStack296.rk;
    ctx->buf[1] = mStack296.rk[1];
    puVar3 = ctx->buf;
    ctx->buf[2] = mStack296.rk[2];
    ctx->buf[3] = mStack296.rk[3];
    while( true ) {
      puVar3 = puVar3 + 4;
      puVar5 = mStack296.rk + -4;
      mStack296.nr = mStack296.nr + -1;
      if (mStack296.nr < 1) break;
      iVar6 = 0;
      do {
        uVar4 = *(uint *)((int)puVar5 + iVar6);
        puVar1 = (uint *)((int)puVar3 + iVar6);
        iVar6 = iVar6 + 4;
        *puVar1 = RT2[FSb[uVar4 >> 0x10 & 0xff]] ^
                  RT0[FSb[uVar4 & 0xff]] ^ RT3[FSb[uVar4 >> 0x18]] ^ RT1[FSb[uVar4 >> 8 & 0xff]];
        mStack296.rk = puVar5;
      } while (iVar6 != 0x10);
    }
    *puVar3 = *puVar5;
    puVar3[1] = mStack296.rk[-3];
    puVar3[2] = mStack296.rk[-2];
    puVar3[3] = mStack296.rk[-1];
  }
  mbedtls_aes_free(&mStack296);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int aes_setkey_enc_wrap(mbedtls_aes_context *ctx,uchar *key,uint keybits)

{
  int iVar1;
  byte *pbVar2;
  uint32_t *puVar3;
  uint uVar4;
  int iVar5;
  uint32_t *puVar6;
  uint32_t *puVar7;
  uint uVar8;
  
  if (aes_init_done == 0) {
    aes_gen_tables();
    aes_init_done = 1;
  }
  if (keybits == 0xc0) {
    iVar1 = 0xc;
  }
  else {
    if (keybits == 0x100) {
      iVar1 = 0xe;
    }
    else {
      iVar1 = -0x20;
      if (keybits != 0x80) goto LAB_2305fa9e;
      iVar1 = 10;
    }
  }
  ctx->nr = iVar1;
  puVar6 = ctx->buf;
  ctx->rk = puVar6;
  pbVar2 = key;
  puVar3 = puVar6;
  while (key + (keybits >> 5) * 4 != pbVar2) {
    *puVar3 = (uint)pbVar2[1] << 8 | (uint)pbVar2[2] << 0x10 | (uint)*pbVar2 |
              (uint)pbVar2[3] << 0x18;
    pbVar2 = pbVar2 + 4;
    puVar3 = puVar3 + 1;
  }
  iVar5 = ctx->nr;
  if (iVar5 == 0xc) {
    puVar3 = RCON;
    do {
      uVar4 = puVar6[5];
      uVar8 = *puVar3;
      puVar7 = puVar6 + 6;
      puVar3 = puVar3 + 1;
      uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
              (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
      *puVar7 = uVar8;
      uVar8 = uVar8 ^ puVar6[1];
      puVar6[7] = uVar8;
      uVar8 = uVar8 ^ puVar6[2];
      puVar6[8] = uVar8;
      uVar8 = uVar8 ^ puVar6[3];
      puVar6[9] = uVar8;
      uVar8 = uVar8 ^ puVar6[4];
      puVar6[10] = uVar8;
      puVar6[0xb] = uVar8 ^ uVar4;
      puVar6 = puVar7;
    } while (puVar7 != ctx->buf + 0x30);
  }
  else {
    if (iVar5 == 0xe) {
      puVar3 = RCON;
      do {
        uVar4 = puVar6[7];
        uVar8 = *puVar3;
        puVar7 = puVar6 + 8;
        puVar3 = puVar3 + 1;
        uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
                (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
        *puVar7 = uVar8;
        uVar8 = uVar8 ^ puVar6[1];
        puVar6[9] = uVar8;
        uVar8 = uVar8 ^ puVar6[2];
        puVar6[10] = uVar8;
        uVar8 = uVar8 ^ puVar6[3];
        puVar6[0xb] = uVar8;
        uVar8 = (uint)FSb[uVar8 >> 0x10 & 0xff] << 0x10 ^
                (uint)FSb[uVar8 & 0xff] ^ puVar6[4] ^ (uint)FSb[uVar8 >> 0x18] << 0x18 ^
                (uint)FSb[uVar8 >> 8 & 0xff] << 8;
        puVar6[0xc] = uVar8;
        uVar8 = uVar8 ^ puVar6[5];
        puVar6[0xd] = uVar8;
        uVar8 = uVar8 ^ puVar6[6];
        puVar6[0xe] = uVar8;
        puVar6[0xf] = uVar8 ^ uVar4;
        puVar6 = puVar7;
      } while (puVar7 != ctx->buf + 0x38);
    }
    else {
      iVar1 = 0;
      if (iVar5 != 10) goto LAB_2305fa9e;
      puVar3 = RCON;
      do {
        uVar4 = puVar6[3];
        uVar8 = *puVar3;
        puVar7 = puVar6 + 4;
        puVar3 = puVar3 + 1;
        uVar8 = (uint)FSb[uVar4 >> 8 & 0xff] ^ *puVar6 ^ uVar8 ^ (uint)FSb[uVar4 >> 0x18] << 0x10 ^
                (uint)FSb[uVar4 & 0xff] << 0x18 ^ (uint)FSb[uVar4 >> 0x10 & 0xff] << 8;
        *puVar7 = uVar8;
        uVar8 = uVar8 ^ puVar6[1];
        puVar6[5] = uVar8;
        uVar8 = uVar8 ^ puVar6[2];
        puVar6[6] = uVar8;
        puVar6[7] = uVar8 ^ uVar4;
        puVar6 = puVar7;
      } while (puVar7 != ctx->buf + 0x28);
    }
  }
  iVar1 = 0;
LAB_2305fa9e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int aes_crypt_ctr_wrap(mbedtls_aes_context *ctx,size_t length,size_t *nc_off,uchar *nonce_counter,
                      uchar *stream_block,uchar *input,uchar *output)

{
  bool bVar1;
  uchar uVar2;
  uint uVar3;
  uchar *puVar4;
  byte *pbVar5;
  
  uVar3 = *nc_off;
  pbVar5 = output;
  do {
    if (pbVar5 == output + length) {
      *nc_off = uVar3;
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (uVar3 == 0) {
      mbedtls_aes_encrypt(ctx,nonce_counter,stream_block);
      puVar4 = nonce_counter + 0xf;
      do {
        uVar2 = *puVar4;
        *puVar4 = uVar2 + '\x01';
        if ((uchar)(uVar2 + '\x01') != '\0') break;
        bVar1 = nonce_counter != puVar4;
        puVar4 = puVar4 + -1;
      } while (bVar1);
    }
    *pbVar5 = stream_block[uVar3] ^ *input;
    uVar3 = uVar3 + 1 & 0xf;
    input = input + 1;
    pbVar5 = pbVar5 + 1;
  } while( true );
}



int aes_crypt_cfb128_wrap
              (mbedtls_aes_context *ctx,int mode,size_t length,size_t *iv_off,uchar *iv,uchar *input
              ,uchar *output)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  
  uVar1 = *iv_off;
  pbVar2 = output;
  if (mode == 0) {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = *input;
      *pbVar2 = iv[uVar1] ^ bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  else {
    while (pbVar2 != output + length) {
      if (uVar1 == 0) {
        mbedtls_aes_encrypt(ctx,iv,iv);
      }
      bVar3 = iv[uVar1] ^ *input;
      *pbVar2 = bVar3;
      iv[uVar1] = bVar3;
      uVar1 = uVar1 + 1 & 0xf;
      pbVar2 = pbVar2 + 1;
      input = input + 1;
    }
  }
  *iv_off = uVar1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int aes_crypt_cbc_wrap(mbedtls_aes_context *ctx,int mode,size_t length,uchar *iv,uchar *input,
                      uchar *output)

{
  uint uVar1;
  int iVar2;
  byte *pbVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *puVar6;
  undefined auStack64 [24];
  
  uVar1 = length & 0xf;
  if (uVar1 == 0) {
    if (mode == 0) {
      while( true ) {
        puVar6 = output + -uVar1;
        if (uVar1 + length == 0) break;
        memcpy(auStack64,input + -uVar1,0x10);
        mbedtls_aes_decrypt(ctx,input + -uVar1,puVar6);
        iVar2 = 0;
        do {
          pbVar3 = puVar6 + iVar2;
          pbVar4 = iv + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar3 = *pbVar4 ^ *pbVar3;
        } while (iVar2 != 0x10);
        memcpy(iv,auStack64,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    else {
      while( true ) {
        puVar6 = output + -uVar1;
        if (length + uVar1 == 0) break;
        iVar2 = 0;
        do {
          pbVar5 = input + -uVar1 + iVar2;
          pbVar3 = iv + iVar2;
          pbVar4 = puVar6 + iVar2;
          iVar2 = iVar2 + 1;
          *pbVar4 = *pbVar5 ^ *pbVar3;
        } while (iVar2 != 0x10);
        mbedtls_aes_crypt_ecb(ctx,mode,puVar6,puVar6);
        memcpy(iv,puVar6,0x10);
        uVar1 = uVar1 - 0x10;
      }
    }
    iVar2 = 0;
  }
  else {
    iVar2 = -0x22;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int aes_crypt_ecb_wrap(mbedtls_aes_context *ctx,int mode,uchar *input,uchar *output)

{
  if (mode == 1) {
    mbedtls_aes_encrypt(ctx,input,output);
  }
  else {
    mbedtls_aes_decrypt(ctx,input,output);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void debug_send_line(int level,char *file,int line,char *str)

{
                    // WARNING: Could not recover jumptable at 0x23062e18. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(level + 0x10))(*(undefined4 *)(level + 0x14));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_mpi
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,mbedtls_mpi *X)

{
  int iVar1;
  size_t sVar2;
  int iVar3;
  bool bVar4;
  uint uVar5;
  uint uVar6;
  char acStack576 [4];
  char str [512];
  
  sVar2 = X->n;
  do {
    sVar2 = sVar2 - 1;
    if (sVar2 == 0) break;
  } while (X->p[sVar2] == 0);
  uVar5 = 0x1f;
  do {
    if ((X->p[sVar2] >> (uVar5 & 0x1f) & 1) != 0) break;
    uVar5 = uVar5 - 1;
  } while (uVar5 != 0xffffffff);
  snprintf(acStack576,0x200,"value of \'%s\' (%d bits) is:\n",text,sVar2 * 0x20 + 1 + uVar5);
  debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  iVar1 = 0;
  bVar4 = true;
  uVar5 = 0;
  while (sVar2 != 0xffffffff) {
    if ((!bVar4) || (X->p[sVar2] != 0)) {
      uVar6 = 0x18;
      do {
        if ((!bVar4) || ((X->p[sVar2] >> (uVar6 & 0x1f) & 0xff) != 0)) {
          if (((uVar5 & 0xf) == 0) && (uVar5 != 0)) {
            snprintf(acStack576 + iVar1,0x200 - iVar1,"\n");
            debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
            iVar1 = 0;
          }
          iVar3 = snprintf(acStack576 + iVar1,0x200 - iVar1," %02x",
                           X->p[sVar2] >> (uVar6 & 0x1f) & 0xff);
          iVar1 = iVar1 + iVar3;
          uVar5 = uVar5 + 1;
          bVar4 = false;
        }
        uVar6 = uVar6 - 8;
      } while (uVar6 != 0xfffffff8);
    }
    sVar2 = sVar2 - 1;
  }
  if (bVar4) {
    iVar3 = snprintf(acStack576 + iVar1,0x200 - iVar1," 00");
    iVar1 = iVar1 + iVar3;
  }
  snprintf(acStack576 + iVar1,0x200 - iVar1,"\n");
  debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_msg
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *format,...)

{
  uint uVar1;
  undefined4 in_a5;
  undefined4 in_a6;
  undefined4 in_a7;
  va_list argp;
  char str [512];
  undefined4 uStack12;
  undefined4 uStack8;
  undefined4 uStack4;
  
  if ((((ssl != (mbedtls_ssl_context *)0x0) && (ssl->conf != (mbedtls_ssl_config_conflict *)0x0)) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    uStack12 = in_a5;
    uStack8 = in_a6;
    uStack4 = in_a7;
    uVar1 = vsnprintf((char *)&argp,0x200,format,&uStack12);
    if (uVar1 < 0x1ff) {
      str[uVar1 - 4] = '\n';
      str[uVar1 - 3] = '\0';
    }
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_ret
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,int ret)

{
  char acStack544 [4];
  char str [512];
  
  if ((((ssl->conf != (mbedtls_ssl_config_conflict *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (level <= debug_threshold)) && (ret != -0x6900)) {
    snprintf(acStack544,0x200,"%s() returned %d (-0x%04x)\n",text,ret,-ret);
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_buf
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,uchar *buf,
               size_t len)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  uint uVar4;
  byte abStack596 [4];
  char txt [17];
  char str [512];
  
  if (((ssl->conf != (mbedtls_ssl_config_conflict *)0x0) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    snprintf(txt + 0x10,0x200,"dumping \'%s\' (%u bytes)\n",text,len);
    debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
    memset(abStack596,0,0x11);
    iVar3 = 0;
    uVar4 = 0;
    while (uVar4 != len) {
      if (uVar4 == 0x1000) goto LAB_23063198;
      if ((uVar4 & 0xf) == 0) {
        if (uVar4 != 0) {
          snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"  %s\n",abStack596);
          debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
          memset(abStack596,0,0x11);
          iVar3 = 0;
        }
        iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"%04x: ",uVar4);
        iVar3 = iVar3 + iVar1;
      }
      iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3," %02x",(uint)buf[uVar4]);
      iVar3 = iVar3 + iVar1;
      bVar2 = buf[uVar4];
      if (0x5e < (byte)(bVar2 - 0x20)) {
        bVar2 = 0x2e;
      }
      abStack596[uVar4 & 0xf] = bVar2;
      uVar4 = uVar4 + 1;
    }
    if (len != 0) {
      while( true ) {
        if ((len & 0xf) == 0) break;
        iVar1 = snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"   ");
        iVar3 = iVar3 + iVar1;
        len = len + 1;
      }
LAB_23063198:
      snprintf(txt + iVar3 + 0x10,0x200 - iVar3,"  %s\n",abStack596);
      debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_mpi
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,mbedtls_mpi *X)

{
  if ((((ssl->conf != (mbedtls_ssl_config_conflict *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (X != (mbedtls_mpi *)0x0)) && (level <= debug_threshold)) {
    mbedtls_debug_print_mpi(ssl,level,file,line,text,X);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_ecp
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_ecp_point *X)

{
  char acStack544 [4];
  char str [512];
  
  snprintf(acStack544,0x200,"%s(X)",text);
  mbedtls_debug_print_mpi(ssl,level,file,line,acStack544,(mbedtls_mpi *)X);
  snprintf(acStack544,0x200,"%s(Y)",text);
  mbedtls_debug_print_mpi(ssl,level,file,line,acStack544,&X->Y);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_ecp
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_ecp_point *X)

{
  if (((ssl->conf != (mbedtls_ssl_config_conflict *)0x0) &&
      (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
     (level <= debug_threshold)) {
    mbedtls_debug_print_ecp(ssl,level,file,line,text,X);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_debug_print_crt
               (mbedtls_ssl_context *ssl,int level,char *file,int line,char *text,
               mbedtls_x509_crt *crt)

{
  int iVar1;
  mbedtls_ssl_config_conflict *level_00;
  char *__src;
  int iVar2;
  void **ppvVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcStack2132;
  char acStack2128 [4];
  char name [16];
  char str [512];
  mbedtls_pk_debug_item items [3];
  char local_440 [4];
  char buf [1024];
  
  if ((((ssl->conf != (mbedtls_ssl_config_conflict *)0x0) &&
       (ssl->conf->f_dbg != (anon_subr_void_void_ptr_int_char_ptr_int_char_ptr_for_f_dbg *)0x0)) &&
      (crt != (mbedtls_x509_crt *)0x0)) && (iVar2 = 0, level <= debug_threshold)) {
    pcStack2132 = text;
    do {
      iVar2 = iVar2 + 1;
      snprintf(name + 0xc,0x200,"%s #%d:\n",pcStack2132,iVar2);
      debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
      mbedtls_x509_crt_info(local_440,0x3ff,"",crt);
      __src = local_440;
      pcVar5 = local_440;
      while (pcVar4 = pcVar5, *pcVar4 != '\0') {
        pcVar5 = pcVar4 + 1;
        if (*pcVar4 == '\n') {
          pcVar4 = pcVar4 + (1 - (int)__src);
          if ((char *)0x1ff < pcVar4) {
            pcVar4 = (char *)0x1ff;
          }
          memcpy(str + 0x1fc,__src,(size_t)pcVar4);
          level_00 = ssl->conf;
          *(undefined *)((int)pcVar4 + (int)register0x00002008 + -0x640) = 0;
          debug_send_line((int)level_00,(char *)level,(int)file,(char *)line);
          __src = pcVar5;
        }
      }
      memset(str + 0x1fc,0,0x24);
      iVar1 = mbedtls_pk_debug(&crt->pk,(mbedtls_pk_debug_item *)(str + 0x1fc));
      if (iVar1 == 0) {
        ppvVar3 = (void **)(str + 0x1fc);
        do {
          if (*(char *)ppvVar3 == '\0') break;
          snprintf(acStack2128,0x10,"%s%s",&UNK_2308b034,ppvVar3[1]);
          name[11] = '\0';
          if (*(char *)ppvVar3 == '\x01') {
            mbedtls_debug_print_mpi(ssl,level,file,line,acStack2128,(mbedtls_mpi *)ppvVar3[2]);
          }
          else {
            if (*(char *)ppvVar3 == '\x02') {
              mbedtls_debug_print_ecp
                        (ssl,level,file,line,acStack2128,(mbedtls_ecp_point *)ppvVar3[2]);
            }
            else {
              debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
            }
          }
          ppvVar3 = ppvVar3 + 3;
        } while (ppvVar3 != &items[2].value);
      }
      else {
        debug_send_line((int)ssl->conf,(char *)level,(int)file,(char *)line);
      }
      crt = crt->next;
    } while (crt != (mbedtls_x509_crt *)0x0);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



ecp_curve_type ecp_get_type(mbedtls_ecp_group *grp)

{
  if ((grp->G).X.p != (mbedtls_mpi_uint *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return ((grp->G).Y.p == (mbedtls_mpi_uint *)0x0) + ECP_TYPE_SHORT_WEIERSTRASS;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ECP_TYPE_NONE;
}



// WARNING: Variable defined which should be unmapped: mQY

int ecp_safe_invert_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *Q,uchar inv)

{
  mbedtls_mpi *B;
  int iVar1;
  undefined auStack28 [4];
  mbedtls_mpi mQY;
  
  B = &Q->Y;
  mbedtls_mpi_init((mbedtls_mpi *)auStack28);
  iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack28,&grp->P,B);
  if (iVar1 == 0) {
    iVar1 = mbedtls_mpi_cmp_int(B,0);
    iVar1 = mbedtls_mpi_safe_cond_assign(B,(mbedtls_mpi *)auStack28,inv & iVar1 != 0);
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack28);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_select_comb(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *T,uchar t_len,
                   uchar i)

{
  bool assign;
  uint uVar1;
  int iVar2;
  undefined3 in_register_00002035;
  undefined3 in_register_00002039;
  
  uVar1 = 0;
  while( true ) {
    assign = (i & 0x7e) >> 1 == uVar1;
    iVar2 = mbedtls_mpi_safe_cond_assign((mbedtls_mpi *)R,(mbedtls_mpi *)T,assign);
    if ((iVar2 != 0) || (iVar2 = mbedtls_mpi_safe_cond_assign(&R->Y,&T->Y,assign), iVar2 != 0))
    break;
    uVar1 = uVar1 + 1 & 0xff;
    T = T + 1;
    if (CONCAT31(in_register_00002035,t_len) == uVar1) {
      iVar2 = ecp_safe_invert_jac(grp,R,(uchar)(CONCAT31(in_register_00002039,i) >> 7));
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int ecp_modp(mbedtls_mpi *N,mbedtls_ecp_group *grp)

{
  mbedtls_mpi *B;
  int iVar1;
  size_t sVar2;
  int iVar3;
  int iVar4;
  
  if (grp->modp == (anon_subr_int_mbedtls_mpi_ptr_for_modp *)0x0) {
    iVar1 = mbedtls_mpi_mod_mpi(N,N,&grp->P);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  if (((N->s < 0) && (iVar1 = mbedtls_mpi_cmp_int(N,0), iVar1 != 0)) ||
     (sVar2 = mbedtls_mpi_bitlen(N), grp->pbits << 1 < sVar2)) {
    iVar1 = -0x4f80;
  }
  else {
    B = &grp->P;
    iVar3 = (*grp->modp)(N);
    iVar1 = iVar3;
    while (iVar1 == 0) {
      if ((-1 < N->s) || (iVar1 = mbedtls_mpi_cmp_int(N,0), iVar1 == 0)) goto LAB_230636c2;
      iVar1 = mbedtls_mpi_add_mpi(N,N,B);
    }
  }
  goto LAB_2306368e;
  while (iVar1 = mbedtls_mpi_sub_abs(N,N,B), iVar1 == 0) {
LAB_230636c2:
    iVar4 = mbedtls_mpi_cmp_mpi(N,B);
    iVar1 = iVar3;
    if (iVar4 < 0) break;
  }
LAB_2306368e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_double_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *P)

{
  mbedtls_mpi *X;
  int iVar1;
  mbedtls_mpi *pmVar2;
  mbedtls_mpi *Y;
  undefined auStack96 [4];
  mbedtls_mpi M;
  mbedtls_mpi S;
  mbedtls_mpi T;
  mbedtls_mpi U;
  
  X = (mbedtls_mpi *)&M.p;
  mbedtls_mpi_init((mbedtls_mpi *)auStack96);
  mbedtls_mpi_init(X);
  mbedtls_mpi_init((mbedtls_mpi *)&S.p);
  mbedtls_mpi_init((mbedtls_mpi *)&T.p);
  if ((grp->A).p == (mbedtls_mpi_uint *)0x0) {
    iVar1 = mbedtls_mpi_mul_mpi(X,&P->Z,&P->Z);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)P,X);
      pmVar2 = &grp->P;
      while (iVar1 == 0) {
        iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&S.p,pmVar2);
        if (iVar1 < 0) {
          iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)P,X);
          goto LAB_230637aa;
        }
        iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,pmVar2);
      }
    }
  }
  else {
    iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)P,(mbedtls_mpi *)P);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)auStack96,X,3);
      pmVar2 = &grp->P;
      while (iVar1 == 0) {
        iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,pmVar2);
        if (iVar1 < 0) {
          iVar1 = mbedtls_mpi_cmp_int(&grp->A,0);
          if (iVar1 == 0) goto LAB_230637e8;
          iVar1 = mbedtls_mpi_mul_mpi(X,&P->Z,&P->Z);
          if (((((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) &&
               (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,X,X), iVar1 == 0)) &&
              ((iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0 &&
               (iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)&S.p,&grp->A), iVar1 == 0)))) &&
             (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
            iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,X);
            goto LAB_23063a66;
          }
          break;
        }
        iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,pmVar2);
      }
    }
  }
  goto cleanup;
LAB_23063a66:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,pmVar2);
  if (iVar1 < 0) goto LAB_230637e8;
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,pmVar2);
  goto LAB_23063a66;
LAB_230637aa:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)&S.p,(mbedtls_mpi *)&T.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)auStack96,X,3);
      goto LAB_230637d8;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,pmVar2);
  goto LAB_230637aa;
LAB_230637d8:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack96,pmVar2);
  if (iVar1 < 0) goto LAB_230637e8;
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack96,(mbedtls_mpi *)auStack96,pmVar2);
  goto LAB_230637d8;
LAB_23063848:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi(X,Y);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&T.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&T.p,1);
      goto LAB_23063880;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs(X,X,Y);
  goto LAB_23063848;
LAB_23063880:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&T.p,Y);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)auStack96,
                                (mbedtls_mpi *)auStack96);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,X);
      goto LAB_230638ba;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,Y);
  goto LAB_23063880;
LAB_230638ba:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)S.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&S.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,X);
    goto LAB_230638d0;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y);
  goto LAB_230638ba;
LAB_230638d0:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)S.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&S.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi(X,X,(mbedtls_mpi *)&S.p);
    goto LAB_230638e6;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y);
  goto LAB_230638d0;
LAB_230638e6:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)M.p) || (iVar1 = mbedtls_mpi_cmp_int(X,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)auStack96);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi(X,X,(mbedtls_mpi *)&T.p);
      goto joined_r0x2306391e;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi(X,X,Y);
  goto LAB_230638e6;
joined_r0x2306391e:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)M.p) || (iVar1 = mbedtls_mpi_cmp_int(X,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T.p,pmVar2,&P->Z);
    if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&T.p,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&T.p,1);
      goto LAB_23063950;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi(X,X,Y);
  goto joined_r0x2306391e;
LAB_23063950:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&T.p,Y);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)R,(mbedtls_mpi *)&S.p);
    if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&R->Y,(mbedtls_mpi *)&M.p), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_copy(&R->Z,(mbedtls_mpi *)&T.p);
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&T.p,(mbedtls_mpi *)&T.p,Y);
  goto LAB_23063950;
LAB_230637e8:
  pmVar2 = &P->Y;
  iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&S.p,pmVar2,pmVar2);
  if ((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&S.p,grp), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_shift_l((mbedtls_mpi *)&S.p,1);
    Y = &grp->P;
    while (iVar1 == 0) {
      iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&S.p,Y);
      if (iVar1 < 0) {
        iVar1 = mbedtls_mpi_mul_mpi(X,(mbedtls_mpi *)P,(mbedtls_mpi *)&S.p);
        if ((iVar1 == 0) && (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
          iVar1 = mbedtls_mpi_shift_l(X,1);
          goto LAB_23063848;
        }
        break;
      }
      iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&S.p,(mbedtls_mpi *)&S.p,Y);
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack96);
  mbedtls_mpi_free(X);
  mbedtls_mpi_free((mbedtls_mpi *)&S.p);
  mbedtls_mpi_free((mbedtls_mpi *)&T.p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_normalize_jac(mbedtls_ecp_group *grp,mbedtls_ecp_point *pt)

{
  mbedtls_mpi *X;
  int iVar1;
  mbedtls_mpi *X_00;
  undefined auStack56 [4];
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  
  X_00 = &pt->Z;
  iVar1 = mbedtls_mpi_cmp_int(X_00,0);
  if (iVar1 != 0) {
    mbedtls_mpi_init((mbedtls_mpi *)auStack56);
    mbedtls_mpi_init((mbedtls_mpi *)&Zi.p);
    iVar1 = mbedtls_mpi_inv_mod((mbedtls_mpi *)auStack56,X_00,&grp->P);
    if ((((iVar1 == 0) &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Zi.p,(mbedtls_mpi *)auStack56,
                                      (mbedtls_mpi *)auStack56), iVar1 == 0)) &&
        (iVar1 = ecp_modp((mbedtls_mpi *)&Zi.p,grp), iVar1 == 0)) &&
       ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)pt,(mbedtls_mpi *)pt,(mbedtls_mpi *)&Zi.p),
        iVar1 == 0 && (iVar1 = ecp_modp((mbedtls_mpi *)pt,grp), iVar1 == 0)))) {
      X = &pt->Y;
      iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)&Zi.p);
      if (((iVar1 == 0) &&
          ((iVar1 = ecp_modp(X,grp), iVar1 == 0 &&
           (iVar1 = mbedtls_mpi_mul_mpi(X,X,(mbedtls_mpi *)auStack56), iVar1 == 0)))) &&
         (iVar1 = ecp_modp(X,grp), iVar1 == 0)) {
        iVar1 = mbedtls_mpi_lset(X_00,1);
      }
    }
    mbedtls_mpi_free((mbedtls_mpi *)auStack56);
    mbedtls_mpi_free((mbedtls_mpi *)&Zi.p);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_normalize_jac_many(mbedtls_ecp_group *grp,mbedtls_ecp_point **T,size_t t_len)

{
  mbedtls_ecp_point **ppmVar1;
  size_t sVar2;
  mbedtls_ecp_point **ppmVar3;
  mbedtls_mpi *pmVar4;
  int iVar5;
  mbedtls_mpi *X;
  size_t sVar6;
  mbedtls_mpi *pmVar7;
  undefined auStack84 [4];
  mbedtls_mpi u;
  mbedtls_mpi Zi;
  mbedtls_mpi ZZi;
  
  if (t_len < 2) {
    iVar5 = ecp_normalize_jac(grp,*T);
  }
  else {
    X = (mbedtls_mpi *)mycalloc(t_len,0xc);
    if (X == (mbedtls_mpi *)0x0) {
      iVar5 = -0x4d80;
    }
    else {
      mbedtls_mpi_init((mbedtls_mpi *)auStack84);
      mbedtls_mpi_init((mbedtls_mpi *)&u.p);
      mbedtls_mpi_init((mbedtls_mpi *)&Zi.p);
      iVar5 = mbedtls_mpi_copy(X,&(*T)->Z);
      if (iVar5 == 0) {
        sVar2 = 1;
        pmVar4 = X;
        do {
          sVar6 = sVar2;
          pmVar7 = pmVar4 + 1;
          iVar5 = mbedtls_mpi_mul_mpi(pmVar7,pmVar4,&T[sVar6]->Z);
          if ((iVar5 != 0) || (iVar5 = ecp_modp(pmVar7,grp), iVar5 != 0)) goto cleanup;
          sVar2 = sVar6 + 1;
          pmVar4 = pmVar7;
        } while (t_len != sVar6 + 1);
        iVar5 = mbedtls_mpi_inv_mod((mbedtls_mpi *)auStack84,X + (t_len - 1),&grp->P);
        if (iVar5 == 0) {
          ppmVar3 = T + t_len;
          do {
            if (sVar6 == 0) {
              iVar5 = mbedtls_mpi_copy((mbedtls_mpi *)&u.p,(mbedtls_mpi *)auStack84);
            }
            else {
              iVar5 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&u.p,(mbedtls_mpi *)auStack84,
                                          X + (sVar6 - 1));
              if (((iVar5 != 0) || (iVar5 = ecp_modp((mbedtls_mpi *)&u.p,grp), iVar5 != 0)) ||
                 (iVar5 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack84,(mbedtls_mpi *)auStack84,
                                              &ppmVar3[-1]->Z), iVar5 != 0)) break;
              iVar5 = ecp_modp((mbedtls_mpi *)auStack84,grp);
            }
            if (((((iVar5 != 0) ||
                  (iVar5 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Zi.p,(mbedtls_mpi *)&u.p,
                                               (mbedtls_mpi *)&u.p), iVar5 != 0)) ||
                 ((iVar5 = ecp_modp((mbedtls_mpi *)&Zi.p,grp), iVar5 != 0 ||
                  ((iVar5 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)ppmVar3[-1],
                                                (mbedtls_mpi *)ppmVar3[-1],(mbedtls_mpi *)&Zi.p),
                   iVar5 != 0 || (iVar5 = ecp_modp((mbedtls_mpi *)ppmVar3[-1],grp), iVar5 != 0))))))
                || (iVar5 = mbedtls_mpi_mul_mpi(&ppmVar3[-1]->Y,&ppmVar3[-1]->Y,(mbedtls_mpi *)&Zi.p
                                               ), iVar5 != 0)) ||
               ((((iVar5 = ecp_modp(&ppmVar3[-1]->Y,grp), iVar5 != 0 ||
                  (iVar5 = mbedtls_mpi_mul_mpi(&ppmVar3[-1]->Y,&ppmVar3[-1]->Y,(mbedtls_mpi *)&u.p),
                  iVar5 != 0)) || (iVar5 = ecp_modp(&ppmVar3[-1]->Y,grp), iVar5 != 0)) ||
                ((iVar5 = mbedtls_mpi_shrink((mbedtls_mpi *)ppmVar3[-1],(grp->P).n), iVar5 != 0 ||
                 (iVar5 = mbedtls_mpi_shrink(&ppmVar3[-1]->Y,(grp->P).n), iVar5 != 0)))))) break;
            ppmVar1 = ppmVar3 + -1;
            ppmVar3 = ppmVar3 + -1;
            mbedtls_mpi_free(&(*ppmVar1)->Z);
            if (sVar6 == 0) break;
            sVar6 = sVar6 - 1;
          } while( true );
        }
      }
cleanup:
      mbedtls_mpi_free((mbedtls_mpi *)auStack84);
      mbedtls_mpi_free((mbedtls_mpi *)&u.p);
      mbedtls_mpi_free((mbedtls_mpi *)&Zi.p);
      pmVar4 = X;
      do {
        pmVar7 = pmVar4 + 1;
        mbedtls_mpi_free(pmVar4);
        pmVar4 = pmVar7;
      } while (X + t_len != pmVar7);
      vPortFree(X);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar5;
}



void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)

{
  mbedtls_mpi_init((mbedtls_mpi *)pt);
  mbedtls_mpi_init(&pt->Y);
  mbedtls_mpi_init(&pt->Z);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)

{
  mbedtls_mpi_free((mbedtls_mpi *)pt);
  mbedtls_mpi_free(&pt->Y);
  mbedtls_mpi_free(&pt->Z);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mbedtls_ecp_group_id * mbedtls_ecp_grp_id_list(void)

{
  int iVar1;
  mbedtls_ecp_curve_info *pmVar2;
  
  if (mbedtls_ecp_grp_id_list::init_done == 0) {
    iVar1 = 0;
    pmVar2 = ecp_supported_curves;
    while (pmVar2->grp_id != MBEDTLS_ECP_DP_NONE) {
      ecp_supported_grp_id[iVar1] = pmVar2->grp_id;
      pmVar2 = pmVar2 + 1;
      iVar1 = iVar1 + 1;
    }
    ecp_supported_grp_id[iVar1] = MBEDTLS_ECP_DP_NONE;
    mbedtls_ecp_grp_id_list::init_done = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ecp_supported_grp_id;
}



void mbedtls_ecp_point_init(mbedtls_ecp_point *pt)

{
  if (pt != (mbedtls_ecp_point *)0x0) {
    mbedtls_ecp_point_init(pt);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_group_init(mbedtls_ecp_group *grp)

{
  if (grp != (mbedtls_ecp_group *)0x0) {
    memset(grp,0,0x7c);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_keypair_init(mbedtls_ecp_keypair *key)

{
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_group_init((mbedtls_ecp_group *)key);
    mbedtls_mpi_init(&key->d);
    mbedtls_ecp_point_init(&key->Q);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_point_free(mbedtls_ecp_point *pt)

{
  if (pt != (mbedtls_ecp_point *)0x0) {
    mbedtls_ecp_point_free(pt);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_group_free(mbedtls_ecp_group *grp)

{
  uint uVar1;
  mbedtls_ecp_group *pmVar2;
  
  if (grp != (mbedtls_ecp_group *)0x0) {
    if (grp->h != 1) {
      mbedtls_mpi_free(&grp->P);
      mbedtls_mpi_free(&grp->A);
      mbedtls_mpi_free(&grp->B);
      mbedtls_ecp_point_free(&grp->G);
      mbedtls_mpi_free(&grp->N);
    }
    uVar1 = 0;
    if (grp->T != (mbedtls_ecp_point *)0x0) {
      while (uVar1 < grp->T_size) {
        mbedtls_ecp_point_free(grp->T + uVar1);
        uVar1 = uVar1 + 1;
      }
      vPortFree(grp->T);
    }
    pmVar2 = grp + 1;
    while (grp != pmVar2) {
      grp->id = MBEDTLS_ECP_DP_NONE;
      grp = (mbedtls_ecp_group *)&grp->field_0x1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_ecp_keypair_free(mbedtls_ecp_keypair *key)

{
  if (key != (mbedtls_ecp_keypair *)0x0) {
    mbedtls_ecp_group_free((mbedtls_ecp_group *)key);
    mbedtls_mpi_free(&key->d);
    mbedtls_ecp_point_free(&key->Q);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_ecp_copy(mbedtls_ecp_point *P,mbedtls_ecp_point *Q)

{
  int iVar1;
  
  iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)P,(mbedtls_mpi *)Q);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&P->Y,&Q->Y), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_copy(&P->Z,&Q->Z);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ecp_group_copy(mbedtls_ecp_group *dst,mbedtls_ecp_group *src)

{
  int iVar1;
  
  iVar1 = mbedtls_ecp_group_load(dst,src->id);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ecp_set_zero(mbedtls_ecp_point *pt)

{
  int iVar1;
  
  iVar1 = mbedtls_mpi_lset((mbedtls_mpi *)pt,1);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_lset(&pt->Y,1), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_lset(&pt->Z,0);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_add_mixed(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_ecp_point *P,
                 mbedtls_ecp_point *Q)

{
  int iVar1;
  mbedtls_ecp_point *Q_00;
  mbedtls_mpi *X_00;
  mbedtls_mpi *pmVar2;
  undefined auStack132 [4];
  mbedtls_mpi T1;
  mbedtls_mpi T2;
  mbedtls_mpi T3;
  mbedtls_mpi T4;
  mbedtls_mpi X;
  mbedtls_mpi Y;
  mbedtls_mpi Z;
  
  pmVar2 = &P->Z;
  iVar1 = mbedtls_mpi_cmp_int(pmVar2,0);
  Q_00 = Q;
  if (iVar1 == 0) {
LAB_2306410a:
    iVar1 = mbedtls_ecp_copy(R,Q_00);
  }
  else {
    if ((Q->Z).p != (mbedtls_mpi_uint *)0x0) {
      iVar1 = mbedtls_mpi_cmp_int(&Q->Z,0);
      Q_00 = P;
      if (iVar1 == 0) goto LAB_2306410a;
      if (((Q->Z).p != (mbedtls_mpi_uint *)0x0) &&
         (iVar1 = mbedtls_mpi_cmp_int(&Q->Z,1), iVar1 != 0)) {
        iVar1 = -0x4f80;
        goto LAB_23064112;
      }
    }
    mbedtls_mpi_init((mbedtls_mpi *)auStack132);
    mbedtls_mpi_init((mbedtls_mpi *)&T1.p);
    mbedtls_mpi_init((mbedtls_mpi *)&T2.p);
    mbedtls_mpi_init((mbedtls_mpi *)&T3.p);
    X_00 = (mbedtls_mpi *)&T4.p;
    mbedtls_mpi_init(X_00);
    mbedtls_mpi_init((mbedtls_mpi *)&X.p);
    mbedtls_mpi_init((mbedtls_mpi *)&Y.p);
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack132,pmVar2,pmVar2);
    if ((((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)auStack132,grp), iVar1 == 0)) &&
        (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)auStack132,pmVar2),
        iVar1 == 0)) &&
       (((iVar1 = ecp_modp((mbedtls_mpi *)&T1.p,grp), iVar1 == 0 &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack132,(mbedtls_mpi *)auStack132,
                                      (mbedtls_mpi *)Q), iVar1 == 0)) &&
        ((iVar1 = ecp_modp((mbedtls_mpi *)auStack132,grp), iVar1 == 0 &&
         ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&Q->Y), iVar1 == 0
          && (iVar1 = ecp_modp((mbedtls_mpi *)&T1.p,grp), iVar1 == 0)))))))) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)auStack132,(mbedtls_mpi *)auStack132,
                                  (mbedtls_mpi *)P);
      while (iVar1 == 0) {
        if ((-1 < auStack132) ||
           (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)auStack132,0), iVar1 == 0)) {
          iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&P->Y);
          goto joined_r0x23064178;
        }
        iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)auStack132,(mbedtls_mpi *)auStack132,&grp->P);
      }
    }
cleanup:
    mbedtls_mpi_free((mbedtls_mpi *)auStack132);
    mbedtls_mpi_free((mbedtls_mpi *)&T1.p);
    mbedtls_mpi_free((mbedtls_mpi *)&T2.p);
    mbedtls_mpi_free((mbedtls_mpi *)&T3.p);
    mbedtls_mpi_free(X_00);
    mbedtls_mpi_free((mbedtls_mpi *)&X.p);
    mbedtls_mpi_free((mbedtls_mpi *)&Y.p);
  }
LAB_23064112:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
joined_r0x23064178:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T1.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T1.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)auStack132,0);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T1.p,0);
      if (iVar1 == 0) {
        iVar1 = ecp_double_jac(grp,R,P);
      }
      else {
        iVar1 = mbedtls_ecp_set_zero(R);
      }
    }
    else {
      iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&Y.p,pmVar2,(mbedtls_mpi *)auStack132);
      if (((((iVar1 == 0) && (iVar1 = ecp_modp((mbedtls_mpi *)&Y.p,grp), iVar1 == 0)) &&
           (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)auStack132,
                                        (mbedtls_mpi *)auStack132), iVar1 == 0)) &&
          ((iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0 &&
           (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T3.p,(mbedtls_mpi *)&T2.p,
                                        (mbedtls_mpi *)auStack132), iVar1 == 0)))) &&
         ((iVar1 = ecp_modp((mbedtls_mpi *)&T3.p,grp), iVar1 == 0 &&
          ((iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)P),
           iVar1 == 0 && (iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0)))))) {
        iVar1 = mbedtls_mpi_mul_int((mbedtls_mpi *)auStack132,(mbedtls_mpi *)&T2.p,2);
        pmVar2 = &grp->P;
        goto joined_r0x23064214;
      }
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p,&grp->P);
  goto joined_r0x23064178;
joined_r0x23064214:
  if (iVar1 != 0) goto cleanup;
  iVar1 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack132,pmVar2);
  if (iVar1 < 0) {
    iVar1 = mbedtls_mpi_mul_mpi(X_00,(mbedtls_mpi *)&T1.p,(mbedtls_mpi *)&T1.p);
    if ((iVar1 == 0) && (iVar1 = ecp_modp(X_00,grp), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_sub_mpi(X_00,X_00,(mbedtls_mpi *)auStack132);
      goto joined_r0x23064250;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_sub_abs((mbedtls_mpi *)auStack132,(mbedtls_mpi *)auStack132,pmVar2);
  goto joined_r0x23064214;
joined_r0x23064250:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T4.p) || (iVar1 = mbedtls_mpi_cmp_int(X_00,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi(X_00,X_00,(mbedtls_mpi *)&T3.p);
    goto LAB_23064264;
  }
  iVar1 = mbedtls_mpi_add_mpi(X_00,X_00,pmVar2);
  goto joined_r0x23064250;
LAB_23064264:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T4.p) || (iVar1 = mbedtls_mpi_cmp_int(X_00,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,X_00);
    goto LAB_2306427a;
  }
  iVar1 = mbedtls_mpi_add_mpi(X_00,X_00,pmVar2);
  goto LAB_23064264;
LAB_2306427a:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)T2.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&T2.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T1.p);
    if ((iVar1 == 0) &&
       (((iVar1 = ecp_modp((mbedtls_mpi *)&T2.p,grp), iVar1 == 0 &&
         (iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&T3.p,(mbedtls_mpi *)&T3.p,&P->Y), iVar1 == 0))
        && (iVar1 = ecp_modp((mbedtls_mpi *)&T3.p,grp), iVar1 == 0)))) {
      iVar1 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&X.p,(mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T3.p);
      goto LAB_230642cc;
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&T2.p,(mbedtls_mpi *)&T2.p,pmVar2);
  goto LAB_2306427a;
LAB_230642cc:
  if (iVar1 != 0) goto cleanup;
  if ((-1 < (int)X.p) || (iVar1 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&X.p,0), iVar1 == 0)) {
    iVar1 = mbedtls_mpi_copy((mbedtls_mpi *)R,X_00);
    if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_copy(&R->Y,(mbedtls_mpi *)&X.p), iVar1 == 0)) {
      iVar1 = mbedtls_mpi_copy(&R->Z,(mbedtls_mpi *)&Y.p);
    }
    goto cleanup;
  }
  iVar1 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&X.p,(mbedtls_mpi *)&X.p,pmVar2);
  goto LAB_230642cc;
}



int ecp_mul_comb(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_mpi *m,mbedtls_ecp_point *P,
                anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  mbedtls_mpi_uint **ppmVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  uchar t_len;
  uint uVar11;
  uint uVar12;
  mbedtls_ecp_point *pmVar13;
  mbedtls_ecp_point *P_00;
  uint uVar14;
  uint uVar15;
  size_t sVar16;
  mbedtls_mpi *pmVar17;
  uint numitems;
  uint uVar18;
  int iVar19;
  mbedtls_mpi_uint **ppmVar20;
  size_t sVar21;
  undefined auStack412 [4];
  mbedtls_mpi M;
  mbedtls_mpi mm;
  mbedtls_mpi l;
  mbedtls_mpi ll;
  mbedtls_ecp_point Txi;
  uchar k [262];
  
  mbedtls_mpi_init((mbedtls_mpi *)auStack412);
  mbedtls_mpi_init((mbedtls_mpi *)&M.p);
  iVar6 = mbedtls_mpi_get_bit(&grp->N,0);
  if (iVar6 != 1) {
    iVar6 = -0x4f80;
    goto LAB_2306452e;
  }
  uVar14 = (uint)(0x17f < grp->nbits);
  iVar7 = mbedtls_mpi_cmp_mpi(&P->Y,&(grp->G).Y);
  uVar15 = uVar14 + 4;
  if (iVar7 == 0) {
    iVar6 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)P,(mbedtls_mpi *)&grp->G);
    if (iVar6 == 0) {
      uVar15 = uVar14 + 5;
      iVar7 = 1;
    }
  }
  else {
    iVar7 = 0;
  }
  if (grp->nbits <= uVar15) {
    uVar15 = 2;
  }
  uVar18 = uVar15 - 1;
  numitems = 1 << (uVar18 & 0x1f);
  uVar14 = ((grp->nbits - 1) + uVar15) / uVar15;
  if ((iVar7 == 0) || (P_00 = grp->T, P_00 == (mbedtls_ecp_point *)0x0)) {
    P_00 = (mbedtls_ecp_point *)mycalloc(numitems,0x24);
    if (P_00 != (mbedtls_ecp_point *)0x0) {
      iVar6 = mbedtls_ecp_copy(P_00,P);
      if (iVar6 == 0) {
        sVar21 = 0;
        uVar11 = 1;
        while (uVar12 = uVar11 >> (uVar18 & 0x1f), uVar12 == 0) {
          pmVar13 = P_00 + uVar11;
          iVar6 = mbedtls_ecp_copy(pmVar13,P_00 + (uVar11 >> 1));
          if (iVar6 != 0) goto LAB_230644f6;
          while (uVar14 != uVar12) {
            iVar6 = ecp_double_jac(grp,pmVar13,pmVar13);
            if (iVar6 != 0) goto LAB_230644f6;
            uVar12 = uVar12 + 1;
          }
          (&Txi.Z.p)[sVar21] = (mbedtls_mpi_uint *)pmVar13;
          uVar11 = (uVar11 & 0x7f) << 1;
          sVar21 = sVar21 + 1 & 0xff;
        }
        iVar6 = ecp_normalize_jac_many(grp,(mbedtls_ecp_point **)&Txi.Z.p,sVar21);
        if (iVar6 == 0) {
          sVar21 = 0;
          uVar11 = 1;
          while (uVar11 >> (uVar18 & 0x1f) == 0) {
            uVar10 = sVar21 + uVar11;
            pmVar13 = P_00 + uVar11;
            uVar12 = uVar11;
            while( true ) {
              sVar21 = (uVar10 & 0xff) - uVar12 & 0xff;
              uVar4 = uVar12 - 1;
              if (uVar12 == 0) break;
              iVar6 = ecp_add_mixed(grp,pmVar13 + uVar4,P_00 + uVar4,pmVar13);
              if (iVar6 != 0) goto LAB_230644f6;
              (&Txi.Z.p)[sVar21] = (mbedtls_mpi_uint *)(pmVar13 + uVar4);
              uVar12 = uVar4;
            }
            uVar11 = (uVar11 & 0x7f) << 1;
          }
          iVar6 = ecp_normalize_jac_many(grp,(mbedtls_ecp_point **)&Txi.Z.p,sVar21);
          if (iVar6 == 0) {
            if (iVar7 != 0) {
              grp->T = P_00;
              grp->T_size = numitems;
            }
            goto LAB_23064618;
          }
        }
      }
      goto LAB_230644f6;
    }
    iVar6 = -0x4d80;
  }
  else {
LAB_23064618:
    iVar8 = mbedtls_mpi_get_bit(m,0);
    iVar6 = mbedtls_mpi_copy((mbedtls_mpi *)auStack412,m);
    if ((iVar6 == 0) && (iVar6 = mbedtls_mpi_sub_mpi((mbedtls_mpi *)&M.p,&grp->N,m), iVar6 == 0)) {
      iVar6 = mbedtls_mpi_safe_cond_assign((mbedtls_mpi *)auStack412,(mbedtls_mpi *)&M.p,iVar8 != 1)
      ;
      if (iVar6 == 0) {
        ppmVar5 = &Txi.Z.p;
        memset(&Txi.Z.p,0,uVar14 + 1);
        sVar21 = 0;
        ppmVar20 = ppmVar5;
        while (uVar14 != sVar21) {
          uVar18 = 0;
          sVar16 = sVar21;
          do {
            iVar6 = mbedtls_mpi_get_bit((mbedtls_mpi *)auStack412,sVar16);
            *(byte *)ppmVar20 = (byte)(iVar6 << (uVar18 & 0x1f)) | *(byte *)ppmVar20;
            uVar18 = uVar18 + 1;
            sVar16 = sVar16 + uVar14;
          } while (uVar18 < uVar15);
          sVar21 = sVar21 + 1;
          ppmVar20 = (mbedtls_mpi_uint **)((int)ppmVar20 + 1);
        }
        uVar14 = 0;
        while (ppmVar5 != (mbedtls_mpi_uint **)(k + (sVar21 - 4))) {
          bVar1 = *(byte *)((int)ppmVar5 + 1);
          uVar15 = bVar1 ^ uVar14;
          uVar18 = ~uVar15 & 1;
          bVar3 = *(byte *)ppmVar5 * (char)uVar18;
          *(byte *)ppmVar5 = (byte)(uVar18 << 7) | *(byte *)ppmVar5;
          bVar2 = (byte)uVar15;
          *(byte *)(mbedtls_mpi_uint **)((int)ppmVar5 + 1) = bVar2 ^ bVar3;
          uVar14 = bVar1 & uVar14 | (int)(char)(bVar2 & bVar3) & 0xffU;
          ppmVar5 = (mbedtls_mpi_uint **)((int)ppmVar5 + 1);
        }
        mbedtls_ecp_point_init((mbedtls_ecp_point *)&ll.p);
        t_len = (uchar)(numitems & 0xff);
        iVar6 = ecp_select_comb(grp,R,P_00,t_len,k[sVar21 - 4]);
        if (iVar6 == 0) {
          pmVar17 = &R->Z;
          iVar9 = mbedtls_mpi_lset(pmVar17,1);
          iVar6 = iVar9;
          if (iVar9 == 0) {
            if (f_rng != (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0) {
              sVar16 = grp->pbits;
              mbedtls_mpi_init((mbedtls_mpi *)&mm.p);
              mbedtls_mpi_init((mbedtls_mpi *)&l.p);
              iVar19 = 0xc;
              do {
                mbedtls_mpi_fill_random((mbedtls_mpi *)&mm.p,sVar16 + 7 >> 3,f_rng,p_rng);
                while (iVar6 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&mm.p,&grp->P), -1 < iVar6) {
                  iVar6 = mbedtls_mpi_shift_r((mbedtls_mpi *)&mm.p,1);
                  if (iVar6 != 0) goto cleanup;
                }
                iVar19 = iVar19 + -1;
                if (iVar19 == 0) {
                  iVar6 = -0x4d00;
                  goto cleanup;
                }
                iVar6 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&mm.p,1);
              } while (iVar6 < 1);
              iVar6 = mbedtls_mpi_mul_mpi(pmVar17,pmVar17,(mbedtls_mpi *)&mm.p);
              if ((((iVar6 == 0) && (iVar6 = ecp_modp(pmVar17,grp), iVar6 == 0)) &&
                  (iVar6 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&l.p,(mbedtls_mpi *)&mm.p,
                                               (mbedtls_mpi *)&mm.p), iVar6 == 0)) &&
                 (((iVar6 = ecp_modp((mbedtls_mpi *)&l.p,grp), iVar6 == 0 &&
                   (iVar6 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)R,(mbedtls_mpi *)R,
                                                (mbedtls_mpi *)&l.p), iVar6 == 0)) &&
                  ((iVar6 = ecp_modp((mbedtls_mpi *)R,grp), iVar6 == 0 &&
                   ((iVar6 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&l.p,(mbedtls_mpi *)&l.p,
                                                 (mbedtls_mpi *)&mm.p), iVar6 == 0 &&
                    (iVar6 = ecp_modp((mbedtls_mpi *)&l.p,grp), iVar6 == 0)))))))) {
                pmVar17 = &R->Y;
                iVar6 = mbedtls_mpi_mul_mpi(pmVar17,pmVar17,(mbedtls_mpi *)&l.p);
                if (iVar6 == 0) {
                  iVar6 = ecp_modp(pmVar17,grp);
                }
              }
cleanup:
              mbedtls_mpi_free((mbedtls_mpi *)&mm.p);
              mbedtls_mpi_free((mbedtls_mpi *)&l.p);
              if (iVar6 != 0) goto cleanup;
            }
            do {
              iVar6 = iVar9;
              if (((sVar21 - 1 == 0xffffffff) || (iVar6 = ecp_double_jac(grp,R,R), iVar6 != 0)) ||
                 (iVar6 = ecp_select_comb(grp,(mbedtls_ecp_point *)&ll.p,P_00,t_len,k[sVar21 - 5]),
                 iVar6 != 0)) break;
              iVar6 = ecp_add_mixed(grp,R,R,(mbedtls_ecp_point *)&ll.p);
              sVar21 = sVar21 - 1;
            } while (iVar6 == 0);
          }
        }
cleanup:
        mbedtls_ecp_point_free((mbedtls_ecp_point *)&ll.p);
        if ((iVar6 == 0) && (iVar6 = ecp_safe_invert_jac(grp,R,iVar8 != 1), iVar6 == 0)) {
          iVar6 = ecp_normalize_jac(grp,R);
        }
      }
    }
LAB_230644f6:
    if (iVar7 == 0) {
      uVar14 = 0;
      do {
        uVar15 = uVar14 + 1;
        mbedtls_ecp_point_free(P_00 + uVar14);
        uVar14 = uVar15;
      } while ((uVar15 & 0xff) < (numitems & 0xff));
      vPortFree(P_00);
    }
  }
  mbedtls_mpi_free((mbedtls_mpi *)auStack412);
  mbedtls_mpi_free((mbedtls_mpi *)&M.p);
  if (iVar6 != 0) {
    mbedtls_ecp_point_free(R);
  }
LAB_2306452e:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar6;
}



int mbedtls_ecp_point_read_binary
              (mbedtls_ecp_group *grp,mbedtls_ecp_point *pt,uchar *buf,size_t ilen)

{
  int iVar1;
  size_t buflen;
  
  if (ilen != 0) {
    if (*buf != '\0') {
      buflen = mbedtls_mpi_size(&grp->P);
      if (*buf == '\x04') {
        if (ilen == buflen * 2 + 1) {
          iVar1 = mbedtls_mpi_read_binary((mbedtls_mpi *)pt,buf + 1,buflen);
          if ((iVar1 == 0) &&
             (iVar1 = mbedtls_mpi_read_binary(&pt->Y,buf + buflen + 1,buflen), iVar1 == 0)) {
            iVar1 = mbedtls_mpi_lset(&pt->Z,1);
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return iVar1;
          }
        }
        else {
          iVar1 = -0x4f80;
        }
      }
      else {
        iVar1 = -0x4e80;
      }
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
    if (ilen == 1) {
      iVar1 = mbedtls_ecp_set_zero(pt);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar1;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4f80;
}



int mbedtls_ecp_check_pubkey(mbedtls_ecp_group *grp,mbedtls_ecp_point *pt)

{
  mbedtls_mpi *X;
  ecp_curve_type eVar1;
  int iVar2;
  undefined3 extraout_var;
  mbedtls_mpi *Y;
  undefined auStack56 [4];
  mbedtls_mpi YY;
  mbedtls_mpi RHS;
  
  iVar2 = mbedtls_mpi_cmp_int(&pt->Z,1);
  if (iVar2 == 0) {
    eVar1 = ecp_get_type(grp);
    if (CONCAT31(extraout_var,eVar1) != 1) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x4f80;
    }
    iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)pt,0);
    if (-1 < iVar2) {
      X = &pt->Y;
      iVar2 = mbedtls_mpi_cmp_int(X,0);
      if (-1 < iVar2) {
        Y = &grp->P;
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)pt,Y);
        if ((iVar2 < 0) && (iVar2 = mbedtls_mpi_cmp_mpi(X,Y), iVar2 < 0)) {
          mbedtls_mpi_init((mbedtls_mpi *)auStack56);
          mbedtls_mpi_init((mbedtls_mpi *)&YY.p);
          iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack56,X,X);
          if ((iVar2 == 0) &&
             (((iVar2 = ecp_modp((mbedtls_mpi *)auStack56,grp), iVar2 == 0 &&
               (iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)pt,(mbedtls_mpi *)pt
                                           ), iVar2 == 0)) &&
              (iVar2 = ecp_modp((mbedtls_mpi *)&YY.p,grp), iVar2 == 0)))) {
            if ((grp->A).p == (mbedtls_mpi_uint *)0x0) {
              iVar2 = mbedtls_mpi_sub_int((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,3);
              while (iVar2 == 0) {
                if ((-1 < (int)YY.p) ||
                   (iVar2 = mbedtls_mpi_cmp_int((mbedtls_mpi *)&YY.p,0), iVar2 == 0))
                goto LAB_230649e4;
                iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
              }
            }
            else {
              iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,&grp->A);
              while (iVar2 == 0) {
                iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&YY.p,Y);
                if (iVar2 < 0) goto LAB_230649e4;
                iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
              }
            }
          }
          goto cleanup;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4c80;
LAB_230649e4:
  iVar2 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,(mbedtls_mpi *)pt);
  if ((iVar2 == 0) && (iVar2 = ecp_modp((mbedtls_mpi *)&YY.p,grp), iVar2 == 0)) {
    iVar2 = mbedtls_mpi_add_mpi((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,&grp->B);
    while (iVar2 == 0) {
      iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&YY.p,Y);
      if (iVar2 < 0) {
        iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack56,(mbedtls_mpi *)&YY.p);
        if (iVar2 != 0) {
          iVar2 = -0x4c80;
        }
        break;
      }
      iVar2 = mbedtls_mpi_sub_abs((mbedtls_mpi *)&YY.p,(mbedtls_mpi *)&YY.p,Y);
    }
  }
cleanup:
  mbedtls_mpi_free((mbedtls_mpi *)auStack56);
  mbedtls_mpi_free((mbedtls_mpi *)&YY.p);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_ecp_check_privkey(mbedtls_ecp_group *grp,mbedtls_mpi *d)

{
  ecp_curve_type eVar1;
  undefined3 extraout_var;
  int iVar2;
  
  eVar1 = ecp_get_type(grp);
  if (CONCAT31(extraout_var,eVar1) == 1) {
    iVar2 = mbedtls_mpi_cmp_int(d,1);
    if ((-1 < iVar2) && (iVar2 = mbedtls_mpi_cmp_mpi(d,&grp->N), iVar2 < 0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    iVar2 = -0x4c80;
  }
  else {
    iVar2 = -0x4f80;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_ecp_mul(mbedtls_ecp_group *grp,mbedtls_ecp_point *R,mbedtls_mpi *m,mbedtls_ecp_point *P,
                   anon_subr_int_void_ptr_uchar_ptr_size_t *f_rng,void *p_rng)

{
  ecp_curve_type eVar1;
  int iVar2;
  undefined3 extraout_var;
  
  iVar2 = mbedtls_mpi_cmp_int(&P->Z,1);
  if (iVar2 == 0) {
    iVar2 = mbedtls_ecp_check_privkey(grp,m);
    if (((iVar2 == 0) && (iVar2 = mbedtls_ecp_check_pubkey(grp,P), iVar2 == 0)) &&
       (eVar1 = ecp_get_type(grp), CONCAT31(extraout_var,eVar1) == 1)) {
      iVar2 = ecp_mul_comb(grp,R,m,P,f_rng,p_rng);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return iVar2;
    }
  }
  else {
    iVar2 = -0x4f80;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_ecp_check_pub_priv(mbedtls_ecp_keypair *pub,mbedtls_ecp_keypair *prv)

{
  mbedtls_ecp_group_id mVar1;
  int iVar2;
  mbedtls_mpi *Y;
  mbedtls_mpi *Y_00;
  undefined auStack192 [4];
  mbedtls_ecp_point Q;
  mbedtls_ecp_group grp;
  
  mVar1 = (pub->grp).id;
  if ((mVar1 != MBEDTLS_ECP_DP_NONE) && ((prv->grp).id == mVar1)) {
    iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&pub->Q,(mbedtls_mpi *)&prv->Q);
    if (iVar2 == 0) {
      Y_00 = &(prv->Q).Y;
      iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Y,Y_00);
      if (iVar2 == 0) {
        Y = &(prv->Q).Z;
        iVar2 = mbedtls_mpi_cmp_mpi(&(pub->Q).Z,Y);
        if (iVar2 == 0) {
          mbedtls_ecp_point_init((mbedtls_ecp_point *)auStack192);
          memset(&Q.Z.p,0,0x7c);
          mbedtls_ecp_group_copy((mbedtls_ecp_group *)&Q.Z.p,(mbedtls_ecp_group *)prv);
          iVar2 = mbedtls_ecp_mul((mbedtls_ecp_group *)&Q.Z.p,(mbedtls_ecp_point *)auStack192,
                                  &prv->d,&(prv->grp).G,
                                  (anon_subr_int_void_ptr_uchar_ptr_size_t *)0x0,(void *)0x0);
          if ((iVar2 == 0) &&
             (((iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)auStack192,(mbedtls_mpi *)&prv->Q),
               iVar2 != 0 || (iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Q.X.p,Y_00), iVar2 != 0))
              || (iVar2 = mbedtls_mpi_cmp_mpi((mbedtls_mpi *)&Q.Y.p,Y), iVar2 != 0)))) {
            iVar2 = -0x4f80;
          }
          mbedtls_ecp_point_free((mbedtls_ecp_point *)auStack192);
          mbedtls_ecp_group_free((mbedtls_ecp_group *)&Q.Z.p);
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return iVar2;
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x4f80;
}



int ecp_mod_koblitz(mbedtls_mpi *N,mbedtls_mpi_uint *Rp,size_t p_limbs)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  mbedtls_mpi_uint **__s;
  undefined auStack100 [4];
  mbedtls_mpi M;
  mbedtls_mpi R;
  mbedtls_mpi_uint Mp [11];
  
  if (N->n < p_limbs) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  __s = &R.p;
  M.p = (mbedtls_mpi_uint *)0x1;
  R.s = 2;
  auStack100 = 1;
  uVar2 = N->n - p_limbs;
  M.s = p_limbs;
  if (uVar2 <= p_limbs) {
    M.s = uVar2;
  }
  M.n = (size_t)__s;
  R.n = (size_t)Rp;
  memset(__s,0,0x2c);
  memcpy(__s,N->p + p_limbs,M.s << 2);
  M.s = M.s + R.s;
  sVar3 = p_limbs;
  while (sVar3 < N->n) {
    N->p[sVar3] = 0;
    sVar3 = sVar3 + 1;
  }
  iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack100,(mbedtls_mpi *)auStack100,
                              (mbedtls_mpi *)&M.p);
  if ((iVar1 == 0) && (iVar1 = mbedtls_mpi_add_abs(N,N,(mbedtls_mpi *)auStack100), iVar1 == 0)) {
    uVar2 = N->n - p_limbs;
    M.s = p_limbs;
    if (uVar2 <= p_limbs) {
      M.s = uVar2;
    }
    memset(__s,0,0x2c);
    memcpy(__s,N->p + p_limbs,M.s << 2);
    M.s = M.s + R.s;
    while (p_limbs < N->n) {
      N->p[p_limbs] = 0;
      p_limbs = p_limbs + 1;
    }
    iVar1 = mbedtls_mpi_mul_mpi((mbedtls_mpi *)auStack100,(mbedtls_mpi *)auStack100,
                                (mbedtls_mpi *)&M.p);
    if (iVar1 == 0) {
      iVar1 = mbedtls_mpi_add_abs(N,N,(mbedtls_mpi *)auStack100);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_mod_p224k1(mbedtls_mpi *N)

{
  int iVar1;
  
  iVar1 = ecp_mod_koblitz(N,ecp_mod_p224k1::Rp,7);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int ecp_mod_p256k1(mbedtls_mpi *N)

{
  int iVar1;
  
  iVar1 = ecp_mod_koblitz(N,ecp_mod_p256k1::Rp,8);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_ecp_group_load(mbedtls_ecp_group *grp,mbedtls_ecp_group_id id)

{
  size_t sVar1;
  undefined3 in_register_0000202d;
  int iVar2;
  mbedtls_mpi_uint *pmVar3;
  
  iVar2 = CONCAT31(in_register_0000202d,id);
  mbedtls_ecp_group_free(grp);
  grp->id = id;
  if (iVar2 == 0xb) {
    (grp->P).p = secp224k1_p;
    (grp->A).p = secp224k1_a;
    (grp->B).p = secp224k1_b;
    (grp->N).n = 8;
    grp->modp = ecp_mod_p224k1;
    (grp->N).p = secp224k1_n;
    (grp->P).n = 7;
    (grp->G).X.n = 7;
    (grp->G).Y.n = 7;
    (grp->P).s = 1;
    (grp->A).s = 1;
    (grp->A).n = 1;
    (grp->B).s = 1;
    (grp->B).n = 1;
    (grp->N).s = 1;
    (grp->G).X.s = 1;
    (grp->G).X.p = secp224k1_gx;
    (grp->G).Y.s = 1;
    pmVar3 = secp224k1_gy;
  }
  else {
    if (iVar2 == 0xc) {
      (grp->P).p = secp256k1_p;
      (grp->A).p = secp256k1_a;
      (grp->B).p = secp256k1_b;
      grp->modp = ecp_mod_p256k1;
      (grp->N).p = secp256k1_n;
      (grp->P).n = 8;
      (grp->N).n = 8;
      (grp->G).X.n = 8;
      (grp->G).Y.n = 8;
      (grp->P).s = 1;
      (grp->A).s = 1;
      (grp->A).n = 1;
      (grp->B).s = 1;
      (grp->B).n = 1;
      (grp->N).s = 1;
      (grp->G).X.s = 1;
      (grp->G).X.p = secp256k1_gx;
      (grp->G).Y.s = 1;
      pmVar3 = secp256k1_gy;
    }
    else {
      if (iVar2 != 3) {
        mbedtls_ecp_group_free(grp);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x4e80;
      }
      (grp->P).p = secp256r1_p;
      (grp->B).p = secp256r1_b;
      (grp->N).p = secp256r1_n;
      (grp->P).n = 8;
      (grp->B).n = 8;
      (grp->N).n = 8;
      (grp->G).X.n = 8;
      (grp->G).Y.n = 8;
      (grp->P).s = 1;
      (grp->B).s = 1;
      (grp->N).s = 1;
      (grp->G).X.s = 1;
      (grp->G).X.p = secp256r1_gx;
      (grp->G).Y.s = 1;
      pmVar3 = secp256r1_gy;
    }
  }
  (grp->G).Y.p = pmVar3;
  (grp->G).Z.p = &one_2614;
  (grp->G).Z.s = 1;
  (grp->G).Z.n = 1;
  sVar1 = mbedtls_mpi_bitlen(&grp->P);
  grp->pbits = sVar1;
  sVar1 = mbedtls_mpi_bitlen(&grp->N);
  grp->nbits = sVar1;
  grp->h = 1;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void gcm_mult(mbedtls_gcm_context *ctx,uchar *x,uchar *output)

{
  uint uVar1;
  uint64_t *puVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  
  iVar7 = 0xf;
  puVar2 = ctx->HL + ((x[0xf] & 0xf) - 8);
  uVar1 = *(uint *)(puVar2 + 0x18);
  uVar4 = *(uint *)((int)puVar2 + 0xc4);
  uVar5 = *(uint *)(puVar2 + 8);
  uVar3 = *(uint *)((int)puVar2 + 0x44);
  do {
    uVar8 = uVar1 << 0x1c;
    uVar6 = uVar4 << 0x1c;
    if (iVar7 != 0xf) {
      puVar2 = ctx->HL + ((x[iVar7] & 0xf) - 8);
      uVar4 = *(uint *)((int)puVar2 + 0xc4) ^ *(int *)(last4 + (uVar5 & 0xf)) << 0x10 ^ uVar4 >> 4;
      uVar1 = *(uint *)(puVar2 + 0x18) ^ (uVar6 | uVar1 >> 4);
      uVar5 = *(uint *)(puVar2 + 8) ^ (uVar5 >> 4 | uVar3 << 0x1c);
      uVar3 = *(uint *)((int)puVar2 + 0x44) ^ (uVar8 | uVar3 >> 4);
    }
    puVar2 = ctx->HL + ((x[iVar7] >> 4) - 8);
    uVar8 = uVar1 << 0x1c;
    uVar9 = uVar4 << 0x1c;
    uVar6 = *(uint *)((int)puVar2 + 0xc4) ^ uVar4 >> 4;
    uVar4 = uVar6 ^ *(int *)(last4 + (uVar5 & 0xf)) << 0x10;
    iVar7 = iVar7 + -1;
    uVar1 = *(uint *)(puVar2 + 0x18) ^ (uVar9 | uVar1 >> 4);
    uVar5 = *(uint *)(puVar2 + 8) ^ (uVar3 << 0x1c | uVar5 >> 4);
    uVar3 = *(uint *)((int)puVar2 + 0x44) ^ (uVar8 | uVar3 >> 4);
  } while (iVar7 != -1);
  *output = (uchar)(uVar4 >> 0x18);
  output[1] = (uchar)(uVar4 >> 0x10);
  output[3] = (uchar)uVar6;
  output[4] = (uchar)(uVar1 >> 0x18);
  output[5] = (uchar)(uVar1 >> 0x10);
  output[6] = (uchar)(uVar1 >> 8);
  output[8] = (uchar)(uVar3 >> 0x18);
  output[9] = (uchar)(uVar3 >> 0x10);
  output[10] = (uchar)(uVar3 >> 8);
  output[0xc] = (uchar)(uVar5 >> 0x18);
  output[0xd] = (uchar)(uVar5 >> 0x10);
  output[2] = (uchar)(uVar6 >> 8);
  output[7] = (uchar)uVar1;
  output[0xb] = (uchar)uVar3;
  output[0xe] = (uchar)(uVar5 >> 8);
  output[0xf] = (uchar)uVar5;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_gcm_init(mbedtls_gcm_context *ctx)

{
  memset(ctx,0,0x188);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Variable defined which should be unmapped: h
// WARNING: Could not reconcile some variable overlaps

int mbedtls_gcm_setkey(mbedtls_gcm_context *ctx,mbedtls_cipher_id_t cipher,uchar *key,uint keybits)

{
  uint uVar1;
  uint64_t *puVar2;
  mbedtls_cipher_info_t *cipher_info;
  int iVar3;
  uint uVar4;
  uint64_t *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint64_t *puVar11;
  int iVar12;
  int iVar13;
  uint64_t *puVar14;
  uint uVar15;
  uint *puVar16;
  size_t sStack36;
  size_t olen;
  uchar h [16];
  
  cipher_info = mbedtls_cipher_info_from_values(cipher,keybits,MBEDTLS_MODE_ECB);
  if (cipher_info == (mbedtls_cipher_info_t *)0x0) {
    iVar3 = -0x14;
  }
  else {
    iVar3 = -0x14;
    if (cipher_info->block_size == 0x10) {
      mbedtls_cipher_free((mbedtls_cipher_context_t *)ctx);
      iVar3 = mbedtls_cipher_setup((mbedtls_cipher_context_t *)ctx,cipher_info);
      if ((iVar3 == 0) &&
         (iVar3 = mbedtls_cipher_setkey((mbedtls_cipher_context_t *)ctx,key,keybits,MBEDTLS_ENCRYPT)
         , iVar3 == 0)) {
        sStack36 = 0;
        memset(&olen,0,0x10);
        iVar3 = mbedtls_cipher_update
                          ((mbedtls_cipher_context_t *)ctx,(uchar *)&olen,0x10,(uchar *)&olen,
                           &sStack36);
        if (iVar3 == 0) {
          uVar6 = (uint)h[0] << 0x18 | (uint)h[1] << 0x10 | (uint)h[3] | (uint)h[2] << 8;
          uVar10 = (uint)(byte)olen << 0x18 | (uint)olen._1_1_ << 0x10 | (uint)olen._3_1_ |
                   (uint)olen._2_1_ << 8;
          uVar8 = (uint)h[4] << 0x18 | (uint)h[5] << 0x10 | (uint)h[7] | (uint)h[6] << 8;
          *(undefined4 *)((int)ctx->HH + 4) = 0;
          *(undefined4 *)((int)ctx->HL + 4) = 0;
          *(uint *)((int)ctx->HL + 0x44) = uVar8;
          *(uint *)(ctx->HH + 8) = uVar6;
          *(uint *)((int)ctx->HH + 0x44) = uVar10;
          uVar7 = (uint)h[8] << 0x18 | (uint)h[9] << 0x10 | (uint)h[11] | (uint)h[10] << 8;
          *(undefined4 *)ctx->HH = 0;
          *(undefined4 *)ctx->HL = 0;
          *(uint *)(ctx->HL + 8) = uVar7;
          iVar12 = 3;
          iVar13 = 4;
          do {
            uVar4 = uVar7 & 1;
            uVar15 = uVar8 << 0x1f;
            uVar8 = uVar6 << 0x1f | uVar8 >> 1;
            uVar1 = uVar10 << 0x1f;
            uVar7 = uVar15 | uVar7 >> 1;
            uVar10 = uVar10 >> 1 ^ uVar4 * -0x1f000000;
            puVar5 = ctx->HL + iVar13 + -8;
            uVar6 = uVar1 | uVar6 >> 1;
            *(uint *)(puVar5 + 8) = uVar7;
            *(uint *)((int)puVar5 + 0x44) = uVar8;
            *(uint *)(puVar5 + 0x18) = uVar6;
            *(uint *)((int)puVar5 + 0xc4) = uVar10;
            iVar12 = iVar12 + -1;
            iVar13 = iVar13 >> 1;
          } while (iVar12 != 0);
          iVar13 = 3;
          iVar12 = 2;
          do {
            puVar14 = ctx->HL + iVar12;
            puVar2 = ctx->HH + iVar12;
            uVar8 = *(uint *)puVar2;
            uVar7 = *(uint *)((int)puVar2 + 4);
            uVar6 = *(uint *)puVar14;
            uVar10 = *(uint *)((int)puVar14 + 4);
            iVar9 = 8;
            puVar5 = ctx->HL;
            do {
              puVar11 = puVar5 + 1;
              *(uint *)((int)puVar2 + iVar9) = *(uint *)(puVar11 + 0x10) ^ uVar8;
              ((uint *)((int)puVar2 + iVar9))[1] = *(uint *)((int)puVar5 + 0x8c) ^ uVar7;
              puVar16 = (uint *)((int)puVar14 + iVar9);
              iVar9 = iVar9 + 8;
              *puVar16 = *(uint *)puVar11 ^ uVar6;
              puVar16[1] = *(uint *)((int)puVar5 + 0xc) ^ uVar10;
              puVar5 = puVar11;
            } while (iVar12 * 8 != iVar9);
            iVar13 = iVar13 + -1;
            iVar12 = iVar12 << 1;
          } while (iVar13 != 0);
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_gcm_starts(mbedtls_gcm_context *ctx,int mode,uchar *iv,size_t iv_len,uchar *add,
                      size_t add_len)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  byte *pbVar4;
  byte *pbVar5;
  byte *pbVar6;
  size_t *psVar7;
  uint uVar8;
  byte *x;
  size_t sStack68;
  size_t olen;
  uchar work_buf [16];
  
  pbVar6 = ctx->y;
  sStack68 = 0;
  x = ctx->buf;
  memset(pbVar6,0,0x10);
  memset(x,0,0x10);
  *(undefined4 *)&ctx->len = 0;
  *(undefined4 *)&ctx->add_len = 0;
  ctx->mode = mode;
  *(undefined4 *)((int)&ctx->len + 4) = 0;
  *(undefined4 *)((int)&ctx->add_len + 4) = 0;
  if (iv_len == 0xc) {
    memcpy(pbVar6,iv,0xc);
    ctx->y[0xf] = '\x01';
  }
  else {
    memset(&olen,0,0x10);
    iVar3 = iv_len << 3;
    work_buf[8] = (uchar)((uint)iVar3 >> 0x18);
    work_buf[9] = (uchar)((uint)iVar3 >> 0x10);
    work_buf[10] = (uchar)((uint)iVar3 >> 8);
    work_buf[11] = (uchar)iVar3;
    while (iv_len != 0) {
      uVar2 = iv_len;
      if (0x10 < iv_len) {
        uVar2 = 0x10;
      }
      uVar8 = 0;
      pbVar4 = pbVar6;
      do {
        pbVar5 = iv + uVar8;
        uVar8 = uVar8 + 1;
        *pbVar4 = *pbVar5 ^ *pbVar4;
        pbVar4 = pbVar4 + 1;
      } while (uVar2 != uVar8);
      gcm_mult(ctx,pbVar6,pbVar6);
      iv_len = iv_len - uVar2;
      iv = iv + uVar2;
    }
    psVar7 = &olen;
    pbVar4 = pbVar6;
    do {
      bVar1 = *(byte *)psVar7;
      pbVar5 = pbVar4 + 1;
      psVar7 = (size_t *)((int)psVar7 + 1);
      *pbVar4 = *pbVar4 ^ bVar1;
      pbVar4 = pbVar5;
    } while (x != pbVar5);
    gcm_mult(ctx,pbVar6,pbVar6);
  }
  iVar3 = mbedtls_cipher_update
                    ((mbedtls_cipher_context_t *)ctx,pbVar6,0x10,ctx->base_ectr,&sStack68);
  if (iVar3 == 0) {
    *(size_t *)&ctx->add_len = add_len;
    *(undefined4 *)((int)&ctx->add_len + 4) = 0;
    while (add_len != 0) {
      uVar2 = add_len;
      if (0x10 < add_len) {
        uVar2 = 0x10;
      }
      uVar8 = 0;
      pbVar6 = x;
      do {
        pbVar4 = add + uVar8;
        uVar8 = uVar8 + 1;
        *pbVar6 = *pbVar4 ^ *pbVar6;
        pbVar6 = pbVar6 + 1;
      } while (uVar2 != uVar8);
      gcm_mult(ctx,x,x);
      add_len = add_len - uVar2;
      add = add + uVar2;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



int mbedtls_gcm_update(mbedtls_gcm_context *ctx,size_t length,uchar *input,uchar *output)

{
  uchar uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  uchar *puVar6;
  uint uVar7;
  byte *x;
  byte *pbVar8;
  size_t sStack68;
  size_t olen;
  uchar ectr [16];
  
  sStack68 = 0;
  if ((output <= input) || (iVar2 = -0x14, length <= output + -(int)input)) {
    uVar4 = *(uint *)((int)&ctx->len + 4);
    uVar5 = length + *(uint *)&ctx->len;
    uVar7 = (uVar5 < length) + uVar4;
    if (((uVar7 < uVar4) || (((uVar4 == uVar7 && (uVar5 < *(uint *)&ctx->len)) || (0xf < uVar7))))
       || ((uVar7 == 0xf && (0xffffffe0 < uVar5)))) {
      iVar2 = -0x14;
    }
    else {
      *(uint *)&ctx->len = uVar5;
      *(uint *)((int)&ctx->len + 4) = uVar7;
      while (length != 0) {
        uVar4 = length;
        if (0x10 < length) {
          uVar4 = 0x10;
        }
        puVar6 = ctx->y + 0xf;
        do {
          uVar1 = *puVar6;
          *puVar6 = uVar1 + '\x01';
          if ((uchar)(uVar1 + '\x01') != '\0') break;
          puVar6 = puVar6 + -1;
        } while (puVar6 != ctx->y + 0xb);
        iVar2 = mbedtls_cipher_update
                          ((mbedtls_cipher_context_t *)ctx,ctx->y,0x10,(uchar *)&olen,&sStack68);
        if (iVar2 != 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return iVar2;
        }
        x = ctx->buf;
        uVar5 = 0;
        pbVar8 = x;
        do {
          if (ctx->mode == 0) {
            *pbVar8 = input[uVar5] ^ *pbVar8;
          }
          bVar3 = ectr[uVar5 - 4] ^ input[uVar5];
          output[uVar5] = bVar3;
          if (ctx->mode == 1) {
            *pbVar8 = bVar3 ^ *pbVar8;
          }
          uVar5 = uVar5 + 1;
          pbVar8 = pbVar8 + 1;
        } while (uVar4 != uVar5);
        gcm_mult(ctx,x,x);
        length = length - uVar4;
        input = input + uVar4;
        output = output + uVar4;
      }
      iVar2 = 0;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

int mbedtls_gcm_finish(mbedtls_gcm_context *ctx,uchar *tag,size_t tag_len)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  int *x;
  int iVar4;
  byte *pbVar5;
  int *piVar6;
  int *piVar7;
  byte *pbVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  byte local_40 [4];
  uchar work_buf [16];
  
  pbVar8 = local_40;
  uVar11 = *(uint *)&ctx->len;
  uVar12 = *(uint *)&ctx->add_len;
  uVar2 = *(int *)((int)&ctx->len + 4) << 3;
  uVar3 = uVar2 | uVar11 >> 0x1d;
  uVar9 = *(int *)((int)&ctx->add_len + 4) << 3;
  uVar10 = uVar12 >> 0x1d | uVar9;
  if (tag_len - 4 < 0xd) {
    memcpy(tag,ctx->base_ectr,tag_len);
    if (((uVar11 | uVar12) << 3 | uVar3 | uVar10) != 0) {
      memset(local_40,0,0x10);
      local_40[0] = (byte)(uVar9 >> 0x18);
      local_40[1] = (char)(uVar9 >> 0x10);
      local_40[2] = (char)(uVar9 >> 8);
      work_buf[0] = (uchar)((uVar12 << 3) >> 0x18);
      work_buf[1] = (uchar)((uVar12 << 3) >> 0x10);
      work_buf[4] = (uchar)(uVar2 >> 0x18);
      work_buf[5] = (uchar)(uVar2 >> 0x10);
      work_buf[6] = (uchar)(uVar2 >> 8);
      work_buf[8] = (uchar)((uVar11 << 3) >> 0x18);
      work_buf[7] = (uchar)uVar3;
      x = (int *)ctx->buf;
      work_buf[9] = (uchar)((uVar11 << 3) >> 0x10);
      local_40[3] = (char)uVar10;
      work_buf._2_2_ = (ushort)(uVar12 << 0xb) | (ushort)((uVar12 << 0x13) >> 0x18);
      work_buf._10_2_ = (ushort)(uVar11 << 0xb) | (ushort)((uVar11 << 0x13) >> 0x18);
      piVar6 = x;
      do {
        bVar1 = *pbVar8;
        piVar7 = (int *)((int)piVar6 + 1);
        pbVar8 = pbVar8 + 1;
        *(byte *)piVar6 = *(byte *)piVar6 ^ bVar1;
        piVar6 = piVar7;
      } while (piVar7 != &ctx->mode);
      gcm_mult(ctx,(uchar *)x,(uchar *)x);
      pbVar8 = tag;
      do {
        bVar1 = *(byte *)x;
        pbVar5 = pbVar8 + 1;
        x = (int *)((int)x + 1);
        *pbVar8 = *pbVar8 ^ bVar1;
        pbVar8 = pbVar5;
      } while (tag + tag_len != pbVar5);
    }
    iVar4 = 0;
  }
  else {
    iVar4 = -0x14;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar4;
}



int mbedtls_gcm_crypt_and_tag
              (mbedtls_gcm_context *ctx,int mode,size_t length,uchar *iv,size_t iv_len,uchar *add,
              size_t add_len,uchar *input,uchar *output,size_t tag_len,uchar *tag)

{
  int iVar1;
  uchar *in_stack_00000000;
  size_t in_stack_00000004;
  uchar *in_stack_00000008;
  
  iVar1 = mbedtls_gcm_starts(ctx,mode,iv,iv_len,add,add_len);
  if ((iVar1 == 0) && (iVar1 = mbedtls_gcm_update(ctx,length,input,in_stack_00000000), iVar1 == 0))
  {
    iVar1 = mbedtls_gcm_finish(ctx,in_stack_00000008,in_stack_00000004);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_gcm_auth_decrypt
              (mbedtls_gcm_context *ctx,size_t length,uchar *iv,size_t iv_len,uchar *add,
              size_t add_len,uchar *tag,size_t tag_len,uchar *input,uchar *output)

{
  undefined *puVar1;
  uint uVar2;
  byte *pbVar3;
  byte *pbVar4;
  size_t sVar5;
  uchar *in_fa2;
  uchar *in_stack_00000000;
  undefined *in_stack_00000004;
  byte local_30 [4];
  uchar check_tag [16];
  
  uVar2 = mbedtls_gcm_crypt_and_tag
                    (ctx,0,length,iv,iv_len,add,add_len,in_stack_00000000,input,(size_t)output,
                     in_fa2);
  sVar5 = 0;
  if (uVar2 == 0) {
    while (sVar5 != tag_len) {
      pbVar4 = tag + sVar5;
      pbVar3 = local_30 + sVar5;
      sVar5 = sVar5 + 1;
      uVar2 = uVar2 | *pbVar4 ^ *pbVar3;
    }
    puVar1 = in_stack_00000004 + length;
    if (uVar2 != 0) {
      while (in_stack_00000004 != puVar1) {
        *in_stack_00000004 = 0;
        in_stack_00000004 = in_stack_00000004 + 1;
      }
      uVar2 = 0xffffffee;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



void mbedtls_gcm_free(mbedtls_gcm_context *ctx)

{
  mbedtls_gcm_context *pmVar1;
  
  mbedtls_cipher_free((mbedtls_cipher_context_t *)ctx);
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)&(ctx->cipher_ctx).cipher_info = 0;
    ctx = (mbedtls_gcm_context *)((int)&(ctx->cipher_ctx).cipher_info + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mbedtls_md_info_t * mbedtls_md_info_from_type(mbedtls_md_type_t md_type)

{
  uint uVar1;
  
  uVar1 = md_type - 3 & 0xff;
  if (uVar1 < 4) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(mbedtls_md_info_t **)(CSWTCH_2 + uVar1 * 4);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_md_info_t *)0x0;
}



void mbedtls_md_init(mbedtls_md_context_t *ctx)

{
  memset(ctx,0,0xc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_md_free(mbedtls_md_context_t *ctx)

{
  undefined *puVar1;
  undefined *puVar2;
  mbedtls_md_context_t *pmVar3;
  
  if (ctx != (mbedtls_md_context_t *)0x0) {
    if (ctx->md_info != (mbedtls_md_info_t *)0x0) {
      if (ctx->md_ctx != (void *)0x0) {
        (*ctx->md_info->ctx_free_func)(ctx->md_ctx);
      }
      puVar2 = (undefined *)ctx->hmac_ctx;
      if (puVar2 != (undefined *)0x0) {
        puVar1 = puVar2 + ctx->md_info->block_size * 2;
        while (puVar2 != puVar1) {
          *puVar2 = 0;
          puVar2 = puVar2 + 1;
        }
        vPortFree(ctx->hmac_ctx);
      }
      pmVar3 = ctx + 1;
      while (ctx != pmVar3) {
        *(undefined *)&ctx->md_info = 0;
        ctx = (mbedtls_md_context_t *)((int)&ctx->md_info + 1);
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_md_setup(mbedtls_md_context_t *ctx,mbedtls_md_info_t *md_info,int hmac)

{
  void *pvVar1;
  int iVar2;
  
  if ((md_info == (mbedtls_md_info_t *)0x0) || (ctx == (mbedtls_md_context_t *)0x0)) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x5100;
  }
  pvVar1 = (*md_info->ctx_alloc_func)(md_info->ctx_alloc_func);
  ctx->md_ctx = pvVar1;
  if (pvVar1 == (void *)0x0) {
LAB_230657a0:
    iVar2 = -0x5180;
  }
  else {
    if (hmac != 0) {
      pvVar1 = mycalloc(2,md_info->block_size);
      ctx->hmac_ctx = pvVar1;
      if (pvVar1 == (void *)0x0) {
        (*md_info->ctx_free_func)(ctx->md_ctx);
        goto LAB_230657a0;
      }
    }
    ctx->md_info = md_info;
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_md_starts(mbedtls_md_context_t *ctx)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md_update(mbedtls_md_context_t *ctx,uchar *input,size_t ilen)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->update_func)(ctx->md_ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md_finish(mbedtls_md_context_t *ctx,uchar *output)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->finish_func)(ctx->md_ctx,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md(mbedtls_md_info_t *md_info,uchar *input,size_t ilen,uchar *output)

{
  if (md_info != (mbedtls_md_info_t *)0x0) {
    (*md_info->digest_func)(input,ilen,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md_hmac_starts(mbedtls_md_context_t *ctx,uchar *key,size_t keylen)

{
  int iVar1;
  size_t __n;
  byte *pbVar2;
  byte *pbVar3;
  mbedtls_md_info_t *pmVar4;
  size_t sVar5;
  uchar *puVar6;
  uchar *__s;
  uchar *__s_00;
  uchar local_40 [4];
  uchar sum [32];
  
  if (ctx == (mbedtls_md_context_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x5100;
  }
  puVar6 = local_40;
  pmVar4 = ctx->md_info;
  if ((pmVar4 == (mbedtls_md_info_t *)0x0) || (ctx->hmac_ctx == (void *)0x0)) {
    iVar1 = -0x5100;
  }
  else {
    if ((uint)pmVar4->block_size < keylen) {
      (*pmVar4->starts_func)(ctx->md_ctx);
      (*ctx->md_info->update_func)(ctx->md_ctx,key,keylen);
      (*ctx->md_info->finish_func)(ctx->md_ctx,local_40);
      keylen = ctx->md_info->size;
      key = local_40;
    }
    __s = (uchar *)ctx->hmac_ctx;
    __n = ctx->md_info->block_size;
    __s_00 = __s + __n;
    memset(__s,0x36,__n);
    memset(__s_00,0x5c,ctx->md_info->block_size);
    sVar5 = 0;
    while (keylen != sVar5) {
      pbVar2 = key + sVar5;
      __s[sVar5] = __s[sVar5] ^ *pbVar2;
      pbVar3 = __s_00 + sVar5;
      sVar5 = sVar5 + 1;
      *pbVar3 = *pbVar3 ^ *pbVar2;
    }
    do {
      *puVar6 = '\0';
      puVar6 = puVar6 + 1;
    } while (puVar6 != sum + 0x1c);
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    (*ctx->md_info->update_func)(ctx->md_ctx,__s,ctx->md_info->block_size);
    iVar1 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_md_hmac_update(mbedtls_md_context_t *ctx,uchar *input,size_t ilen)

{
  if (((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) &&
     (ctx->hmac_ctx != (void *)0x0)) {
    (*ctx->md_info->update_func)(ctx->md_ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



// WARNING: Variable defined which should be unmapped: tmp

int mbedtls_md_hmac_finish(mbedtls_md_context_t *ctx,uchar *output)

{
  int iVar1;
  mbedtls_md_info_t *pmVar2;
  void *pvVar3;
  uchar auStack48 [4];
  uchar tmp [32];
  
  if (((ctx != (mbedtls_md_context_t *)0x0) &&
      (pmVar2 = ctx->md_info, pmVar2 != (mbedtls_md_info_t *)0x0)) &&
     (pvVar3 = ctx->hmac_ctx, pvVar3 != (void *)0x0)) {
    iVar1 = pmVar2->block_size;
    (*pmVar2->finish_func)(ctx->md_ctx,auStack48);
    (*ctx->md_info->starts_func)(ctx->md_ctx);
    (*ctx->md_info->update_func)
              (ctx->md_ctx,(uchar *)(iVar1 + (int)pvVar3),ctx->md_info->block_size);
    (*ctx->md_info->update_func)(ctx->md_ctx,auStack48,ctx->md_info->size);
    (*ctx->md_info->finish_func)(ctx->md_ctx,output);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md_hmac_reset(mbedtls_md_context_t *ctx)

{
  int iVar1;
  uchar *puVar2;
  
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    puVar2 = (uchar *)ctx->hmac_ctx;
    if (puVar2 == (uchar *)0x0) {
      iVar1 = -0x5100;
    }
    else {
      (*ctx->md_info->starts_func)(ctx->md_ctx);
      (*ctx->md_info->update_func)(ctx->md_ctx,puVar2,ctx->md_info->block_size);
      iVar1 = 0;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



int mbedtls_md_process(mbedtls_md_context_t *ctx,uchar *data)

{
  if ((ctx != (mbedtls_md_context_t *)0x0) && (ctx->md_info != (mbedtls_md_info_t *)0x0)) {
    (*ctx->md_info->process_func)(ctx->md_ctx,data);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x5100;
}



uchar mbedtls_md_get_size(mbedtls_md_info_t *md_info)

{
  if (md_info != (mbedtls_md_info_t *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return *(uchar *)&md_info->size;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return '\0';
}



void md5_process_wrap(mbedtls_md5_context *ctx,uchar *data)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  
  iVar1 = *(int *)data;
  iVar2 = *(int *)(data + 4);
  iVar3 = *(int *)(data + 0x10);
  iVar4 = *(int *)(data + 8);
  iVar5 = *(int *)(data + 0xc);
  iVar6 = *(int *)(data + 0x14);
  iVar7 = *(int *)(data + 0x18);
  iVar8 = *(int *)(data + 0x24);
  iVar9 = *(int *)(data + 0x1c);
  iVar10 = *(int *)(data + 0x20);
  iVar11 = *(int *)(data + 0x2c);
  iVar12 = *(int *)(data + 0x28);
  iVar13 = *(int *)(data + 0x30);
  uVar19 = ctx->state[3];
  iVar14 = *(int *)(data + 0x34);
  iVar15 = *(int *)(data + 0x38);
  iVar16 = *(int *)(data + 0x3c);
  uVar17 = ctx->state[2];
  uVar18 = ctx->state[1];
  uVar20 = ((uVar17 ^ uVar19) & uVar18 ^ uVar19) + ctx->state[0] + 0xd76aa478 + iVar1;
  uVar21 = (uVar20 >> 0x19 | uVar20 * 0x80) + uVar18;
  uVar20 = ((uVar18 ^ uVar17) & uVar21 ^ uVar17) + uVar19 + 0xe8c7b756 + iVar2;
  uVar23 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar18 ^ uVar21) & uVar23 ^ uVar18) + uVar17 + 0x242070db + iVar4;
  uVar22 = (uVar20 * 0x20000 | uVar20 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + uVar18 + 0xc1bdceee + iVar5;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar3 + -0xa83f051 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar6 + 0x4787c62a + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar7 + -0x57cfb9ed + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar9 + -0x2b96aff + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar10 + 0x698098d8 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar8 + -0x74bb0851 + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar12 + -0xa44f + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar11 + -0x76a32842 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar13 + 0x6b901122 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar14 + -0x2678e6d + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar15 + -0x5986bc72 + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar16 + 0x49b40821 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar2 + -0x9e1da9e + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar7 + -0x3fbf4cc0 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar11 + 0x265e5a51 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar1 + -0x16493856 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar6 + -0x29d0efa3 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar12 + 0x2441453 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar16 + -0x275e197f + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar3 + -0x182c0438 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar8 + 0x21e1cde6 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar15 + -0x3cc8f82a + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar5 + -0xb2af279 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar10 + 0x455a14ed + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar14 + -0x561c16fb + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar4 + -0x3105c08 + uVar23;
  uVar24 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar24) & uVar20 ^ uVar21) + iVar9 + 0x676f02d9 + uVar22;
  uVar23 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar24;
  uVar20 = ((uVar24 ^ uVar23) & uVar21 ^ uVar24) + iVar13 + -0x72d5b376 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar23;
  uVar21 = (uVar24 ^ uVar23 ^ uVar20) + iVar6 + -0x5c6be + uVar21;
  uVar21 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar20;
  uVar22 = (uVar23 ^ uVar20 ^ uVar21) + uVar24 + iVar10 + -0x788e097f;
  uVar22 = (uVar22 >> 0x15 | uVar22 * 0x800) + uVar21;
  uVar23 = (uVar20 ^ uVar21 ^ uVar22) + uVar23 + iVar11 + 0x6d9d6122;
  uVar24 = (uVar23 >> 0x10 | uVar23 * 0x10000) + uVar22;
  uVar20 = (uVar21 ^ uVar22 ^ uVar24) + uVar20 + iVar15 + -0x21ac7f4;
  uVar23 = (uVar20 * 0x800000 | uVar20 >> 9) + uVar24;
  uVar20 = (uVar22 ^ uVar24 ^ uVar23) + iVar2 + -0x5b4115bc + uVar21;
  uVar21 = (uVar20 >> 0x1c | uVar20 * 0x10) + uVar23;
  uVar20 = (uVar24 ^ uVar23 ^ uVar21) + uVar22 + iVar3 + 0x4bdecfa9;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar21;
  uVar22 = (uVar23 ^ uVar21 ^ uVar20) + iVar9 + -0x944b4a0 + uVar24;
  uVar24 = (uVar22 >> 0x10 | uVar22 * 0x10000) + uVar20;
  uVar22 = (uVar21 ^ uVar20 ^ uVar24) + uVar23 + iVar12 + -0x41404390;
  uVar22 = (uVar22 * 0x800000 | uVar22 >> 9) + uVar24;
  uVar21 = (uVar20 ^ uVar24 ^ uVar22) + uVar21 + iVar14 + 0x289b7ec6;
  uVar23 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar22;
  uVar20 = (uVar24 ^ uVar22 ^ uVar23) + iVar1 + -0x155ed806 + uVar20;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar21 = (uVar22 ^ uVar23 ^ uVar20) + iVar5 + -0x2b10cf7b + uVar24;
  uVar24 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar20;
  uVar21 = (uVar23 ^ uVar20 ^ uVar24) + uVar22 + iVar7 + 0x4881d05;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar24;
  uVar22 = (uVar20 ^ uVar24 ^ uVar21) + iVar8 + -0x262b2fc7 + uVar23;
  uVar23 = (uVar22 >> 0x1c | uVar22 * 0x10) + uVar21;
  uVar20 = (uVar24 ^ uVar21 ^ uVar23) + uVar20 + iVar13 + -0x1924661b;
  uVar22 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar20 = (uVar21 ^ uVar23 ^ uVar22) + uVar24 + iVar16 + 0x1fa27cf8;
  uVar20 = (uVar20 >> 0x10 | uVar20 * 0x10000) + uVar22;
  uVar21 = (uVar23 ^ uVar22 ^ uVar20) + iVar4 + -0x3b53a99b + uVar21;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar20;
  uVar23 = ((~uVar22 | uVar21) ^ uVar20) + uVar23 + iVar1 + -0xbd6ddbc;
  uVar24 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar21;
  uVar22 = ((~uVar20 | uVar24) ^ uVar21) + uVar22 + iVar9 + 0x432aff97;
  uVar23 = (uVar22 >> 0x16 | uVar22 * 0x400) + uVar24;
  uVar20 = ((~uVar21 | uVar23) ^ uVar24) + iVar15 + -0x546bdc59 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar23;
  uVar21 = ((~uVar24 | uVar20) ^ uVar23) + iVar6 + -0x36c5fc7 + uVar21;
  uVar22 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar23 | uVar22) ^ uVar20) + iVar13 + 0x655b59c3 + uVar24;
  uVar24 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar24) ^ uVar22) + uVar23 + iVar5 + -0x70f3336e;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar24;
  uVar20 = ((~uVar22 | uVar21) ^ uVar24) + iVar12 + -0x100b83 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar22 = ((~uVar24 | uVar20) ^ uVar21) + iVar2 + -0x7a7ba22f + uVar22;
  uVar22 = (uVar22 * 0x200000 | uVar22 >> 0xb) + uVar20;
  uVar23 = ((~uVar21 | uVar22) ^ uVar20) + iVar10 + 0x6fa87e4f + uVar24;
  uVar25 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar25) ^ uVar22) + uVar21 + iVar16 + -0x1d31920;
  uVar24 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar25;
  uVar20 = ((~uVar22 | uVar24) ^ uVar25) + iVar7 + -0x5cfebcec + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar24;
  uVar21 = ((~uVar25 | uVar20) ^ uVar24) + iVar14 + 0x4e0811a1 + uVar22;
  uVar23 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar24 | uVar23) ^ uVar20) + uVar25 + iVar3 + -0x8ac817e;
  uVar22 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar23;
  uVar21 = ((~uVar20 | uVar22) ^ uVar23) + uVar24 + iVar11 + -0x42c50dcb;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar22;
  uVar20 = ((~uVar23 | uVar21) ^ uVar22) + uVar20 + iVar4 + 0x2ad7d2bb;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar23 = ((~uVar22 | uVar20) ^ uVar21) + uVar23 + iVar8 + -0x14792c6f;
  ctx->state[0] = ctx->state[0] + uVar22;
  ctx->state[1] = uVar18 + uVar20 + (uVar23 >> 0xb | uVar23 * 0x200000);
  ctx->state[2] = uVar20 + uVar17;
  ctx->state[3] = uVar21 + uVar19;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void md5_clone_wrap(mbedtls_md5_context *dst,mbedtls_md5_context *src)

{
  memcpy(dst,src,0x58);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void md5_ctx_free(void *ctx)

{
  mbedtls_md5_free((mbedtls_md5_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * md5_ctx_alloc(void)

{
  mbedtls_md5_context *ctx;
  
  ctx = (mbedtls_md5_context *)mycalloc(1,0x58);
  if (ctx != (mbedtls_md5_context *)0x0) {
    mbedtls_md5_init(ctx);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



void md5_finish_wrap(mbedtls_md5_context *ctx,uchar *output)

{
  uint uVar1;
  int iVar2;
  int iStack24;
  uint uStack20;
  
  uVar1 = ctx->total[0];
  uStack20 = ctx->total[1] << 3 | uVar1 >> 0x1d;
  iStack24 = uVar1 << 3;
  if ((uVar1 & 0x3f) < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  mbedtls_md5_update(ctx,md5_padding,iVar2 - (uVar1 & 0x3f));
  mbedtls_md5_update(ctx,(uchar *)&iStack24,8);
  *output = (uchar)ctx->state[0];
  output[1] = (uchar)(ctx->state[0] >> 8);
  output[2] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[3] = *(uchar *)((int)ctx->state + 3);
  output[4] = (uchar)ctx->state[1];
  output[5] = (uchar)(ctx->state[1] >> 8);
  output[6] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[7] = *(uchar *)((int)ctx->state + 7);
  output[8] = (uchar)ctx->state[2];
  output[9] = (uchar)(ctx->state[2] >> 8);
  output[10] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[0xb] = *(uchar *)((int)ctx->state + 0xb);
  output[0xc] = (uchar)ctx->state[3];
  output[0xd] = (uchar)(ctx->state[3] >> 8);
  output[0xe] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xf] = *(uchar *)((int)ctx->state + 0xf);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void md5_update_wrap(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_md5_update(ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void md5_starts_wrap(mbedtls_md5_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[3] = 0x10325476;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha1_process_wrap(mbedtls_sha1_context *ctx,uchar *data)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint32_t uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  
  uVar8 = (uint)*data << 0x18 | (uint)data[1] << 0x10 | (uint)data[3] | (uint)data[2] << 8;
  uVar10 = (uint)data[4] << 0x18 | (uint)data[5] << 0x10 | (uint)data[7] | (uint)data[6] << 8;
  uVar9 = (uint)data[8] << 0x18 | (uint)data[9] << 0x10 | (uint)data[0xb] | (uint)data[10] << 8;
  uVar1 = (uint)data[0xc] << 0x18 | (uint)data[0xd] << 0x10 | (uint)data[0xf] | (uint)data[0xe] << 8
  ;
  uVar27 = (uint)data[0x10] << 0x18 | (uint)data[0x11] << 0x10 | (uint)data[0x13] |
           (uint)data[0x12] << 8;
  uVar25 = (uint)data[0x14] << 0x18 | (uint)data[0x15] << 0x10 | (uint)data[0x17] |
           (uint)data[0x16] << 8;
  uVar14 = (uint)data[0x18] << 0x18 | (uint)data[0x19] << 0x10 | (uint)data[0x1b] |
           (uint)data[0x1a] << 8;
  uVar20 = (uint)data[0x1c] << 0x18 | (uint)data[0x1d] << 0x10 | (uint)data[0x1f] |
           (uint)data[0x1e] << 8;
  uVar28 = (uint)data[0x20] << 0x18 | (uint)data[0x21] << 0x10 | (uint)data[0x23] |
           (uint)data[0x22] << 8;
  uVar26 = (uint)data[0x24] << 0x18 | (uint)data[0x25] << 0x10 | (uint)data[0x27] |
           (uint)data[0x26] << 8;
  uVar2 = (uint)data[0x28] << 0x18 | (uint)data[0x29] << 0x10 | (uint)data[0x2b] |
          (uint)data[0x2a] << 8;
  uVar13 = (uint)data[0x2c] << 0x18 | (uint)data[0x2d] << 0x10 | (uint)data[0x2f] |
           (uint)data[0x2e] << 8;
  uVar11 = (uint)data[0x30] << 0x18 | (uint)data[0x31] << 0x10 | (uint)data[0x33] |
           (uint)data[0x32] << 8;
  uVar16 = ctx->state[2];
  uVar15 = ctx->state[0];
  uVar5 = (uint)data[0x34] << 0x18 | (uint)data[0x35] << 0x10 | (uint)data[0x37] |
          (uint)data[0x36] << 8;
  uVar4 = (uint)data[0x38] << 0x18 | (uint)data[0x39] << 0x10 | (uint)data[0x3b] |
          (uint)data[0x3a] << 8;
  uVar3 = (uint)data[0x3c] << 0x18 | (uint)data[0x3d] << 0x10 | (uint)data[0x3f] |
          (uint)data[0x3e] << 8;
  uVar6 = (uVar15 << 5 | uVar15 >> 0x1b) + ctx->state[4] + 0x5a827999 +
          ((uVar16 ^ ctx->state[3]) & ctx->state[1] ^ ctx->state[3]) + uVar8;
  uVar17 = ctx->state[1] << 0x1e | ctx->state[1] >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar16 ^ uVar17) & uVar15 ^ uVar16) + ctx->state[3] + 0x5a827999 + uVar10;
  uVar23 = uVar15 << 0x1e | uVar15 >> 2;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar6 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
          ((uVar17 ^ uVar23) & uVar6 ^ uVar17) + uVar16 + 0x5a827999 + uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar23 ^ uVar7) & uVar18 ^ uVar23) + uVar17 + 0x5a827999 + uVar1;
  uVar21 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar19) & uVar6 ^ uVar7) + uVar23 + 0x5a827999 + uVar27;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + uVar25 + 0x5a827999 + uVar7;
  uVar6 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
          ((uVar21 ^ uVar6) & uVar17 ^ uVar21) + uVar14 + 0x5a827999 + uVar19;
  uVar24 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar19 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           ((uVar6 ^ uVar18) & uVar23 ^ uVar6) + uVar21 + uVar20 + 0x5a827999;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar18 ^ uVar24) & uVar7 ^ uVar18) + uVar28 + 0x5a827999 + uVar6;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar24 ^ uVar17) & uVar19 ^ uVar24) + uVar18 + uVar26 + 0x5a827999;
  uVar22 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar17 ^ uVar23) & uVar7 ^ uVar17) + uVar2 + 0x5a827999 + uVar24;
  uVar18 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar23 ^ uVar22) & uVar6 ^ uVar23) + uVar17 + uVar13 + 0x5a827999;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar22 ^ uVar18) & uVar19 ^ uVar22) + uVar11 + 0x5a827999 + uVar23;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar18 ^ uVar21) & uVar7 ^ uVar18) + uVar22 + uVar5 + 0x5a827999;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar23 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           ((uVar21 ^ uVar17) & uVar6 ^ uVar21) + uVar4 + 0x5a827999 + uVar18;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           ((uVar17 ^ uVar7) & uVar19 ^ uVar17) + uVar21 + uVar3 + 0x5a827999;
  uVar8 = uVar6 >> 0x1f | uVar6 << 1;
  uVar6 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar10 = uVar6 >> 0x1f | uVar6 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar22) & uVar23 ^ uVar7) + uVar8 + 0x5a827999 + uVar17;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar6 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          ((uVar22 ^ uVar19) & uVar18 ^ uVar22) + uVar7 + uVar10 + 0x5a827999;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar8;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar17 ^ uVar19) + uVar9 + 0x5a827999 + uVar22;
  uVar17 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar21 ^ uVar23) & uVar6 ^ uVar21) + uVar1 + 0x5a827999 + uVar19;
  uVar6 = uVar25 ^ uVar20 ^ uVar5 ^ uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar24 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar7 ^ uVar18) + uVar21 + uVar27 + 0x6ed9eba1;
  uVar6 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar7 ^ uVar19 ^ uVar17) + uVar24 + 0x6ed9eba1 + uVar23;
  uVar14 = uVar6 >> 0x1f | uVar6 << 1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar20 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar14 + 0x6ed9eba1 + uVar7;
  uVar7 = uVar28 ^ uVar2 ^ uVar8 ^ uVar24;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar28 = uVar7 >> 0x1f | uVar7 << 1;
  uVar7 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar6 + 0x6ed9eba1;
  uVar17 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar26 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar28 + 0x6ed9eba1;
  uVar2 = uVar2 ^ uVar11 ^ uVar9 ^ uVar6;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar20 ^ uVar22 ^ uVar7) + uVar23 + uVar26 + 0x6ed9eba1;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar7 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar13 = uVar7 >> 0x1f | uVar7 << 1;
  uVar20 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar19 ^ uVar17) + uVar2 + 0x6ed9eba1 + uVar20;
  uVar7 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar11 = uVar7 >> 0x1f | uVar7 << 1;
  uVar17 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar13 + 0x6ed9eba1 + uVar22;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar7 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar20) + uVar19 + uVar11 + 0x6ed9eba1;
  uVar4 = uVar4 ^ uVar8 ^ uVar14 ^ uVar13;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) + (uVar23 ^ uVar22 ^ uVar17) + uVar18 + uVar5 + 0x6ed9eba1
  ;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar22 ^ uVar20 ^ uVar7) + uVar23 + uVar4 + 0x6ed9eba1;
  uVar7 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar20 ^ uVar19 ^ uVar17) + uVar3 + 0x6ed9eba1 + uVar22;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar8 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar8 >> 0x1f | uVar8 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar7 + 0x6ed9eba1 + uVar20;
  uVar8 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar10 + 0x6ed9eba1;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar9 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar8 + 0x6ed9eba1;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar19 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar21 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar20 ^ uVar22 ^ uVar17) + uVar1 + 0x6ed9eba1 + uVar23
  ;
  uVar27 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar25 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar18 ^ uVar9) + uVar27 + 0x6ed9eba1 + uVar20;
  uVar9 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar14 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar18 ^ uVar17 ^ uVar21) + uVar22 + uVar25 + 0x6ed9eba1;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          (uVar17 ^ uVar23 ^ uVar19) + uVar14 + 0x6ed9eba1 + uVar18;
  uVar18 = uVar28 ^ uVar2 ^ uVar7 ^ uVar25;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar28 = uVar18 >> 0x1f | uVar18 << 1;
  uVar17 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar23 ^ uVar21 ^ uVar20) + uVar6 + 0x6ed9eba1 + uVar17
  ;
  uVar19 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar20 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar18 = ((uVar9 | uVar22) & uVar21 | uVar9 & uVar22) +
           uVar28 + 0x8f1bbcdc + uVar23 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar26 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar17 | uVar19) & uVar22 | uVar17 & uVar19) + uVar26 + 0x8f1bbcdc + uVar21;
  uVar9 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = ((uVar18 | uVar23) & uVar19 | uVar18 & uVar23) +
           uVar2 + 0x8f1bbcdc + uVar22 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar9 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar11 = uVar9 >> 0x1f | uVar9 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          ((uVar17 | uVar21) & uVar23 | uVar17 & uVar21) + uVar13 + 0x8f1bbcdc + uVar19;
  uVar24 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 ^ uVar3 ^ uVar25 ^ uVar2;
  uVar19 = ((uVar20 | uVar18) & uVar21 | uVar20 & uVar18) +
           uVar11 + 0x8f1bbcdc + uVar23 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar9 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar9 | uVar24) & uVar18 | uVar9 & uVar24) + uVar5 + 0x8f1bbcdc + uVar21;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar18 = ((uVar19 | uVar17) & uVar24 | uVar19 & uVar17) +
           uVar4 + 0x8f1bbcdc + uVar18 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar20 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar9 | uVar22) & uVar17 | uVar9 & uVar22) + uVar3 + 0x8f1bbcdc + uVar24;
  uVar9 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar10 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar7 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar9 + 0x8f1bbcdc + uVar22;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar7;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar10 = ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) +
           uVar8 + 0x8f1bbcdc + uVar20 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar21 = uVar27 ^ uVar14 ^ uVar11 ^ uVar9;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar27 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) + uVar19 + uVar1 + 0x8f1bbcdc;
  uVar19 = uVar25 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar24 = uVar19 >> 0x1f | uVar19 << 1;
  uVar21 = ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) +
           uVar27 + 0x8f1bbcdc + uVar23 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar10 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar14 = uVar10 >> 0x1f | uVar10 << 1;
  uVar10 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) + uVar17 + uVar24 + 0x8f1bbcdc;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar18 = ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) +
           uVar14 + 0x8f1bbcdc + uVar22 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar21 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar28 = uVar21 >> 0x1f | uVar21 << 1;
  uVar10 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) + uVar20 + uVar6 + 0x8f1bbcdc;
  uVar21 = uVar26 ^ uVar13 ^ uVar9 ^ uVar14;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar25 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) +
           uVar28 + 0x8f1bbcdc + uVar19 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) + uVar23 + uVar25 + 0x8f1bbcdc;
  uVar10 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar10 >> 0x1f | uVar10 << 1;
  uVar17 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar2 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar10 = uVar11 ^ uVar4 ^ uVar27 ^ uVar25;
  uVar18 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar10 >> 0x1f | uVar10 << 1;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar22 + uVar13 + 0x8f1bbcdc;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar11 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar21 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar17) + uVar20 + uVar10 + 0xca62c1d6;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar20 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar11 ^ uVar23) + uVar19 + uVar5 + 0xca62c1d6;
  uVar3 = uVar3 ^ uVar9 ^ uVar6 ^ uVar10;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar11 ^ uVar20 ^ uVar21) + uVar18 + uVar4 + 0xca62c1d6;
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar20 ^ uVar23 ^ uVar17) + uVar11 + uVar3 + 0xca62c1d6;
  uVar9 = uVar9 ^ uVar1 ^ uVar25 ^ uVar4;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar20 + uVar7 + 0xca62c1d6;
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar17 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar11) + uVar23 + uVar9 + 0xca62c1d6;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar17 ^ uVar20) + uVar18 + uVar8 + 0xca62c1d6;
  uVar18 = uVar27 ^ uVar14 ^ uVar10 ^ uVar9;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar26 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar17 ^ uVar22 ^ uVar19) + uVar21 + uVar1 + 0xca62c1d6;
  uVar21 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar18 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar24 = uVar21 >> 0x1f | uVar21 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar22 ^ uVar23 ^ uVar11) + uVar17 + uVar26 + 0xca62c1d6;
  uVar11 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar11 = uVar11 >> 0x1f | uVar11 << 1;
  uVar20 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar22 + uVar24 + 0xca62c1d6;
  uVar6 = uVar6 ^ uVar25 ^ uVar3 ^ uVar26;
  uVar14 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar17) + uVar23 + uVar11 + 0xca62c1d6;
  uVar17 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar14 ^ uVar20) + uVar18 + uVar6 + 0xca62c1d6;
  uVar18 = uVar25 ^ uVar13 ^ uVar9 ^ uVar11;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar20 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar14 ^ uVar22 ^ uVar19) + uVar21 + uVar27 + 0xca62c1d6;
  uVar2 = uVar2 ^ uVar10 ^ uVar8 ^ uVar6;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar8 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          (uVar22 ^ uVar23 ^ uVar17) + uVar14 + uVar20 + 0xca62c1d6;
  uVar27 = uVar13 ^ uVar5 ^ uVar1 ^ uVar27;
  uVar13 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar21 = uVar27 >> 0x1f | uVar27 << 1;
  uVar14 = uVar22 + uVar2 + 0xca62c1d6 + (uVar23 ^ uVar18 ^ uVar19) + (uVar8 * 0x20 | uVar8 >> 0x1b)
  ;
  uVar20 = uVar10 ^ uVar4 ^ uVar26 ^ uVar20;
  uVar10 = (uVar14 * 0x20 | uVar14 >> 0x1b) +
           (uVar18 ^ uVar13 ^ uVar8) + uVar23 + uVar21 + 0xca62c1d6;
  uVar1 = uVar8 * 0x40000000 | uVar8 >> 2;
  uVar17 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar5 = uVar18 + uVar17 + 0xca62c1d6 + (uVar13 ^ uVar1 ^ uVar14) +
          (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar8 = uVar14 * 0x40000000 | uVar14 >> 2;
  uVar21 = uVar4 ^ uVar7 ^ uVar11 ^ uVar21;
  uVar4 = uVar13 + (uVar2 << 1 | uVar2 >> 0x1f) + 0xca62c1d6 + (uVar1 ^ uVar8 ^ uVar10) +
          (uVar5 * 0x20 | uVar5 >> 0x1b);
  uVar7 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar17 = uVar3 ^ uVar9 ^ uVar6 ^ uVar17;
  uVar1 = uVar1 + (uVar21 << 1 | uVar21 >> 0x1f) + 0xca62c1d6 + (uVar8 ^ uVar7 ^ uVar5) +
          (uVar4 * 0x20 | uVar4 >> 0x1b);
  uVar2 = uVar5 * 0x40000000 | uVar5 >> 2;
  uVar12 = ctx->state[1];
  ctx->state[0] =
       uVar8 + (uVar17 << 1 | uVar17 >> 0x1f) + uVar15 + 0xca62c1d6 + (uVar7 ^ uVar2 ^ uVar4) +
       (uVar1 * 0x20 | uVar1 >> 0x1b);
  ctx->state[1] = uVar1 + uVar12;
  ctx->state[2] = uVar16 + (uVar4 >> 2 | uVar4 * 0x40000000);
  ctx->state[3] = uVar2 + ctx->state[3];
  ctx->state[4] = uVar7 + ctx->state[4];
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha1_clone_wrap(mbedtls_sha1_context *dst,mbedtls_sha1_context *src)

{
  memcpy(dst,src,0x5c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha1_ctx_free(void *ctx)

{
  mbedtls_sha1_free((mbedtls_sha1_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * sha1_ctx_alloc(void)

{
  mbedtls_sha1_context *ctx;
  
  ctx = (mbedtls_sha1_context *)mycalloc(1,0x5c);
  if (ctx != (mbedtls_sha1_context *)0x0) {
    mbedtls_sha1_init(ctx);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



void sha1_finish_wrap(mbedtls_sha1_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  undefined uStack20;
  undefined uStack19;
  ushort uStack18;
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  uStack20 = (undefined)((uVar1 << 3) >> 0x18);
  uStack19 = (undefined)((uVar1 << 3) >> 0x10);
  uStack18 = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha1_update(ctx,sha1_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha1_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha1_update_wrap(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha1_update(ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha1_starts_wrap(mbedtls_sha1_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->state[3] = 0x10325476;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[4] = 0xc3d2e1f0;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_process_wrap(mbedtls_sha256_context *ctx,uchar *data)

{
  uint uVar1;
  uint32_t *puVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint uVar8;
  uint *puVar9;
  uint uVar10;
  uint32_t *puVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint *puVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint *puVar22;
  uint32_t *puVar23;
  uint uVar24;
  uint uVar25;
  uint auStack336 [4];
  uint uStack320;
  uint uStack316;
  uint uStack312;
  uint uStack308;
  uint auStack304 [67];
  
  puVar18 = auStack336;
  puVar9 = auStack336;
  puVar11 = ctx->state;
  do {
    uVar7 = *puVar11;
    puVar11 = puVar11 + 1;
    *puVar9 = uVar7;
    puVar9 = puVar9 + 1;
  } while ((uint32_t *)ctx->buffer != puVar11);
  puVar22 = auStack304;
  pbVar3 = data;
  puVar9 = puVar22;
  do {
    pbVar4 = pbVar3 + 4;
    *puVar9 = (uint)*pbVar3 << 0x18 | (uint)pbVar3[1] << 0x10 | (uint)pbVar3[3] |
              (uint)pbVar3[2] << 8;
    pbVar3 = pbVar4;
    puVar9 = puVar9 + 1;
  } while (data + 0x40 != pbVar4);
  puVar2 = K;
  puVar11 = K;
  puVar9 = puVar22;
  do {
    puVar23 = puVar11 + 8;
    iVar13 = uStack308 +
             ((uStack320 >> 6 | uStack320 << 0x1a) ^ (uStack320 >> 0xb | uStack320 << 0x15) ^
             (uStack320 << 7 | uStack320 >> 0x19)) + *puVar11 + *puVar9 +
             ((uStack312 ^ uStack316) & uStack320 ^ uStack312);
    uVar12 = auStack336[3] + iVar13;
    uVar14 = iVar13 + ((auStack336[0] >> 2 | auStack336[0] << 0x1e) ^
                       (auStack336[0] >> 0xd | auStack336[0] << 0x13) ^
                      (auStack336[0] << 10 | auStack336[0] >> 0x16)) +
                      ((auStack336[0] | auStack336[1]) & auStack336[2] |
                      auStack336[0] & auStack336[1]);
    iVar13 = ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19)) +
             uStack312 + puVar11[1] + puVar9[1] + ((uStack320 ^ uStack316) & uVar12 ^ uStack316);
    uVar1 = ((uVar14 >> 2 | uVar14 * 0x40000000) ^ (uVar14 >> 0xd | uVar14 * 0x80000) ^
            (uVar14 * 0x400 | uVar14 >> 0x16)) +
            ((uVar14 | auStack336[0]) & auStack336[1] | uVar14 & auStack336[0]) + iVar13;
    uVar10 = auStack336[2] + iVar13;
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             uStack316 + puVar11[2] + puVar9[2] + ((uVar12 ^ uStack320) & uVar10 ^ uStack320);
    uVar5 = ((uVar1 >> 2 | uVar1 * 0x40000000) ^ (uVar1 >> 0xd | uVar1 * 0x80000) ^
            (uVar1 * 0x400 | uVar1 >> 0x16)) + ((uVar14 | uVar1) & auStack336[0] | uVar14 & uVar1) +
            iVar13;
    uVar8 = auStack336[1] + iVar13;
    iVar13 = ((uVar8 >> 6 | uVar8 * 0x4000000) ^ (uVar8 >> 0xb | uVar8 * 0x200000) ^
             (uVar8 * 0x80 | uVar8 >> 0x19)) +
             uStack320 + puVar11[3] + puVar9[3] + ((uVar12 ^ uVar10) & uVar8 ^ uVar12);
    uVar16 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
             (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar1 | uVar5) & uVar14 | uVar1 & uVar5) + iVar13;
    uVar6 = auStack336[0] + iVar13;
    iVar13 = ((uVar6 >> 6 | uVar6 * 0x4000000) ^ (uVar6 >> 0xb | uVar6 * 0x200000) ^
             (uVar6 * 0x80 | uVar6 >> 0x19)) +
             uVar12 + puVar11[4] + puVar9[4] + ((uVar10 ^ uVar8) & uVar6 ^ uVar10);
    auStack336[3] =
         ((uVar16 >> 2 | uVar16 * 0x40000000) ^ (uVar16 >> 0xd | uVar16 * 0x80000) ^
         (uVar16 * 0x400 | uVar16 >> 0x16)) + ((uVar5 | uVar16) & uVar1 | uVar5 & uVar16) + iVar13;
    uStack308 = uVar14 + iVar13;
    iVar13 = ((uStack308 >> 6 | uStack308 * 0x4000000) ^ (uStack308 >> 0xb | uStack308 * 0x200000) ^
             (uStack308 * 0x80 | uStack308 >> 0x19)) +
             uVar10 + puVar11[5] + puVar9[5] + ((uVar8 ^ uVar6) & uStack308 ^ uVar8);
    auStack336[2] =
         ((auStack336[3] >> 2 | auStack336[3] * 0x40000000) ^
          (auStack336[3] >> 0xd | auStack336[3] * 0x80000) ^
         (auStack336[3] * 0x400 | auStack336[3] >> 0x16)) +
         ((uVar16 | auStack336[3]) & uVar5 | uVar16 & auStack336[3]) + iVar13;
    uStack312 = uVar1 + iVar13;
    iVar13 = ((uStack312 >> 6 | uStack312 * 0x4000000) ^ (uStack312 >> 0xb | uStack312 * 0x200000) ^
             (uStack312 * 0x80 | uStack312 >> 0x19)) +
             uVar8 + puVar11[6] + puVar9[6] + ((uVar6 ^ uStack308) & uStack312 ^ uVar6);
    auStack336[1] =
         ((auStack336[2] >> 2 | auStack336[2] * 0x40000000) ^
          (auStack336[2] >> 0xd | auStack336[2] * 0x80000) ^
         (auStack336[2] * 0x400 | auStack336[2] >> 0x16)) +
         ((auStack336[3] | auStack336[2]) & uVar16 | auStack336[3] & auStack336[2]) + iVar13;
    uStack316 = uVar5 + iVar13;
    iVar13 = ((uStack316 >> 6 | uStack316 * 0x4000000) ^ (uStack316 >> 0xb | uStack316 * 0x200000) ^
             (uStack316 * 0x80 | uStack316 >> 0x19)) +
             uVar6 + puVar11[7] + puVar9[7] + ((uStack308 ^ uStack312) & uStack316 ^ uStack308);
    uStack320 = uVar16 + iVar13;
    auStack336[0] =
         ((auStack336[1] >> 2 | auStack336[1] * 0x40000000) ^
          (auStack336[1] >> 0xd | auStack336[1] * 0x80000) ^
         (auStack336[1] * 0x400 | auStack336[1] >> 0x16)) +
         ((auStack336[2] | auStack336[1]) & auStack336[3] | auStack336[2] & auStack336[1]) + iVar13;
    puVar11 = puVar23;
    puVar9 = puVar9 + 8;
  } while (puVar23 != K + 0x10);
  do {
    uVar19 = puVar22[0xe];
    uVar1 = puVar22[1];
    uVar20 = puVar22[0xf];
    uVar24 = ((uVar19 << 0xf | uVar19 >> 0x11) ^ (uVar19 << 0xd | uVar19 >> 0x13) ^ uVar19 >> 10) +
             puVar22[9] + *puVar22 +
             ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    uVar10 = puVar22[3];
    iVar13 = uStack308 +
             ((uStack320 >> 6 | uStack320 << 0x1a) ^ (uStack320 >> 0xb | uStack320 << 0x15) ^
             (uStack320 << 7 | uStack320 >> 0x19)) +
             ((uStack312 ^ uStack316) & uStack320 ^ uStack312) + puVar2[0x10] + uVar24;
    uVar16 = auStack336[3] + iVar13;
    uVar15 = iVar13 + ((auStack336[0] >> 2 | auStack336[0] << 0x1e) ^
                       (auStack336[0] >> 0xd | auStack336[0] << 0x13) ^
                      (auStack336[0] << 10 | auStack336[0] >> 0x16)) +
                      ((auStack336[0] | auStack336[1]) & auStack336[2] |
                      auStack336[0] & auStack336[1]);
    uVar6 = puVar22[2];
    uVar1 = ((uVar20 << 0xf | uVar20 >> 0x11) ^ (uVar20 << 0xd | uVar20 >> 0x13) ^ uVar20 >> 10) +
            uVar1 + puVar22[10] +
            ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((uStack320 ^ uStack316) & uVar16 ^ uStack316) + uStack312 + puVar2[0x11] + uVar1 +
             ((uVar16 >> 6 | uVar16 * 0x4000000) ^ (uVar16 >> 0xb | uVar16 * 0x200000) ^
             (uVar16 * 0x80 | uVar16 >> 0x19));
    uVar5 = ((uVar15 >> 2 | uVar15 * 0x40000000) ^ (uVar15 >> 0xd | uVar15 * 0x80000) ^
            (uVar15 * 0x400 | uVar15 >> 0x16)) +
            ((auStack336[0] | uVar15) & auStack336[1] | auStack336[0] & uVar15) + iVar13;
    uVar14 = auStack336[2] + iVar13;
    uVar6 = ((uVar24 * 0x8000 | uVar24 >> 0x11) ^ (uVar24 * 0x2000 | uVar24 >> 0x13) ^ uVar24 >> 10)
            + uVar6 + puVar22[0xb] +
            ((uVar10 >> 7 | uVar10 << 0x19) ^ (uVar10 << 0xe | uVar10 >> 0x12) ^ uVar10 >> 3);
    iVar13 = ((uStack320 ^ uVar16) & uVar14 ^ uStack320) + uStack316 + puVar2[0x12] + uVar6 +
             ((uVar14 >> 6 | uVar14 * 0x4000000) ^ (uVar14 >> 0xb | uVar14 * 0x200000) ^
             (uVar14 * 0x80 | uVar14 >> 0x19));
    puVar22[0x11] = uVar1;
    uVar8 = ((uVar5 >> 2 | uVar5 * 0x40000000) ^ (uVar5 >> 0xd | uVar5 * 0x80000) ^
            (uVar5 * 0x400 | uVar5 >> 0x16)) + ((uVar15 | uVar5) & auStack336[0] | uVar15 & uVar5) +
            iVar13;
    uVar12 = auStack336[1] + iVar13;
    uVar25 = puVar22[4];
    uVar1 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
            uVar10 + puVar22[0xc] +
            ((uVar25 >> 7 | uVar25 << 0x19) ^ (uVar25 << 0xe | uVar25 >> 0x12) ^ uVar25 >> 3);
    iVar13 = ((uVar16 ^ uVar14) & uVar12 ^ uVar16) + uStack320 + puVar2[0x13] + uVar1 +
             ((uVar12 >> 6 | uVar12 * 0x4000000) ^ (uVar12 >> 0xb | uVar12 * 0x200000) ^
             (uVar12 * 0x80 | uVar12 >> 0x19));
    uVar17 = ((uVar8 >> 2 | uVar8 * 0x40000000) ^ (uVar8 >> 0xd | uVar8 * 0x80000) ^
             (uVar8 * 0x400 | uVar8 >> 0x16)) + ((uVar5 | uVar8) & uVar15 | uVar5 & uVar8) + iVar13;
    uVar10 = auStack336[0] + iVar13;
    puVar22[0x12] = uVar6;
    uVar21 = puVar22[5];
    uVar25 = ((uVar6 * 0x8000 | uVar6 >> 0x11) ^ (uVar6 * 0x2000 | uVar6 >> 0x13) ^ uVar6 >> 10) +
             uVar25 + puVar22[0xd] +
             ((uVar21 >> 7 | uVar21 << 0x19) ^ (uVar21 << 0xe | uVar21 >> 0x12) ^ uVar21 >> 3);
    iVar13 = ((uVar10 >> 6 | uVar10 * 0x4000000) ^ (uVar10 >> 0xb | uVar10 * 0x200000) ^
             (uVar10 * 0x80 | uVar10 >> 0x19)) +
             ((uVar14 ^ uVar12) & uVar10 ^ uVar14) + uVar16 + puVar2[0x14] + uVar25;
    auStack336[3] =
         ((uVar17 >> 2 | uVar17 * 0x40000000) ^ (uVar17 >> 0xd | uVar17 * 0x80000) ^
         (uVar17 * 0x400 | uVar17 >> 0x16)) + ((uVar8 | uVar17) & uVar5 | uVar8 & uVar17) + iVar13;
    uStack308 = uVar15 + iVar13;
    uVar6 = puVar22[6];
    puVar22[0x13] = uVar1;
    uVar16 = ((uVar1 * 0x8000 | uVar1 >> 0x11) ^ (uVar1 * 0x2000 | uVar1 >> 0x13) ^ uVar1 >> 10) +
             uVar19 + uVar21 +
             ((uVar6 >> 7 | uVar6 << 0x19) ^ (uVar6 << 0xe | uVar6 >> 0x12) ^ uVar6 >> 3);
    iVar13 = ((uStack308 >> 6 | uStack308 * 0x4000000) ^ (uStack308 >> 0xb | uStack308 * 0x200000) ^
             (uStack308 * 0x80 | uStack308 >> 0x19)) +
             ((uVar12 ^ uVar10) & uStack308 ^ uVar12) + uVar14 + puVar2[0x15] + uVar16;
    auStack336[2] =
         ((auStack336[3] >> 2 | auStack336[3] * 0x40000000) ^
          (auStack336[3] >> 0xd | auStack336[3] * 0x80000) ^
         (auStack336[3] * 0x400 | auStack336[3] >> 0x16)) +
         ((uVar17 | auStack336[3]) & uVar8 | uVar17 & auStack336[3]) + iVar13;
    uStack312 = uVar5 + iVar13;
    uVar1 = puVar22[7];
    puVar22[0x14] = uVar25;
    uVar6 = uVar20 + uVar6 +
            ((uVar25 * 0x8000 | uVar25 >> 0x11) ^ (uVar25 * 0x2000 | uVar25 >> 0x13) ^ uVar25 >> 10)
            + ((uVar1 >> 7 | uVar1 << 0x19) ^ (uVar1 << 0xe | uVar1 >> 0x12) ^ uVar1 >> 3);
    iVar13 = ((uStack312 >> 6 | uStack312 * 0x4000000) ^ (uStack312 >> 0xb | uStack312 * 0x200000) ^
             (uStack312 * 0x80 | uStack312 >> 0x19)) +
             ((uVar10 ^ uStack308) & uStack312 ^ uVar10) + uVar12 + puVar2[0x16] + uVar6;
    auStack336[1] =
         ((auStack336[2] >> 2 | auStack336[2] * 0x40000000) ^
          (auStack336[2] >> 0xd | auStack336[2] * 0x80000) ^
         (auStack336[2] * 0x400 | auStack336[2] >> 0x16)) +
         ((auStack336[3] | auStack336[2]) & uVar17 | auStack336[3] & auStack336[2]) + iVar13;
    uStack316 = uVar8 + iVar13;
    uVar5 = puVar22[8];
    puVar22[0x15] = uVar16;
    puVar22[0x10] = uVar24;
    uVar7 = puVar2[0x17];
    uVar1 = uVar24 + uVar1 +
            ((uVar16 * 0x8000 | uVar16 >> 0x11) ^ (uVar16 * 0x2000 | uVar16 >> 0x13) ^ uVar16 >> 10)
            + ((uVar5 >> 7 | uVar5 << 0x19) ^ (uVar5 << 0xe | uVar5 >> 0x12) ^ uVar5 >> 3);
    puVar22[0x17] = uVar1;
    iVar13 = ((uStack316 >> 6 | uStack316 * 0x4000000) ^ (uStack316 >> 0xb | uStack316 * 0x200000) ^
             (uStack316 * 0x80 | uStack316 >> 0x19)) +
             uVar10 + uVar7 + uVar1 + ((uStack308 ^ uStack312) & uStack316 ^ uStack308);
    puVar22[0x16] = uVar6;
    puVar22 = puVar22 + 8;
    uStack320 = uVar17 + iVar13;
    auStack336[0] =
         ((auStack336[1] >> 2 | auStack336[1] * 0x40000000) ^
          (auStack336[1] >> 0xd | auStack336[1] * 0x80000) ^
         (auStack336[1] * 0x400 | auStack336[1] >> 0x16)) +
         ((auStack336[2] | auStack336[1]) & auStack336[3] | auStack336[2] & auStack336[1]) + iVar13;
    puVar2 = puVar2 + 8;
  } while (auStack304 + 0x30 != puVar22);
  puVar11 = ctx->state;
  do {
    iVar13 = *puVar18;
    puVar2 = puVar11 + 1;
    puVar18 = (uint *)((int *)puVar18 + 1);
    *puVar11 = *puVar11 + iVar13;
    puVar11 = puVar2;
  } while ((uint32_t *)ctx->buffer != puVar2);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_clone_wrap(mbedtls_sha256_context *dst,mbedtls_sha256_context *src)

{
  memcpy(dst,src,0x74);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_ctx_free(void *ctx)

{
  mbedtls_sha256_free((mbedtls_sha256_context *)ctx);
  vPortFree(ctx);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void * sha224_ctx_alloc(void)

{
  mbedtls_sha256_context *ctx;
  
  ctx = (mbedtls_sha256_context *)mycalloc(1,0x74);
  if (ctx != (mbedtls_sha256_context *)0x0) {
    mbedtls_sha256_init(ctx);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ctx;
}



void sha224_wrap(uchar *input,size_t ilen,uchar *output)

{
  mbedtls_sha256(input,ilen,output,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha256_wrap(uchar *input,size_t ilen,uchar *output)

{
  mbedtls_sha256(input,ilen,output,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_finish_wrap(mbedtls_sha256_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  undefined uStack20;
  undefined uStack19;
  ushort uStack18;
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  uStack20 = (undefined)((uVar1 << 3) >> 0x18);
  uStack19 = (undefined)((uVar1 << 3) >> 0x10);
  uStack18 = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha256_update(ctx,sha256_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha256_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  output[0x14] = *(uchar *)((int)ctx->state + 0x17);
  output[0x15] = (uchar)*(undefined2 *)((int)ctx->state + 0x16);
  output[0x16] = (uchar)(ctx->state[5] >> 8);
  output[0x17] = (uchar)ctx->state[5];
  output[0x18] = *(uchar *)((int)ctx->state + 0x1b);
  output[0x19] = (uchar)*(undefined2 *)((int)ctx->state + 0x1a);
  output[0x1a] = (uchar)(ctx->state[6] >> 8);
  output[0x1b] = (uchar)ctx->state[6];
  if (ctx->is224 == 0) {
    output[0x1c] = *(uchar *)((int)ctx->state + 0x1f);
    output[0x1d] = (uchar)*(undefined2 *)((int)ctx->state + 0x1e);
    output[0x1e] = (uchar)(ctx->state[7] >> 8);
    output[0x1f] = (uchar)ctx->state[7];
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_update_wrap(mbedtls_sha256_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha256_update(ctx,input,ilen);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha224_starts_wrap(void *ctx)

{
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,1);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void sha256_starts_wrap(void *ctx)

{
  mbedtls_sha256_starts((mbedtls_sha256_context *)ctx,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



oid_sig_alg_t * oid_sig_alg_from_asn1(mbedtls_asn1_buf *oid)

{
  oid_sig_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  poVar1 = oid_sig_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (oid_sig_alg_t *)0x0;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return poVar1;
}



int mbedtls_oid_get_attr_short_name(mbedtls_asn1_buf *oid,char **short_name)

{
  oid_x520_attr_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar1 = oid_x520_attr_type;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *short_name = poVar1->short_name;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_x509_ext_type(mbedtls_asn1_buf *oid,int *ext_type)

{
  oid_x509_ext_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar1 = oid_x509_ext;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *ext_type = poVar1->ext_type;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_extended_key_usage(mbedtls_asn1_buf *oid,char **description)

{
  mbedtls_oid_descriptor_t *pmVar1;
  int iVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  pmVar1 = oid_ext_key_usage;
  while( true ) {
    if (pmVar1->asn1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    if ((pmVar1->asn1_len == oid->len) &&
       (iVar2 = memcmp(pmVar1->asn1,oid->p,pmVar1->asn1_len), iVar2 == 0)) break;
    pmVar1 = pmVar1 + 1;
  }
  *description = pmVar1->description;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_sig_alg_desc(mbedtls_asn1_buf *oid,char **description)

{
  int iVar1;
  oid_sig_alg_t *poVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar2 = oid_sig_alg_from_asn1(oid);
  if (poVar2 == (oid_sig_alg_t *)0x0) {
    iVar1 = -0x2e;
  }
  else {
    iVar1 = 0;
    *description = (poVar2->descriptor).description;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_oid_get_sig_alg
              (mbedtls_asn1_buf *oid,mbedtls_md_type_t *md_alg,mbedtls_pk_type_t *pk_alg)

{
  int iVar1;
  oid_sig_alg_t *poVar2;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar2 = oid_sig_alg_from_asn1(oid);
  if (poVar2 == (oid_sig_alg_t *)0x0) {
    iVar1 = -0x2e;
  }
  else {
    *md_alg = poVar2->md_alg;
    iVar1 = 0;
    *pk_alg = poVar2->pk_alg;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_oid_get_pk_alg(mbedtls_asn1_buf *oid,mbedtls_pk_type_t *pk_alg)

{
  oid_pk_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar1 = oid_pk_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *pk_alg = poVar1->pk_alg;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_ec_grp(mbedtls_asn1_buf *oid,mbedtls_ecp_group_id *grp_id)

{
  oid_ecp_grp_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar1 = oid_ecp_grp;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *grp_id = poVar1->grp_id;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_md_alg(mbedtls_asn1_buf *oid,mbedtls_md_type_t *md_alg)

{
  oid_md_alg_t *poVar1;
  char *__s1;
  int iVar2;
  size_t __n;
  
  if (oid == (mbedtls_asn1_buf *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x2e;
  }
  poVar1 = oid_md_alg;
  while( true ) {
    __s1 = (poVar1->descriptor).asn1;
    if (__s1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    __n = (poVar1->descriptor).asn1_len;
    if ((__n == oid->len) && (iVar2 = memcmp(__s1,oid->p,__n), iVar2 == 0)) break;
    poVar1 = poVar1 + 1;
  }
  *md_alg = poVar1->md_alg;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_oid_get_oid_by_md(mbedtls_md_type_t md_alg,char **oid,size_t *olen)

{
  undefined3 in_register_00002029;
  char *pcVar1;
  oid_md_alg_t *poVar2;
  
  poVar2 = oid_md_alg;
  while( true ) {
    pcVar1 = (poVar2->descriptor).asn1;
    if (pcVar1 == (char *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2e;
    }
    if ((uint)poVar2->md_alg == CONCAT31(in_register_00002029,md_alg)) break;
    poVar2 = poVar2 + 1;
  }
  *oid = pcVar1;
  *olen = (poVar2->descriptor).asn1_len;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



// WARNING: Variable defined which should be unmapped: aes_ctx

void pem_aes_decrypt(uchar *aes_iv,uint keylen,uchar *buf,size_t buflen,uchar *pwd,size_t pwdlen)

{
  uchar *key;
  size_t __n;
  uchar *puVar1;
  uchar *puVar2;
  uchar local_1c0 [4];
  uchar md5sum [16];
  uchar aes_key [32];
  mbedtls_md5_context md5_ctx;
  mbedtls_aes_context aes_ctx;
  
  puVar1 = local_1c0;
  puVar2 = local_1c0;
  mbedtls_aes_init((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c));
  mbedtls_md5_init((mbedtls_md5_context *)(aes_key + 0x1c));
  mbedtls_md5_starts((mbedtls_md5_context *)(aes_key + 0x1c));
  mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),pwd,pwdlen);
  mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),aes_iv,8);
  mbedtls_md5_finish((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0);
  key = md5sum + 0xc;
  if (keylen == 0x10) {
    memcpy(key,local_1c0,0x10);
    mbedtls_md5_free((mbedtls_md5_context *)(aes_key + 0x1c));
    do {
      *puVar1 = '\0';
      puVar1 = puVar1 + 1;
    } while (puVar1 != key);
  }
  else {
    memcpy(key,local_1c0,0x10);
    mbedtls_md5_starts((mbedtls_md5_context *)(aes_key + 0x1c));
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0,0x10);
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),pwd,pwdlen);
    mbedtls_md5_update((mbedtls_md5_context *)(aes_key + 0x1c),aes_iv,8);
    mbedtls_md5_finish((mbedtls_md5_context *)(aes_key + 0x1c),local_1c0);
    __n = 0x10;
    if (keylen != 0x20) {
      __n = keylen - 0x10;
    }
    memcpy(aes_key + 0xc,local_1c0,__n);
    mbedtls_md5_free((mbedtls_md5_context *)(aes_key + 0x1c));
    do {
      *puVar2 = '\0';
      puVar2 = puVar2 + 1;
    } while (puVar2 != key);
  }
  mbedtls_aes_setkey_dec((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c),key,keylen << 3);
  mbedtls_aes_crypt_cbc((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c),0,buflen,aes_iv,buf,buf);
  mbedtls_aes_free((mbedtls_aes_context *)(md5_ctx.buffer + 0x3c));
  while (keylen = keylen - 1, keylen != 0xffffffff) {
    *key = '\0';
    key = key + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_pem_init(mbedtls_pem_context *ctx)

{
  memset(ctx,0,0xc);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int mbedtls_pem_read_buffer
              (mbedtls_pem_context *ctx,char *header,char *footer,uchar *data,uchar *pwd,
              size_t pwdlen,size_t *use_len)

{
  bool bVar1;
  uchar *puVar2;
  uchar *puVar3;
  size_t sVar4;
  int iVar5;
  int iVar6;
  uchar *puVar7;
  byte bVar8;
  uint uVar9;
  uint uVar10;
  uchar uVar11;
  uint uVar12;
  uchar *puVar13;
  size_t sStack68;
  size_t len;
  uchar pem_iv [16];
  
  if (ctx == (mbedtls_pem_context *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1480;
  }
  puVar2 = (uchar *)strstr((char *)data,header);
  if (((puVar2 == (uchar *)0x0) ||
      (puVar3 = (uchar *)strstr((char *)data,footer), puVar3 == (uchar *)0x0)) || (puVar3 <= puVar2)
     ) {
LAB_23065f1e:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1080;
  }
  sVar4 = strlen(header);
  puVar2 = puVar2 + sVar4;
  if (*puVar2 == ' ') {
    puVar2 = puVar2 + 1;
  }
  if (*puVar2 == '\r') {
    puVar2 = puVar2 + 1;
  }
  if (*puVar2 != '\n') goto LAB_23065f1e;
  sVar4 = strlen(footer);
  puVar7 = puVar3 + sVar4;
  puVar13 = puVar2 + 1;
  if (*puVar7 == ' ') {
    puVar7 = puVar7 + 1;
  }
  if (*puVar7 == '\r') {
    puVar7 = puVar7 + 1;
  }
  if (*puVar7 == '\n') {
    puVar7 = puVar7 + 1;
  }
  *use_len = (size_t)(puVar7 + -(int)data);
  if (((int)(puVar3 + -(int)puVar13) < 0x16) ||
     (iVar5 = memcmp(puVar13,"Proc-Type: 4,ENCRYPTED",0x16), iVar5 != 0)) {
    iVar5 = 0;
    bVar1 = false;
  }
  else {
    uVar11 = puVar2[0x17];
    puVar7 = puVar2 + 0x17;
    if (uVar11 == '\r') {
      uVar11 = puVar2[0x18];
      puVar7 = puVar2 + 0x18;
    }
    if (uVar11 != '\n') goto LAB_23065f1e;
    puVar2 = puVar7 + 1;
    if ((((int)(puVar3 + -(int)puVar2) < 0xe) ||
        (iVar5 = memcmp(puVar2,"DEK-Info: AES-",0xe), iVar5 != 0)) ||
       ((int)(puVar3 + -(int)puVar2) < 0x16)) {
LAB_23065f1e:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x1280;
    }
    iVar6 = memcmp(puVar2,"DEK-Info: AES-128-CBC,",0x16);
    iVar5 = 5;
    if (iVar6 != 0) {
      iVar6 = memcmp(puVar2,"DEK-Info: AES-192-CBC,",0x16);
      iVar5 = 6;
      if (iVar6 != 0) {
        iVar5 = memcmp(puVar2,"DEK-Info: AES-256-CBC,",0x16);
        if (iVar5 != 0) goto LAB_23065f1e;
        iVar5 = 7;
      }
    }
    if ((int)(puVar3 + -(int)(puVar7 + 0x17)) < 0x20) {
LAB_23065f1e:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x1200;
    }
    memset(&len,0,0x10);
    uVar12 = 0;
    do {
      uVar10 = (uint)puVar7[uVar12 + 0x17];
      uVar9 = uVar10 - 0x30;
      if (9 < (uVar9 & 0xff)) {
        if ((uVar10 - 0x41 & 0xff) < 6) {
          uVar9 = uVar10 - 0x37;
        }
        else {
          if (5 < (uVar10 - 0x61 & 0xff)) goto LAB_23065f1e;
          uVar9 = uVar10 - 0x57;
        }
      }
      bVar8 = (byte)uVar9;
      if ((uVar12 & 1) == 0) {
        bVar8 = (byte)(uVar9 << 4);
      }
      uVar9 = uVar12 >> 1;
      uVar12 = uVar12 + 1;
      pem_iv[uVar9 - 4] = bVar8 | pem_iv[uVar9 - 4];
    } while (uVar12 != 0x20);
    puVar13 = puVar7 + 0x38;
    if (puVar7[0x37] != '\r') {
      puVar13 = puVar7 + 0x37;
    }
    if (*puVar13 != '\n') goto LAB_23065f1e;
    puVar13 = puVar13 + 1;
    bVar1 = true;
  }
  if (puVar3 <= puVar13) {
LAB_23065f1e:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1100;
  }
  iVar6 = mbedtls_base64_decode((uchar *)0x0,0,&sStack68,puVar13,(size_t)(puVar3 + -(int)puVar13));
  if (iVar6 == -0x2c) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x112c;
  }
  puVar2 = (uchar *)mycalloc(1,sStack68);
  if (puVar2 == (uchar *)0x0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1180;
  }
  iVar6 = mbedtls_base64_decode(puVar2,sStack68,&sStack68,puVar13,(size_t)(puVar3 + -(int)puVar13));
  if (iVar6 != 0) {
    vPortFree(puVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar6 + -0x1100;
  }
  if (!bVar1) goto LAB_230661ca;
  if (pwd == (uchar *)0x0) {
    vPortFree(puVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1300;
  }
  if (iVar5 == 5) {
    uVar12 = 0x10;
LAB_23066174:
    pem_aes_decrypt((uchar *)&len,uVar12,puVar2,sStack68,pwd,pwdlen);
  }
  else {
    if (iVar5 == 6) {
      uVar12 = 0x18;
      goto LAB_23066174;
    }
    if (iVar5 == 7) {
      uVar12 = 0x20;
      goto LAB_23066174;
    }
  }
  if (((sStack68 < 3) || (*puVar2 != '0')) || (0x83 < puVar2[1])) {
    vPortFree(puVar2);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x1380;
  }
LAB_230661ca:
  ctx->buf = puVar2;
  ctx->buflen = sStack68;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



void mbedtls_pem_free(mbedtls_pem_context *ctx)

{
  mbedtls_pem_context *pmVar1;
  
  vPortFree(ctx->buf);
  vPortFree(ctx->info);
  pmVar1 = ctx + 1;
  while (ctx != pmVar1) {
    *(undefined *)&ctx->buf = 0;
    ctx = (mbedtls_pem_context *)((int)&ctx->buf + 1);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_md5_init(mbedtls_md5_context *ctx)

{
  memset(ctx,0,0x58);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_md5_free(mbedtls_md5_context *ctx)

{
  mbedtls_md5_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_md5_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_md5_context *)((int)ctx->total + 1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_md5_clone(mbedtls_md5_context *dst,mbedtls_md5_context *src)

{
  memcpy(dst,src,0x58);
  return;
}



void mbedtls_md5_starts(mbedtls_md5_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[3] = 0x10325476;
  return;
}



void mbedtls_md5_process(mbedtls_md5_context *ctx,uchar *data)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  int iVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  int iVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  
  iVar1 = *(int *)data;
  iVar2 = *(int *)(data + 4);
  iVar3 = *(int *)(data + 0x10);
  iVar4 = *(int *)(data + 8);
  iVar5 = *(int *)(data + 0xc);
  iVar6 = *(int *)(data + 0x14);
  iVar7 = *(int *)(data + 0x18);
  iVar8 = *(int *)(data + 0x24);
  iVar9 = *(int *)(data + 0x1c);
  iVar10 = *(int *)(data + 0x20);
  iVar11 = *(int *)(data + 0x2c);
  iVar12 = *(int *)(data + 0x28);
  iVar13 = *(int *)(data + 0x30);
  uVar19 = ctx->state[3];
  iVar14 = *(int *)(data + 0x34);
  iVar15 = *(int *)(data + 0x38);
  iVar16 = *(int *)(data + 0x3c);
  uVar17 = ctx->state[2];
  uVar18 = ctx->state[1];
  uVar20 = ((uVar17 ^ uVar19) & uVar18 ^ uVar19) + ctx->state[0] + 0xd76aa478 + iVar1;
  uVar21 = (uVar20 >> 0x19 | uVar20 * 0x80) + uVar18;
  uVar20 = ((uVar18 ^ uVar17) & uVar21 ^ uVar17) + uVar19 + 0xe8c7b756 + iVar2;
  uVar23 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar18 ^ uVar21) & uVar23 ^ uVar18) + uVar17 + 0x242070db + iVar4;
  uVar22 = (uVar20 * 0x20000 | uVar20 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + uVar18 + 0xc1bdceee + iVar5;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar3 + -0xa83f051 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar6 + 0x4787c62a + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar7 + -0x57cfb9ed + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar9 + -0x2b96aff + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar10 + 0x698098d8 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar8 + -0x74bb0851 + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar12 + -0xa44f + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar11 + -0x76a32842 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar23 ^ uVar22) & uVar20 ^ uVar23) + iVar13 + 0x6b901122 + uVar21;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar20;
  uVar23 = ((uVar22 ^ uVar20) & uVar21 ^ uVar22) + iVar14 + -0x2678e6d + uVar23;
  uVar23 = (uVar23 >> 0x14 | uVar23 * 0x1000) + uVar21;
  uVar22 = ((uVar20 ^ uVar21) & uVar23 ^ uVar20) + iVar15 + -0x5986bc72 + uVar22;
  uVar22 = (uVar22 * 0x20000 | uVar22 >> 0xf) + uVar23;
  uVar20 = ((uVar21 ^ uVar23) & uVar22 ^ uVar21) + iVar16 + 0x49b40821 + uVar20;
  uVar20 = (uVar20 * 0x400000 | uVar20 >> 10) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar2 + -0x9e1da9e + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar7 + -0x3fbf4cc0 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar11 + 0x265e5a51 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar1 + -0x16493856 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar6 + -0x29d0efa3 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar12 + 0x2441453 + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar16 + -0x275e197f + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar3 + -0x182c0438 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar8 + 0x21e1cde6 + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar15 + -0x3cc8f82a + uVar23;
  uVar23 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar23) & uVar20 ^ uVar21) + iVar5 + -0xb2af279 + uVar22;
  uVar22 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar23;
  uVar20 = ((uVar23 ^ uVar22) & uVar21 ^ uVar23) + iVar10 + 0x455a14ed + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar22;
  uVar21 = ((uVar22 ^ uVar20) & uVar23 ^ uVar22) + iVar14 + -0x561c16fb + uVar21;
  uVar21 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar20;
  uVar23 = ((uVar20 ^ uVar21) & uVar22 ^ uVar20) + iVar4 + -0x3105c08 + uVar23;
  uVar24 = (uVar23 >> 0x17 | uVar23 * 0x200) + uVar21;
  uVar22 = ((uVar21 ^ uVar24) & uVar20 ^ uVar21) + iVar9 + 0x676f02d9 + uVar22;
  uVar23 = (uVar22 >> 0x12 | uVar22 * 0x4000) + uVar24;
  uVar20 = ((uVar24 ^ uVar23) & uVar21 ^ uVar24) + iVar13 + -0x72d5b376 + uVar20;
  uVar20 = (uVar20 * 0x100000 | uVar20 >> 0xc) + uVar23;
  uVar21 = (uVar24 ^ uVar23 ^ uVar20) + iVar6 + -0x5c6be + uVar21;
  uVar21 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar20;
  uVar22 = (uVar23 ^ uVar20 ^ uVar21) + uVar24 + iVar10 + -0x788e097f;
  uVar22 = (uVar22 >> 0x15 | uVar22 * 0x800) + uVar21;
  uVar23 = (uVar20 ^ uVar21 ^ uVar22) + uVar23 + iVar11 + 0x6d9d6122;
  uVar24 = (uVar23 >> 0x10 | uVar23 * 0x10000) + uVar22;
  uVar20 = (uVar21 ^ uVar22 ^ uVar24) + uVar20 + iVar15 + -0x21ac7f4;
  uVar23 = (uVar20 * 0x800000 | uVar20 >> 9) + uVar24;
  uVar20 = (uVar22 ^ uVar24 ^ uVar23) + iVar2 + -0x5b4115bc + uVar21;
  uVar21 = (uVar20 >> 0x1c | uVar20 * 0x10) + uVar23;
  uVar20 = (uVar24 ^ uVar23 ^ uVar21) + uVar22 + iVar3 + 0x4bdecfa9;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar21;
  uVar22 = (uVar23 ^ uVar21 ^ uVar20) + iVar9 + -0x944b4a0 + uVar24;
  uVar24 = (uVar22 >> 0x10 | uVar22 * 0x10000) + uVar20;
  uVar22 = (uVar21 ^ uVar20 ^ uVar24) + uVar23 + iVar12 + -0x41404390;
  uVar22 = (uVar22 * 0x800000 | uVar22 >> 9) + uVar24;
  uVar21 = (uVar20 ^ uVar24 ^ uVar22) + uVar21 + iVar14 + 0x289b7ec6;
  uVar23 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar22;
  uVar20 = (uVar24 ^ uVar22 ^ uVar23) + iVar1 + -0x155ed806 + uVar20;
  uVar20 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar21 = (uVar22 ^ uVar23 ^ uVar20) + iVar5 + -0x2b10cf7b + uVar24;
  uVar24 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar20;
  uVar21 = (uVar23 ^ uVar20 ^ uVar24) + uVar22 + iVar7 + 0x4881d05;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar24;
  uVar22 = (uVar20 ^ uVar24 ^ uVar21) + iVar8 + -0x262b2fc7 + uVar23;
  uVar23 = (uVar22 >> 0x1c | uVar22 * 0x10) + uVar21;
  uVar20 = (uVar24 ^ uVar21 ^ uVar23) + uVar20 + iVar13 + -0x1924661b;
  uVar22 = (uVar20 >> 0x15 | uVar20 * 0x800) + uVar23;
  uVar20 = (uVar21 ^ uVar23 ^ uVar22) + uVar24 + iVar16 + 0x1fa27cf8;
  uVar20 = (uVar20 >> 0x10 | uVar20 * 0x10000) + uVar22;
  uVar21 = (uVar23 ^ uVar22 ^ uVar20) + iVar4 + -0x3b53a99b + uVar21;
  uVar21 = (uVar21 * 0x800000 | uVar21 >> 9) + uVar20;
  uVar23 = ((~uVar22 | uVar21) ^ uVar20) + uVar23 + iVar1 + -0xbd6ddbc;
  uVar24 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar21;
  uVar22 = ((~uVar20 | uVar24) ^ uVar21) + uVar22 + iVar9 + 0x432aff97;
  uVar23 = (uVar22 >> 0x16 | uVar22 * 0x400) + uVar24;
  uVar20 = ((~uVar21 | uVar23) ^ uVar24) + iVar15 + -0x546bdc59 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar23;
  uVar21 = ((~uVar24 | uVar20) ^ uVar23) + iVar6 + -0x36c5fc7 + uVar21;
  uVar22 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar23 | uVar22) ^ uVar20) + iVar13 + 0x655b59c3 + uVar24;
  uVar24 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar24) ^ uVar22) + uVar23 + iVar5 + -0x70f3336e;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar24;
  uVar20 = ((~uVar22 | uVar21) ^ uVar24) + iVar12 + -0x100b83 + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar22 = ((~uVar24 | uVar20) ^ uVar21) + iVar2 + -0x7a7ba22f + uVar22;
  uVar22 = (uVar22 * 0x200000 | uVar22 >> 0xb) + uVar20;
  uVar23 = ((~uVar21 | uVar22) ^ uVar20) + iVar10 + 0x6fa87e4f + uVar24;
  uVar25 = (uVar23 >> 0x1a | uVar23 * 0x40) + uVar22;
  uVar21 = ((~uVar20 | uVar25) ^ uVar22) + uVar21 + iVar16 + -0x1d31920;
  uVar24 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar25;
  uVar20 = ((~uVar22 | uVar24) ^ uVar25) + iVar7 + -0x5cfebcec + uVar20;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar24;
  uVar21 = ((~uVar25 | uVar20) ^ uVar24) + iVar14 + 0x4e0811a1 + uVar22;
  uVar23 = (uVar21 * 0x200000 | uVar21 >> 0xb) + uVar20;
  uVar21 = ((~uVar24 | uVar23) ^ uVar20) + uVar25 + iVar3 + -0x8ac817e;
  uVar22 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar23;
  uVar21 = ((~uVar20 | uVar22) ^ uVar23) + uVar24 + iVar11 + -0x42c50dcb;
  uVar21 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar22;
  uVar20 = ((~uVar23 | uVar21) ^ uVar22) + uVar20 + iVar4 + 0x2ad7d2bb;
  uVar20 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar21;
  uVar23 = ((~uVar22 | uVar20) ^ uVar21) + uVar23 + iVar8 + -0x14792c6f;
  ctx->state[0] = ctx->state[0] + uVar22;
  ctx->state[1] = uVar18 + uVar20 + (uVar23 >> 0xb | uVar23 * 0x200000);
  ctx->state[2] = uVar20 + uVar17;
  ctx->state[3] = uVar21 + uVar19;
  return;
}



void mbedtls_md5_update(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_md5_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_md5_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_md5_update(mbedtls_md5_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_md5_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_md5_finish(mbedtls_md5_context *ctx,uchar *output)

{
  uint uVar1;
  int iVar2;
  int iStack24;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  msglen._0_4_ = ctx->total[1] << 3 | uVar1 >> 0x1d;
  iStack24 = uVar1 << 3;
  if ((uVar1 & 0x3f) < 0x38) {
    iVar2 = 0x38;
  }
  else {
    iVar2 = 0x78;
  }
  mbedtls_md5_update(ctx,md5_padding,iVar2 - (uVar1 & 0x3f));
  mbedtls_md5_update(ctx,(uchar *)&iStack24,8);
  *output = (uchar)ctx->state[0];
  output[1] = (uchar)(ctx->state[0] >> 8);
  output[2] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[3] = *(uchar *)((int)ctx->state + 3);
  output[4] = (uchar)ctx->state[1];
  output[5] = (uchar)(ctx->state[1] >> 8);
  output[6] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[7] = *(uchar *)((int)ctx->state + 7);
  output[8] = (uchar)ctx->state[2];
  output[9] = (uchar)(ctx->state[2] >> 8);
  output[10] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[0xb] = *(uchar *)((int)ctx->state + 0xb);
  output[0xc] = (uchar)ctx->state[3];
  output[0xd] = (uchar)(ctx->state[3] >> 8);
  output[0xe] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xf] = *(uchar *)((int)ctx->state + 0xf);
  return;
}



void mbedtls_md5(uchar *input,size_t ilen,uchar *output)

{
  undefined auStack104 [4];
  mbedtls_md5_context ctx;
  
  mbedtls_md5_init((mbedtls_md5_context *)auStack104);
  mbedtls_md5_starts((mbedtls_md5_context *)auStack104);
  mbedtls_md5_update((mbedtls_md5_context *)auStack104,input,ilen);
  mbedtls_md5_finish((mbedtls_md5_context *)auStack104,output);
  mbedtls_md5_free((mbedtls_md5_context *)auStack104);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha1_init(mbedtls_sha1_context *ctx)

{
  memset(ctx,0,0x5c);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha1_free(mbedtls_sha1_context *ctx)

{
  mbedtls_sha1_context *pmVar1;
  
  pmVar1 = ctx + 1;
  if (ctx != (mbedtls_sha1_context *)0x0) {
    while (ctx != pmVar1) {
      *(undefined *)ctx->total = 0;
      ctx = (mbedtls_sha1_context *)((int)ctx->total + 1);
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha1_clone(mbedtls_sha1_context *dst,mbedtls_sha1_context *src)

{
  memcpy(dst,src,0x5c);
  return;
}



void mbedtls_sha1_starts(mbedtls_sha1_context *ctx)

{
  ctx->state[0] = 0x67452301;
  ctx->state[1] = 0xefcdab89;
  ctx->state[2] = 0x98badcfe;
  ctx->state[3] = 0x10325476;
  ctx->total[0] = 0;
  ctx->total[1] = 0;
  ctx->state[4] = 0xc3d2e1f0;
  return;
}



void mbedtls_sha1_process(mbedtls_sha1_context *ctx,uchar *data)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint32_t uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  uint uVar17;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint uVar21;
  uint uVar22;
  uint uVar23;
  uint uVar24;
  uint uVar25;
  uint uVar26;
  uint uVar27;
  uint uVar28;
  
  uVar8 = (uint)*data << 0x18 | (uint)data[1] << 0x10 | (uint)data[3] | (uint)data[2] << 8;
  uVar10 = (uint)data[4] << 0x18 | (uint)data[5] << 0x10 | (uint)data[7] | (uint)data[6] << 8;
  uVar9 = (uint)data[8] << 0x18 | (uint)data[9] << 0x10 | (uint)data[0xb] | (uint)data[10] << 8;
  uVar1 = (uint)data[0xc] << 0x18 | (uint)data[0xd] << 0x10 | (uint)data[0xf] | (uint)data[0xe] << 8
  ;
  uVar27 = (uint)data[0x10] << 0x18 | (uint)data[0x11] << 0x10 | (uint)data[0x13] |
           (uint)data[0x12] << 8;
  uVar25 = (uint)data[0x14] << 0x18 | (uint)data[0x15] << 0x10 | (uint)data[0x17] |
           (uint)data[0x16] << 8;
  uVar14 = (uint)data[0x18] << 0x18 | (uint)data[0x19] << 0x10 | (uint)data[0x1b] |
           (uint)data[0x1a] << 8;
  uVar20 = (uint)data[0x1c] << 0x18 | (uint)data[0x1d] << 0x10 | (uint)data[0x1f] |
           (uint)data[0x1e] << 8;
  uVar28 = (uint)data[0x20] << 0x18 | (uint)data[0x21] << 0x10 | (uint)data[0x23] |
           (uint)data[0x22] << 8;
  uVar26 = (uint)data[0x24] << 0x18 | (uint)data[0x25] << 0x10 | (uint)data[0x27] |
           (uint)data[0x26] << 8;
  uVar2 = (uint)data[0x28] << 0x18 | (uint)data[0x29] << 0x10 | (uint)data[0x2b] |
          (uint)data[0x2a] << 8;
  uVar13 = (uint)data[0x2c] << 0x18 | (uint)data[0x2d] << 0x10 | (uint)data[0x2f] |
           (uint)data[0x2e] << 8;
  uVar11 = (uint)data[0x30] << 0x18 | (uint)data[0x31] << 0x10 | (uint)data[0x33] |
           (uint)data[0x32] << 8;
  uVar16 = ctx->state[2];
  uVar15 = ctx->state[0];
  uVar5 = (uint)data[0x34] << 0x18 | (uint)data[0x35] << 0x10 | (uint)data[0x37] |
          (uint)data[0x36] << 8;
  uVar4 = (uint)data[0x38] << 0x18 | (uint)data[0x39] << 0x10 | (uint)data[0x3b] |
          (uint)data[0x3a] << 8;
  uVar3 = (uint)data[0x3c] << 0x18 | (uint)data[0x3d] << 0x10 | (uint)data[0x3f] |
          (uint)data[0x3e] << 8;
  uVar6 = (uVar15 << 5 | uVar15 >> 0x1b) + ctx->state[4] + 0x5a827999 +
          ((uVar16 ^ ctx->state[3]) & ctx->state[1] ^ ctx->state[3]) + uVar8;
  uVar17 = ctx->state[1] << 0x1e | ctx->state[1] >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar16 ^ uVar17) & uVar15 ^ uVar16) + ctx->state[3] + 0x5a827999 + uVar10;
  uVar23 = uVar15 << 0x1e | uVar15 >> 2;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar6 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
          ((uVar17 ^ uVar23) & uVar6 ^ uVar17) + uVar16 + 0x5a827999 + uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar23 ^ uVar7) & uVar18 ^ uVar23) + uVar17 + 0x5a827999 + uVar1;
  uVar21 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar19) & uVar6 ^ uVar7) + uVar23 + 0x5a827999 + uVar27;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar18 ^ uVar19) + uVar25 + 0x5a827999 + uVar7;
  uVar6 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
          ((uVar21 ^ uVar6) & uVar17 ^ uVar21) + uVar14 + 0x5a827999 + uVar19;
  uVar24 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar19 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           ((uVar6 ^ uVar18) & uVar23 ^ uVar6) + uVar21 + uVar20 + 0x5a827999;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar18 ^ uVar24) & uVar7 ^ uVar18) + uVar28 + 0x5a827999 + uVar6;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar24 ^ uVar17) & uVar19 ^ uVar24) + uVar18 + uVar26 + 0x5a827999;
  uVar22 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar17 ^ uVar23) & uVar7 ^ uVar17) + uVar2 + 0x5a827999 + uVar24;
  uVar18 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar7 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar23 ^ uVar22) & uVar6 ^ uVar23) + uVar17 + uVar13 + 0x5a827999;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
          ((uVar22 ^ uVar18) & uVar19 ^ uVar22) + uVar11 + 0x5a827999 + uVar23;
  uVar17 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar19 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar18 ^ uVar21) & uVar7 ^ uVar18) + uVar22 + uVar5 + 0x5a827999;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar23 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           ((uVar21 ^ uVar17) & uVar6 ^ uVar21) + uVar4 + 0x5a827999 + uVar18;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           ((uVar17 ^ uVar7) & uVar19 ^ uVar17) + uVar21 + uVar3 + 0x5a827999;
  uVar8 = uVar6 >> 0x1f | uVar6 << 1;
  uVar6 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar10 = uVar6 >> 0x1f | uVar6 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar7 ^ uVar22) & uVar23 ^ uVar7) + uVar8 + 0x5a827999 + uVar17;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar6 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          ((uVar22 ^ uVar19) & uVar18 ^ uVar22) + uVar7 + uVar10 + 0x5a827999;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar8;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar18 = (uVar6 * 0x20 | uVar6 >> 0x1b) +
           ((uVar19 ^ uVar21) & uVar17 ^ uVar19) + uVar9 + 0x5a827999 + uVar22;
  uVar17 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar7 = uVar6 * 0x40000000 | uVar6 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar21 ^ uVar23) & uVar6 ^ uVar21) + uVar1 + 0x5a827999 + uVar19;
  uVar6 = uVar25 ^ uVar20 ^ uVar5 ^ uVar9;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar24 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar7 ^ uVar18) + uVar21 + uVar27 + 0x6ed9eba1;
  uVar6 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar7 ^ uVar19 ^ uVar17) + uVar24 + 0x6ed9eba1 + uVar23;
  uVar14 = uVar6 >> 0x1f | uVar6 << 1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar20 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar14 + 0x6ed9eba1 + uVar7;
  uVar7 = uVar28 ^ uVar2 ^ uVar8 ^ uVar24;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar28 = uVar7 >> 0x1f | uVar7 << 1;
  uVar7 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar6 + 0x6ed9eba1;
  uVar17 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar26 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) +
           (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar28 + 0x6ed9eba1;
  uVar2 = uVar2 ^ uVar11 ^ uVar9 ^ uVar6;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar20 ^ uVar22 ^ uVar7) + uVar23 + uVar26 + 0x6ed9eba1;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar7 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar13 = uVar7 >> 0x1f | uVar7 << 1;
  uVar20 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar19 ^ uVar17) + uVar2 + 0x6ed9eba1 + uVar20;
  uVar7 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar11 = uVar7 >> 0x1f | uVar7 << 1;
  uVar17 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar13 + 0x6ed9eba1 + uVar22;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar7 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar18 ^ uVar23 ^ uVar20) + uVar19 + uVar11 + 0x6ed9eba1;
  uVar4 = uVar4 ^ uVar8 ^ uVar14 ^ uVar13;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar7 * 0x20 | uVar7 >> 0x1b) + (uVar23 ^ uVar22 ^ uVar17) + uVar18 + uVar5 + 0x6ed9eba1
  ;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar19 = uVar7 * 0x40000000 | uVar7 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar22 ^ uVar20 ^ uVar7) + uVar23 + uVar4 + 0x6ed9eba1;
  uVar7 = uVar8 ^ uVar9 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar20 ^ uVar19 ^ uVar17) + uVar3 + 0x6ed9eba1 + uVar22;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar8 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar8 >> 0x1f | uVar8 << 1;
  uVar21 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar21) + uVar7 + 0x6ed9eba1 + uVar20;
  uVar8 = uVar9 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar20 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar23 ^ uVar17) + uVar19 + uVar10 + 0x6ed9eba1;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar9 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
          (uVar23 ^ uVar20 ^ uVar21) + uVar18 + uVar8 + 0x6ed9eba1;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar19 = uVar27 ^ uVar14 ^ uVar11 ^ uVar10;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar21 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar20 ^ uVar22 ^ uVar17) + uVar1 + 0x6ed9eba1 + uVar23
  ;
  uVar27 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar25 = uVar19 >> 0x1f | uVar19 << 1;
  uVar19 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar22 ^ uVar18 ^ uVar9) + uVar27 + 0x6ed9eba1 + uVar20;
  uVar9 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar14 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar18 ^ uVar17 ^ uVar21) + uVar22 + uVar25 + 0x6ed9eba1;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          (uVar17 ^ uVar23 ^ uVar19) + uVar14 + 0x6ed9eba1 + uVar18;
  uVar18 = uVar28 ^ uVar2 ^ uVar7 ^ uVar25;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar28 = uVar18 >> 0x1f | uVar18 << 1;
  uVar17 = (uVar9 * 0x20 | uVar9 >> 0x1b) + (uVar23 ^ uVar21 ^ uVar20) + uVar6 + 0x6ed9eba1 + uVar17
  ;
  uVar19 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar20 = uVar26 ^ uVar13 ^ uVar10 ^ uVar14;
  uVar18 = ((uVar9 | uVar22) & uVar21 | uVar9 & uVar22) +
           uVar28 + 0x8f1bbcdc + uVar23 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar26 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar23 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar17 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar17 | uVar19) & uVar22 | uVar17 & uVar19) + uVar26 + 0x8f1bbcdc + uVar21;
  uVar9 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar21 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = ((uVar18 | uVar23) & uVar19 | uVar18 & uVar23) +
           uVar2 + 0x8f1bbcdc + uVar22 + (uVar17 * 0x20 | uVar17 >> 0x1b);
  uVar9 = uVar11 ^ uVar4 ^ uVar27 ^ uVar26;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar11 = uVar9 >> 0x1f | uVar9 << 1;
  uVar9 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
          ((uVar17 | uVar21) & uVar23 | uVar17 & uVar21) + uVar13 + 0x8f1bbcdc + uVar19;
  uVar24 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar5 = uVar5 ^ uVar3 ^ uVar25 ^ uVar2;
  uVar19 = ((uVar20 | uVar18) & uVar21 | uVar20 & uVar18) +
           uVar11 + 0x8f1bbcdc + uVar23 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar17 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar9 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          ((uVar9 | uVar24) & uVar18 | uVar9 & uVar24) + uVar5 + 0x8f1bbcdc + uVar21;
  uVar3 = uVar3 ^ uVar10 ^ uVar6 ^ uVar11;
  uVar22 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar18 = ((uVar19 | uVar17) & uVar24 | uVar19 & uVar17) +
           uVar4 + 0x8f1bbcdc + uVar18 + (uVar9 * 0x20 | uVar9 >> 0x1b);
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar20 = uVar9 * 0x40000000 | uVar9 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar9 | uVar22) & uVar17 | uVar9 & uVar22) + uVar3 + 0x8f1bbcdc + uVar24;
  uVar9 = uVar10 ^ uVar1 ^ uVar26 ^ uVar4;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar10 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar7 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar9 + 0x8f1bbcdc + uVar22;
  uVar1 = uVar1 ^ uVar25 ^ uVar13 ^ uVar7;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar10 = ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) +
           uVar8 + 0x8f1bbcdc + uVar20 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar21 = uVar27 ^ uVar14 ^ uVar11 ^ uVar9;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar27 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = (uVar10 * 0x20 | uVar10 >> 0x1b) +
           ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) + uVar19 + uVar1 + 0x8f1bbcdc;
  uVar19 = uVar25 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar24 = uVar19 >> 0x1f | uVar19 << 1;
  uVar21 = ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) +
           uVar27 + 0x8f1bbcdc + uVar23 + (uVar18 * 0x20 | uVar18 >> 0x1b);
  uVar10 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar14 = uVar10 >> 0x1f | uVar10 << 1;
  uVar10 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) + uVar17 + uVar24 + 0x8f1bbcdc;
  uVar6 = uVar6 ^ uVar26 ^ uVar3 ^ uVar27;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar18 = ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) +
           uVar14 + 0x8f1bbcdc + uVar22 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar21 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar17 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar28 = uVar21 >> 0x1f | uVar21 << 1;
  uVar10 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar23) & uVar19 | uVar10 & uVar23) + uVar20 + uVar6 + 0x8f1bbcdc;
  uVar21 = uVar26 ^ uVar13 ^ uVar9 ^ uVar14;
  uVar22 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar25 = uVar21 >> 0x1f | uVar21 << 1;
  uVar18 = ((uVar18 | uVar17) & uVar23 | uVar18 & uVar17) +
           uVar28 + 0x8f1bbcdc + uVar19 + (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar2 = uVar2 ^ uVar11 ^ uVar8 ^ uVar6;
  uVar20 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar21 = (uVar18 * 0x20 | uVar18 >> 0x1b) +
           ((uVar10 | uVar22) & uVar17 | uVar10 & uVar22) + uVar23 + uVar25 + 0x8f1bbcdc;
  uVar10 = uVar13 ^ uVar5 ^ uVar1 ^ uVar28;
  uVar19 = uVar18 * 0x40000000 | uVar18 >> 2;
  uVar13 = uVar10 >> 0x1f | uVar10 << 1;
  uVar17 = ((uVar18 | uVar20) & uVar22 | uVar18 & uVar20) +
           uVar2 + 0x8f1bbcdc + uVar17 + (uVar21 * 0x20 | uVar21 >> 0x1b);
  uVar10 = uVar11 ^ uVar4 ^ uVar27 ^ uVar25;
  uVar18 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar10 = uVar10 >> 0x1f | uVar10 << 1;
  uVar23 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           ((uVar21 | uVar19) & uVar20 | uVar21 & uVar19) + uVar22 + uVar13 + 0x8f1bbcdc;
  uVar5 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar11 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar5 = uVar5 >> 0x1f | uVar5 << 1;
  uVar21 = (uVar23 * 0x20 | uVar23 >> 0x1b) +
           (uVar19 ^ uVar18 ^ uVar17) + uVar20 + uVar10 + 0xca62c1d6;
  uVar4 = uVar4 ^ uVar7 ^ uVar14 ^ uVar13;
  uVar20 = uVar23 * 0x40000000 | uVar23 >> 2;
  uVar4 = uVar4 >> 0x1f | uVar4 << 1;
  uVar17 = (uVar21 * 0x20 | uVar21 >> 0x1b) +
           (uVar18 ^ uVar11 ^ uVar23) + uVar19 + uVar5 + 0xca62c1d6;
  uVar3 = uVar3 ^ uVar9 ^ uVar6 ^ uVar10;
  uVar23 = uVar21 * 0x40000000 | uVar21 >> 2;
  uVar3 = uVar3 >> 0x1f | uVar3 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar11 ^ uVar20 ^ uVar21) + uVar18 + uVar4 + 0xca62c1d6;
  uVar7 = uVar7 ^ uVar8 ^ uVar28 ^ uVar5;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar7 = uVar7 >> 0x1f | uVar7 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar20 ^ uVar23 ^ uVar17) + uVar11 + uVar3 + 0xca62c1d6;
  uVar9 = uVar9 ^ uVar1 ^ uVar25 ^ uVar4;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar9 = uVar9 >> 0x1f | uVar9 << 1;
  uVar20 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar20 + uVar7 + 0xca62c1d6;
  uVar8 = uVar8 ^ uVar27 ^ uVar2 ^ uVar3;
  uVar17 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar8 = uVar8 >> 0x1f | uVar8 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar11) + uVar23 + uVar9 + 0xca62c1d6;
  uVar1 = uVar1 ^ uVar24 ^ uVar13 ^ uVar7;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar1 = uVar1 >> 0x1f | uVar1 << 1;
  uVar11 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar17 ^ uVar20) + uVar18 + uVar8 + 0xca62c1d6;
  uVar18 = uVar27 ^ uVar14 ^ uVar10 ^ uVar9;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar26 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar11 * 0x20 | uVar11 >> 0x1b) +
           (uVar17 ^ uVar22 ^ uVar19) + uVar21 + uVar1 + 0xca62c1d6;
  uVar21 = uVar24 ^ uVar6 ^ uVar5 ^ uVar8;
  uVar18 = uVar11 * 0x40000000 | uVar11 >> 2;
  uVar24 = uVar21 >> 0x1f | uVar21 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar22 ^ uVar23 ^ uVar11) + uVar17 + uVar26 + 0xca62c1d6;
  uVar11 = uVar14 ^ uVar28 ^ uVar4 ^ uVar1;
  uVar21 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar11 = uVar11 >> 0x1f | uVar11 << 1;
  uVar20 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar23 ^ uVar18 ^ uVar19) + uVar22 + uVar24 + 0xca62c1d6;
  uVar6 = uVar6 ^ uVar25 ^ uVar3 ^ uVar26;
  uVar14 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar6 = uVar6 >> 0x1f | uVar6 << 1;
  uVar19 = (uVar20 * 0x20 | uVar20 >> 0x1b) +
           (uVar18 ^ uVar21 ^ uVar17) + uVar23 + uVar11 + 0xca62c1d6;
  uVar17 = uVar28 ^ uVar2 ^ uVar7 ^ uVar24;
  uVar22 = uVar20 * 0x40000000 | uVar20 >> 2;
  uVar27 = uVar17 >> 0x1f | uVar17 << 1;
  uVar17 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
           (uVar21 ^ uVar14 ^ uVar20) + uVar18 + uVar6 + 0xca62c1d6;
  uVar18 = uVar25 ^ uVar13 ^ uVar9 ^ uVar11;
  uVar23 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar20 = uVar18 >> 0x1f | uVar18 << 1;
  uVar19 = (uVar17 * 0x20 | uVar17 >> 0x1b) +
           (uVar14 ^ uVar22 ^ uVar19) + uVar21 + uVar27 + 0xca62c1d6;
  uVar2 = uVar2 ^ uVar10 ^ uVar8 ^ uVar6;
  uVar18 = uVar17 * 0x40000000 | uVar17 >> 2;
  uVar2 = uVar2 >> 0x1f | uVar2 << 1;
  uVar8 = (uVar19 * 0x20 | uVar19 >> 0x1b) +
          (uVar22 ^ uVar23 ^ uVar17) + uVar14 + uVar20 + 0xca62c1d6;
  uVar27 = uVar13 ^ uVar5 ^ uVar1 ^ uVar27;
  uVar13 = uVar19 * 0x40000000 | uVar19 >> 2;
  uVar21 = uVar27 >> 0x1f | uVar27 << 1;
  uVar14 = uVar22 + uVar2 + 0xca62c1d6 + (uVar23 ^ uVar18 ^ uVar19) + (uVar8 * 0x20 | uVar8 >> 0x1b)
  ;
  uVar20 = uVar10 ^ uVar4 ^ uVar26 ^ uVar20;
  uVar10 = (uVar14 * 0x20 | uVar14 >> 0x1b) +
           (uVar18 ^ uVar13 ^ uVar8) + uVar23 + uVar21 + 0xca62c1d6;
  uVar1 = uVar8 * 0x40000000 | uVar8 >> 2;
  uVar17 = uVar20 >> 0x1f | uVar20 << 1;
  uVar2 = uVar5 ^ uVar3 ^ uVar24 ^ uVar2;
  uVar5 = uVar18 + uVar17 + 0xca62c1d6 + (uVar13 ^ uVar1 ^ uVar14) +
          (uVar10 * 0x20 | uVar10 >> 0x1b);
  uVar8 = uVar14 * 0x40000000 | uVar14 >> 2;
  uVar21 = uVar4 ^ uVar7 ^ uVar11 ^ uVar21;
  uVar4 = uVar13 + (uVar2 << 1 | uVar2 >> 0x1f) + 0xca62c1d6 + (uVar1 ^ uVar8 ^ uVar10) +
          (uVar5 * 0x20 | uVar5 >> 0x1b);
  uVar7 = uVar10 * 0x40000000 | uVar10 >> 2;
  uVar17 = uVar3 ^ uVar9 ^ uVar6 ^ uVar17;
  uVar1 = uVar1 + (uVar21 << 1 | uVar21 >> 0x1f) + 0xca62c1d6 + (uVar8 ^ uVar7 ^ uVar5) +
          (uVar4 * 0x20 | uVar4 >> 0x1b);
  uVar2 = uVar5 * 0x40000000 | uVar5 >> 2;
  uVar12 = ctx->state[1];
  ctx->state[0] =
       uVar8 + (uVar17 << 1 | uVar17 >> 0x1f) + uVar15 + 0xca62c1d6 + (uVar7 ^ uVar2 ^ uVar4) +
       (uVar1 * 0x20 | uVar1 >> 0x1b);
  ctx->state[1] = uVar1 + uVar12;
  ctx->state[2] = uVar16 + (uVar4 >> 2 | uVar4 * 0x40000000);
  ctx->state[3] = uVar2 + ctx->state[3];
  ctx->state[4] = uVar7 + ctx->state[4];
  return;
}



void mbedtls_sha1_update(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  size_t __n;
  uint uVar1;
  uint uVar2;
  uint __n_00;
  
  uVar2 = ctx->total[0] & 0x3f;
  uVar1 = ctx->total[0] + ilen;
  ctx->total[0] = uVar1;
  if (uVar1 < ilen) {
    ctx->total[1] = ctx->total[1] + 1;
  }
  uVar1 = ilen;
  if ((uVar2 != 0) && (__n_00 = 0x40 - uVar2, __n_00 <= ilen)) {
    memcpy(ctx->buffer + uVar2,input,__n_00);
    ilen = (ilen - 0x40) + uVar2;
    mbedtls_sha1_process(ctx,ctx->buffer);
    input = input + __n_00;
    uVar2 = 0;
    uVar1 = ilen;
  }
  while (0x3f < ilen) {
    mbedtls_sha1_process(ctx,input + (uVar1 - ilen));
    ilen = ilen - 0x40;
  }
  __n = (uVar1 >> 6) * -0x40 + uVar1;
  if (__n == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  memcpy(ctx->buffer + uVar2,input + (uVar1 & 0xffffffc0),__n);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



void mbedtls_sha1_update(mbedtls_sha1_context *ctx,uchar *input,size_t ilen)

{
  if (ilen != 0) {
    mbedtls_sha1_update(ctx,input,ilen);
    return;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void mbedtls_sha1_finish(mbedtls_sha1_context *ctx,uchar *output)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  uchar uStack24;
  undefined uStack23;
  ushort uStack22;
  uchar msglen [8];
  
  uVar1 = ctx->total[0];
  uVar2 = ctx->total[1] << 3;
  uStack24 = (uchar)(uVar2 >> 0x18);
  uStack23 = (undefined)(uVar2 >> 0x10);
  uStack22 = (ushort)(uVar2 >> 8) & 0xff | (ushort)((uVar2 | uVar1 >> 0x1d) << 8);
  msglen[0] = (uchar)((uVar1 << 3) >> 0x18);
  msglen[1] = (uchar)((uVar1 << 3) >> 0x10);
  msglen._2_2_ = (ushort)((uVar1 << 0x13) >> 0x18) | (ushort)(uVar1 << 0xb);
  if ((uVar1 & 0x3f) < 0x38) {
    iVar3 = 0x38;
  }
  else {
    iVar3 = 0x78;
  }
  mbedtls_sha1_update(ctx,sha1_padding,iVar3 - (uVar1 & 0x3f));
  mbedtls_sha1_update(ctx,&uStack24,8);
  *output = *(uchar *)((int)ctx->state + 3);
  output[1] = (uchar)*(undefined2 *)((int)ctx->state + 2);
  output[2] = (uchar)(ctx->state[0] >> 8);
  output[3] = (uchar)ctx->state[0];
  output[4] = *(uchar *)((int)ctx->state + 7);
  output[5] = (uchar)*(undefined2 *)((int)ctx->state + 6);
  output[6] = (uchar)(ctx->state[1] >> 8);
  output[7] = (uchar)ctx->state[1];
  output[8] = *(uchar *)((int)ctx->state + 0xb);
  output[9] = (uchar)*(undefined2 *)((int)ctx->state + 10);
  output[10] = (uchar)(ctx->state[2] >> 8);
  output[0xb] = (uchar)ctx->state[2];
  output[0xc] = *(uchar *)((int)ctx->state + 0xf);
  output[0xd] = (uchar)*(undefined2 *)((int)ctx->state + 0xe);
  output[0xe] = (uchar)(ctx->state[3] >> 8);
  output[0xf] = (uchar)ctx->state[3];
  output[0x10] = *(uchar *)((int)ctx->state + 0x13);
  output[0x11] = (uchar)*(undefined2 *)((int)ctx->state + 0x12);
  output[0x12] = (uchar)(ctx->state[4] >> 8);
  output[0x13] = (uchar)ctx->state[4];
  return;
}



void mbedtls_sha1(uchar *input,size_t ilen,uchar *output)

{
  undefined auStack108 [4];
  mbedtls_sha1_context ctx;
  
  mbedtls_sha1_init((mbedtls_sha1_context *)auStack108);
  mbedtls_sha1_starts((mbedtls_sha1_context *)auStack108);
  mbedtls_sha1_update((mbedtls_sha1_context *)auStack108,input,ilen);
  mbedtls_sha1_finish((mbedtls_sha1_context *)auStack108,output);
  mbedtls_sha1_free((mbedtls_sha1_context *)auStack108);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



mbedtls_ssl_ciphersuite_t * mbedtls_ssl_ciphersuite_from_id(int ciphersuite)

{
  mbedtls_ssl_ciphersuite_t *pmVar1;
  
  pmVar1 = ciphersuite_definitions;
  while( true ) {
    if (pmVar1->id == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (mbedtls_ssl_ciphersuite_t *)0x0;
    }
    if (pmVar1->id == ciphersuite) break;
    pmVar1 = pmVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pmVar1;
}



int * mbedtls_ssl_list_ciphersuites(void)

{
  int *piVar1;
  int *piVar2;
  mbedtls_ssl_ciphersuite_t *pmVar3;
  int ciphersuite;
  
  if (supported_init == 0) {
    piVar1 = supported_ciphersuites;
    piVar2 = ciphersuite_preference;
    while ((ciphersuite = *piVar2, ciphersuite != 0 && (piVar1 < supported_ciphersuites + 5))) {
      pmVar3 = mbedtls_ssl_ciphersuite_from_id(ciphersuite);
      if (pmVar3 != (mbedtls_ssl_ciphersuite_t *)0x0) {
        *piVar1 = ciphersuite;
        piVar1 = piVar1 + 1;
      }
      piVar2 = piVar2 + 1;
    }
    *piVar1 = 0;
    supported_init = 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return supported_ciphersuites;
}



char * mbedtls_ssl_get_ciphersuite_name(int ciphersuite_id)

{
  mbedtls_ssl_ciphersuite_t *pmVar1;
  char *pcVar2;
  
  pmVar1 = mbedtls_ssl_ciphersuite_from_id(ciphersuite_id);
  if (pmVar1 == (mbedtls_ssl_ciphersuite_t *)0x0) {
    pcVar2 = "unknown";
  }
  else {
    pcVar2 = pmVar1->name;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar2;
}



mbedtls_pk_type_t mbedtls_ssl_get_ciphersuite_sig_pk_alg(mbedtls_ssl_ciphersuite_t *info)

{
  mbedtls_pk_type_t mVar1;
  uint uVar2;
  
  if (info->key_exchange < 0xb) {
    uVar2 = 1 << (info->key_exchange & 0x1f);
    mVar1 = MBEDTLS_PK_RSA;
    if (((uVar2 & 0x8e) == 0) && (mVar1 = MBEDTLS_PK_ECKEY, (uVar2 & 0x600) == 0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (mbedtls_pk_type_t)(((uVar2 & 0x10) != 0) << 2);
    }
  }
  else {
    mVar1 = MBEDTLS_PK_NONE;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return mVar1;
}



mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_key_cert *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = ssl->handshake->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) ||
     (pmVar1 = ssl->conf->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) {
    pmVar1 = (mbedtls_ssl_key_cert *)pmVar1->key;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_pk_context *)pmVar1;
}



size_t mbedtls_ssl_hs_hdr_len(void)

{
  int in_a0;
  
  if ((*(ushort *)(in_a0 + 0x74) & 2) != 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0xc;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 4;
}



int mbedtls_ssl_handshake_client_step(mbedtls_ssl_context *ssl)

{
  uchar uVar1;
  mbedtls_key_exchange_type_t mVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  byte bVar6;
  uchar *puVar7;
  uchar *puVar8;
  uchar uVar9;
  uint uVar10;
  mbedtls_ssl_session *pmVar11;
  size_t sVar12;
  mbedtls_x509_crt *pmVar13;
  mbedtls_pk_context *pmVar14;
  size_t sVar15;
  mbedtls_md_type_t md_alg;
  int iVar16;
  int iVar17;
  char *pcVar18;
  uint uVar19;
  size_t sVar20;
  uchar *puVar21;
  int *piVar22;
  mbedtls_ssl_config_conflict *pmVar23;
  mbedtls_ssl_key_cert *pmVar24;
  uchar *puVar25;
  ushort *puVar26;
  byte *pbVar27;
  mbedtls_ssl_handshake_params *pmVar28;
  uint uVar29;
  mbedtls_ssl_ciphersuite_t *pmVar30;
  uchar *puVar31;
  uint uVar32;
  byte *pbVar33;
  uchar *puVar34;
  mbedtls_ssl_transform *pmVar35;
  char **ppcVar36;
  uchar *puVar37;
  byte *pbVar38;
  uchar *puVar39;
  uint uVar40;
  size_t local_74;
  int major_ver;
  int minor_ver;
  
  if ((ssl->state == 0x10) || (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) {
LAB_23068af0:
    uVar19 = 0xffff8f00;
    goto LAB_23068a62;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0xccf,"client state: %d");
  uVar10 = mbedtls_ssl_flush_output(ssl);
  uVar19 = uVar10;
  if ((uVar10 != 0) ||
     ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0 && (ssl->handshake->retransmit_state == '\x01')
       ) && (uVar19 = mbedtls_ssl_resend(ssl), uVar19 != 0)))) goto LAB_23068a62;
  if ((ssl->state == 0xc) && (ssl->handshake->new_session_ticket != 0)) {
    ssl->state = 0x11;
  }
  uVar19 = ssl->state;
  switch(uVar19) {
  case 0:
    ssl->state = 1;
    break;
  case 1:
    mbedtls_debug_print_msg(ssl,2,"file1",0x2cd,"=> write client hello");
    pmVar23 = ssl->conf;
    if (pmVar23->f_rng == (mbedtls_ssl_recv_t *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x2d1,"no RNG provided");
      uVar19 = 0xffff8c00;
      break;
    }
    ssl->major_ver = (uint)pmVar23->min_major_ver;
    ssl->minor_ver = (uint)pmVar23->min_minor_ver;
    if (pmVar23->max_major_ver == 0) {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0x2e0,
                                  
                 "configured max major version is invalid, consider using mbedtls_ssl_config_defaults()"
                );
      goto LAB_23068af0;
    }
    puVar37 = ssl->out_msg;
    mbedtls_ssl_write_version
              ((uint)pmVar23->max_major_ver,(uint)pmVar23->max_minor_ver,
               *(uint *)&pmVar23->field_0x74 >> 1 & 1,puVar37 + 4);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x2f3,"client hello, max version: [%d:%d]",(uint)puVar37[4],
               (uint)puVar37[5]);
    pmVar23 = ssl->conf;
    pmVar28 = ssl->handshake;
    if ((((*(ushort *)&pmVar23->field_0x74 & 2) == 0) || (pmVar28->verify_cookie == (uchar *)0x0))
       && ((uVar10 = (*pmVar23->f_rng)(pmVar23->p_rng,pmVar28->randbytes,4), uVar10 != 0 ||
           (uVar10 = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar28->randbytes + 4,0x1c), uVar10 != 0)
           ))) {
      pcVar18 = "ssl_generate_random";
      iVar17 = 0x2f7;
    }
    else {
      memcpy(puVar37 + 6,ssl->handshake->randbytes,0x20);
      mbedtls_debug_print_buf(ssl,3,"file1",0x2fc,"client hello, random bytes",puVar37 + 6,0x20);
      pmVar11 = ssl->session_negotiate;
      sVar15 = pmVar11->id_len;
      if ((0x10 < sVar15 - 0x10) || (ssl->handshake->resume == 0)) {
        sVar15 = 0;
      }
      if ((pmVar11->ticket != (uchar *)0x0) && (pmVar11->ticket_len != 0)) {
        uVar19 = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar11->id,0x20);
        if (uVar19 != 0) break;
        sVar15 = 0x20;
        ssl->session_negotiate->id_len = 0x20;
      }
      puVar37[0x26] = (uchar)sVar15;
      sVar20 = 0;
      while (sVar15 != sVar20) {
        puVar37[sVar20 + 0x27] = ssl->session_negotiate->id[sVar20];
        sVar20 = sVar20 + 1;
      }
      puVar31 = puVar37 + 0x27 + sVar15;
      mbedtls_debug_print_msg(ssl,3,"file1",0x331,"client hello, session id len.: %d",sVar15);
      mbedtls_debug_print_buf(ssl,3,"file1",0x332,"client hello, session id",puVar37 + 0x27,sVar15);
      puVar25 = puVar31;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        puVar25 = puVar31 + 1;
        puVar21 = ssl->handshake->verify_cookie;
        if (puVar21 == (uchar *)0x0) {
          mbedtls_debug_print_msg(ssl,3,"file1",0x33c,"no verify cookie to send");
          *puVar31 = '\0';
        }
        else {
          mbedtls_debug_print_buf
                    (ssl,3,"file1",0x343,"client hello, cookie",puVar21,
                     (uint)ssl->handshake->verify_cookie_len);
          *puVar31 = ssl->handshake->verify_cookie_len;
          memcpy(puVar25,ssl->handshake->verify_cookie,(uint)ssl->handshake->verify_cookie_len);
          puVar25 = puVar25 + ssl->handshake->verify_cookie_len;
        }
      }
      piVar22 = ssl->conf->ciphersuite_list[ssl->minor_ver];
      iVar17 = 0;
      puVar31 = puVar25 + 2;
      while (*piVar22 != 0) {
        pmVar30 = mbedtls_ssl_ciphersuite_from_id(*piVar22);
        puVar21 = puVar31;
        if ((((pmVar30 != (mbedtls_ssl_ciphersuite_t *)0x0) &&
             (pmVar23 = ssl->conf, pmVar30->min_minor_ver <= (int)(uint)pmVar23->max_minor_ver)) &&
            ((int)(uint)pmVar23->min_minor_ver <= pmVar30->max_minor_ver)) &&
           (((*(ushort *)&pmVar23->field_0x74 & 2) == 0 || ((pmVar30->flags & 4) == 0)))) {
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0x375,"client hello, add ciphersuite: %04x",*piVar22);
          iVar17 = iVar17 + 1;
          puVar21 = puVar31 + 2;
          *puVar31 = (uchar)((uint)*piVar22 >> 8);
          puVar31[1] = (uchar)*piVar22;
        }
        piVar22 = piVar22 + 1;
        puVar31 = puVar21;
      }
      puVar31[1] = -1;
      *puVar31 = '\0';
      *puVar25 = (uchar)(iVar17 + 1U >> 7);
      puVar25[1] = (char)(iVar17 + 1U) * '\x02';
      mbedtls_debug_print_msg(ssl,3,"file1",0x396,"client hello, got %d ciphersuites");
      mbedtls_debug_print_msg(ssl,3,"file1",0x3b5,"client hello, compress len.: %d",1);
      mbedtls_debug_print_msg(ssl,3,"file1",0x3b7,"client hello, compress alg.: %d",0);
      puVar31[2] = '\x01';
      puVar31[3] = '\0';
      puVar25 = puVar31 + 4;
      puVar21 = puVar31 + 6;
      puVar34 = (uchar *)0x0;
      if (ssl->hostname != (char *)0x0) {
        puVar7 = ssl->out_msg;
        mbedtls_debug_print_msg(ssl,3,"file1",0x48,"client hello, adding server name extension: %s")
        ;
        sVar12 = strlen(ssl->hostname);
        if ((puVar7 + 0x4000 < puVar21) ||
           (puVar34 = (uchar *)(sVar12 + 9), puVar7 + 0x4000 + -(int)puVar21 < puVar34)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x4e,"buffer too small");
          puVar34 = (uchar *)0x0;
        }
        else {
          puVar31[8] = (uchar)(sVar12 + 5 >> 8);
          uVar9 = (uchar)sVar12;
          puVar31[9] = uVar9 + '\x05';
          puVar31[10] = (uchar)(sVar12 + 3 >> 8);
          puVar31[0xb] = uVar9 + '\x03';
          puVar31[6] = '\0';
          puVar31[7] = '\0';
          puVar31[0xc] = '\0';
          puVar31[0xd] = (uchar)(sVar12 >> 8);
          puVar31[0xe] = uVar9;
          memcpy(puVar31 + 0xf,ssl->hostname,sVar12);
        }
      }
      iVar17 = 0;
      if (ssl->conf->max_minor_ver == '\x03') {
        puVar7 = ssl->out_msg;
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0xb2,"client hello, adding signature_algorithms extension");
        piVar22 = ssl->conf->sig_hashes;
        iVar17 = 0;
        while (*(int *)(iVar17 * 2 + (int)piVar22) != 0) {
          iVar17 = iVar17 + 2;
        }
        puVar8 = puVar34 + 2 + (int)puVar25;
        if ((puVar7 + 0x4000 < puVar8) || (puVar7 + 0x4000 + -(int)puVar8 < (uchar *)(iVar17 + 6)))
        {
          mbedtls_debug_print_msg(ssl,1,"file1",0xc0,"buffer too small");
          iVar17 = 0;
        }
        else {
          puVar7 = puVar8 + 6;
          iVar17 = 0;
          while( true ) {
            iVar16 = *(int *)(iVar17 * 2 + (int)piVar22);
            if (iVar16 == 0) break;
            uVar9 = mbedtls_ssl_hash_from_md_alg(iVar16);
            *puVar7 = uVar9;
            puVar7[1] = '\x01';
            puVar7 = puVar7 + 2;
            iVar17 = iVar17 + 2;
          }
          puVar8[1] = '\r';
          puVar8[3] = (uchar)iVar17 + '\x02';
          *puVar8 = '\0';
          puVar8[2] = (uchar)((uint)(iVar17 + 2) >> 8);
          puVar8[4] = (uchar)((uint)iVar17 >> 8);
          puVar8[5] = (uchar)iVar17;
          iVar17 = iVar17 + 6;
        }
      }
      puVar34 = puVar34 + iVar17;
      iVar17 = 0;
      if ((*(ushort *)&ssl->conf->field_0x74 & 0x1c0) != 0) {
        puVar8 = ssl->out_msg;
        puVar7 = puVar25 + (int)(puVar34 + 2);
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x1b8,"client hello, adding max_fragment_length extension");
        if ((puVar8 + 0x4000 < puVar7) || (puVar8 + 0x4000 + -(int)puVar7 < &DAT_00000005)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x1bc,"buffer too small");
          iVar17 = 0;
        }
        else {
          *puVar7 = '\0';
          puVar7[1] = '\x01';
          puVar7[2] = '\0';
          puVar7[3] = '\x01';
          puVar7[4] = (byte)(*(uint *)&ssl->conf->field_0x74 >> 6) & 7;
          iVar17 = 5;
        }
      }
      puVar34 = puVar34 + iVar17;
      pbVar38 = (byte *)0x0;
      if (ssl->conf->alpn_list != (char **)0x0) {
        puVar7 = ssl->out_msg;
        mbedtls_debug_print_msg(ssl,3,"file1",0x26c,"client hello, adding alpn extension");
        ppcVar36 = ssl->conf->alpn_list;
        while (*ppcVar36 != (char *)0x0) {
          sVar12 = strlen(*ppcVar36);
          pbVar38 = pbVar38 + (sVar12 & 0xff) + 1;
          ppcVar36 = ppcVar36 + 1;
        }
        puVar8 = puVar25 + (int)(puVar34 + 2);
        if ((puVar7 + 0x4000 < puVar8) || (puVar7 + 0x4000 + -(int)puVar8 < pbVar38 + 6)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x273,"buffer too small");
          pbVar38 = (byte *)0x0;
        }
        else {
          *puVar8 = '\0';
          puVar8[1] = '\x10';
          pbVar38 = puVar8 + 6;
          ppcVar36 = ssl->conf->alpn_list;
          while (*ppcVar36 != (char *)0x0) {
            sVar12 = strlen(*ppcVar36);
            *pbVar38 = (byte)sVar12;
            memcpy(pbVar38 + 1,*ppcVar36,sVar12 & 0xff);
            ppcVar36 = ppcVar36 + 1;
            pbVar38 = pbVar38 + *pbVar38 + 1;
          }
          pbVar38 = pbVar38 + -(int)puVar8;
          puVar8[4] = (uchar)((uint)(pbVar38 + -6) >> 8);
          puVar8[5] = (char)pbVar38 + -6;
          puVar8[2] = (uchar)((uint)(pbVar38 + -4) >> 8);
          puVar8[3] = (char)pbVar38 + -4;
        }
      }
      puVar7 = (uchar *)0x0;
      if ((*(ushort *)&ssl->conf->field_0x74 & 0x200) != 0) {
        puVar39 = ssl->out_msg;
        puVar8 = puVar25 + (int)(pbVar38 + (int)puVar34 + 2);
        sVar12 = ssl->session_negotiate->ticket_len;
        mbedtls_debug_print_msg(ssl,3,"file1",0x23f,"client hello, adding session ticket extension")
        ;
        if ((puVar39 + 0x4000 < puVar8) ||
           (puVar7 = (uchar *)(sVar12 + 4), puVar39 + 0x4000 + -(int)puVar8 < puVar7)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x243,"buffer too small");
          puVar7 = (uchar *)0x0;
        }
        else {
          puVar8[1] = '#';
          *puVar8 = '\0';
          puVar8[2] = (uchar)(sVar12 >> 8);
          puVar8[3] = (uchar)sVar12;
          if ((ssl->session_negotiate->ticket == (uchar *)0x0) || (sVar12 == 0)) {
            puVar7 = &DAT_00000004;
          }
          else {
            mbedtls_debug_print_msg
                      (ssl,3,"file1",0x254,"sending session ticket of length %d",sVar12);
            memcpy(puVar8 + 4,ssl->session_negotiate->ticket,sVar12);
          }
        }
      }
      puVar7 = puVar7 + (int)(pbVar38 + (int)puVar34);
      mbedtls_debug_print_msg(ssl,3,"file1",0x3ff,"client hello, total extension length: %d",puVar7)
      ;
      if (puVar7 != (uchar *)0x0) {
        puVar31[4] = (uchar)((uint)puVar7 >> 8);
        puVar31[5] = (uchar)puVar7;
        puVar25 = puVar21 + (int)puVar7;
      }
      ssl->out_msgtype = 0x16;
      ssl->out_msglen = (size_t)(puVar25 + -(int)puVar37);
      *ssl->out_msg = '\x01';
      ssl->state = ssl->state + 1;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        mbedtls_ssl_send_flight_completed(ssl);
      }
      uVar10 = mbedtls_ssl_write_record(ssl);
      if (uVar10 == 0) {
        pcVar18 = "<= write client hello";
        iVar17 = 0x419;
        goto LAB_2306920e;
      }
      pcVar18 = "mbedtls_ssl_write_record";
      iVar17 = 0x415;
    }
    goto LAB_230690ee;
  case 2:
    mbedtls_debug_print_msg(ssl,2,"file1",0x582,"=> parse server hello");
    puVar37 = ssl->in_msg;
    uVar10 = mbedtls_ssl_read_record(ssl);
    if (uVar10 == 0) {
      if (ssl->in_msgtype != 0x16) {
        pcVar18 = "bad server hello message";
        iVar17 = 0x5a0;
LAB_2306926a:
        iVar16 = 1;
LAB_23069270:
        mbedtls_debug_print_msg(ssl,iVar16,"file1",iVar17,pcVar18);
        uVar19 = 0xffff8900;
        break;
      }
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
LAB_23069464:
        sVar15 = mbedtls_ssl_hs_hdr_len();
        if ((ssl->in_hslen < sVar15 + 0x26) || (*puVar37 != '\x02')) {
          iVar17 = 0x5ba;
        }
        else {
          puVar37 = puVar37 + sVar15;
          mbedtls_debug_print_buf(ssl,3,"file1",0x5cb,"server hello, version",puVar37,2);
          mbedtls_ssl_read_version
                    (&ssl->major_ver,&ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,
                     puVar37);
          pmVar23 = ssl->conf;
          if (((ssl->major_ver < (int)(uint)pmVar23->min_major_ver) ||
              (ssl->minor_ver < (int)(uint)pmVar23->min_minor_ver)) ||
             (((int)(uint)pmVar23->max_major_ver < ssl->major_ver ||
              ((int)(uint)pmVar23->max_minor_ver < ssl->minor_ver)))) {
            mbedtls_debug_print_msg
                      (ssl,1,"file1",0x5d8,
                       "server version out of bounds -  min: [%d:%d], server: [%d:%d], max: [%d:%d]"
                      );
LAB_2306935a:
            mbedtls_ssl_send_alert_message(ssl,'\x02','F');
            uVar19 = 0xffff9180;
            break;
          }
          mbedtls_debug_print_msg
                    (ssl,3,"file1",0x5e5,"server hello, current time: %lu",
                     (uint)puVar37[4] << 8 |
                     (uint)puVar37[2] << 0x18 | (uint)puVar37[3] << 0x10 | (uint)puVar37[5]);
          memcpy(ssl->handshake->randbytes + 0x20,puVar37 + 2,0x20);
          uVar29 = (uint)puVar37[0x22];
          mbedtls_debug_print_buf(ssl,3,"file1",0x5ec,"server hello, random bytes",puVar37 + 2,0x20)
          ;
          if (uVar29 < 0x21) {
            uVar19 = ssl->in_hslen;
            sVar15 = mbedtls_ssl_hs_hdr_len();
            iVar17 = sVar15 + uVar29;
            if (iVar17 + 0x27U < uVar19) {
              uVar32 = (uint)CONCAT11((puVar37 + uVar29)[0x26],(puVar37 + uVar29)[0x27]);
              if ((uVar32 - 1 < 3) || (uVar19 != iVar17 + uVar32 + 0x28)) {
                iVar17 = 0x5fc;
              }
              else {
LAB_23069606:
                uVar40 = (uint)CONCAT11((puVar37 + uVar29)[0x23],(puVar37 + uVar29)[0x24]);
                if (puVar37[uVar29 + 0x25] != 0) {
                  mbedtls_debug_print_msg(ssl,1,"file1",0x621,"server hello, bad compression: %d");
                  uVar19 = 0xffff8f80;
                  break;
                }
                pmVar35 = ssl->transform_negotiate;
                pmVar30 = mbedtls_ssl_ciphersuite_from_id(uVar40);
                pmVar35->ciphersuite_info = pmVar30;
                pmVar30 = ssl->transform_negotiate->ciphersuite_info;
                if (pmVar30 == (mbedtls_ssl_ciphersuite_t *)0x0) {
                  pcVar18 = "ciphersuite info for %04x not found";
                  iVar17 = 0x62c;
                  goto LAB_2306966a;
                }
                mbedtls_ssl_optimize_checksum(ssl,pmVar30);
                mbedtls_debug_print_msg
                          (ssl,3,"file1",0x632,"server hello, session id len.: %d",uVar29);
                puVar25 = puVar37 + 0x23;
                mbedtls_debug_print_buf
                          (ssl,3,"file1",0x633,"server hello, session id",puVar25,uVar29);
                if ((((ssl->handshake->resume == 0) || (uVar29 == 0)) ||
                    (pmVar11 = ssl->session_negotiate, uVar40 != pmVar11->ciphersuite)) ||
                   (((pmVar11->compression != 0 || (uVar29 != pmVar11->id_len)) ||
                    (iVar17 = memcmp(pmVar11->id,puVar25,uVar29), iVar17 != 0)))) {
                  ssl->state = ssl->state + 1;
                  ssl->handshake->resume = 0;
                  ssl->session_negotiate->ciphersuite = uVar40;
                  ssl->session_negotiate->compression = 0;
                  ssl->session_negotiate->id_len = uVar29;
                  memcpy(ssl->session_negotiate->id,puVar25,uVar29);
                }
                else {
                  ssl->state = 0xc;
                  uVar19 = mbedtls_ssl_derive_keys(ssl);
                  if (uVar19 != 0) {
                    mbedtls_debug_print_ret(ssl,1,"file1",0x651,"mbedtls_ssl_derive_keys",uVar19);
                    break;
                  }
                }
                if (ssl->handshake->resume == 0) {
                  pcVar18 = "no";
                }
                else {
                  pcVar18 = "a";
                }
                mbedtls_debug_print_msg(ssl,3,"file1",0x657,"%s session has been resumed",pcVar18);
                mbedtls_debug_print_msg
                          (ssl,3,"file1",0x659,"server hello, chosen ciphersuite: %04x",uVar40);
                mbedtls_debug_print_msg
                          (ssl,3,"file1",0x65a,"server hello, compress alg.: %d",
                           (uint)puVar37[uVar29 + 0x25]);
                pmVar30 = mbedtls_ssl_ciphersuite_from_id(ssl->session_negotiate->ciphersuite);
                if (pmVar30 == (mbedtls_ssl_ciphersuite_t *)0x0) {
                  iVar17 = 0x664;
                }
                else {
                  mbedtls_debug_print_msg
                            (ssl,3,"file1",0x668,"server hello, chosen ciphersuite: %s",
                             pmVar30->name);
                  piVar22 = ssl->conf->ciphersuite_list[ssl->minor_ver];
                  do {
                    iVar17 = *piVar22;
                    if (iVar17 == 0) {
                      iVar17 = 0x66f;
                      goto LAB_2306948e;
                    }
                    piVar22 = piVar22 + 1;
                  } while (iVar17 != ssl->session_negotiate->ciphersuite);
                  ssl->session_negotiate->compression = 0;
                  puVar26 = (ushort *)(puVar37 + uVar29 + 0x28);
                  mbedtls_debug_print_msg
                            (ssl,2,"file1",0x687,"server hello, total extension length: %d",uVar32);
                  do {
                    if (uVar32 == 0) {
                      if ((ssl->secure_renegotiation != 0) ||
                         ((*(ushort *)&ssl->conf->field_0x74 & 0x30) != 0x20)) {
                        pcVar18 = "<= parse server hello";
                        iVar17 = 0x743;
                        goto LAB_2306920e;
                      }
                      iVar17 = -0x430;
                      iVar16 = 0x720;
LAB_23069934:
                      mbedtls_debug_print_msg
                                (ssl,1,"file1",iVar16,(char *)((int)&PTR_caseD_e_2308d000 + iVar17))
                      ;
                      uVar19 = mbedtls_ssl_send_fatal_handshake_failure(ssl);
                      if (uVar19 != 0) goto LAB_23068a62;
                      goto LAB_230693ca;
                    }
                    uVar19 = (uint)(*puVar26 >> 8) | (*puVar26 & 0xff) << 8;
                    uVar40 = (puVar26[1] & 0xff) << 8 | (uint)(puVar26[1] >> 8);
                    if (uVar32 < uVar40 + 4) {
                      iVar17 = 0x692;
                      goto LAB_2306948e;
                    }
                    if (uVar19 == 0x10) {
                      mbedtls_debug_print_msg(ssl,3,"file1",0x703,"found alpn extension");
                      ppcVar36 = ssl->conf->alpn_list;
                      if ((((ppcVar36 == (char **)0x0) || (uVar40 < 4)) ||
                          (((uint)(puVar26[2] >> 8) | (puVar26[2] & 0xff) << 8) != uVar40 - 2)) ||
                         (uVar19 = (uint)*(byte *)(puVar26 + 3), uVar19 != uVar40 - 3))
                      goto LAB_230693ca;
                      while( true ) {
                        if (*ppcVar36 == (char *)0x0) goto LAB_230693ca;
                        sVar12 = strlen(*ppcVar36);
                        if ((uVar19 == sVar12) &&
                           (iVar17 = memcmp((void *)((int)puVar26 + 7),*ppcVar36,uVar19),
                           iVar17 == 0)) break;
                        ppcVar36 = ppcVar36 + 1;
                      }
                      ssl->alpn_chosen = *ppcVar36;
                    }
                    else {
                      if (uVar19 < 0x11) {
                        if (uVar19 == 1) {
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x6a6,"found max_fragment_length extension");
                          if ((((*(ushort *)&ssl->conf->field_0x74 & 0x1c0) == 0) || (uVar40 != 1))
                             || ((uint)*(byte *)(puVar26 + 2) !=
                                 (*(uint *)&ssl->conf->field_0x74 >> 6 & 7))) goto LAB_230693ca;
                        }
                        else {
LAB_230698de:
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x70d,"unknown extension found: %d (ignoring)");
                        }
                      }
                      else {
                        if (uVar19 == 0x23) {
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x6da,"found session_ticket extension");
                          if (((*(ushort *)&ssl->conf->field_0x74 & 0x200) == 0) || (uVar40 != 0))
                          goto LAB_230693ca;
                          ssl->handshake->new_session_ticket = 1;
                        }
                        else {
                          if (uVar19 != 0xff01) goto LAB_230698de;
                          mbedtls_debug_print_msg
                                    (ssl,3,"file1",0x699,"found renegotiation extension");
                          if ((uVar40 != 1) || (*(char *)(puVar26 + 2) != '\0')) {
                            iVar17 = -0x4d8;
                            iVar16 = 0x43c;
                            goto LAB_23069934;
                          }
                          ssl->secure_renegotiation = 1;
                        }
                      }
                    }
                    iVar17 = uVar32 - uVar40;
                    uVar32 = iVar17 - 4;
                    puVar26 = (ushort *)((int)puVar26 + uVar40 + 4);
                  } while (2 < iVar17 - 5U);
                  iVar17 = 0x715;
                }
              }
            }
            else {
              uVar32 = 0;
              if (uVar19 == iVar17 + 0x26U) goto LAB_23069606;
              iVar17 = 0x606;
            }
          }
          else {
            iVar17 = 0x5f0;
          }
        }
LAB_2306948e:
        mbedtls_debug_print_msg(ssl,1,"file1",iVar17,"bad server hello message");
      }
      else {
        if (*puVar37 != '\x03') {
          vPortFree(ssl->handshake->verify_cookie);
          ssl->handshake->verify_cookie = (uchar *)0x0;
          ssl->handshake->verify_cookie_len = '\0';
          goto LAB_23069464;
        }
        mbedtls_debug_print_msg(ssl,2,"file1",0x5a9,"received hello verify request");
        mbedtls_debug_print_msg(ssl,2,"file1",0x5aa,"<= parse server hello");
        sVar15 = mbedtls_ssl_hs_hdr_len();
        puVar37 = ssl->in_msg + sVar15;
        mbedtls_debug_print_msg(ssl,2,"file1",0x52e,"=> parse hello verify request");
        mbedtls_debug_print_buf(ssl,3,"file1",0x536,"server version",puVar37,2);
        mbedtls_ssl_read_version
                  ((int *)&local_74,&major_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,puVar37);
        if (((((int)local_74 < 3) || (major_ver < 2)) ||
            ((int)(uint)ssl->conf->max_major_ver < (int)local_74)) ||
           ((int)(uint)ssl->conf->max_minor_ver < major_ver)) {
          mbedtls_debug_print_msg(ssl,1,"file1",0x543,"bad server version");
          goto LAB_2306935a;
        }
        puVar25 = puVar37 + 3;
        bVar3 = puVar37[2];
        uVar19 = (uint)bVar3;
        mbedtls_debug_print_buf(ssl,3,"file1",0x54c,"cookie",puVar25,uVar19);
        if ((int)uVar19 <= (int)(ssl->in_msg + (ssl->in_msglen - (int)puVar25))) {
          vPortFree(ssl->handshake->verify_cookie);
          pmVar28 = ssl->handshake;
          puVar37 = (uchar *)mycalloc(1,uVar19);
          pmVar28->verify_cookie = puVar37;
          puVar37 = ssl->handshake->verify_cookie;
          if (puVar37 == (uchar *)0x0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0x55c,"alloc failed (%d bytes)",uVar19);
LAB_23069410:
            uVar19 = 0xffff8100;
            break;
          }
          memcpy(puVar37,puVar25,uVar19);
          ssl->handshake->verify_cookie_len = bVar3;
          ssl->state = 1;
          mbedtls_ssl_reset_checksum(ssl);
          mbedtls_ssl_recv_flight_completed(ssl);
          pcVar18 = "<= parse hello verify request";
          iVar17 = 0x569;
          goto LAB_2306920e;
        }
        mbedtls_debug_print_msg
                  (ssl,1,"file1",0x551,"cookie length does not match incoming message size");
        mbedtls_ssl_send_alert_message(ssl,'\x02','2');
      }
LAB_230693ca:
      uVar19 = 0xffff8680;
      break;
    }
    pcVar18 = "mbedtls_ssl_read_record";
    iVar17 = 0x588;
    goto LAB_230690ee;
  case 3:
    uVar19 = mbedtls_ssl_parse_certificate(ssl);
    break;
  case 4:
    pmVar30 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0x896,"=> parse server key exchange");
    if (pmVar30->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
      pcVar18 = "<= skip parse server key exchange";
      iVar17 = 0x89b;
LAB_23069ac2:
      mbedtls_debug_print_msg(ssl,2,"file1",iVar17,pcVar18);
      iVar17 = ssl->state + 1;
      uVar19 = uVar10;
      goto LAB_23069ad4;
    }
    uVar10 = mbedtls_ssl_read_record(ssl);
    if (uVar10 == 0) {
      if (ssl->in_msgtype == 0x16) {
        puVar37 = ssl->in_msg;
        if (*puVar37 == '\f') {
          sVar15 = mbedtls_ssl_hs_hdr_len();
          mbedtls_debug_print_buf
                    (ssl,3,"file1",0x8d6,"server key exchange",puVar37 + sVar15,
                     ssl->in_hslen - sVar15);
          iVar17 = 0x91b;
          goto LAB_23069b94;
        }
        if ((pmVar30->key_exchange & 0xfd) == 5) {
          ssl->record_read = 1;
          ssl->state = ssl->state + 1;
          pcVar18 = "<= parse server key exchange";
          iVar17 = 0x9d4;
          goto LAB_2306920e;
        }
        pcVar18 = "bad server key exchange message";
        iVar17 = 0x8d0;
      }
      else {
        pcVar18 = "bad server key exchange message";
        iVar17 = 0x8bf;
      }
      goto LAB_2306926a;
    }
    pcVar18 = "mbedtls_ssl_read_record";
    iVar17 = 0x8b9;
    goto LAB_230690ee;
  case 5:
    pmVar30 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0x9fc,"=> parse certificate request");
    mVar2 = pmVar30->key_exchange;
    if (((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
       (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) {
      pcVar18 = "<= skip parse certificate request";
      iVar17 = 0xa04;
      goto LAB_23069ac2;
    }
    if (ssl->record_read == 0) {
      uVar19 = mbedtls_ssl_read_record(ssl);
      if (uVar19 != 0) {
        iVar17 = 0xa0d;
        goto LAB_23069c12;
      }
      if (ssl->in_msgtype != 0x16) {
        pcVar18 = "bad certificate request message";
        iVar17 = 0xa13;
        goto LAB_2306926a;
      }
      ssl->record_read = 1;
    }
    ssl->client_auth = 0;
    ssl->state = ssl->state + 1;
    if (*ssl->in_msg == '\r') {
      ssl->client_auth = 1;
      pcVar18 = "a";
    }
    else {
      pcVar18 = "no";
    }
    mbedtls_debug_print_msg(ssl,3,"file1",0xa21,"got %s certificate request",pcVar18);
    if (ssl->client_auth != 0) {
      puVar37 = ssl->in_msg;
      ssl->record_read = 0;
      sVar15 = mbedtls_ssl_hs_hdr_len();
      pbVar27 = (byte *)(uint)puVar37[sVar15];
      pbVar38 = pbVar27 + sVar15;
      if ((byte *)ssl->in_hslen < pbVar38 + 2) {
        iVar17 = 0xa48;
      }
      else {
        if (ssl->minor_ver == 3) {
          uVar9 = puVar37[(int)(pbVar38 + 1)];
          uVar1 = puVar37[(int)(pbVar38 + 2)];
          pbVar33 = puVar37 + (int)(pbVar38 + 3);
          while (pbVar33 + -(int)(puVar37 + (int)(pbVar38 + 3)) <
                 (byte *)(uint)CONCAT11(uVar9,uVar1)) {
            mbedtls_debug_print_msg
                      (ssl,3,"file1",0xa58,"Supported Signature Algorithm found: %d,%d",
                       (uint)*pbVar33,(uint)pbVar33[1]);
            pbVar33 = pbVar33 + 2;
          }
          pbVar27 = (byte *)(uint)CONCAT11(uVar9,uVar1) + (int)(pbVar27 + 2);
          sVar15 = mbedtls_ssl_hs_hdr_len();
          if ((byte *)ssl->in_hslen < pbVar27 + sVar15 + 2) {
            iVar17 = 0xa60;
            goto LAB_23069cc2;
          }
        }
        sVar15 = mbedtls_ssl_hs_hdr_len();
        pbVar27 = pbVar27 + sVar15;
        if ((byte *)ssl->in_hslen ==
            pbVar27 + CONCAT11((puVar37 + (int)pbVar27)[1],(puVar37 + (int)pbVar27)[2]) + 3)
        goto exit;
        iVar17 = 0xa6d;
      }
LAB_23069cc2:
      mbedtls_debug_print_msg(ssl,1,"file1",iVar17,"bad certificate request message");
      uVar19 = 0xffff8580;
      break;
    }
exit:
    pcVar18 = "<= parse certificate request";
    iVar17 = 0xa72;
    goto LAB_2306920e;
  case 6:
    mbedtls_debug_print_msg(ssl,2,"file1",0xa81,"=> parse server hello done");
    if (ssl->record_read == 0) {
      uVar19 = mbedtls_ssl_read_record(ssl);
      if (uVar19 != 0) {
        iVar17 = 0xa87;
LAB_23069c12:
        mbedtls_debug_print_ret(ssl,1,"file1",iVar17,"mbedtls_ssl_read_record",uVar19);
        break;
      }
      if (ssl->in_msgtype != 0x16) {
        pcVar18 = "bad server hello done message";
        iVar17 = 0xa8d;
        goto LAB_2306926a;
      }
    }
    pmVar23 = ssl->conf;
    ssl->record_read = 0;
    sVar15 = mbedtls_ssl_hs_hdr_len();
    if ((ssl->in_hslen != sVar15) || (*ssl->in_msg != '\x0e')) {
      mbedtls_debug_print_msg(ssl,1,"file1",0xa96,"bad server hello done message");
      uVar19 = 0xffff8480;
      break;
    }
    ssl->state = ssl->state + 1;
    if ((*(ushort *)&pmVar23->field_0x74 & 2) != 0) {
      mbedtls_ssl_recv_flight_completed(ssl);
    }
    pcVar18 = "<= parse server hello done";
    iVar17 = 0xaa1;
LAB_2306920e:
    mbedtls_debug_print_msg(ssl,2,"file1",iVar17,pcVar18);
    uVar19 = uVar10;
    break;
  case 7:
    uVar19 = mbedtls_ssl_write_certificate(ssl);
    break;
  case 8:
    pmVar30 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xaac,"=> write client key exchange");
    if (pmVar30->key_exchange != MBEDTLS_KEY_EXCHANGE_RSA) {
      iVar17 = 0xb91;
LAB_23069b94:
      mbedtls_debug_print_msg(ssl,1,"file1",iVar17,"should never happen");
      uVar19 = 0xffff9400;
      break;
    }
    pmVar23 = ssl->conf;
    pmVar28 = ssl->handshake;
    iVar17 = ssl->minor_ver;
    puVar37 = pmVar28->premaster;
    mbedtls_ssl_write_version
              ((uint)pmVar23->max_major_ver,(uint)pmVar23->max_minor_ver,
               *(uint *)&pmVar23->field_0x74 >> 1 & 1,puVar37);
    uVar19 = (uint)(iVar17 != 0);
    uVar10 = (*ssl->conf->f_rng)(ssl->conf->p_rng,pmVar28->premaster + 2,0x2e);
    iVar17 = uVar19 * 2 + 4;
    if (uVar10 == 0) {
      ssl->handshake->pmslen = 0x30;
      pmVar13 = ssl->session_negotiate->peer_cert;
      if (pmVar13 == (mbedtls_x509_crt *)0x0) {
        pcVar18 = "certificate required";
        iVar17 = 0x801;
        iVar16 = 2;
        goto LAB_23069270;
      }
      iVar16 = mbedtls_pk_can_do(&pmVar13->pk,MBEDTLS_PK_RSA);
      if (iVar16 == 0) {
        mbedtls_debug_print_msg(ssl,1,"file1",0x80b,"certificate key type mismatch");
        uVar19 = 0xffff9300;
        break;
      }
      uVar10 = mbedtls_pk_encrypt(&ssl->session_negotiate->peer_cert->pk,puVar37,
                                  ssl->handshake->pmslen,ssl->out_msg + iVar17,(size_t *)&major_ver,
                                  0x4000 - iVar17,
                                  (anon_subr_int_void_ptr_uchar_ptr_size_t *)ssl->conf->f_rng,
                                  ssl->conf->p_rng);
      if (uVar10 == 0) {
        if (uVar19 == 1) {
          ssl->out_msg[4] = (uchar)((uint)major_ver >> 8);
          ssl->out_msg[5] = (uchar)major_ver;
          major_ver = major_ver + 2;
        }
        ssl->out_msglen = major_ver + 4;
        ssl->out_msgtype = 0x16;
        *ssl->out_msg = '\x10';
        ssl->state = ssl->state + 1;
        uVar10 = mbedtls_ssl_write_record(ssl);
        if (uVar10 == 0) {
          pcVar18 = "<= write client key exchange";
          iVar17 = 0xba1;
          goto LAB_2306920e;
        }
        pcVar18 = "mbedtls_ssl_write_record";
        iVar17 = 0xb9d;
      }
      else {
        pcVar18 = "mbedtls_rsa_pkcs1_encrypt";
        iVar17 = 0x815;
      }
    }
    else {
      pcVar18 = "f_rng";
      iVar17 = 0x7f9;
    }
    goto LAB_230690ee;
  case 9:
    pmVar30 = ssl->transform_negotiate->ciphersuite_info;
    local_74 = 0;
    mbedtls_debug_print_msg(ssl,2,"file1",0xbd2,"=> write certificate verify");
    uVar10 = mbedtls_ssl_derive_keys(ssl);
    if (uVar10 == 0) {
      mVar2 = pmVar30->key_exchange;
      if (((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
         (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) {
        pcVar18 = "<= skip write certificate verify";
        iVar17 = 0xbe0;
      }
      else {
        if ((ssl->client_auth != 0) &&
           ((((pmVar28 = ssl->handshake, pmVar28 != (mbedtls_ssl_handshake_params *)0x0 &&
              (pmVar24 = pmVar28->key_cert, pmVar24 != (mbedtls_ssl_key_cert *)0x0)) ||
             (pmVar24 = ssl->conf->key_cert, pmVar24 != (mbedtls_ssl_key_cert *)0x0)) &&
            (pmVar24->cert != (mbedtls_x509_crt *)0x0)))) {
          pmVar14 = mbedtls_ssl_own_key(ssl);
          if (pmVar14 == (mbedtls_pk_context *)0x0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0xbee,"got no private key for certificate");
            uVar19 = 0xffff8a00;
            break;
          }
          (*pmVar28->calc_verify)(ssl,(uchar *)&major_ver);
          if (ssl->minor_ver != 3) {
            iVar17 = 0xc3d;
            goto LAB_23069b94;
          }
          md_alg = ssl->transform_negotiate->ciphersuite_info->mac;
          if (md_alg == MBEDTLS_MD_SHA384) {
            ssl->out_msg[4] = '\x05';
          }
          else {
            ssl->out_msg[4] = '\x04';
            md_alg = MBEDTLS_MD_SHA256;
          }
          pmVar14 = mbedtls_ssl_own_key(ssl);
          puVar37 = ssl->out_msg;
          uVar9 = mbedtls_ssl_sig_from_pk(pmVar14);
          puVar37[5] = uVar9;
          pmVar14 = mbedtls_ssl_own_key(ssl);
          uVar10 = mbedtls_pk_sign(pmVar14,md_alg,(uchar *)&major_ver,0,ssl->out_msg + 8,&local_74,
                                   (anon_subr_int_void_ptr_uchar_ptr_size_t *)ssl->conf->f_rng,
                                   ssl->conf->p_rng);
          if (uVar10 == 0) {
            ssl->out_msg[6] = (uchar)(local_74 >> 8);
            ssl->out_msg[7] = (uchar)local_74;
            ssl->out_msglen = local_74 + 8;
            ssl->out_msgtype = 0x16;
            *ssl->out_msg = '\x0f';
            ssl->state = ssl->state + 1;
            uVar10 = mbedtls_ssl_write_record(ssl);
            if (uVar10 == 0) {
              pcVar18 = "<= write certificate verify";
              iVar17 = 0xc58;
              goto LAB_2306920e;
            }
            pcVar18 = "mbedtls_ssl_write_record";
            iVar17 = 0xc54;
          }
          else {
            pcVar18 = "mbedtls_pk_sign";
            iVar17 = 0xc45;
          }
          goto LAB_230690ee;
        }
        pcVar18 = "<= skip write certificate verify";
        iVar17 = 0xbe7;
      }
      goto LAB_23069ac2;
    }
    pcVar18 = "mbedtls_ssl_derive_keys";
    iVar17 = 0xbd6;
    goto LAB_230690ee;
  case 10:
    uVar19 = mbedtls_ssl_write_change_cipher_spec(ssl);
    break;
  case 0xb:
    uVar19 = mbedtls_ssl_write_finished(ssl);
    break;
  case 0xc:
    uVar19 = mbedtls_ssl_parse_change_cipher_spec(ssl);
    break;
  case 0xd:
    uVar19 = mbedtls_ssl_parse_finished(ssl);
    break;
  case 0xe:
    mbedtls_debug_print_msg(ssl,2,"file1",0xd3e,"handshake: done");
    iVar17 = 0xf;
    uVar19 = uVar10;
LAB_23069ad4:
    ssl->state = iVar17;
    break;
  case 0xf:
    mbedtls_ssl_handshake_wrapup(ssl);
    uVar19 = uVar10;
    break;
  default:
    pcVar18 = "invalid state %d";
    iVar17 = 0xd47;
    uVar40 = uVar19;
LAB_2306966a:
    mbedtls_debug_print_msg(ssl,1,"file1",iVar17,pcVar18,uVar40);
    goto LAB_23068af0;
  case 0x11:
    mbedtls_debug_print_msg(ssl,2,"file1",0xc6c,"=> parse new session ticket");
    uVar19 = mbedtls_ssl_read_record(ssl);
    uVar10 = uVar19;
    if (uVar19 == 0) {
      if (ssl->in_msgtype != 0x16) {
        pcVar18 = "bad new session ticket message";
        iVar17 = 0xc76;
        goto LAB_2306926a;
      }
      puVar37 = ssl->in_msg;
      if (*puVar37 == '\x04') {
        uVar40 = ssl->in_hslen;
        sVar15 = mbedtls_ssl_hs_hdr_len();
        if (uVar40 < sVar15 + 6) goto LAB_2306a262;
        pbVar38 = puVar37 + sVar15;
        bVar3 = *pbVar38;
        uVar29 = (*(ushort *)(pbVar38 + 4) & 0xff) << 8 | (uint)(*(ushort *)(pbVar38 + 4) >> 8);
        bVar4 = pbVar38[1];
        bVar5 = pbVar38[2];
        bVar6 = pbVar38[3];
        if (uVar40 == sVar15 + 6 + uVar29) {
          mbedtls_debug_print_msg(ssl,3,"file1",0xc98,"ticket length: %d",uVar29);
          ssl->handshake->new_session_ticket = 0;
          ssl->state = 0xc;
          if (uVar29 == 0) break;
          puVar25 = ssl->session_negotiate->ticket;
          puVar37 = puVar25 + ssl->session_negotiate->ticket_len;
          while (puVar25 != puVar37) {
            *puVar25 = '\0';
            puVar25 = puVar25 + 1;
          }
          vPortFree(ssl->session_negotiate->ticket);
          ssl->session_negotiate->ticket = (uchar *)0x0;
          ssl->session_negotiate->ticket_len = 0;
          puVar37 = (uchar *)mycalloc(1,uVar29);
          if (puVar37 == (uchar *)0x0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0xcad,"ticket alloc failed");
            goto LAB_23069410;
          }
          memcpy(puVar37,pbVar38 + 6,uVar29);
          ssl->session_negotiate->ticket = puVar37;
          ssl->session_negotiate->ticket_len = uVar29;
          ssl->session_negotiate->ticket_lifetime =
               (uint)bVar3 << 0x18 | (uint)bVar4 << 0x10 | (uint)bVar6 | (uint)bVar5 << 8;
          mbedtls_debug_print_msg(ssl,3,"file1",0xcbc,"ticket in use, discarding session id");
          pcVar18 = "<= parse new session ticket";
          ssl->session_negotiate->id_len = 0;
          iVar17 = 0xcbf;
          goto LAB_2306920e;
        }
        iVar17 = 0xc94;
      }
      else {
LAB_2306a262:
        iVar17 = 0xc87;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",iVar17,"bad new session ticket message");
      uVar19 = 0xffff9200;
      break;
    }
    pcVar18 = "mbedtls_ssl_read_record";
    iVar17 = 0xc70;
LAB_230690ee:
    mbedtls_debug_print_ret(ssl,1,"file1",iVar17,pcVar18,uVar10);
    uVar19 = uVar10;
  }
LAB_23068a62:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar19;
}



mbedtls_pk_context * mbedtls_ssl_own_key(mbedtls_ssl_context *ssl)

{
  mbedtls_ssl_key_cert *pmVar1;
  
  if (((ssl->handshake != (mbedtls_ssl_handshake_params *)0x0) &&
      (pmVar1 = ssl->handshake->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) ||
     (pmVar1 = ssl->conf->key_cert, pmVar1 != (mbedtls_ssl_key_cert *)0x0)) {
    pmVar1 = (mbedtls_ssl_key_cert *)pmVar1->key;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (mbedtls_pk_context *)pmVar1;
}



// WARNING: Could not reconcile some variable overlaps

int mbedtls_ssl_handshake_server_step(mbedtls_ssl_context *ssl)

{
  byte bVar1;
  mbedtls_key_exchange_type_t mVar2;
  ushort uVar3;
  char cVar4;
  mbedtls_x509_crt *pmVar5;
  ushort *buf;
  uchar *puVar6;
  mbedtls_ssl_handshake_params *pmVar7;
  mbedtls_ssl_ciphersuite_t *pmVar8;
  uchar uVar9;
  mbedtls_md_type_t mVar10;
  mbedtls_pk_type_t mVar11;
  int iVar12;
  int iVar13;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  size_t sVar14;
  undefined3 extraout_var_01;
  mbedtls_pk_context *pmVar15;
  size_t sVar16;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  ushort *puVar17;
  uint uVar18;
  int iVar19;
  mbedtls_ssl_config_conflict *pmVar20;
  char *pcVar21;
  anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_get_cache *paVar22;
  mbedtls_ssl_session *pmVar23;
  uchar *buf_00;
  uchar *puVar24;
  uint uVar25;
  uchar *puVar26;
  byte *pbVar27;
  byte *pbVar28;
  uint uVar29;
  byte *pbVar30;
  uint uVar31;
  byte *pbVar32;
  uint *puVar33;
  uchar *puVar34;
  size_t sVar35;
  int *piVar36;
  int iVar37;
  byte *pbVar38;
  uint uVar39;
  mbedtls_ssl_key_cert *pmVar40;
  uchar *puVar41;
  byte *pbVar42;
  byte *pbVar43;
  char **ppcVar44;
  mbedtls_ssl_key_cert *pmVar45;
  byte bStack236;
  byte bStack235;
  uchar ver [2];
  int major;
  int minor;
  undefined local_b4 [4];
  mbedtls_ssl_session session;
  
  if ((ssl->state == 0x10) || (ssl->handshake == (mbedtls_ssl_handshake_params *)0x0)) {
LAB_2306c080:
    iVar37 = -0x7100;
    goto LAB_2306a4ce;
  }
  mbedtls_debug_print_msg(ssl,2,"file1",0xede,"server state: %d");
  iVar12 = mbedtls_ssl_flush_output(ssl);
  iVar37 = iVar12;
  if ((iVar12 != 0) ||
     ((((*(ushort *)&ssl->conf->field_0x74 & 2) != 0 && (ssl->handshake->retransmit_state == '\x01')
       ) && (iVar37 = mbedtls_ssl_resend(ssl), iVar37 != 0)))) goto LAB_2306a4ce;
  iVar37 = ssl->state;
  switch(iVar37) {
  case 0:
    ssl->state = 1;
    break;
  case 1:
    mbedtls_debug_print_msg(ssl,2,"file1",0x440,"=> parse client hello");
    iVar19 = mbedtls_ssl_fetch_input(ssl,5);
    if (iVar19 == 0) {
      pbVar28 = ssl->in_hdr;
      sVar35 = 5;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        sVar35 = 0xd;
      }
      mbedtls_debug_print_buf(ssl,4,"file1",0x45f,"record header",pbVar28,sVar35);
      mbedtls_debug_print_msg
                (ssl,3,"file1",0x46b,"client hello v3, message type: %d",(uint)*pbVar28);
      if (*pbVar28 == 0x16) {
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x474,"client hello v3, message len.: %d",
                   (*(ushort *)ssl->in_len & 0xff) << 8 | (uint)(*(ushort *)ssl->in_len >> 8));
        mbedtls_debug_print_msg
                  (ssl,3,"file1",0x477,"client hello v3, protocol version: [%d:%d]",(uint)pbVar28[1]
                   ,(uint)pbVar28[2]);
        mbedtls_ssl_read_version
                  ((int *)ver,&major,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,pbVar28 + 1);
        if ((int)_ver < 3) {
          iVar37 = 0x481;
        }
        else {
          if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
            puVar24 = ssl->in_ctr;
            if ((*puVar24 != '\0') || (puVar24[1] != '\0')) {
              iVar37 = 0x491;
              goto LAB_2306a59a;
            }
            memcpy(ssl->out_ctr + 2,puVar24 + 2,6);
          }
          uVar29 = (*(ushort *)ssl->in_len & 0xff) << 8 | (uint)(*(ushort *)ssl->in_len >> 8);
          if (uVar29 < 0x4001) {
            iVar12 = 5;
            if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
              iVar12 = 0xd;
            }
            iVar13 = mbedtls_ssl_fetch_input(ssl,iVar12 + uVar29);
            if (iVar13 != 0) {
              pcVar21 = "mbedtls_ssl_fetch_input";
              iVar12 = 0x4b9;
              iVar37 = iVar13;
              goto LAB_2306a528;
            }
            if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
              ssl->in_left = 0;
            }
            else {
              ssl->next_record_offset = uVar29 + 0xd;
            }
            pbVar28 = ssl->in_msg;
            mbedtls_debug_print_buf(ssl,4,"file1",0x4c8,"record contents",pbVar28,uVar29);
            (*ssl->handshake->update_checksum)(ssl,pbVar28,uVar29);
            uVar25 = 4;
            if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
              uVar25 = 0xc;
            }
            if (uVar29 < uVar25) {
              iVar37 = 0x4d6;
            }
            else {
              mbedtls_debug_print_msg
                        (ssl,3,"file1",0x4da,"client hello v3, handshake type: %d",(uint)*pbVar28);
              if (*pbVar28 == 1) {
                mbedtls_debug_print_msg
                          (ssl,3,"file1",0x4e3,"client hello v3, handshake len.: %d",
                           (uint)pbVar28[1] << 0x10 | (uint)pbVar28[2] << 8 | (uint)pbVar28[3]);
                if (pbVar28[1] == 0) {
                  iVar12 = 4;
                  uVar3 = *(ushort *)&ssl->conf->field_0x74;
                  if ((uVar3 & 2) != 0) {
                    iVar12 = 0xc;
                  }
                  if (uVar29 == ((uint)(*(ushort *)(pbVar28 + 2) >> 8) |
                                (*(ushort *)(pbVar28 + 2) & 0xff) << 8) + iVar12) {
                    if ((uVar3 & 2) == 0) {
LAB_2306a850:
                      iVar12 = 4;
                    }
                    else {
                      uVar25 = (*(ushort *)(ssl->in_msg + 4) & 0xff) << 8 |
                               (uint)(*(ushort *)(ssl->in_msg + 4) >> 8);
                      ssl->handshake->out_msg_seq = uVar25;
                      ssl->handshake->in_msg_seq = uVar25 + 1;
                      puVar24 = ssl->in_msg;
                      if ((((puVar24[6] != '\0') || (puVar24[7] != '\0')) || (puVar24[8] != '\0'))
                         || (iVar12 = memcmp(puVar24 + 1,puVar24 + 9,3), iVar12 != 0)) {
                        mbedtls_debug_print_msg
                                  (ssl,1,"file1",0x515,"ClientHello fragmentation not supported");
                        iVar37 = -0x7080;
                        break;
                      }
                      iVar12 = 0xc;
                      if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) goto LAB_2306a850;
                    }
                    pbVar28 = pbVar28 + iVar12;
                    pbVar38 = (byte *)(uVar29 - iVar12);
                    if (pbVar38 < (byte *)0x26) {
                      iVar37 = 0x535;
                      goto LAB_2306a59a;
                    }
                    mbedtls_debug_print_buf(ssl,3,"file1",0x53c,"client hello, version",pbVar28,2);
                    mbedtls_ssl_read_version
                              (&ssl->major_ver,&ssl->minor_ver,
                               *(uint *)&ssl->conf->field_0x74 >> 1 & 1,pbVar28);
                    ssl->handshake->max_major_ver = ssl->major_ver;
                    iVar12 = ssl->minor_ver;
                    ssl->handshake->max_minor_ver = iVar12;
                    pmVar20 = ssl->conf;
                    if ((ssl->major_ver < (int)(uint)pmVar20->min_major_ver) ||
                       (iVar12 < (int)(uint)pmVar20->min_minor_ver)) {
                      mbedtls_debug_print_msg
                                (ssl,1,"file1",0x54a,
                                 "client only supports ssl smaller than minimum [%d:%d] < [%d:%d]");
                      mbedtls_ssl_send_alert_message(ssl,'\x02','F');
                      iVar37 = -0x6e80;
                      break;
                    }
                    if ((int)(uint)pmVar20->max_major_ver < ssl->major_ver) {
                      ssl->major_ver = (uint)pmVar20->max_major_ver;
                      uVar29 = (uint)pmVar20->max_minor_ver;
LAB_2306a910:
                      ssl->minor_ver = uVar29;
                    }
                    else {
                      uVar29 = (uint)pmVar20->max_minor_ver;
                      if ((int)uVar29 < iVar12) goto LAB_2306a910;
                    }
                    mbedtls_debug_print_buf
                              (ssl,3,"file1",0x55d,"client hello, random bytes",pbVar28 + 2,0x20);
                    memcpy(ssl->handshake->randbytes,pbVar28 + 2,0x20);
                    uVar29 = (uint)pbVar28[0x22];
                    if ((uVar29 < 0x21) && (pbVar32 = (byte *)(uVar29 + 0x24), pbVar32 <= pbVar38))
                    {
                      mbedtls_debug_print_buf
                                (ssl,3,"file1",0x56d,"client hello, session id",pbVar28 + 0x23,
                                 uVar29);
                      ssl->session_negotiate->id_len = uVar29;
                      pbVar30 = (byte *)(uVar29 + 0x23);
                      memset(ssl->session_negotiate->id,0,0x20);
                      memcpy(ssl->session_negotiate->id,pbVar28 + 0x23,
                             ssl->session_negotiate->id_len);
                      if ((*(ushort *)&ssl->conf->field_0x74 & 2) == 0) {
LAB_2306aa32:
                        bVar1 = (pbVar28 + (int)pbVar30)[1];
                        uVar3 = CONCAT11(pbVar28[(int)pbVar30],bVar1);
                        pbVar32 = (byte *)(uint)uVar3;
                        if (1 < uVar3) {
                          pbVar42 = pbVar32 + (int)pbVar30;
                          if ((pbVar42 + 3 <= pbVar38) &&
                             (uVar29 = (uint)pbVar32 & 1, (bVar1 & 1) == 0)) {
                            pbVar30 = pbVar28 + (int)(pbVar30 + 2);
                            mbedtls_debug_print_buf
                                      (ssl,3,"file1",0x5bd,"client hello, ciphersuitelist",pbVar30,
                                       (size_t)pbVar32);
                            uVar25 = (uint)pbVar28[(int)(pbVar42 + 2)];
                            if (uVar25 - 1 < 0x10) {
                              pbVar43 = pbVar42 + 2 + uVar25;
                              pbVar27 = pbVar43 + 1;
                              if (pbVar27 <= pbVar38) {
                                mbedtls_debug_print_buf
                                          (ssl,3,"file1",0x5cf,"client hello, compression",
                                           pbVar28 + (int)(pbVar42 + 3),uVar25);
                                ssl->session_negotiate->compression = 0;
                                if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
                                  ssl->session_negotiate->compression = 0;
                                }
                                pbVar42 = pbVar43 + 3;
                                if (pbVar27 < pbVar38) {
                                  if (pbVar38 < pbVar42) {
                                    iVar37 = 0x5f0;
                                  }
                                  else {
                                    uVar29 = (uint)CONCAT11(pbVar28[(int)pbVar27],
                                                            pbVar28[(int)(pbVar43 + 2)]);
                                    if ((2 < uVar29 - 1) && (pbVar38 == pbVar42 + uVar29))
                                    goto LAB_2306ab4a;
                                    iVar37 = 0x5fa;
                                  }
                                }
                                else {
LAB_2306ab4a:
                                  buf = (ushort *)(pbVar28 + (int)pbVar42);
                                  mbedtls_debug_print_buf
                                            (ssl,3,"file1",0x602,"client hello extensions",
                                             (uchar *)buf,uVar29);
                                  do {
                                    pbVar28 = pbVar30;
                                    if (uVar29 == 0) goto LAB_2306ab72;
                                    uVar25 = (uint)(*buf >> 8) | (*buf & 0xff) << 8;
                                    uVar31 = (buf[1] & 0xff) << 8 | (uint)(buf[1] >> 8);
                                    uVar39 = uVar31 + 4;
                                    if (uVar29 < uVar39) {
                                      iVar37 = 0x60d;
                                      goto LAB_2306a59a;
                                    }
                                    if (uVar25 == 0xd) {
                                      mbedtls_debug_print_msg
                                                (ssl,3,"file1",0x62c,
                                                 "found signature_algorithms extension");
                                      uVar3 = buf[2] >> 8;
                                      if ((uVar31 == ((buf[2] & 0xff) << 8 | (uint)uVar3) + 2) &&
                                         ((uVar3 & 1) == 0)) {
                                        piVar36 = ssl->conf->sig_hashes;
                                        while (*piVar36 != 0) {
                                          puVar17 = buf + 3;
                                          while (puVar17 < (ushort *)((int)buf + uVar39)) {
                                            iVar12 = *piVar36;
                                            mVar10 = mbedtls_ssl_md_alg_from_hash(*(byte *)puVar17);
                                            if (iVar12 == CONCAT31(extraout_var,mVar10)) {
                                              iVar19 = 0xe4;
                                              ssl->handshake->sig_alg = (uint)*(byte *)puVar17;
                                              iVar12 = 0x298;
                                              uVar25 = ssl->handshake->sig_alg;
                                              goto LAB_2306aeda;
                                            }
                                            puVar17 = puVar17 + 1;
                                          }
                                          piVar36 = piVar36 + 1;
                                        }
                                        pcVar21 = "no signature_algorithm in common";
                                        iVar12 = 0xdf;
                                        goto LAB_2306ae8c;
                                      }
                                      iVar37 = 0xcb;
                                      goto LAB_2306a59a;
                                    }
                                    if (uVar25 < 0xe) {
                                      if (uVar25 == 0) {
                                        mbedtls_debug_print_msg
                                                  (ssl,3,"file1",0x614,"found ServerName extension")
                                        ;
                                        if (ssl->conf->f_sni !=
                                            (
                                             anon_subr_int_void_ptr_mbedtls_ssl_context_ptr_uchar_ptr_size_t_for_f_sni
                                             *)0x0) {
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",0x62,"parse ServerName extension"
                                                    );
                                          uVar25 = (buf[2] & 0xff) << 8 | (uint)(buf[2] >> 8);
                                          if (uVar31 != uVar25 + 2) {
                                            iVar37 = 0x67;
                                            goto LAB_2306a59a;
                                          }
                                          puVar17 = buf + 3;
                                          while (uVar25 != 0) {
                                            uVar18 = (*(ushort *)((int)puVar17 + 1) & 0xff) << 8 |
                                                     (uint)(*(ushort *)((int)puVar17 + 1) >> 8);
                                            if (uVar25 < uVar18 + 3) {
                                              iVar37 = 0x71;
                                              goto LAB_2306a59a;
                                            }
                                            if (*(byte *)puVar17 == 0) {
                                              iVar12 = (*ssl->conf->f_sni)(ssl->conf->p_sni,ssl,
                                                                           (byte *)((int)puVar17 + 3
                                                                                   ),uVar18);
                                              if (iVar12 != 0) {
                                                mbedtls_debug_print_ret
                                                          (ssl,1,"file1",0x7b,"ssl_sni_wrapper",
                                                           iVar12);
                                                uVar9 = 'p';
                                                goto LAB_2306adbc;
                                              }
                                              break;
                                            }
                                            uVar25 = uVar25 + (-3 - uVar18);
                                            puVar17 = (ushort *)((int)puVar17 + uVar18 + 3);
                                          }
                                        }
                                      }
                                      else {
                                        if (uVar25 == 1) {
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",0x65a,
                                                     "found max fragment length extension");
                                          if ((uVar31 != 1) || (4 < *(byte *)(buf + 2))) {
                                            iVar37 = 0x16a;
                                            goto LAB_2306a59a;
                                          }
                                          ssl->session_negotiate->mfl_code = *(byte *)(buf + 2);
                                        }
                                        else {
LAB_2306ac44:
                                          iVar12 = -0x458;
                                          iVar19 = 0x696;
LAB_2306aeda:
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",iVar19,
                                                     (char *)((int)&PTR_caseD_e_2308d000 + iVar12),
                                                     uVar25);
                                        }
                                      }
                                    }
                                    else {
                                      if (uVar25 == 0x23) {
                                        mbedtls_debug_print_msg
                                                  (ssl,3,"file1",0x682,
                                                   "found session ticket extension");
                                        mbedtls_ssl_session_init((mbedtls_ssl_session *)local_b4);
                                        if ((ssl->conf->f_ticket_parse !=
                                             (mbedtls_ssl_ticket_parse_t *)0x0) &&
                                           (ssl->conf->f_ticket_write !=
                                            (mbedtls_ssl_ticket_write_t *)0x0)) {
                                          ssl->handshake->new_session_ticket = 1;
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",0x1c9,"ticket length: %d",uVar31)
                                          ;
                                          if (uVar31 != 0) {
                                            iVar12 = (*ssl->conf->f_ticket_parse)
                                                               (ssl->conf->p_ticket,
                                                                (mbedtls_ssl_session *)local_b4,
                                                                (uchar *)(buf + 2),uVar31);
                                            if (iVar12 == 0) {
                                              session.compression = ssl->session_negotiate->id_len;
                                              memcpy(&session.id_len,ssl->session_negotiate->id,
                                                     session.compression);
                                              mbedtls_ssl_session_free(ssl->session_negotiate);
                                              memcpy(ssl->session_negotiate,local_b4,0x74);
                                              puVar24 = local_b4;
                                              do {
                                                *puVar24 = '\0';
                                                puVar24 = puVar24 + 1;
                                              } while (puVar24 != &session.mfl_code);
                                              mbedtls_debug_print_msg
                                                        (ssl,3,"file1",0x1f5,
                                                         "session successfully restored from ticket"
                                                        );
                                              ssl->handshake->resume = 1;
                                              ssl->handshake->new_session_ticket = 0;
                                            }
                                            else {
                                              mbedtls_ssl_session_free
                                                        ((mbedtls_ssl_session *)local_b4);
                                              if (iVar12 == -0x7180) {
                                                pcVar21 = "ticket is not authentic";
                                                iVar12 = 0x1df;
                                              }
                                              else {
                                                if (iVar12 != -0x6d80) {
                                                  mbedtls_debug_print_ret
                                                            (ssl,1,"file1",0x1e3,
                                                             "mbedtls_ssl_ticket_parse",iVar12);
                                                  goto LAB_2306ad3a;
                                                }
                                                pcVar21 = "ticket is expired";
                                                iVar12 = 0x1e1;
                                              }
LAB_2306ae8c:
                                              mbedtls_debug_print_msg(ssl,3,"file1",iVar12,pcVar21);
                                            }
                                          }
                                        }
                                      }
                                      else {
                                        if (uVar25 == 0xff01) {
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",0x61f,
                                                     "found renegotiation extension");
                                          if ((uVar31 != 1) || (*(byte *)(buf + 2) != 0)) {
                                            pcVar21 = "non-zero length renegotiation info";
                                            iVar37 = 0xad;
                                            goto LAB_2306ae02;
                                          }
                                          ssl->secure_renegotiation = 1;
                                        }
                                        else {
                                          if (uVar25 != 0x10) goto LAB_2306ac44;
                                          mbedtls_debug_print_msg
                                                    (ssl,3,"file1",0x68c,"found alpn extension");
                                          ppcVar44 = ssl->conf->alpn_list;
                                          if (ppcVar44 != (char **)0x0) {
                                            if ((3 < uVar31) &&
                                               (((uint)(buf[2] >> 8) | (buf[2] & 0xff) << 8) ==
                                                uVar31 - 2)) {
                                              while (*ppcVar44 != (char *)0x0) {
                                                sVar14 = strlen(*ppcVar44);
                                                puVar17 = buf + 3;
                                                while ((ushort *)((int)buf + uVar39) != puVar17) {
                                                  if ((ushort *)((int)buf + uVar39) < puVar17)
                                                  goto LAB_2306a5a2;
                                                  uVar25 = (uint)*(byte *)puVar17;
                                                  if (uVar25 == 0) goto LAB_2306a5a2;
                                                  if ((sVar14 == uVar25) &&
                                                     (iVar12 = memcmp((byte *)((int)puVar17 + 1),
                                                                      *ppcVar44,sVar14), iVar12 == 0
                                                     )) {
                                                    ssl->alpn_chosen = *ppcVar44;
                                                    goto LAB_2306ad3a;
                                                  }
                                                  puVar17 = (ushort *)
                                                            ((byte *)((int)puVar17 + 1) + uVar25);
                                                }
                                                ppcVar44 = ppcVar44 + 1;
                                              }
                                              uVar9 = 'x';
LAB_2306adbc:
                                              mbedtls_ssl_send_alert_message(ssl,'\x02',uVar9);
                                            }
                                            goto LAB_2306a5a2;
                                          }
                                        }
                                      }
                                    }
LAB_2306ad3a:
                                    iVar12 = uVar29 - uVar31;
                                    uVar29 = iVar12 - 4;
                                    buf = (ushort *)((int)buf + uVar39);
                                  } while (2 < iVar12 - 5U);
                                  iVar37 = 0x69e;
                                }
                                goto LAB_2306a59a;
                              }
                            }
                            iVar37 = 0x5ca;
                            goto LAB_2306a59a;
                          }
                        }
                        iVar37 = 0x5b8;
                      }
                      else {
                        uVar29 = (uint)pbVar28[(int)pbVar30];
                        if (pbVar38 < pbVar30 + uVar29 + 3) {
                          iVar37 = 0x580;
                        }
                        else {
                          mbedtls_debug_print_buf
                                    (ssl,3,"file1",0x585,"client hello, cookie",
                                     pbVar28 + (int)pbVar32,uVar29);
                          if (uVar29 == 0) {
                            mbedtls_debug_print_msg
                                      (ssl,2,"file1",0x5a5,"cookie verification skipped");
                            pbVar30 = pbVar32;
                            goto LAB_2306aa32;
                          }
                          iVar37 = 0x5a1;
                        }
                      }
                    }
                    else {
                      iVar37 = 0x569;
                    }
                    goto LAB_2306a59a;
                  }
                }
                iVar37 = 0x4e9;
              }
              else {
                iVar37 = 0x4de;
              }
            }
          }
          else {
            iVar37 = 0x4b3;
          }
        }
      }
      else {
        iVar37 = 0x46f;
      }
LAB_2306a59a:
      mbedtls_debug_print_msg(ssl,1,"file1",iVar37,"bad client hello message");
      goto LAB_2306a5a2;
    }
    pcVar21 = "mbedtls_ssl_fetch_input";
    iVar12 = 0x450;
    iVar37 = iVar19;
    goto LAB_2306a528;
  case 2:
    mbedtls_debug_print_msg(ssl,2,"file1",0x8b1,"=> write server hello");
    if (ssl->conf->f_rng == (mbedtls_ssl_recv_t *)0x0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x8c0,"no RNG provided");
      iVar37 = -0x7400;
      break;
    }
    puVar41 = ssl->out_msg;
    mbedtls_ssl_write_version
              (ssl->major_ver,ssl->minor_ver,*(uint *)&ssl->conf->field_0x74 >> 1 & 1,puVar41 + 4);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x8d3,"server hello, chosen version: [%d:%d]",(uint)puVar41[4],
               (uint)puVar41[5]);
    puVar24 = puVar41 + 6;
    iVar37 = (*ssl->conf->f_rng)(ssl->conf->p_rng,puVar24,4);
    if ((iVar37 != 0) ||
       (iVar37 = (*ssl->conf->f_rng)(ssl->conf->p_rng,puVar41 + 10,0x1c), iVar37 != 0)) break;
    memcpy(ssl->handshake->randbytes + 0x20,puVar24,0x20);
    mbedtls_debug_print_buf(ssl,3,"file1",0x8eb,"server hello, random bytes",puVar24,0x20);
    if ((ssl->handshake->resume == 0) && (ssl->session_negotiate->id_len != 0)) {
      paVar22 = ssl->conf->f_get_cache;
      if ((paVar22 != (anon_subr_int_void_ptr_mbedtls_ssl_session_ptr_for_f_get_cache *)0x0) &&
         (iVar37 = (*paVar22)(ssl->conf->p_cache,ssl->session_negotiate), iVar37 == 0)) {
        mbedtls_debug_print_msg(ssl,3,"file1",0x8fa,"session successfully restored from cache");
        ssl->handshake->resume = 1;
      }
    }
    pmVar23 = ssl->session_negotiate;
    if (ssl->handshake->resume == 0) {
      ssl->state = ssl->state + 1;
      if (ssl->handshake->new_session_ticket == 0) {
        pmVar23->id_len = 0x20;
        sVar35 = 0x20;
        iVar37 = (*ssl->conf->f_rng)(ssl->conf->p_rng,ssl->session_negotiate->id,0x20);
        if (iVar37 != 0) break;
      }
      else {
        pmVar23->id_len = 0;
        memset(ssl->session_negotiate->id,0,0x20);
        sVar35 = 0;
      }
    }
    else {
      sVar35 = pmVar23->id_len;
      ssl->state = 0xc;
      iVar37 = mbedtls_ssl_derive_keys(ssl);
      if (iVar37 != 0) {
        pcVar21 = "mbedtls_ssl_derive_keys";
        iVar12 = 0x923;
        goto LAB_2306a528;
      }
    }
    puVar24 = puVar41 + 0x27;
    puVar41[0x26] = (uchar)ssl->session_negotiate->id_len;
    memcpy(puVar24,ssl->session_negotiate->id,ssl->session_negotiate->id_len);
    sVar16 = ssl->session_negotiate->id_len;
    mbedtls_debug_print_msg(ssl,3,"file1",0x934,"server hello, session id len.: %d",sVar35);
    mbedtls_debug_print_buf(ssl,3,"file1",0x935,"server hello, session id",puVar24,sVar35);
    puVar24 = puVar24 + sVar16;
    if (ssl->handshake->resume == 0) {
      pcVar21 = "no";
    }
    else {
      pcVar21 = "a";
    }
    mbedtls_debug_print_msg(ssl,3,"file1",0x937,"%s session has been resumed",pcVar21);
    puVar34 = puVar24 + 3;
    *puVar24 = (uchar)((uint)ssl->session_negotiate->ciphersuite >> 8);
    puVar24[1] = (uchar)ssl->session_negotiate->ciphersuite;
    puVar24[2] = (uchar)ssl->session_negotiate->compression;
    pcVar21 = mbedtls_ssl_get_ciphersuite_name(ssl->session_negotiate->ciphersuite);
    mbedtls_debug_print_msg(ssl,3,"file1",0x93e,"server hello, chosen ciphersuite: %s",pcVar21);
    mbedtls_debug_print_msg
              (ssl,3,"file1",0x940,"server hello, compress alg.: 0x%02X",
               ssl->session_negotiate->compression);
    puVar6 = (uchar *)0x0;
    if (ssl->secure_renegotiation == 1) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7c3,"server hello, secure renegotiation extension");
      puVar24[5] = -1;
      puVar24[6] = '\x01';
      puVar24[7] = '\0';
      puVar24[8] = '\x01';
      puVar24[9] = '\0';
      puVar6 = puVar24 + (10 - (int)(puVar24 + 5));
    }
    iVar37 = 0;
    if (ssl->session_negotiate->mfl_code != '\0') {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7ec,"server hello, max_fragment_length extension");
      puVar26 = puVar6 + 2 + (int)puVar34;
      *puVar26 = '\0';
      puVar26[1] = '\x01';
      puVar26[2] = '\0';
      puVar26[3] = '\x01';
      puVar26[4] = ssl->session_negotiate->mfl_code;
      iVar37 = 5;
    }
    puVar6 = puVar6 + iVar37;
    iVar37 = 0;
    if (ssl->handshake->new_session_ticket != 0) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x7ab,"server hello, adding session ticket extension");
      puVar26 = puVar34 + (int)(puVar6 + 2);
      *puVar26 = '\0';
      puVar26[1] = '#';
      puVar26[2] = '\0';
      puVar26[3] = '\0';
      iVar37 = 4;
    }
    iVar12 = 0;
    if (ssl->alpn_chosen != (char *)0x0) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x84f,"server hello, adding alpn extension");
      puVar26 = puVar34 + (int)(puVar6 + iVar37 + 2);
      puVar26[1] = '\x10';
      *puVar26 = '\0';
      sVar14 = strlen(ssl->alpn_chosen);
      iVar12 = sVar14 + 7;
      puVar26[2] = (uchar)(sVar14 + 3 >> 8);
      cVar4 = (char)iVar12;
      puVar26[3] = cVar4 + -4;
      puVar26[4] = (uchar)(sVar14 + 1 >> 8);
      puVar26[5] = cVar4 + -6;
      puVar26[6] = cVar4 + -7;
      memcpy(puVar26 + 7,ssl->alpn_chosen,sVar14);
    }
    puVar6 = puVar6 + iVar37 + iVar12;
    mbedtls_debug_print_msg(ssl,3,"file1",0x977,"server hello, total extension length: %d",puVar6);
    if (puVar6 != (uchar *)0x0) {
      puVar24[3] = (uchar)((uint)puVar6 >> 8);
      puVar24[4] = (uchar)puVar6;
      puVar34 = puVar24 + 5 + (int)puVar6;
    }
    ssl->out_msgtype = 0x16;
    ssl->out_msglen = (size_t)(puVar34 + -(int)puVar41);
    *ssl->out_msg = '\x02';
    iVar37 = mbedtls_ssl_write_record(ssl);
    pcVar21 = "<= write server hello";
    iVar19 = 0x98a;
    goto LAB_2306b2ac;
  case 3:
    iVar37 = mbedtls_ssl_write_certificate(ssl);
    break;
  case 4:
    pmVar8 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xa7f,"=> write server key exchange");
    mVar2 = pmVar8->key_exchange;
    if (((mVar2 & 0xfb) == 1) || (mVar2 == MBEDTLS_KEY_EXCHANGE_RSA_PSK)) {
      pcVar21 = "<= skip write server key exchange";
      iVar37 = 0xa88;
LAB_2306b7d0:
      mbedtls_debug_print_msg(ssl,2,"file1",iVar37,pcVar21);
      iVar37 = ssl->state + 1;
      goto LAB_2306b7e2;
    }
    ssl->out_msglen = 4;
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\f';
    ssl->state = ssl->state + 1;
    iVar37 = mbedtls_ssl_write_record(ssl);
    if (iVar37 != 0) {
      pcVar21 = "mbedtls_ssl_write_record";
      iVar12 = 0xbd4;
      goto LAB_2306a528;
    }
    pcVar21 = "<= write server key exchange";
    iVar19 = 0xbd8;
    goto LAB_2306b2ac;
  case 5:
    pmVar8 = ssl->transform_negotiate->ciphersuite_info;
    puVar24 = ssl->out_msg;
    mbedtls_debug_print_msg(ssl,2,"file1",0x9b5,"=> write certificate request");
    ssl->state = ssl->state + 1;
    uVar29 = ssl->handshake->sni_authmode;
    if (uVar29 == 3) {
      uVar29 = *(uint *)&ssl->conf->field_0x74 >> 2 & 3;
    }
    mVar2 = pmVar8->key_exchange;
    if ((((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
        (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) || (uVar29 == 0)) {
      pcVar21 = "<= skip write certificate request";
      iVar19 = 0x9c7;
      iVar37 = iVar12;
    }
    else {
      puVar34 = ssl->out_msg;
      iVar37 = 0;
      puVar34[5] = '\x01';
      puVar34[4] = '\x01';
      puVar6 = puVar34 + 6;
      puVar41 = puVar6;
      if (ssl->minor_ver == 3) {
        iVar12 = 0;
        piVar36 = ssl->conf->sig_hashes;
        while( true ) {
          iVar37 = iVar12 + 2;
          puVar41 = puVar6 + iVar37;
          if (*piVar36 == 0) break;
          uVar9 = mbedtls_ssl_hash_from_md_alg(*piVar36);
          if ((CONCAT31(extraout_var_01,uVar9) != 0) &&
             (iVar19 = mbedtls_ssl_set_calc_verify_md(ssl,CONCAT31(extraout_var_01,uVar9)),
             iVar19 == 0)) {
            *puVar41 = uVar9;
            puVar6[iVar12 + 3] = '\x01';
            iVar12 = iVar37;
          }
          piVar36 = piVar36 + 1;
        }
        puVar34[6] = (uchar)((uint)iVar12 >> 8);
        puVar34[7] = (uchar)iVar12;
      }
      puVar41 = puVar41 + 2;
      pmVar5 = ssl->handshake->sni_ca_chain;
      if (pmVar5 == (mbedtls_x509_crt *)0x0) {
        pmVar5 = ssl->conf->ca_chain;
      }
      puVar24 = puVar24 + 0x4000;
      puVar6 = (uchar *)0x0;
      while( true ) {
        if ((pmVar5 == (mbedtls_x509_crt *)0x0) || (pmVar5->version == 0)) goto LAB_2306b93e;
        puVar26 = (uchar *)(pmVar5->subject_raw).len;
        if ((puVar24 < puVar41) ||
           ((puVar24 + -(int)puVar41 < puVar26 || (puVar24 + -(int)puVar41 < puVar26 + 2)))) break;
        *puVar41 = (uchar)((uint)puVar26 >> 8);
        puVar41[1] = (uchar)puVar26;
        buf_00 = puVar41 + 2;
        memcpy(buf_00,(pmVar5->subject_raw).p,(size_t)puVar26);
        puVar41 = buf_00 + (int)puVar26;
        puVar6 = puVar26 + 2 + (int)puVar6;
        mbedtls_debug_print_buf(ssl,3,"file1",0xa38,"requested DN",buf_00,(size_t)puVar26);
        pmVar5 = pmVar5->next;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",0xa2f,"skipping CAs: buffer too short");
LAB_2306b93e:
      ssl->out_msglen = (size_t)(puVar41 + -(int)puVar34);
      ssl->out_msgtype = 0x16;
      *ssl->out_msg = '\r';
      ssl->out_msg[iVar37 + 6] = (uchar)((uint)puVar6 >> 8);
      ssl->out_msg[iVar37 + 7] = (uchar)puVar6;
      iVar37 = mbedtls_ssl_write_record(ssl);
      pcVar21 = "<= write certificate request";
      iVar19 = 0xa46;
    }
    goto LAB_2306b2ac;
  case 6:
    mbedtls_debug_print_msg(ssl,2,"file1",0xbe1,"=> write server hello done");
    ssl->out_msglen = 4;
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\x0e';
    ssl->state = ssl->state + 1;
    if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
      mbedtls_ssl_send_flight_completed(ssl);
    }
    iVar37 = mbedtls_ssl_write_record(ssl);
    if (iVar37 == 0) {
      pcVar21 = "<= write server hello done";
      iVar19 = 0xbf4;
      goto LAB_2306b2ac;
    }
    pcVar21 = "mbedtls_ssl_write_record";
    iVar12 = 0xbf0;
    goto LAB_2306a528;
  case 7:
    iVar37 = mbedtls_ssl_parse_certificate(ssl);
    break;
  case 8:
    pmVar8 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xcd4,"=> parse client key exchange");
    iVar37 = mbedtls_ssl_read_record(ssl);
    if (iVar37 == 0) {
      puVar24 = ssl->in_msg;
      iVar37 = 4;
      if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
        iVar37 = 0xc;
      }
      sVar35 = ssl->in_hslen;
      pbVar28 = puVar24 + iVar37;
      if (ssl->in_msgtype == 0x16) {
        if (*puVar24 != '\x10') {
          iVar37 = 0xce7;
          goto LAB_2306bade;
        }
        if (pmVar8->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA) {
          pmVar15 = mbedtls_ssl_own_key(ssl);
          sVar16 = mbedtls_pk_get_bitlen(pmVar15);
          pmVar15 = mbedtls_ssl_own_key(ssl);
          uVar29 = sVar16 + 7 >> 3;
          pmVar7 = ssl->handshake;
          iVar37 = mbedtls_pk_can_do(pmVar15,MBEDTLS_PK_RSA);
          if (iVar37 == 0) {
            mbedtls_debug_print_msg(ssl,1,"file1",0xc34,"got no RSA private key");
            iVar37 = -0x7600;
          }
          else {
            if ((ssl->minor_ver == 0) ||
               (((uint)*pbVar28 == (sVar16 + 7 >> 0xb & 0xff) &&
                (pbVar38 = pbVar28 + 1, pbVar28 = pbVar28 + 2, (uint)*pbVar38 == (uVar29 & 0xff)))))
            {
              if (puVar24 + sVar35 == pbVar28 + uVar29) {
                mbedtls_ssl_write_version
                          (ssl->handshake->max_major_ver,ssl->handshake->max_minor_ver,
                           *(uint *)&ssl->conf->field_0x74 >> 1 & 1,&bStack236);
                iVar37 = (*ssl->conf->f_rng)(ssl->conf->p_rng,(uchar *)&major,0x30);
                if (iVar37 == 0) {
                  pmVar15 = mbedtls_ssl_own_key(ssl);
                  uVar29 = mbedtls_pk_decrypt(pmVar15,pbVar28,uVar29,local_b4,(size_t *)ver,0x30,
                                              (anon_subr_int_void_ptr_uchar_ptr_size_t *)
                                              ssl->conf->f_rng,ssl->conf->p_rng);
                  uVar29 = uVar29 | (uint)(byte)(local_b4[0] ^ bStack236 | local_b4[1] ^ bStack235)
                                    | _ver ^ 0x30;
                  ssl->handshake->pmslen = 0x30;
                  bVar1 = (char)((byte)(uVar29 >> 0x18) | (byte)(-uVar29 >> 0x18)) >> 7;
                  uVar29 = 0;
                  while (uVar29 < ssl->handshake->pmslen) {
                    pmVar7->premaster[uVar29] =
                         session.id[uVar29 - 0x10] & ~bVar1 |
                         *(byte *)((int)&major + uVar29) & bVar1;
                    uVar29 = uVar29 + 1;
                  }
                  iVar37 = mbedtls_ssl_derive_keys(ssl);
                  if (iVar37 == 0) {
                    ssl->state = ssl->state + 1;
                    pcVar21 = "<= parse client key exchange";
                    iVar19 = 0xdc1;
                    goto LAB_2306b2ac;
                  }
                  pcVar21 = "mbedtls_ssl_derive_keys";
                  iVar12 = 0xdbb;
                  goto LAB_2306a528;
                }
                goto LAB_2306bb5c;
              }
              iVar37 = 0xc4a;
            }
            else {
              iVar37 = 0xc42;
            }
            mbedtls_debug_print_msg(ssl,1,"file1",iVar37,"bad client key exchange message");
            iVar37 = -0x7c00;
          }
LAB_2306bb5c:
          pcVar21 = "ssl_parse_parse_encrypted_pms_secret";
          iVar12 = 0xd98;
          goto LAB_2306a528;
        }
        iVar37 = 0xdb5;
LAB_2306b108:
        mbedtls_debug_print_msg(ssl,1,"file1",iVar37,"should never happen");
        iVar37 = -0x7000;
      }
      else {
        iVar37 = 0xce1;
LAB_2306bade:
        mbedtls_debug_print_msg(ssl,1,"file1",iVar37,"bad client key exchange message");
        iVar37 = -0x8000;
      }
      iVar37 = iVar37 + 0x400;
      break;
    }
    pcVar21 = "mbedtls_ssl_read_record";
    iVar12 = 0xcd8;
    goto LAB_2306a528;
  case 9:
    pmVar8 = ssl->transform_negotiate->ciphersuite_info;
    mbedtls_debug_print_msg(ssl,2,"file1",0xdee,"=> parse certificate verify");
    mVar2 = pmVar8->key_exchange;
    if ((((byte)(mVar2 + ~MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA) < 4) ||
        (mVar2 == MBEDTLS_KEY_EXCHANGE_ECJPAKE)) ||
       (ssl->session_negotiate->peer_cert == (mbedtls_x509_crt *)0x0)) {
      pcVar21 = "<= skip parse certificate verify";
      iVar37 = 0xdf7;
      goto LAB_2306b7d0;
    }
    do {
      iVar37 = mbedtls_ssl_read_record_layer(ssl);
      if (iVar37 != 0) {
        pcVar21 = "mbedtls_ssl_read_record_layer";
        iVar12 = 0xe01;
        goto LAB_2306a528;
      }
      iVar37 = mbedtls_ssl_handle_message_type(ssl);
    } while (iVar37 == -0x6680);
    if (iVar37 == 0) {
      ssl->state = ssl->state + 1;
      if ((ssl->in_msgtype == 0x16) && (*ssl->in_msg == '\x0f')) {
        iVar37 = 4;
        if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
          iVar37 = 0xc;
        }
        if (ssl->minor_ver != 3) {
          iVar37 = 0xe6c;
          goto LAB_2306b108;
        }
        if (ssl->in_hslen < iVar37 + 2U) {
          pcVar21 = "bad certificate verify message";
          iVar37 = 0xe39;
        }
        else {
          mVar10 = mbedtls_ssl_md_alg_from_hash(ssl->in_msg[iVar37]);
          if ((CONCAT31(extraout_var_02,mVar10) == 0) ||
             (iVar12 = mbedtls_ssl_set_calc_verify_md(ssl,(uint)ssl->in_msg[iVar37]), iVar12 != 0))
          {
            pcVar21 = "peer not adhering to requested sig_alg for verify message";
            iVar37 = 0xe45;
          }
          else {
            puVar24 = local_b4;
            if (CONCAT31(extraout_var_02,mVar10) == 4) {
              puVar24 = session.id;
            }
            mVar11 = mbedtls_ssl_pk_alg_from_sig(ssl->in_msg[iVar37 + 1]);
            if (CONCAT31(extraout_var_03,mVar11) == 0) {
              pcVar21 = "peer not adhering to requested sig_alg for verify message";
              iVar37 = 0xe5a;
            }
            else {
              iVar12 = mbedtls_pk_can_do(&ssl->session_negotiate->peer_cert->pk,mVar11);
              if (iVar12 == 0) {
                pcVar21 = "sig_alg doesn\'t match cert key";
                iVar37 = 0xe63;
              }
              else {
                uVar29 = iVar37 + 4;
                if (ssl->in_hslen < uVar29) {
                  pcVar21 = "bad certificate verify message";
                  iVar37 = 0xe72;
                }
                else {
                  uVar25 = (uint)CONCAT11(ssl->in_msg[iVar37 + 2U],ssl->in_msg[iVar37 + 3]);
                  if (ssl->in_hslen == uVar29 + uVar25) {
                    (*ssl->handshake->calc_verify)(ssl,local_b4);
                    iVar37 = mbedtls_pk_verify(&ssl->session_negotiate->peer_cert->pk,mVar10,puVar24
                                               ,0,ssl->in_msg + uVar29,uVar25);
                    if (iVar37 == 0) {
                      mbedtls_ssl_update_handshake_status(ssl);
                      pcVar21 = "<= parse certificate verify";
                      iVar19 = 0xe8c;
                      goto LAB_2306b2ac;
                    }
                    pcVar21 = "mbedtls_pk_verify";
                    iVar12 = 0xe86;
                    goto LAB_2306a528;
                  }
                  pcVar21 = "bad certificate verify message";
                  iVar37 = 0xe7b;
                }
              }
            }
          }
        }
      }
      else {
        pcVar21 = "bad certificate verify message";
        iVar37 = 0xe15;
      }
      mbedtls_debug_print_msg(ssl,1,"file1",iVar37,pcVar21);
      iVar37 = -0x7d80;
      break;
    }
    pcVar21 = "mbedtls_ssl_handle_message_type";
    iVar12 = 0xe0b;
LAB_2306a528:
    mbedtls_debug_print_ret(ssl,1,"file1",iVar12,pcVar21,iVar37);
    break;
  case 10:
    iVar37 = mbedtls_ssl_parse_change_cipher_spec(ssl);
    break;
  case 0xb:
    iVar37 = mbedtls_ssl_parse_finished(ssl);
    break;
  case 0xc:
    if (ssl->handshake->new_session_ticket == 0) {
      iVar37 = mbedtls_ssl_write_change_cipher_spec(ssl);
      break;
    }
    mbedtls_debug_print_msg(ssl,2,"file1",0xe9e,"=> write new session ticket");
    ssl->out_msgtype = 0x16;
    *ssl->out_msg = '\x04';
    iVar37 = (*ssl->conf->f_ticket_write)
                       (ssl->conf->p_ticket,ssl->session_negotiate,ssl->out_msg + 10,
                        ssl->out_msg + 0x4000,(size_t *)&major,(uint32_t *)local_b4);
    if (iVar37 != 0) {
      mbedtls_debug_print_ret(ssl,1,"file1",0xeb4,"mbedtls_ssl_ticket_write",iVar37);
      major = 0;
    }
    ssl->out_msg[4] = (uchar)(local_b4 >> 0x18);
    ssl->out_msg[5] = (uchar)(local_b4 >> 0x10);
    ssl->out_msg[6] = (uchar)(local_b4 >> 8);
    ssl->out_msg[7] = (uchar)local_b4;
    ssl->out_msg[8] = (uchar)((uint)major >> 8);
    ssl->out_msg[9] = (uchar)major;
    ssl->out_msglen = major + 10;
    ssl->handshake->new_session_ticket = 0;
    iVar37 = mbedtls_ssl_write_record(ssl);
    if (iVar37 != 0) {
      pcVar21 = "mbedtls_ssl_write_record";
      iVar12 = 0xeca;
      goto LAB_2306a528;
    }
    pcVar21 = "<= write new session ticket";
    iVar19 = 0xece;
LAB_2306b2ac:
    mbedtls_debug_print_msg(ssl,2,"file1",iVar19,pcVar21);
    break;
  case 0xd:
    iVar37 = mbedtls_ssl_write_finished(ssl);
    break;
  case 0xe:
    mbedtls_debug_print_msg(ssl,2,"file1",0xf47,"handshake: done");
    iVar37 = 0xf;
LAB_2306b7e2:
    ssl->state = iVar37;
    iVar37 = iVar12;
    break;
  case 0xf:
    mbedtls_ssl_handshake_wrapup(ssl);
    iVar37 = iVar12;
    break;
  default:
    mbedtls_debug_print_msg(ssl,1,"file1",0xf50,"invalid state %d",iVar37);
    goto LAB_2306c080;
  case 0x12:
    iVar37 = -0x6a80;
  }
LAB_2306a4ce:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar37;
  while (pbVar28 = pbVar28 + 2, pbVar28 + -(int)pbVar30 < pbVar32) {
LAB_2306ab72:
    if ((*pbVar28 == 0) && (pbVar28[1] == 0xff)) {
      mbedtls_debug_print_msg(ssl,3,"file1",0x6c4,"received TLS_EMPTY_RENEGOTIATION_INFO ");
      ssl->secure_renegotiation = 1;
      goto LAB_2306aba0;
    }
  }
  if ((ssl->secure_renegotiation == 1) || ((*(ushort *)&ssl->conf->field_0x74 & 0x30) != 0x20)) {
LAB_2306aba0:
    puVar33 = (uint *)ssl->conf->ciphersuite_list[ssl->minor_ver];
    iVar12 = 0;
    while (pbVar28 = pbVar30, *puVar33 != 0) {
      do {
        uVar29 = *puVar33;
        if (((uint)*pbVar28 == ((int)uVar29 >> 8 & 0xffU)) && ((uint)pbVar28[1] == (uVar29 & 0xff)))
        {
          pmVar8 = mbedtls_ssl_ciphersuite_from_id(uVar29);
          if (pmVar8 == (mbedtls_ssl_ciphersuite_t *)0x0) {
            iVar37 = 0x2cc;
            goto LAB_2306b108;
          }
          mbedtls_debug_print_msg(ssl,3,"file1",0x2d0,"trying ciphersuite: %s",pmVar8->name);
          iVar12 = iVar37;
          if ((ssl->minor_ver < pmVar8->min_minor_ver) || (pmVar8->max_minor_ver < ssl->minor_ver))
          {
            pcVar21 = "ciphersuite mismatch: version";
            iVar19 = 0x2d5;
          }
          else {
            if (((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) && ((pmVar8->flags & 4) != 0))
            goto LAB_2306b15a;
            mVar11 = mbedtls_ssl_get_ciphersuite_sig_pk_alg(pmVar8);
            pmVar45 = ssl->handshake->sni_key_cert;
            if (pmVar45 == (mbedtls_ssl_key_cert *)0x0) {
              pmVar45 = ssl->conf->key_cert;
            }
            if (CONCAT31(extraout_var_00,mVar11) == 0) {
have_ciphersuite:
              mbedtls_debug_print_msg(ssl,2,"file1",0x72e,"selected ciphersuite: %s",pmVar8->name);
              ssl->session_negotiate->ciphersuite = *puVar33;
              ssl->transform_negotiate->ciphersuite_info = pmVar8;
              ssl->state = ssl->state + 1;
              if ((*(ushort *)&ssl->conf->field_0x74 & 2) != 0) {
                mbedtls_ssl_recv_flight_completed(ssl);
              }
              pcVar21 = "<= parse client hello";
              iVar19 = 0x73a;
              iVar37 = iVar13;
              goto LAB_2306b2ac;
            }
            mbedtls_debug_print_msg(ssl,3,"file1",0x26f,"ciphersuite requires certificate");
            pmVar40 = (mbedtls_ssl_key_cert *)0x0;
            if (pmVar45 == (mbedtls_ssl_key_cert *)0x0) {
              mbedtls_debug_print_msg(ssl,3,"file1",0x273,"server has no certificate");
            }
            else {
              do {
                mbedtls_debug_print_crt
                          (ssl,3,"file1",0x27a,"candidate certificate chain, certificate",
                           pmVar45->cert);
                iVar19 = mbedtls_pk_can_do(pmVar45->key,mVar11);
                if (iVar19 == 0) {
                  pcVar21 = "certificate mismatch: key type";
                  iVar19 = 0x27e;
                }
                else {
                  iVar19 = mbedtls_ssl_check_cert_usage(pmVar45->cert,pmVar8,1,(uint32_t *)local_b4)
                  ;
                  if (iVar19 == 0) {
                    if ((2 < ssl->minor_ver) || (pmVar45->cert->sig_md == MBEDTLS_MD_SHA1))
                    goto LAB_2306b22e;
                    if (pmVar40 == (mbedtls_ssl_key_cert *)0x0) {
                      pmVar40 = pmVar45;
                    }
                    pcVar21 = "certificate not preferred: sha-2 with pre-TLS 1.2 client";
                    iVar19 = 0x2a7;
                  }
                  else {
                    pcVar21 = "certificate mismatch: (extended) key usage extension";
                    iVar19 = 0x28e;
                  }
                }
                mbedtls_debug_print_msg(ssl,3,"file1",iVar19,pcVar21);
                pmVar45 = pmVar45->next;
              } while (pmVar45 != (mbedtls_ssl_key_cert *)0x0);
              pmVar45 = pmVar40;
              if (pmVar40 != (mbedtls_ssl_key_cert *)0x0) {
LAB_2306b22e:
                ssl->handshake->key_cert = pmVar45;
                mbedtls_debug_print_crt
                          (ssl,3,"file1",0x2b8,"selected certificate chain, certificate",
                           ssl->handshake->key_cert->cert);
                goto have_ciphersuite;
              }
            }
            pcVar21 = "ciphersuite mismatch: no suitable certificate";
            iVar19 = 0x316;
          }
          mbedtls_debug_print_msg(ssl,3,"file1",iVar19,pcVar21);
        }
LAB_2306b15a:
        pbVar28 = pbVar28 + 2;
      } while (pbVar28 + -(int)pbVar30 < pbVar32);
      puVar33 = puVar33 + 1;
    }
    if (iVar12 == 0) {
      mbedtls_debug_print_msg(ssl,1,"file1",0x728,"got no ciphersuites in common");
      mbedtls_ssl_send_fatal_handshake_failure(ssl);
      iVar37 = -0x7380;
    }
    else {
      mbedtls_debug_print_msg
                (ssl,1,"file1",0x722,"got ciphersuites in common, but none of them usable");
      mbedtls_ssl_send_fatal_handshake_failure(ssl);
      iVar37 = -0x6980;
    }
    goto LAB_2306a4ce;
  }
  pcVar21 = "legacy renegotiation, breaking off handshake";
  iVar37 = 0x6db;
LAB_2306ae02:
  mbedtls_debug_print_msg(ssl,1,"file1",iVar37,pcVar21);
  iVar37 = mbedtls_ssl_send_fatal_handshake_failure(ssl);
  if (iVar37 != 0) goto LAB_2306a4ce;
LAB_2306a5a2:
  iVar37 = -0x7900;
  goto LAB_2306a4ce;
}



int mbedtls_x509_get_serial(uchar **p,uchar *end,mbedtls_x509_buf *serial)

{
  int iVar1;
  byte *pbVar2;
  uchar *puVar3;
  
  pbVar2 = *p;
  if ((int)(end + -(int)pbVar2) < 1) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return -0x22e0;
  }
  if ((*pbVar2 & 0x7f) == 2) {
    *p = pbVar2 + 1;
    serial->tag = (uint)*pbVar2;
    iVar1 = mbedtls_asn1_get_len(p,end,&serial->len);
    if (iVar1 == 0) {
      puVar3 = *p;
      serial->p = puVar3;
      *p = puVar3 + serial->len;
    }
    else {
      iVar1 = iVar1 + -0x2280;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x22e2;
}



int mbedtls_x509_get_alg(uchar **p,uchar *end,mbedtls_x509_buf *alg,mbedtls_x509_buf *params)

{
  int iVar1;
  
  iVar1 = mbedtls_asn1_get_alg(p,end,(mbedtls_asn1_buf *)alg,(mbedtls_asn1_buf *)params);
  if (iVar1 != 0) {
    iVar1 = iVar1 + -0x2300;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_x509_get_name(uchar **p,uchar *end,mbedtls_x509_name *cur)

{
  mbedtls_x509_name *pmVar1;
  int iVar2;
  mbedtls_asn1_named_data *pmVar3;
  uchar *puVar4;
  byte *pbVar5;
  uchar *end_00;
  size_t sStack56;
  size_t set_len;
  size_t len;
  
LAB_2306c13a:
  iVar2 = mbedtls_asn1_get_tag(p,end,&sStack56,0x31);
  if (iVar2 == 0) {
    end_00 = *p + sStack56;
    pmVar1 = cur;
    do {
      iVar2 = mbedtls_asn1_get_tag(p,end_00,&set_len,0x30);
      if (iVar2 == 0) {
        if ((int)(end_00 + -(int)*p) < 1) {
LAB_2306c1b6:
          iVar2 = -0x23e0;
          goto LAB_2306c152;
        }
        (pmVar1->oid).tag = (uint)**p;
        iVar2 = mbedtls_asn1_get_tag(p,end_00,&(pmVar1->oid).len,6);
        if (iVar2 != 0) goto LAB_2306c186;
        puVar4 = *p;
        (pmVar1->oid).p = puVar4;
        pbVar5 = puVar4 + (pmVar1->oid).len;
        *p = pbVar5;
        if ((int)(end_00 + -(int)pbVar5) < 1) goto LAB_2306c1b6;
        if ((0x1e < *pbVar5) || ((0x50581008U >> (*pbVar5 & 0x1f) & 1) == 0)) {
          iVar2 = -0x23e2;
          goto LAB_2306c152;
        }
        *p = pbVar5 + 1;
        (pmVar1->val).tag = (uint)*pbVar5;
        iVar2 = mbedtls_asn1_get_len(p,end_00,&(pmVar1->val).len);
        if (iVar2 != 0) goto LAB_2306c186;
        puVar4 = *p;
        (pmVar1->val).p = puVar4;
        *p = puVar4 + (pmVar1->val).len;
        pmVar1->next = (mbedtls_asn1_named_data *)0x0;
      }
      else {
LAB_2306c186:
        iVar2 = iVar2 + -0x2380;
        if (iVar2 != 0) goto LAB_2306c152;
      }
      if (*p == end_00) goto LAB_2306c228;
      pmVar1->next_merged = '\x01';
      pmVar3 = (mbedtls_asn1_named_data *)mycalloc(1,0x20);
      pmVar1->next = pmVar3;
      pmVar1 = (mbedtls_x509_name *)pmVar3;
      if (pmVar3 == (mbedtls_asn1_named_data *)0x0) goto LAB_2306c1a4;
    } while( true );
  }
  iVar2 = iVar2 + -0x2380;
  goto LAB_2306c152;
LAB_2306c228:
  if (end == end_00) {
    iVar2 = 0;
    goto LAB_2306c152;
  }
  cur = (mbedtls_x509_name *)mycalloc(1,0x20);
  pmVar1->next = (mbedtls_asn1_named_data *)cur;
  if (cur == (mbedtls_x509_name *)0x0) {
LAB_2306c1a4:
    iVar2 = -0x2880;
LAB_2306c152:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  goto LAB_2306c13a;
}



// WARNING: Variable defined which should be unmapped: len

int mbedtls_x509_get_sig(uchar **p,uchar *end,mbedtls_x509_buf *sig)

{
  byte bVar1;
  int iVar2;
  uchar *puVar3;
  size_t sStack20;
  size_t len;
  
  if (0 < (int)(end + -(int)*p)) {
    bVar1 = **p;
    iVar2 = mbedtls_asn1_get_bitstring_null(p,end,&sStack20);
    if (iVar2 == 0) {
      sig->tag = (uint)bVar1;
      sig->len = sStack20;
      puVar3 = *p;
      sig->p = puVar3;
      *p = puVar3 + sStack20;
    }
    else {
      iVar2 = iVar2 + -0x2480;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar2;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x24e0;
}



int mbedtls_x509_get_sig_alg
              (mbedtls_x509_buf *sig_oid,mbedtls_x509_buf *sig_params,mbedtls_md_type_t *md_alg,
              mbedtls_pk_type_t *pk_alg,void **sig_opts)

{
  int iVar1;
  
  if (*sig_opts == (void *)0x0) {
    iVar1 = mbedtls_oid_get_sig_alg((mbedtls_asn1_buf *)sig_oid,md_alg,pk_alg);
    if (iVar1 == 0) {
      if (((sig_params->tag != 5) && (sig_params->tag != 0)) || (sig_params->len != 0)) {
        iVar1 = -0x2300;
      }
    }
    else {
      iVar1 = iVar1 + -0x2600;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return iVar1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return -0x2800;
}



int mbedtls_x509_get_ext(uchar **p,uchar *end,mbedtls_x509_buf *ext,int tag)

{
  int iVar1;
  uchar *puVar2;
  size_t sStack20;
  size_t len;
  
  if (*p == end) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
  ext->tag = (uint)**p;
  iVar1 = mbedtls_asn1_get_tag(p,end,&ext->len,tag | 0xa0);
  if (iVar1 == 0) {
    puVar2 = *p;
    ext->p = puVar2;
    puVar2 = puVar2 + ext->len;
    iVar1 = mbedtls_asn1_get_tag(p,puVar2,&sStack20,0x30);
    if (iVar1 == 0) {
      iVar1 = 0;
      if (puVar2 != *p + sStack20) {
        iVar1 = -0x2566;
      }
    }
    else {
      iVar1 = iVar1 + -0x2500;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



int mbedtls_x509_dn_gets(char *buf,size_t size,mbedtls_x509_name *dn)

{
  size_t n;
  uint n_00;
  uint uVar1;
  int iVar2;
  char *format;
  byte bVar3;
  uchar uVar4;
  uint uVar5;
  mbedtls_x509_name *oid;
  char *pcStack308;
  char *short_name;
  char s [256];
  
  pcStack308 = (char *)0x0;
  memset(&short_name,0,0x100);
  uVar4 = '\0';
  n = size;
  oid = dn;
  do {
    if (oid == (mbedtls_x509_name *)0x0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return size - n;
    }
    if ((oid->oid).p != (uchar *)0x0) {
      if (oid != dn) {
        format = " + ";
        if (uVar4 == '\0') {
          format = ", ";
        }
        uVar1 = snprintf(buf,n,format);
        if (((int)uVar1 < 0) || (n <= uVar1)) goto LAB_2306c3d6;
        n = n - uVar1;
        buf = buf + uVar1;
      }
      iVar2 = mbedtls_oid_get_attr_short_name((mbedtls_asn1_buf *)oid,&pcStack308);
      if (iVar2 == 0) {
        uVar1 = snprintf(buf,n,"%s=",pcStack308);
      }
      else {
        uVar1 = snprintf(buf,n,"??=");
      }
      if (((int)uVar1 < 0) || (n <= uVar1)) {
LAB_2306c3d6:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return -0x2980;
      }
      n_00 = n - uVar1;
      uVar5 = 0;
      while ((uVar5 < (oid->val).len && (uVar5 != 0xff))) {
        bVar3 = (oid->val).p[uVar5];
        if ((bVar3 < 0x20) || ((bVar3 == 0x7f || ((byte)(bVar3 + 0x7f) < 0x1f)))) {
          bVar3 = 0x3f;
        }
        s[uVar5 - 4] = bVar3;
        uVar5 = uVar5 + 1;
      }
      s[uVar5 - 4] = '\0';
      uVar5 = snprintf(buf + uVar1,n_00,"%s",&short_name);
      if (((int)uVar5 < 0) || (n_00 <= uVar5)) goto LAB_2306c3d6;
      n = n_00 - uVar5;
      buf = buf + uVar1 + uVar5;
      uVar4 = oid->next_merged;
    }
    oid = (mbedtls_x509_name *)oid->next;
  } while( true );
}



int mbedtls_x509_serial_gets(char *buf,size_t size,mbedtls_x509_buf *serial)

{
  size_t n;
  uint uVar1;
  char *pcVar2;
  uint uVar3;
  uint uVar4;
  
  uVar4 = serial->len;
  if (0x20 < uVar4) {
    uVar4 = 0x1c;
  }
  uVar3 = 0;
  n = size;
  while (uVar3 != uVar4) {
    if (((uVar3 != 0) || (uVar4 == 1)) || (*serial->p != '\0')) {
      pcVar2 = ":";
      if (uVar4 - 1 <= uVar3) {
        pcVar2 = "";
      }
      uVar1 = snprintf(buf,n,"%02X%s",(uint)serial->p[uVar3],pcVar2);
      if (((int)uVar1 < 0) || (n <= uVar1)) goto LAB_2306c55e;
      n = n - uVar1;
      buf = buf + uVar1;
    }
    uVar3 = uVar3 + 1;
  }
  if (serial->len != uVar3) {
    uVar4 = snprintf(buf,n,"....");
    if (((int)uVar4 < 0) || (n <= uVar4)) {
LAB_2306c55e:
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return -0x2980;
    }
    n = n - uVar4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return size - n;
}



int mbedtls_x509_sig_alg_gets
              (char *buf,size_t size,mbedtls_x509_buf *sig_oid,mbedtls_pk_type_t pk_alg,
              mbedtls_md_type_t md_alg,void *sig_opts)

{
  int iVar1;
  uint uVar2;
  char *pcStack20;
  char *desc;
  
  pcStack20 = (char *)0x0;
  iVar1 = mbedtls_oid_get_sig_alg_desc((mbedtls_asn1_buf *)sig_oid,&pcStack20);
  if (iVar1 == 0) {
    uVar2 = snprintf(buf,size,"%s",pcStack20);
  }
  else {
    uVar2 = snprintf(buf,size,"???");
  }
  if (((int)uVar2 < 0) || (size <= uVar2)) {
    uVar2 = 0xffffd680;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



int mbedtls_x509_key_size_helper(char *buf,size_t buf_size,char *name)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = snprintf(buf,buf_size,"%s key size",name);
  if (((int)uVar1 < 0) || (buf_size <= uVar1)) {
    iVar2 = -0x2980;
  }
  else {
    iVar2 = 0;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar2;
}



int mbedtls_x509_time_is_past(mbedtls_x509_time *to)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



undefined4 mbedtls_x509_time_is_future(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



int mbedtls_base64_decode(uchar *dst,size_t dlen,size_t *olen,uchar *src,size_t slen)

{
  byte bVar1;
  uint uVar2;
  int iVar3;
  byte *pbVar4;
  uint uVar5;
  uchar *puVar6;
  uint uVar7;
  size_t sVar8;
  uint uVar9;
  int iVar10;
  
  uVar5 = 0;
  uVar7 = 0;
  sVar8 = 0;
  while (sVar8 < slen) {
    iVar3 = 0;
    uVar9 = sVar8;
    while( true ) {
      bVar1 = src[uVar9];
      uVar2 = (uint)bVar1;
      sVar8 = slen;
      if (uVar2 != 0x20) break;
      uVar9 = uVar9 + 1;
      iVar3 = iVar3 + 1;
      if (slen == uVar9) goto LAB_2306c656;
    }
    if (slen == uVar9) break;
    if ((slen - uVar9 < 2) || (uVar2 != 0xd)) {
      if (uVar2 != 10) goto LAB_2306c690;
    }
    else {
      if ((src + uVar9)[1] != 10) {
LAB_2306c690:
        if (iVar3 == 0) {
          if (uVar2 == 0x3d) {
            uVar5 = uVar5 + 1;
            if (uVar5 < 3) {
LAB_2306c6b0:
              if ((
                   "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                   [uVar2] != 0x7f) &&
                 ((0x3f < 
                          "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                          [uVar2] || (uVar5 == 0)))) {
                uVar7 = uVar7 + 1;
                goto LAB_2306c688;
              }
            }
          }
          else {
            if (-1 < (char)bVar1) goto LAB_2306c6b0;
          }
        }
        iVar3 = -0x2c;
        goto LAB_2306c71a;
      }
    }
LAB_2306c688:
    sVar8 = uVar9 + 1;
  }
LAB_2306c656:
  if (uVar7 == 0) {
    *olen = 0;
  }
  else {
    uVar5 = ((uVar7 >> 3) * 6 - uVar5) + ((uVar7 & 7) * 6 + 7 >> 3);
    if ((dst == (uchar *)0x0) || (dlen < uVar5)) {
      *olen = uVar5;
      iVar3 = -0x2a;
      goto LAB_2306c71a;
    }
    pbVar4 = src + sVar8;
    uVar5 = 0;
    iVar10 = 3;
    iVar3 = 0;
    puVar6 = dst;
    while (pbVar4 != src) {
      uVar7 = *src - 10;
      if ((0x16 < (uVar7 & 0xff)) || ((0x400009U >> (uVar7 & 0x1f) & 1) == 0)) {
        uVar7 = uVar5 << 6;
        iVar3 = iVar3 + 1;
        iVar10 = iVar10 - (uint)(
                                 "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                                 [*src] == 0x40);
        uVar5 = 
                "\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f\x7f>\x7f\x7f\x7f?456789:;<=\x7f\x7f\x7f@\x7f\x7f\x7f"
                [*src] & 0x3f | uVar7;
        if ((iVar3 == 4) && (iVar3 = 0, iVar10 != 0)) {
          *puVar6 = (uchar)(uVar7 >> 0x10);
          if (iVar10 == 1) {
            puVar6 = puVar6 + 1;
          }
          else {
            puVar6[1] = (uchar)(uVar7 >> 8);
            if (iVar10 == 2) {
              puVar6 = puVar6 + 2;
            }
            else {
              puVar6[2] = (uchar)uVar5;
              puVar6 = puVar6 + 3;
            }
          }
        }
      }
      src = src + 1;
    }
    *olen = (size_t)(puVar6 + -(int)dst);
  }
  iVar3 = 0;
LAB_2306c71a:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar3;
}



double modf(double __x,double *__iptr)

{
  double *pdVar1;
  double *in_a1;
  double **in_a2;
  uint uVar2;
  uint uVar3;
  double in_fa0;
  double dVar4;
  
  uVar2 = (int)in_a1 >> 0x14 & 0x7ff;
  uVar3 = uVar2 - 0x3ff;
  if ((int)uVar3 < 0x14) {
    if ((int)uVar3 < 0) {
      *in_a2 = (double *)0x0;
      in_a2[1] = (double *)((uint)in_a1 & 0x80000000);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return in_fa0;
    }
    uVar2 = 0xfffff >> (uVar3 & 0x1f);
    if ((uVar2 & (uint)in_a1 | (uint)__iptr) != 0) {
      in_a1 = (double *)(~uVar2 & (uint)in_a1);
      pdVar1 = (double *)0x0;
LAB_2306c840:
      *in_a2 = pdVar1;
      in_a2[1] = in_a1;
      dVar4 = (double)__subdf3();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return dVar4;
    }
  }
  else {
    if (((int)uVar3 < 0x34) &&
       (uVar2 = 0xffffffff >> (uVar2 - 0x413 & 0x1f), (uVar2 & (uint)__iptr) != 0)) {
      pdVar1 = (double *)(~uVar2 & (uint)__iptr);
      goto LAB_2306c840;
    }
  }
  in_a2[1] = in_a1;
  *in_a2 = __iptr;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



DItype __lshrdi3(shift_count_type b)

{
  DItype in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



int __clzsi2(USItype x)

{
  int iVar1;
  
  if (x < 0x10000) {
    iVar1 = (uint)(0xff < x) << 3;
  }
  else {
    iVar1 = 0x10;
    if (0xffffff < x) {
      iVar1 = 0x18;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (0x20 - iVar1) - (uint)""[x >> iVar1];
}



SFtype __floatundisf(void)

{
  USItype in_a0;
  SFtype SVar1;
  uint in_a1;
  
  if ((0x1fffff < in_a1) && ((in_a0 & 0x7ff) != 0)) {
    in_a0 = in_a0 & 0xfffff800 | 0x800;
  }
  __floatunsidf(in_a1);
  __muldf3();
  __floatunsidf(in_a0);
  __adddf3();
  SVar1 = __truncdfsf2();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return SVar1;
}



// WARNING: Type propagation algorithm not settling

DItype __divdi3(void)

{
  DItype in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DItype __moddi3(void)

{
  DItype in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __udivdi3(void)

{
  UDItype in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

UDItype __umoddi3(void)

{
  UDItype in_fa0;
  
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DFtype __adddf3(void)

{
  bool bVar1;
  uint uVar2;
  USItype x;
  uint in_a0;
  uint in_a1;
  uint uVar3;
  uint in_a2;
  uint in_a3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  DFtype in_fa0;
  
  uVar2 = in_a0 * 8;
  uVar8 = in_a1 >> 0x14 & 0x7ff;
  uVar5 = in_a3 >> 0x14 & 0x7ff;
  uVar3 = in_a0 >> 0x1d | (in_a1 & 0xfffff) << 3;
  uVar4 = uVar8 - uVar5;
  uVar6 = in_a2 >> 0x1d | (in_a3 & 0xfffff) << 3;
  uVar7 = in_a2 * 8;
  if (-((int)in_a1 >> 0x1f) == in_a3 >> 0x1f) goto LAB_2306e544;
  if ((int)uVar4 < 1) {
    if (uVar4 != 0) {
      uVar4 = uVar5 - uVar8;
      if (uVar8 == 0) {
        if ((uVar3 | uVar2) == 0) goto LAB_2306e544;
        if (uVar4 - 1 == 0) {
          uVar5 = uVar7 + in_a0 * -8;
          uVar4 = (uVar6 - uVar3) - (uint)(uVar7 < uVar5);
          goto sub3;
        }
        bVar1 = uVar4 == 0x7ff;
        uVar4 = uVar4 - 1;
        if (bVar1) goto LAB_2306e544;
      }
      else {
        if (uVar5 == 0x7ff) goto LAB_2306e544;
        uVar3 = uVar3 | 0x800000;
      }
      if ((int)uVar4 < 0x39) {
        if (0x1f < (int)uVar4) {
          uVar5 = 0;
          if (uVar4 != 0x20) {
            uVar5 = uVar3 << (0x40 - uVar4 & 0x1f);
          }
          uVar5 = uVar3 >> (uVar4 - 0x20 & 0x1f) | (uint)((uVar5 | uVar2) != 0);
          goto LAB_2306e150;
        }
        uVar5 = uVar3 << (0x20 - uVar4 & 0x1f) | uVar2 >> (uVar4 & 0x1f) |
                (uint)(uVar2 << (0x20 - uVar4 & 0x1f) != 0);
        uVar3 = uVar3 >> (uVar4 & 0x1f);
      }
      else {
        uVar5 = (uint)((uVar3 | uVar2) != 0);
LAB_2306e150:
        uVar3 = 0;
      }
      uVar5 = uVar7 - uVar5;
      uVar4 = (uVar6 - uVar3) - (uint)(uVar7 < uVar5);
      goto sub3;
    }
    if ((uVar8 + 1 & 0x7fe) == 0) goto LAB_2306e544;
    uVar5 = uVar2 + in_a2 * -8;
    x = (uVar3 - uVar6) - (uint)(uVar2 < uVar5);
    if ((int)(x * 0x100) < 0) {
      uVar5 = uVar7 + in_a0 * -8;
      x = (uVar6 - uVar3) - (uint)(uVar7 < uVar5);
    }
    else {
      if ((uVar5 | x) == 0) goto LAB_2306e544;
    }
  }
  else {
    if (uVar5 == 0) {
      if ((uVar6 | uVar7) == 0) goto LAB_2306e544;
      if (uVar4 - 1 != 0) {
        bVar1 = uVar4 == 0x7ff;
        uVar4 = uVar4 - 1;
        if (bVar1) goto LAB_2306e544;
        goto sub1;
      }
      uVar5 = uVar2 + in_a2 * -8;
      uVar4 = (uVar3 - uVar6) - (uint)(uVar2 < uVar5);
    }
    else {
      if (uVar8 == 0x7ff) goto LAB_2306e544;
      uVar6 = uVar6 | 0x800000;
sub1:
      if ((int)uVar4 < 0x39) {
        if (0x1f < (int)uVar4) {
          uVar5 = 0;
          if (uVar4 != 0x20) {
            uVar5 = uVar6 << (0x40 - uVar4 & 0x1f);
          }
          uVar5 = uVar6 >> (uVar4 - 0x20 & 0x1f) | (uint)((uVar5 | uVar7) != 0);
          goto LAB_2306e010;
        }
        uVar5 = uVar6 << (0x20 - uVar4 & 0x1f) | uVar7 >> (uVar4 & 0x1f) |
                (uint)(uVar7 << (0x20 - uVar4 & 0x1f) != 0);
        uVar6 = uVar6 >> (uVar4 & 0x1f);
      }
      else {
        uVar5 = (uint)((uVar6 | uVar7) != 0);
LAB_2306e010:
        uVar6 = 0;
      }
      uVar5 = uVar2 - uVar5;
      uVar4 = (uVar3 - uVar6) - (uint)(uVar2 < uVar5);
    }
sub3:
    if (-1 < (int)(uVar4 << 8)) goto LAB_2306e544;
    x = uVar4 & 0x7fffff;
  }
  if (x == 0) {
    __clzsi2(uVar5);
  }
  else {
    __clzsi2(x);
  }
LAB_2306e544:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DFtype __divdf3(void)

{
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  DFtype in_fa0;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar2 = in_a1 & 0xfffff;
  if (uVar1 == 0) {
    if ((uVar2 | in_a0) == 0) {
      iVar3 = 1;
      goto LAB_2306e674;
    }
    if (uVar2 == 0) {
      __clzsi2(in_a0);
    }
    else {
      __clzsi2(uVar2);
    }
LAB_2306e670:
    iVar3 = 0;
LAB_2306e674:
    iVar4 = iVar3;
  }
  else {
    if (uVar1 != 0x7ff) goto LAB_2306e670;
    if ((uVar2 | in_a0) == 0) {
      iVar3 = 2;
      goto LAB_2306e674;
    }
    iVar3 = 3;
    iVar4 = 3;
    if ((int)(uVar2 << 0xc) < 0) goto LAB_2306e674;
  }
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  uVar1 = in_a3 & 0xfffff;
  if (uVar2 == 0) {
    if ((uVar1 | in_a2) == 0) {
      uVar1 = 1;
      goto LAB_2306e744;
    }
    if (uVar1 == 0) {
      __clzsi2(in_a2);
    }
    else {
      __clzsi2(uVar1);
    }
  }
  else {
    if (uVar2 == 0x7ff) {
      if ((uVar1 | in_a2) == 0) {
        uVar1 = 2;
      }
      else {
        if ((int)(uVar1 << 0xc) < 0) {
          uVar1 = 3;
        }
        else {
          uVar1 = 3;
        }
      }
      goto LAB_2306e744;
    }
  }
  uVar1 = 0;
LAB_2306e744:
  switch(iVar4 << 2 | uVar1) {
  case 1:
    break;
  case 2:
  case 4:
  case 6:
    break;
  case 3:
  case 7:
  case 0xb:
    break;
  case 5:
  case 10:
    break;
  case 0xc:
  case 0xd:
  case 0xe:
    break;
  case 0xf:
    break;
  default:
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



__gcc_CMPtype __eqdf2(void)

{
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar2 = in_a1 & 0xfffff;
  uVar3 = in_a3 >> 0x14 & 0x7ff;
  if (uVar1 == 0x7ff) {
    if (((uVar2 | in_a0) != 0) || (uVar3 != 0x7ff)) goto LAB_2306ef64;
LAB_2306eef0:
    if ((in_a3 & 0xfffff | in_a2) != 0) goto LAB_2306ef64;
  }
  else {
    if (uVar3 == 0x7ff) goto LAB_2306eef0;
  }
  if (((uVar1 == uVar3) && (uVar2 == (in_a3 & 0xfffff))) && (in_a2 == in_a0)) {
    if (in_a1 >> 0x1f == in_a3 >> 0x1f) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    if (uVar1 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (uint)((uVar2 | in_a2) != 0);
    }
  }
LAB_2306ef64:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 1;
}



__gcc_CMPtype __gedf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  __gcc_CMPtype _Var2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  _Var2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
code_r0x2306efb0:
      _Var2 = -2;
      goto LAB_2306f000;
    }
    if (uVar4 == 0x7ff) goto LAB_2306efbc;
LAB_2306f048:
    if (uVar4 != 0) goto LAB_2306efe0;
    bVar1 = false;
LAB_2306efd4:
    if ((uVar5 | in_a2) != 0) goto LAB_2306efdc;
    if (bVar1) goto LAB_2306f024;
LAB_2306efe8:
    if (_Var2 == 0) {
      _Var2 = 1;
      goto LAB_2306f000;
    }
  }
  else {
    if (uVar4 == 0x7ff) {
LAB_2306efbc:
      if ((uVar5 | in_a2) != 0) goto code_r0x2306efb0;
    }
    if (uVar6 != 0) goto LAB_2306f048;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306efd4;
LAB_2306efdc:
    if (bVar1) {
      _Var2 = -1;
      if (iVar3 != 0) {
        _Var2 = iVar3;
      }
      goto LAB_2306f000;
    }
LAB_2306efe0:
    if ((_Var2 != iVar3) || (uVar4 < uVar6)) goto LAB_2306efe8;
    if (uVar4 <= uVar6) {
      if (uVar7 <= uVar5) {
        if (uVar7 == uVar5) {
          if (in_a2 < in_a0) goto LAB_2306efe8;
          if (in_a0 < in_a2) goto LAB_2306f00c;
        }
        else {
          if (uVar7 < uVar5) goto LAB_2306f00c;
        }
LAB_2306f024:
        _Var2 = 0;
        goto LAB_2306f000;
      }
      goto LAB_2306efe8;
    }
LAB_2306f00c:
    if (_Var2 != 0) goto LAB_2306f000;
  }
  _Var2 = -1;
LAB_2306f000:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



__gcc_CMPtype __ledf2(void)

{
  bool bVar1;
  uint in_a0;
  uint in_a1;
  __gcc_CMPtype _Var2;
  uint in_a2;
  uint in_a3;
  int iVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  uVar6 = in_a1 >> 0x14 & 0x7ff;
  uVar7 = in_a1 & 0xfffff;
  uVar5 = in_a3 & 0xfffff;
  _Var2 = -((int)in_a1 >> 0x1f);
  uVar4 = in_a3 >> 0x14 & 0x7ff;
  iVar3 = -((int)in_a3 >> 0x1f);
  if (uVar6 == 0x7ff) {
    if ((uVar7 | in_a0) != 0) {
code_r0x2306f09c:
      _Var2 = 2;
      goto LAB_2306f0ec;
    }
    if (uVar4 == 0x7ff) goto LAB_2306f0a8;
LAB_2306f134:
    if (uVar4 != 0) goto LAB_2306f0cc;
    bVar1 = false;
LAB_2306f0c0:
    if ((uVar5 | in_a2) != 0) goto LAB_2306f0c8;
    if (bVar1) goto LAB_2306f110;
LAB_2306f0d4:
    if (_Var2 == 0) {
      _Var2 = 1;
      goto LAB_2306f0ec;
    }
  }
  else {
    if (uVar4 == 0x7ff) {
LAB_2306f0a8:
      if ((uVar5 | in_a2) != 0) goto code_r0x2306f09c;
    }
    if (uVar6 != 0) goto LAB_2306f134;
    bVar1 = (uVar7 | in_a0) == 0;
    if (uVar4 == 0) goto LAB_2306f0c0;
LAB_2306f0c8:
    if (bVar1) {
      _Var2 = -1;
      if (iVar3 != 0) {
        _Var2 = iVar3;
      }
      goto LAB_2306f0ec;
    }
LAB_2306f0cc:
    if ((_Var2 != iVar3) || (uVar4 < uVar6)) goto LAB_2306f0d4;
    if (uVar4 <= uVar6) {
      if (uVar7 <= uVar5) {
        if (uVar7 == uVar5) {
          if (in_a2 < in_a0) goto LAB_2306f0d4;
          if (in_a0 < in_a2) goto LAB_2306f0f8;
        }
        else {
          if (uVar7 < uVar5) goto LAB_2306f0f8;
        }
LAB_2306f110:
        _Var2 = 0;
        goto LAB_2306f0ec;
      }
      goto LAB_2306f0d4;
    }
LAB_2306f0f8:
    if (_Var2 != 0) goto LAB_2306f0ec;
  }
  _Var2 = -1;
LAB_2306f0ec:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _Var2;
}



// WARNING: Type propagation algorithm not settling

DFtype __muldf3(void)

{
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  DFtype in_fa0;
  
  uVar2 = in_a1 >> 0x14 & 0x7ff;
  uVar1 = in_a1 & 0xfffff;
  if (uVar2 == 0) {
    if ((uVar1 | in_a0) == 0) {
      iVar3 = 1;
      goto LAB_2306f1c0;
    }
    if (uVar1 == 0) {
      __clzsi2(in_a0);
    }
    else {
      __clzsi2(uVar1);
    }
LAB_2306f1bc:
    iVar3 = 0;
LAB_2306f1c0:
    iVar4 = iVar3;
  }
  else {
    if (uVar2 != 0x7ff) goto LAB_2306f1bc;
    if ((uVar1 | in_a0) == 0) {
      iVar3 = 2;
      goto LAB_2306f1c0;
    }
    iVar3 = 3;
    iVar4 = 3;
    if ((int)(uVar1 << 0xc) < 0) goto LAB_2306f1c0;
  }
  uVar2 = in_a3 >> 0x14 & 0x7ff;
  uVar1 = in_a3 & 0xfffff;
  if (uVar2 == 0) {
    if ((uVar1 | in_a2) == 0) {
      uVar1 = 1;
      goto LAB_2306f290;
    }
    if (uVar1 == 0) {
      __clzsi2(in_a2);
    }
    else {
      __clzsi2(uVar1);
    }
  }
  else {
    if (uVar2 == 0x7ff) {
      if ((uVar1 | in_a2) == 0) {
        uVar1 = 2;
      }
      else {
        if ((int)(uVar1 << 0xc) < 0) {
          uVar1 = 3;
        }
        else {
          uVar1 = 3;
        }
      }
      goto LAB_2306f290;
    }
  }
  uVar1 = 0;
LAB_2306f290:
  switch(iVar4 << 2 | uVar1) {
  case 3:
  case 7:
  case 0xb:
    break;
  case 6:
  case 9:
    break;
  case 0xc:
  case 0xd:
  case 0xe:
    break;
  case 0xf:
    break;
  default:
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



// WARNING: Type propagation algorithm not settling

DFtype __subdf3(void)

{
  bool bVar1;
  uint uVar2;
  USItype x;
  uint uVar3;
  uint in_a0;
  uint in_a1;
  uint in_a2;
  uint in_a3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  DFtype in_fa0;
  
  uVar6 = in_a2 >> 0x1d | (in_a3 & 0xfffff) << 3;
  uVar7 = in_a3 >> 0x14 & 0x7ff;
  uVar3 = in_a1 >> 0x14 & 0x7ff;
  uVar9 = in_a0 >> 0x1d | (in_a1 & 0xfffff) << 3;
  uVar8 = in_a0 * 8;
  uVar4 = in_a3 >> 0x1f;
  uVar2 = in_a2 * 8;
  if ((uVar7 != 0x7ff) || ((uVar6 | uVar2) == 0)) {
    uVar4 = uVar4 ^ 1;
  }
  uVar5 = uVar3 - uVar7;
  if (uVar4 == -((int)in_a1 >> 0x1f)) goto LAB_23070110;
  if ((int)uVar5 < 1) {
    if (uVar5 != 0) {
      uVar4 = uVar7 - uVar3;
      if (uVar3 == 0) {
        if ((uVar9 | uVar8) == 0) goto LAB_23070110;
        if (uVar4 - 1 == 0) {
          uVar3 = uVar2 + in_a0 * -8;
          uVar2 = (uVar6 - uVar9) - (uint)(uVar2 < uVar3);
          goto sub3;
        }
        bVar1 = uVar4 == 0x7ff;
        uVar4 = uVar4 - 1;
        if (bVar1) goto LAB_23070110;
      }
      else {
        if (uVar7 == 0x7ff) goto LAB_23070110;
        uVar9 = uVar9 | 0x800000;
      }
      if ((int)uVar4 < 0x39) {
        if (0x1f < (int)uVar4) {
          uVar3 = 0;
          if (uVar4 != 0x20) {
            uVar3 = uVar9 << (0x40 - uVar4 & 0x1f);
          }
          uVar3 = uVar9 >> (uVar4 - 0x20 & 0x1f) | (uint)((uVar3 | uVar8) != 0);
          goto LAB_2306ffa0;
        }
        uVar3 = uVar9 << (0x20 - uVar4 & 0x1f) | uVar8 >> (uVar4 & 0x1f) |
                (uint)(uVar8 << (0x20 - uVar4 & 0x1f) != 0);
        uVar9 = uVar9 >> (uVar4 & 0x1f);
      }
      else {
        uVar3 = (uint)((uVar9 | uVar8) != 0);
LAB_2306ffa0:
        uVar9 = 0;
      }
      uVar3 = uVar2 - uVar3;
      uVar2 = (uVar6 - uVar9) - (uint)(uVar2 < uVar3);
      goto sub3;
    }
    if ((uVar3 + 1 & 0x7fe) == 0) goto LAB_23070110;
    uVar3 = uVar8 + in_a2 * -8;
    x = (uVar9 - uVar6) - (uint)(uVar8 < uVar3);
    if ((int)(x * 0x100) < 0) {
      uVar3 = uVar2 + in_a0 * -8;
      x = (uVar6 - uVar9) - (uint)(uVar2 < uVar3);
    }
    else {
      if ((uVar3 | x) == 0) goto LAB_23070110;
    }
  }
  else {
    if (uVar7 == 0) {
      if ((uVar6 | uVar2) == 0) goto LAB_23070110;
      if (uVar5 - 1 != 0) {
        bVar1 = uVar5 == 0x7ff;
        uVar5 = uVar5 - 1;
        if (bVar1) goto LAB_23070110;
        goto sub1;
      }
      uVar3 = uVar8 + in_a2 * -8;
      uVar2 = (uVar9 - uVar6) - (uint)(uVar8 < uVar3);
    }
    else {
      if (uVar3 == 0x7ff) goto LAB_23070110;
      uVar6 = uVar6 | 0x800000;
sub1:
      if ((int)uVar5 < 0x39) {
        if (0x1f < (int)uVar5) {
          uVar3 = 0;
          if (uVar5 != 0x20) {
            uVar3 = uVar6 << (0x40 - uVar5 & 0x1f);
          }
          uVar3 = uVar6 >> (uVar5 - 0x20 & 0x1f) | (uint)((uVar3 | uVar2) != 0);
          goto LAB_2306fe5c;
        }
        uVar3 = uVar6 << (0x20 - uVar5 & 0x1f) | uVar2 >> (uVar5 & 0x1f) |
                (uint)(uVar2 << (0x20 - uVar5 & 0x1f) != 0);
        uVar6 = uVar6 >> (uVar5 & 0x1f);
      }
      else {
        uVar3 = (uint)((uVar6 | uVar2) != 0);
LAB_2306fe5c:
        uVar6 = 0;
      }
      uVar3 = uVar8 - uVar3;
      uVar2 = (uVar9 - uVar6) - (uint)(uVar8 < uVar3);
    }
sub3:
    if (-1 < (int)(uVar2 << 8)) goto LAB_23070110;
    x = uVar2 & 0x7fffff;
  }
  if (x == 0) {
    __clzsi2(uVar3);
  }
  else {
    __clzsi2(x);
  }
LAB_23070110:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



SItype __fixdfsi(void)

{
  uint in_a0;
  uint in_a1;
  uint uVar1;
  uint uVar2;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  if (uVar1 < 0x3ff) {
    if ((uVar1 != 0) || (uVar2 = in_a1 & 0xfffff | in_a0, uVar2 != 0)) {
      uVar2 = 0;
    }
  }
  else {
    if (uVar1 < 0x41e) {
      uVar2 = in_a1 & 0xfffff | 0x100000;
      if ((int)(0x433 - uVar1) < 0x20) {
        uVar2 = uVar2 << (uVar1 - 0x413 & 0x1f) | in_a0 >> (0x433 - uVar1 & 0x1f);
      }
      else {
        uVar2 = uVar2 >> (0x413 - uVar1 & 0x1f);
      }
      if (-((int)in_a1 >> 0x1f) != 0) {
        uVar2 = -uVar2;
      }
    }
    else {
      uVar2 = -((int)in_a1 >> 0x1f) + 0x7fffffff;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



USItype __fixunsdfsi(void)

{
  uint in_a0;
  USItype UVar1;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar3 = in_a1 >> 0x14 & 0x7ff;
  if (uVar3 < 0x3ff) {
    if ((uVar3 == 0) && ((in_a1 & 0xfffff | in_a0) == 0)) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return 0;
    }
    UVar1 = 0;
  }
  else {
    if ((int)in_a1 < 0) {
      UVar1 = 0;
    }
    else {
      if (uVar3 < 0x41f) {
        uVar5 = in_a1 & 0xfffff | 0x100000;
        uVar2 = 0x433 - uVar3;
        if ((int)uVar2 < 0x20) {
          uVar4 = in_a0 << (uVar3 - 0x413 & 0x1f);
          UVar1 = uVar5 << (uVar3 - 0x413 & 0x1f) | in_a0 >> (uVar2 & 0x1f);
        }
        else {
          uVar4 = 0;
          if (uVar2 != 0x20) {
            uVar4 = uVar5 << (uVar3 - 0x3f3 & 0x1f);
          }
          uVar4 = uVar4 | in_a0;
          UVar1 = uVar5 >> (0x413 - uVar3 & 0x1f);
        }
        if (uVar4 == 0) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return UVar1;
        }
      }
      else {
        UVar1 = 0xffffffff;
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return UVar1;
}



DFtype __floatsidf(SItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2((i >> 0x1f ^ i) - (i >> 0x1f));
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



DFtype __floatunsidf(USItype i)

{
  DFtype in_fa0;
  
  if (i != 0) {
    __clzsi2(i);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_fa0;
}



DFtype __extendsfdf2(SFtype a)

{
  uint uVar1;
  uint in_a5;
  undefined4 in_fa0;
  undefined4 in_register_00003054;
  
  uVar1 = in_a5 >> 0x17 & 0xff;
  if ((((uVar1 + 1 & 0xfe) == 0) && (uVar1 == 0)) && ((in_a5 & 0x7fffff) != 0)) {
    __clzsi2(in_a5 & 0x7fffff);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (DFtype)CONCAT44(in_register_00003054,in_fa0);
}



SFtype __truncdfsf2(void)

{
  uint uVar1;
  SFtype in_a0;
  uint in_a1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int in_frm;
  
  uVar1 = in_a1 >> 0x14 & 0x7ff;
  uVar3 = (uint)in_a0 >> 0x1d | (in_a1 & 0xfffff) << 3;
  uVar5 = (int)in_a0 << 3;
  if ((uVar1 + 1 & 0x7fe) == 0) {
    uVar3 = uVar3 | uVar5;
    if (uVar1 == 0) {
      uVar1 = (uint)(uVar3 != 0);
LAB_23070968:
      if (uVar1 == 0) goto LAB_230708c4;
LAB_2307096c:
      if (((((uVar1 * 2 & 7) != 0) && (in_frm != 2)) && (in_frm != 3)) && (in_frm == 0)) {
        in_a0 = 5.605194e-45;
      }
    }
    else {
      if (uVar3 == 0) goto LAB_230708c4;
      uVar1 = 0;
    }
LAB_23070a08:
    if ((uVar1 & 7) == 0) goto LAB_230708c4;
  }
  else {
    iVar6 = uVar1 - 0x380;
    if (iVar6 < 0xff) {
      if (iVar6 < 1) {
        if (-0x18 < iVar6) {
          uVar3 = uVar3 | 0x800000;
          uVar2 = 0x1e - iVar6;
          if ((int)uVar2 < 0x20) {
            uVar1 = uVar5 >> (uVar2 & 0x1f) |
                    (uint)(uVar5 << (uVar1 - 0x37e & 0x1f) != 0) | uVar3 << (uVar1 - 0x37e & 0x1f);
          }
          else {
            in_a0 = 4.484155e-44;
            uVar4 = 0;
            if (uVar2 != 0x20) {
              uVar4 = uVar3 << (uVar1 - 0x35e & 0x1f);
            }
            uVar1 = uVar3 >> (-iVar6 - 2U & 0x1f) | (uint)((uVar4 | uVar5) != 0);
          }
          goto LAB_23070968;
        }
        uVar1 = 1;
        goto LAB_2307096c;
      }
      in_a0 = (SFtype)(uint)(((uint)in_a0 & 0x3ffffff) != 0);
      uVar1 = (uint)in_a0 | uVar5 >> 0x1d;
      goto LAB_23070a08;
    }
    if (in_frm == 0) goto LAB_230708c4;
    if (in_frm == 3) {
      if (-1 < (int)in_a1) goto LAB_230708c4;
    }
    else {
      if ((in_frm == 2) && ((int)in_a1 < 0)) goto LAB_230708c4;
    }
  }
  if (((in_frm != 2) && (in_frm != 3)) && (in_frm == 0)) {
    in_a0 = 5.605194e-45;
  }
LAB_230708c4:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return in_a0;
}



int atoi(char *__nptr)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,(char **)0x0,10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return lVar1;
}



void _atoi_r(undefined4 *param_1,byte *param_2)

{
  _strtol_r(param_1,param_2,(byte **)0x0,10);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



undefined * __errno(void)

{
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return _impure_ptr;
}



void * memchr(void *__s,int __c,size_t __n)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar5 = __c & 0xff;
  if (((uint)__s & 3) == 0) {
LAB_23070b58:
    if (3 < __n) {
      uVar2 = (__c & 0xffU) << 8 | __c & 0xffU;
      do {
                    // WARNING: Load size is inaccurate
        uVar3 = (uVar2 << 0x10 | uVar2) ^ *__s;
        if ((uVar3 + 0xfefefeff & ~uVar3 & 0x80808080) != 0) goto LAB_23070b64;
        __n = __n - 4;
        __s = (void *)((int)__s + 4);
      } while (3 < __n);
    }
    if (__n != 0) {
LAB_23070b64:
                    // WARNING: Load size is inaccurate
      if (*__s != uVar5) {
        puVar4 = (uint *)((int)__s + __n);
        do {
          __s = (void *)((int)__s + 1);
          if (puVar4 == (uint *)__s) goto LAB_23070b84;
                    // WARNING: Load size is inaccurate
        } while (*__s != uVar5);
      }
      goto LAB_23070b88;
    }
  }
  else {
    if (__n != 0) {
                    // WARNING: Load size is inaccurate
      bVar1 = *__s;
      __n = __n - 1;
      while (bVar1 != uVar5) {
        __s = (void *)((int)__s + 1);
        if (((uint)__s & 3) == 0) goto LAB_23070b58;
        __n = __n - 1;
        if (__n == 0xffffffff) goto LAB_23070b84;
                    // WARNING: Load size is inaccurate
        bVar1 = *__s;
      }
      goto LAB_23070b88;
    }
  }
LAB_23070b84:
  __s = (uint *)0x0;
LAB_23070b88:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



int memcmp(void *__s1,void *__s2,size_t __n)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  
  if (3 < __n) {
    if ((((uint)__s1 | (uint)__s2) & 3) != 0) goto LAB_23070c30;
    do {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
      if (*__s1 != *__s2) goto LAB_23070c30;
      __n = __n - 4;
      __s1 = (void *)((int)__s1 + 4);
      __s2 = (void *)((int)__s2 + 4);
    } while (3 < __n);
  }
  if (__n == 0) {
LAB_23070c64:
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return 0;
  }
LAB_23070c30:
                    // WARNING: Load size is inaccurate
  uVar3 = (uint)*__s1;
                    // WARNING: Load size is inaccurate
  uVar2 = (uint)*__s2;
  if (uVar3 == uVar2) {
    piVar1 = (int *)((int)__s1 + __n);
    do {
      __s1 = (void *)((int)__s1 + 1);
      __s2 = (void *)((int)__s2 + 1);
      if ((int *)__s1 == piVar1) goto LAB_23070c64;
                    // WARNING: Load size is inaccurate
      uVar3 = (uint)*__s1;
                    // WARNING: Load size is inaccurate
      uVar2 = (uint)*__s2;
    } while (uVar3 == uVar2);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar3 - uVar2;
}



void * memcpy(void *__dest,void *__src,size_t __n)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined4 uVar6;
  undefined4 *puVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined4 *puVar10;
  int iVar11;
  undefined4 uVar12;
  undefined4 *puVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  undefined4 uVar16;
  undefined4 uVar17;
  
  puVar13 = (undefined4 *)((int)__dest + __n);
  if (((((uint)__src ^ (uint)__dest) & 3) == 0) && (3 < __n)) {
    uVar8 = (uint)__dest & 3;
    puVar5 = (undefined4 *)__dest;
    while (puVar4 = (undefined4 *)__src, puVar7 = puVar5, uVar8 != 0) {
                    // WARNING: Load size is inaccurate
      puVar7 = (undefined4 *)((int)puVar5 + 1);
      *(undefined *)puVar5 = *__src;
      puVar4 = (undefined4 *)((int)__src + 1);
      if (((uint)puVar7 & 3) == 0) break;
      uVar8 = (uint)(undefined4 *)((int)puVar5 + 2) & 3;
      *(undefined *)((int)puVar5 + 1) = *(undefined *)puVar4;
      __src = (void *)((int)__src + 2);
      puVar5 = (undefined4 *)((int)puVar5 + 2);
    }
    puVar5 = (undefined4 *)((uint)puVar13 & 0xfffffffc);
    __src = puVar4;
    while (puVar7 < puVar5 + -8) {
                    // WARNING: Load size is inaccurate
      uVar2 = *(undefined4 *)((int)__src + 4);
      uVar17 = *(undefined4 *)((int)__src + 8);
      uVar16 = *(undefined4 *)((int)__src + 0xc);
      uVar15 = *(undefined4 *)((int)__src + 0x10);
      uVar14 = *(undefined4 *)((int)__src + 0x14);
      uVar3 = *(undefined4 *)((int)__src + 0x18);
      uVar12 = *(undefined4 *)((int)__src + 0x1c);
      *puVar7 = *__src;
      uVar6 = *(undefined4 *)((int)__src + 0x20);
      puVar7[1] = uVar2;
      puVar7[2] = uVar17;
      puVar7[3] = uVar16;
      puVar7[4] = uVar15;
      puVar7[5] = uVar14;
      puVar7[6] = uVar3;
      puVar7[7] = uVar12;
      puVar7[8] = uVar6;
      __src = (undefined4 *)((int)__src + 0x24);
      puVar7 = puVar7 + 9;
    }
    puVar4 = (undefined4 *)__src;
    puVar9 = puVar7;
    if (puVar7 < puVar5) {
      do {
        puVar10 = puVar9 + 1;
        *puVar9 = *puVar4;
        puVar4 = puVar4 + 1;
        puVar9 = puVar10;
      } while (puVar10 < puVar5);
      iVar11 = ((int)puVar5 + (-1 - (int)puVar7) & 0xfffffffcU) + 4;
      puVar7 = (undefined4 *)((int)puVar7 + iVar11);
      __src = (void *)((int)__src + iVar11);
    }
    if (puVar7 < puVar13) {
LAB_23070cf4:
      do {
                    // WARNING: Load size is inaccurate
        uVar1 = *__src;
        puVar5 = (undefined4 *)((int)puVar7 + 1);
        __src = (void *)((int)__src + 1);
        *(undefined *)puVar7 = uVar1;
        puVar7 = puVar5;
      } while (puVar5 < puVar13);
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __dest;
    }
  }
  else {
    puVar7 = (undefined4 *)__dest;
    if (__dest < puVar13) goto LAB_23070cf4;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __dest;
}



void * memmove(void *__dest,void *__src,size_t __n)

{
  int iVar1;
  undefined *puVar2;
  undefined4 *puVar3;
  undefined *puVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  uint uVar8;
  undefined4 *puVar4;
  
  if ((__src < __dest) && (puVar5 = (undefined *)((int)__src + __n), __dest < puVar5)) {
    puVar2 = (undefined *)((int)__dest + __n);
    if (__n == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __dest;
    }
    do {
      puVar5 = puVar5 + -1;
      puVar2 = puVar2 + -1;
      *puVar2 = *puVar5;
    } while ((undefined *)__src != puVar5);
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return __dest;
  }
  uVar8 = __n;
  puVar6 = (undefined4 *)__dest;
  if (0xf < __n) {
    if ((((uint)__src | (uint)__dest) & 3) != 0) {
      iVar1 = __n - 1;
      goto LAB_23070dd8;
    }
    iVar1 = (__n - 0x10 & 0xfffffff0) + 0x10;
    puVar3 = (undefined4 *)__src;
    puVar7 = (undefined4 *)__dest;
    do {
      puVar6 = puVar7 + 4;
      *puVar7 = *puVar3;
      puVar7[1] = puVar3[1];
      puVar7[2] = puVar3[2];
      puVar7[3] = puVar3[3];
      puVar3 = puVar3 + 4;
      puVar7 = puVar6;
    } while ((undefined4 *)((int)__dest + iVar1) != puVar6);
    __src = (void *)((int)__src + iVar1);
    uVar8 = __n & 0xf;
    puVar3 = (undefined4 *)__src;
    if ((__n & 0xc) != 0) {
      do {
        puVar4 = puVar3 + 1;
        *puVar7 = *puVar3;
        puVar3 = puVar4;
        puVar7 = puVar7 + 1;
      } while (3 < (int)__src + (uVar8 - (int)puVar4));
      iVar1 = (uVar8 - 4 & 0xfffffffc) + 4;
      __src = (void *)((int)__src + iVar1);
      uVar8 = __n & 3;
      puVar6 = (undefined4 *)((int)puVar6 + iVar1);
    }
  }
  iVar1 = uVar8 - 1;
  if (uVar8 == 0) {
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return __dest;
  }
LAB_23070dd8:
  puVar3 = puVar6;
  do {
                    // WARNING: Load size is inaccurate
    puVar7 = (undefined4 *)((int)puVar3 + 1);
    *(undefined *)puVar3 = *__src;
    __src = (undefined4 *)((int)__src + 1);
    puVar3 = puVar7;
  } while (puVar7 != (undefined4 *)((int)puVar6 + iVar1 + 1));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __dest;
}



void * memset(void *__s,int __c,size_t __n)

{
  uint uVar1;
  void *pvVar2;
  uint extraout_a1;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  
  uVar1 = 0xf;
  if (0xf < __n) {
    uVar5 = (uint)__s & 0xf;
    puVar4 = (uint *)__s;
    if (uVar5 != 0) {
      pvVar2 = __s;
      __s = (void *)(*(code *)(uVar5 * 4 + 0x23070f0c))();
      puVar4 = (uint *)((int)pvVar2 - (uVar5 - 0x10));
      __n = __n + (uVar5 - 0x10);
      __c = extraout_a1;
      if (__n <= uVar1) goto LAB_23070efc;
    }
    if (__c != 0) {
      uVar5 = __c & 0xffU | (__c & 0xffU) << 8;
      __c = uVar5 | uVar5 << 0x10;
    }
    uVar5 = __n & 0xfffffff0;
    __n = __n & 0xf;
    puVar3 = (uint *)(uVar5 + (int)puVar4);
    do {
      *puVar4 = __c;
      puVar4[1] = __c;
      puVar4[2] = __c;
      puVar4[3] = __c;
      puVar4 = puVar4 + 4;
    } while (puVar4 < puVar3);
    if (__n == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __s;
    }
  }
LAB_23070efc:
                    // WARNING: Could not recover jumptable at 0x23070f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar2 = (void *)(*(code *)(&UNK_23070f10 + (uVar1 - __n) * 4))();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar2;
}



char * strchr(char *__s,int __c)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  
  uVar3 = __c & 0xff;
  if (uVar3 == 0) {
    if (((uint)__s & 3) == 0) {
LAB_23071098:
      uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
      while ((uVar3 & 0x80808080) == 0) {
        __s = (char *)((int)__s + 4);
        uVar3 = *(uint *)__s + 0xfefefeff & ~*(uint *)__s;
      }
      if (*__s != 0) {
        do {
          __s = (char *)((int)__s + 1);
        } while (*__s != 0);
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return __s;
      }
    }
    else {
      if (*__s == '\0') {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return __s;
      }
      do {
        __s = (char *)((int)__s + 1);
        if (((uint)__s & 3) == 0) goto LAB_23071098;
      } while (*__s != 0);
    }
  }
  else {
    if (((uint)__s & 3) == 0) {
LAB_23070fcc:
      uVar1 = __c & 0xffU | (__c & 0xffU) << 8;
      uVar4 = *(uint *)__s;
      uVar1 = uVar1 << 0x10 | uVar1;
      uVar2 = uVar1 ^ uVar4;
      uVar2 = ~uVar4 & uVar4 + 0xfefefeff | ~uVar2 & uVar2 + 0xfefefeff;
      while ((uVar2 & 0x80808080) == 0) {
        __s = (char *)((int)__s + 4);
        uVar4 = *(uint *)__s;
        uVar2 = uVar4 ^ uVar1;
        uVar2 = uVar4 + 0xfefefeff & ~uVar4 | uVar2 + 0xfefefeff & ~uVar2;
      }
      if ((byte)*__s != 0) {
        if (uVar3 == (byte)*__s) goto LAB_23071070;
        while( true ) {
          __s = (char *)((int)__s + 1);
          if ((byte)*__s == 0) break;
          if ((byte)*__s == uVar3) {
            gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
            return __s;
          }
        }
      }
    }
    else {
      if ((byte)*__s != 0) {
        if (uVar3 == (byte)*__s) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return __s;
        }
        do {
          __s = (char *)((int)__s + 1);
          if (((uint)__s & 3) == 0) goto LAB_23070fcc;
          if ((byte)*__s == 0) goto LAB_2307106c;
        } while ((byte)*__s != uVar3);
        goto LAB_23071070;
      }
    }
LAB_2307106c:
    __s = (char *)0x0;
  }
LAB_23071070:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __s;
}



int strcmp(char *__s1,char *__s2)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  
  if ((((uint)__s1 | (uint)__s2) & 3) == 0) {
    do {
      uVar2 = *(uint *)__s1;
      uVar3 = *(uint *)__s2;
      if (((uVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar2 | 0x7f7f7f7f) != 0xffffffff) {
LAB_23071234:
        if (uVar2 == uVar3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar2 != uVar3) break;
      uVar2 = *(uint *)((int)__s1 + 4);
      uVar3 = *(uint *)((int)__s2 + 4);
      if (((uVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar2 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 4);
        __s2 = (char *)((int)__s2 + 4);
        goto LAB_23071234;
      }
      if (uVar2 != uVar3) break;
      uVar2 = *(uint *)((int)__s1 + 8);
      uVar3 = *(uint *)((int)__s2 + 8);
      if (((uVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar2 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 8);
        __s2 = (char *)((int)__s2 + 8);
        if (uVar2 == uVar3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar2 != uVar3) break;
      uVar2 = *(uint *)((int)__s1 + 0xc);
      uVar3 = *(uint *)((int)__s2 + 0xc);
      if (((uVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar2 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 0xc);
        __s2 = (char *)((int)__s2 + 0xc);
        if (uVar2 == uVar3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        goto LAB_2307120c;
      }
      if (uVar2 != uVar3) break;
      uVar2 = *(uint *)((int)__s1 + 0x10);
      uVar3 = *(uint *)((int)__s2 + 0x10);
      if (((uVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar2 | 0x7f7f7f7f) != 0xffffffff) {
        __s1 = (char *)((int)__s1 + 0x10);
        __s2 = (char *)((int)__s2 + 0x10);
        if (uVar2 == uVar3) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return 0;
        }
        goto LAB_2307120c;
      }
      __s1 = (char *)((int)__s1 + 0x14);
      __s2 = (char *)((int)__s2 + 0x14);
    } while (uVar2 == uVar3);
    if (uVar2 << 0x10 == uVar3 << 0x10) {
      uVar2 = uVar2 >> 0x10;
      uVar3 = uVar3 >> 0x10;
      if ((uVar2 - uVar3 & 0xff) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar2 - uVar3;
      }
    }
    else {
      uVar2 = uVar2 & 0xffff;
      uVar3 = uVar3 & 0xffff;
      if ((uVar2 - uVar3 & 0xff) == 0) {
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar2 - uVar3;
      }
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (uVar2 & 0xff) - (uVar3 & 0xff);
  }
LAB_2307120c:
  do {
    uVar2 = (uint)(byte)*__s1;
    bVar1 = *__s2;
    __s1 = (char *)((int)__s1 + 1);
    __s2 = (char *)((int)__s2 + 1);
    if (uVar2 != bVar1) break;
  } while (uVar2 != 0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2 - bVar1;
}



char * strcpy(char *__dest,char *__src)

{
  char cVar1;
  char cVar2;
  char cVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  char *pcVar7;
  
  pcVar7 = __dest;
  if ((((uint)__dest | (uint)__src) & 3) != 0) {
    do {
      cVar1 = *__src;
      __src = __src + 1;
      *pcVar7 = cVar1;
      pcVar7 = pcVar7 + 1;
    } while (cVar1 != '\0');
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return __dest;
  }
  uVar5 = *(uint *)__src;
  uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
  puVar4 = (uint *)__dest;
  while ((uVar6 | 0x7f7f7f7f) == 0xffffffff) {
    __src = (char *)((int)__src + 4);
    *puVar4 = uVar5;
    uVar5 = *(uint *)__src;
    uVar6 = (uVar5 & 0x7f7f7f7f) + 0x7f7f7f7f | uVar5;
    puVar4 = puVar4 + 1;
  }
  cVar1 = *__src;
  cVar2 = *(char *)((int)__src + 1);
  cVar3 = *(char *)((int)__src + 2);
  *(char *)puVar4 = cVar1;
  if (((cVar1 != '\0') && (*(char *)((int)puVar4 + 1) = cVar2, cVar2 != '\0')) &&
     (*(char *)((int)puVar4 + 2) = cVar3, cVar3 != '\0')) {
    *(char *)((int)puVar4 + 3) = '\0';
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return __dest;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __dest;
}



size_t strlen(char *__s)

{
  char cVar1;
  uint *puVar2;
  uint uVar3;
  uint *puVar4;
  
  uVar3 = (uint)__s & 3;
  puVar4 = (uint *)__s;
  while (uVar3 != 0) {
    cVar1 = *(char *)puVar4;
    puVar4 = (uint *)((int)puVar4 + 1);
    uVar3 = (uint)puVar4 & 3;
    if (cVar1 == '\0') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (size_t)((int)puVar4 + (-1 - (int)__s));
    }
  }
  do {
    puVar2 = puVar4;
    puVar4 = puVar2 + 1;
  } while (((*puVar2 & 0x7f7f7f7f) + 0x7f7f7f7f | *puVar2 | 0x7f7f7f7f) == 0xffffffff);
  puVar4 = (uint *)((int)(puVar2 + 1) - (int)__s);
  if (*(char *)puVar2 != '\0') {
    if (*(char *)((int)puVar2 + 1) != '\0') {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return (size_t)((int)puVar4 + ((*(char *)((int)puVar2 + 2) != '\0') - 2));
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return (size_t)((int)puVar4 + -3);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (size_t)(puVar4 + -1);
}



int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  uint *puVar2;
  uint uVar3;
  uint uVar4;
  
  if (__n != 0) {
    if (((((uint)__s1 | (uint)__s2) & 3) == 0) && (3 < __n)) {
      uVar4 = *(uint *)__s1;
      if (uVar4 == *(uint *)__s2) {
        __n = __n - 4;
        if (__n != 0) {
          uVar4 = uVar4 + 0xfefefeff & ~uVar4;
          do {
            if ((uVar4 & 0x80808080) != 0) break;
            __s1 = (char *)((int)__s1 + 4);
            __s2 = (char *)((int)__s2 + 4);
            if (__n < 4) goto LAB_23071444;
            uVar3 = *(uint *)__s1;
            uVar4 = uVar3 + 0xfefefeff & ~uVar3;
            if (uVar3 != *(uint *)__s2) goto LAB_23071494;
            __n = __n - 4;
          } while (__n != 0);
        }
        goto LAB_2307148c;
      }
LAB_23071494:
      uVar3 = (uint)(byte)*__s1;
      uVar4 = (uint)(byte)*__s2;
      iVar1 = __n - 1;
      if (uVar4 != uVar3) goto LAB_23071484;
    }
    else {
LAB_23071444:
      uVar3 = (uint)(byte)*__s1;
      uVar4 = (uint)(byte)*__s2;
      iVar1 = __n - 1;
      if (uVar4 != uVar3) {
LAB_23071484:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return uVar3 - uVar4;
      }
      if (iVar1 == 0) goto LAB_2307148c;
    }
    if (uVar3 != 0) {
      puVar2 = (uint *)((int)__s1 + iVar1);
      do {
        __s1 = (char *)((int)__s1 + 1);
        __s2 = (char *)((int)__s2 + 1);
        uVar3 = (uint)(byte)*__s1;
        uVar4 = (uint)(byte)*__s2;
        if (uVar3 != uVar4) goto LAB_23071484;
      } while ((puVar2 != (uint *)__s1) && (uVar3 != 0));
    }
  }
LAB_2307148c:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return 0;
}



char * strncpy(char *__dest,char *__src,size_t __n)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  char *pcVar5;
  char *pcVar6;
  char *pcVar7;
  int iVar8;
  
  puVar3 = (uint *)__dest;
  if (((((uint)__src | (uint)__dest) & 3) == 0) && (puVar4 = (uint *)__dest, 3 < __n)) {
    do {
      uVar2 = *(uint *)__src;
      if ((uVar2 + 0xfefefeff & ~uVar2 & 0x80808080) != 0) goto LAB_230714c4;
      puVar3 = puVar4 + 1;
      __n = __n - 4;
      *puVar4 = uVar2;
      __src = (char *)((int)__src + 4);
      puVar4 = puVar3;
    } while (3 < __n);
  }
  puVar4 = puVar3;
  if (__n != 0) {
LAB_230714c4:
    cVar1 = *__src;
    *(char *)puVar4 = cVar1;
    pcVar5 = (char *)((int)puVar4 + 1);
    iVar8 = __n - 1;
    if (cVar1 != '\0') {
      pcVar6 = pcVar5;
      do {
        __src = (char *)((int)__src + 1);
        iVar8 = (__n - 1) - (int)pcVar6;
        if (pcVar6 == (char *)((int)puVar4 + __n)) {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return __dest;
        }
        cVar1 = *__src;
        pcVar5 = pcVar6 + 1;
        *pcVar6 = cVar1;
        pcVar6 = pcVar5;
        iVar8 = (int)puVar4 + iVar8;
      } while (cVar1 != '\0');
    }
    pcVar6 = pcVar5;
    if (iVar8 == 0) {
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      return __dest;
    }
    do {
      pcVar7 = pcVar6 + 1;
      *pcVar6 = '\0';
      pcVar6 = pcVar7;
    } while (pcVar7 != pcVar5 + iVar8);
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return __dest;
}



size_t strnlen(char *__string,size_t __maxlen)

{
  char *pcVar1;
  
  if (__maxlen != 0) {
    if (*__string == '\0') {
      __maxlen = 0;
    }
    else {
      pcVar1 = __string;
      while (pcVar1 = pcVar1 + 1, pcVar1 != __string + __maxlen) {
        if (*pcVar1 == '\0') {
          gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
          return (size_t)(pcVar1 + -(int)__string);
        }
      }
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (size_t)(char *)__maxlen;
}



char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  char *pcVar2;
  
  if (__c != 0) {
    pcVar2 = (char *)0x0;
    while (pcVar1 = strchr(__s,__c), pcVar1 != (char *)0x0) {
      __s = pcVar1 + 1;
      pcVar2 = pcVar1;
    }
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return pcVar2;
  }
  pcVar2 = strchr(__s,0);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pcVar2;
}



byte * two_way_long_needle(int param_1,int param_2,byte *param_3,byte *param_4)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  size_t sVar4;
  byte *pbVar5;
  byte *pbVar6;
  byte *pbVar7;
  byte *pbVar8;
  byte *pbVar9;
  byte *pbVar10;
  byte *pbVar11;
  byte **ppbVar12;
  byte *pbVar13;
  byte *pbVar14;
  byte *pbVar15;
  byte *local_440 [256];
  byte *apbStack64 [3];
  
  pbVar15 = (byte *)0x1;
  pbVar6 = (byte *)0x1;
  pbVar7 = (byte *)0x0;
  pbVar14 = (byte *)0xffffffff;
  do {
    pbVar9 = pbVar6 + (int)(param_3 + (int)pbVar14);
    pbVar10 = pbVar6 + (int)pbVar7;
    pbVar5 = pbVar7;
    while( true ) {
      pbVar7 = pbVar10;
      if (param_4 <= pbVar7) {
        pbVar6 = (byte *)0x1;
        pbVar7 = (byte *)0x1;
        pbVar5 = (byte *)0xffffffff;
        pbVar9 = (byte *)0x0;
        goto LAB_230716b8;
      }
      if (*pbVar9 <= param_3[(int)pbVar7]) break;
      pbVar6 = (byte *)0x1;
      pbVar15 = pbVar7 + -(int)pbVar14;
      pbVar9 = (byte *)((int)param_3 + (int)pbVar14 + 1);
      pbVar10 = pbVar7 + 1;
      pbVar5 = pbVar7;
    }
    if (param_3[(int)pbVar7] == *pbVar9) {
      if (pbVar6 == pbVar15) {
        pbVar6 = (byte *)0x1;
      }
      else {
        pbVar6 = pbVar6 + 1;
        pbVar7 = pbVar5;
      }
    }
    else {
      pbVar15 = (byte *)0x1;
      pbVar6 = (byte *)0x1;
      pbVar7 = pbVar5 + 1;
      pbVar14 = pbVar5;
    }
  } while( true );
LAB_230716b8:
  pbVar10 = pbVar7 + (int)(param_3 + (int)pbVar5);
  pbVar8 = pbVar7 + (int)pbVar9;
  pbVar13 = pbVar9;
  while (pbVar9 = pbVar8, pbVar9 < param_4) {
    if (param_3[(int)pbVar9] <= *pbVar10) goto LAB_2307188c;
    pbVar7 = (byte *)0x1;
    pbVar6 = pbVar9 + -(int)pbVar5;
    pbVar10 = (byte *)((int)param_3 + (int)pbVar5 + 1);
    pbVar8 = pbVar9 + 1;
    pbVar13 = pbVar9;
  }
  pbVar7 = pbVar14 + 1;
  if (pbVar14 + 1 <= pbVar5 + 1) {
    pbVar15 = pbVar6;
    pbVar7 = pbVar5 + 1;
  }
  ppbVar12 = local_440;
  do {
    *ppbVar12 = param_4;
    ppbVar12 = ppbVar12 + 1;
  } while (apbStack64 != ppbVar12);
  pbVar14 = param_4 + -1;
  pbVar6 = param_3;
  if (param_4 != (byte *)0x0) {
    do {
      bVar1 = *pbVar6;
      pbVar9 = (byte *)(((int)param_3 + (int)pbVar14) - (int)pbVar6);
      pbVar6 = pbVar6 + 1;
      local_440[bVar1] = pbVar9;
    } while (pbVar6 != param_3 + (int)param_4);
  }
  iVar3 = memcmp(param_3,param_3 + (int)pbVar15,(size_t)pbVar7);
  if (iVar3 != 0) {
    pbVar15 = param_4 + -(int)pbVar7;
    if (param_4 + -(int)pbVar7 < pbVar7) {
      pbVar15 = pbVar7;
    }
    pbVar6 = pbVar7 + -1;
    pbVar9 = (byte *)0x0;
LAB_2307194c:
    pbVar5 = pbVar9 + param_1;
    pbVar10 = local_440[pbVar5[(int)pbVar14]];
    if (pbVar10 == (byte *)0x0) goto LAB_230719b0;
    do {
      pbVar9 = pbVar9 + (int)pbVar10;
      while( true ) {
        if (pbVar9 <= (byte *)(param_2 - (int)param_4)) goto LAB_2307194c;
        sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
        param_2 = param_2 + sVar4;
        if ((byte *)(param_2 - (int)param_4) < pbVar9) goto LAB_230717ec;
        pbVar5 = pbVar9 + param_1;
        pbVar10 = local_440[pbVar5[(int)pbVar14]];
        if (pbVar10 != (byte *)0x0) break;
LAB_230719b0:
        if (pbVar7 < pbVar14) {
          pbVar10 = pbVar7;
          if (pbVar5[(int)pbVar7] == param_3[(int)pbVar7]) {
            do {
              pbVar10 = pbVar10 + 1;
              if (pbVar14 <= pbVar10) goto LAB_230719f0;
            } while (param_3[(int)pbVar10] == pbVar10[(int)(pbVar9 + param_1)]);
          }
          pbVar9 = pbVar10 + (int)(pbVar9 + (1 - (int)pbVar7));
        }
        else {
LAB_230719f0:
          if (pbVar6 == (byte *)0xffffffff) goto LAB_230717f0;
          if (pbVar5[(int)pbVar6] == param_3[(int)pbVar6]) {
            pbVar13 = param_3 + (int)(pbVar7 + -2);
            pbVar10 = pbVar7 + -2 + (int)(pbVar9 + param_1);
            do {
              if (pbVar13 == param_3 + -1) goto LAB_230717f0;
              bVar1 = *pbVar13;
              bVar2 = *pbVar10;
              pbVar13 = pbVar13 + -1;
              pbVar10 = pbVar10 + -1;
            } while (bVar1 == bVar2);
          }
          pbVar9 = pbVar15 + (int)(pbVar9 + 1);
        }
      }
    } while( true );
  }
  pbVar6 = pbVar7 + -1;
  pbVar9 = (byte *)0x0;
  pbVar10 = (byte *)0x0;
  do {
    pbVar5 = pbVar10 + param_1;
    pbVar13 = local_440[pbVar5[(int)pbVar14]];
    if (pbVar13 == (byte *)0x0) {
      pbVar13 = pbVar9;
      if (pbVar9 < pbVar7) {
        pbVar13 = pbVar7;
      }
      if (pbVar13 < pbVar14) {
        pbVar8 = pbVar13 + (int)(pbVar10 + param_1);
        pbVar11 = param_3 + (int)pbVar13;
        do {
          if (*pbVar8 != *pbVar11) {
            pbVar10 = pbVar10 + (1 - (int)pbVar7);
            goto LAB_230717c4;
          }
          pbVar13 = pbVar13 + 1;
          pbVar8 = param_3 + (int)pbVar13;
          pbVar11 = pbVar13 + (int)(pbVar10 + param_1);
        } while (pbVar13 < pbVar14);
      }
      if ((pbVar9 < pbVar7) &&
         (pbVar13 = pbVar6, pbVar6[(int)(pbVar10 + param_1)] == param_3[(int)pbVar6])) {
        do {
          pbVar8 = pbVar13;
          pbVar13 = pbVar8 + -1;
          if (pbVar9 == pbVar8) break;
        } while (param_3[(int)pbVar13] == pbVar13[(int)(pbVar10 + param_1)]);
        if (pbVar8 < pbVar9 + 1) goto LAB_230717f0;
      }
      else {
        if (pbVar7 < pbVar9 + 1) goto LAB_230717f0;
      }
      pbVar10 = pbVar15 + (int)pbVar10;
      pbVar9 = param_4 + -(int)pbVar15;
    }
    else {
      if ((pbVar9 != (byte *)0x0) && (pbVar13 < pbVar15)) {
        pbVar13 = param_4 + -(int)pbVar15;
      }
LAB_230717c4:
      pbVar10 = pbVar13 + (int)pbVar10;
      pbVar9 = (byte *)0x0;
    }
    if ((byte *)(param_2 - (int)param_4) < pbVar10) {
      sVar4 = strnlen((char *)(param_1 + param_2),(uint)param_4 | 0x800);
      param_2 = param_2 + sVar4;
      if ((byte *)(param_2 - (int)param_4) < pbVar10) {
LAB_230717ec:
        pbVar5 = (byte *)0x0;
LAB_230717f0:
        gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
        return pbVar5;
      }
    }
  } while( true );
LAB_2307188c:
  if (param_3[(int)pbVar9] == *pbVar10) {
    if (pbVar7 == pbVar6) {
      pbVar7 = (byte *)0x1;
    }
    else {
      pbVar7 = pbVar7 + 1;
      pbVar9 = pbVar13;
    }
  }
  else {
    pbVar6 = (byte *)0x1;
    pbVar7 = (byte *)0x1;
    pbVar5 = pbVar13;
    pbVar9 = pbVar13 + 1;
  }
  goto LAB_230716b8;
}



char * strstr(char *__haystack,char *__needle)

{
  byte bVar1;
  char cVar2;
  char *pcVar3;
  byte *__n;
  byte *pbVar4;
  int iVar5;
  size_t sVar6;
  uint uVar7;
  uint uVar8;
  char *pcVar9;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  byte abStack96 [68];
  
  uVar7 = (uint)(byte)*__needle;
  if (uVar7 != 0) {
    uVar10 = (uint)(byte)__needle[1];
    if (uVar10 == 0) {
      __haystack = strchr(__haystack,uVar7);
    }
    else {
      uVar8 = (uint)(byte)__needle[2];
      if (uVar8 == 0) {
        uVar8 = (uint)(byte)*__haystack;
        if (uVar8 != 0) {
          bVar1 = __haystack[1];
          pcVar3 = __haystack + 1;
          do {
            pcVar9 = pcVar3;
            uVar8 = (uint)bVar1 | uVar8 << 0x10;
            if (bVar1 == 0) goto LAB_23071c58;
            bVar1 = pcVar9[1];
            pcVar3 = pcVar9 + 1;
          } while ((uVar7 << 0x10 | uVar10) != uVar8);
          __haystack = pcVar9 + -1;
          goto LAB_23071ba8;
        }
      }
      else {
        if ((byte)__needle[3] == 0) {
          if ((byte)*__haystack != 0) {
            uVar11 = (uint)(byte)*__haystack << 8;
            bVar1 = __haystack[1];
            pcVar3 = __haystack + 1;
            do {
              pcVar9 = pcVar3;
              uVar11 = (bVar1 | uVar11) << 8;
              if (bVar1 == 0) goto LAB_23071c58;
              bVar1 = pcVar9[1];
              pcVar3 = pcVar9 + 1;
            } while ((uVar7 << 0x18 | uVar10 << 0x10 | uVar8 << 8) != uVar11);
            __haystack = pcVar9 + -2;
            goto LAB_23071ba8;
          }
        }
        else {
          if (__needle[4] == '\0') {
            uVar11 = (uint)(byte)*__haystack;
            uVar7 = uVar7 << 0x18 | uVar10 << 0x10 | (uint)(byte)__needle[3] | uVar8 << 8;
            if (uVar11 != 0) {
              uVar10 = 0;
              do {
                pcVar3 = __haystack;
                uVar10 = uVar11 | uVar10 << 8;
                uVar11 = (uint)(byte)pcVar3[1];
                if (uVar11 == 0) {
                  if (uVar7 != uVar10) goto LAB_23071c58;
                  break;
                }
                __haystack = pcVar3 + 1;
              } while (uVar7 != uVar10);
              __haystack = pcVar3 + -3;
              goto LAB_23071ba8;
            }
          }
          else {
            __n = (byte *)strlen(__needle);
            pbVar4 = (byte *)strnlen(__haystack,(uint)__n | 0x200);
            if (__n <= pbVar4) {
              if (__n < (byte *)0xff) {
                pbVar4 = (byte *)(__haystack + (int)(pbVar4 + -(int)__n));
                memset(abStack96,(int)(__n + 1),0x40);
                if (__n != (byte *)0x0) {
                  pbVar12 = (byte *)__needle;
                  do {
                    bVar1 = *pbVar12;
                    cVar2 = (char)pbVar12;
                    pbVar12 = pbVar12 + 1;
                    abStack96[bVar1 & 0x3f] = ((char)__needle + (char)__n) - cVar2;
                  } while (__n + (int)__needle != pbVar12);
                }
                do {
                  __haystack = (char *)((byte *)__haystack + -1 +
                                       abStack96[__n[(int)((byte *)__haystack + -1)] & 0x3f]);
                  while (__haystack <= pbVar4) {
                    bVar1 = abStack96[((byte *)__haystack)[(int)__n] & 0x3f];
                    iVar5 = memcmp(__haystack,__needle,(size_t)__n);
                    if (iVar5 == 0) goto LAB_23071ba8;
                    __haystack = (char *)((byte *)__haystack + bVar1);
                  }
                  if (pbVar4[(int)__n] == 0) goto LAB_23071c58;
                  sVar6 = strnlen((char *)(pbVar4 + (int)__n),0x800);
                  pbVar4 = pbVar4 + sVar6;
                } while (__haystack <= pbVar4);
                __haystack = (char *)0x0;
              }
              else {
                __haystack = (char *)two_way_long_needle((int)__haystack,(int)pbVar4,
                                                         (byte *)__needle,__n);
              }
              goto LAB_23071ba8;
            }
          }
        }
      }
LAB_23071c58:
      __haystack = (char *)0x0;
    }
  }
LAB_23071ba8:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (char *)(byte *)__haystack;
}



uint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  bool bVar1;
  uint uVar2;
  byte *pbVar3;
  uint uVar4;
  byte *pbVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  
  pbVar5 = param_2;
  do {
    pbVar3 = pbVar5;
    pbVar5 = pbVar3 + 1;
    uVar6 = (uint)*pbVar3;
  } while ((_ctype_[uVar6 + 1] & 8) != 0);
  if (uVar6 == 0x2d) {
    uVar6 = (uint)*pbVar5;
    bVar1 = true;
    pbVar5 = pbVar3 + 2;
LAB_23071d58:
    if (param_4 != 0) goto LAB_23071d5c;
LAB_23071de0:
    if (uVar6 != 0x30) {
      uVar9 = 10;
      param_4 = 10;
      goto LAB_23071d68;
    }
    if ((*pbVar5 & 0xdf) != 0x58) {
      uVar9 = 8;
      param_4 = 8;
      goto LAB_23071d68;
    }
  }
  else {
    if (uVar6 != 0x2b) {
      bVar1 = false;
      goto LAB_23071d58;
    }
    uVar6 = (uint)*pbVar5;
    bVar1 = false;
    pbVar5 = pbVar3 + 2;
    if (param_4 == 0) goto LAB_23071de0;
LAB_23071d5c:
    uVar9 = param_4;
    if (param_4 != 0x10) goto LAB_23071d68;
    if ((uVar6 != 0x30) || ((*pbVar5 & 0xdf) != 0x58)) {
      uVar9 = 0x10;
      goto LAB_23071d68;
    }
  }
  uVar6 = (uint)pbVar5[1];
  uVar9 = 0x10;
  pbVar5 = pbVar5 + 2;
  param_4 = 0x10;
LAB_23071d68:
  uVar2 = 0x80000000;
  if (!bVar1) {
    uVar2 = 0x7fffffff;
  }
  iVar8 = 0;
  uVar4 = 0;
  do {
    uVar7 = uVar6 - 0x30;
    if (9 < uVar7) {
      if (uVar6 - 0x41 < 0x1a) {
        uVar7 = uVar6 - 0x37;
      }
      else {
        if (0x19 < uVar6 - 0x61) break;
        uVar7 = uVar6 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar7) break;
    if (((iVar8 != -1) && (iVar8 = -1, uVar4 <= uVar2 / uVar9)) &&
       ((uVar2 / uVar9 != uVar4 || ((int)uVar7 <= (int)(uVar2 % uVar9))))) {
      iVar8 = 1;
      uVar4 = uVar7 + uVar9 * uVar4;
    }
    uVar6 = (uint)*pbVar5;
    pbVar5 = pbVar5 + 1;
  } while( true );
  if (iVar8 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) {
      return uVar2;
    }
  }
  else {
    uVar2 = uVar4;
    if (bVar1) {
      uVar2 = -uVar4;
    }
    if (param_3 == (byte **)0x0) {
      return uVar2;
    }
    if (iVar8 == 0) goto LAB_23071e1c;
  }
  param_2 = pbVar5 + -1;
LAB_23071e1c:
  *param_3 = param_2;
  return uVar2;
}



uint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)

{
  bool bVar1;
  uint uVar2;
  byte *pbVar3;
  uint uVar4;
  byte *pbVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  
  pbVar5 = param_2;
  do {
    pbVar3 = pbVar5;
    pbVar5 = pbVar3 + 1;
    uVar6 = (uint)*pbVar3;
  } while ((_ctype_[uVar6 + 1] & 8) != 0);
  if (uVar6 == 0x2d) {
    uVar6 = (uint)*pbVar5;
    bVar1 = true;
    pbVar5 = pbVar3 + 2;
LAB_23071d58:
    if (param_4 != 0) goto LAB_23071d5c;
LAB_23071de0:
    if (uVar6 != 0x30) {
      uVar9 = 10;
      param_4 = 10;
      goto LAB_23071d68;
    }
    if ((*pbVar5 & 0xdf) != 0x58) {
      uVar9 = 8;
      param_4 = 8;
      goto LAB_23071d68;
    }
  }
  else {
    if (uVar6 != 0x2b) {
      bVar1 = false;
      goto LAB_23071d58;
    }
    uVar6 = (uint)*pbVar5;
    bVar1 = false;
    pbVar5 = pbVar3 + 2;
    if (param_4 == 0) goto LAB_23071de0;
LAB_23071d5c:
    uVar9 = param_4;
    if (param_4 != 0x10) goto LAB_23071d68;
    if ((uVar6 != 0x30) || ((*pbVar5 & 0xdf) != 0x58)) {
      uVar9 = 0x10;
      goto LAB_23071d68;
    }
  }
  uVar6 = (uint)pbVar5[1];
  uVar9 = 0x10;
  pbVar5 = pbVar5 + 2;
  param_4 = 0x10;
LAB_23071d68:
  uVar2 = 0x80000000;
  if (!bVar1) {
    uVar2 = 0x7fffffff;
  }
  iVar8 = 0;
  uVar4 = 0;
  do {
    uVar7 = uVar6 - 0x30;
    if (9 < uVar7) {
      if (uVar6 - 0x41 < 0x1a) {
        uVar7 = uVar6 - 0x37;
      }
      else {
        if (0x19 < uVar6 - 0x61) break;
        uVar7 = uVar6 - 0x57;
      }
    }
    if ((int)param_4 <= (int)uVar7) break;
    if (((iVar8 != -1) && (iVar8 = -1, uVar4 <= uVar2 / uVar9)) &&
       ((uVar2 / uVar9 != uVar4 || ((int)uVar7 <= (int)(uVar2 % uVar9))))) {
      iVar8 = 1;
      uVar4 = uVar7 + uVar9 * uVar4;
    }
    uVar6 = (uint)*pbVar5;
    pbVar5 = pbVar5 + 1;
  } while( true );
  if (iVar8 == -1) {
    *param_1 = 0x22;
    if (param_3 == (byte **)0x0) goto LAB_23071e20;
LAB_23071e48:
    param_2 = pbVar5 + -1;
  }
  else {
    uVar2 = uVar4;
    if (bVar1) {
      uVar2 = -uVar4;
    }
    if (param_3 == (byte **)0x0) goto LAB_23071e20;
    if (iVar8 != 0) goto LAB_23071e48;
  }
  *param_3 = param_2;
LAB_23071e20:
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar2;
}



long strtol_l(char *__nptr,char **__endptr,int __base,__locale_t __loc)

{
  uint uVar1;
  
  uVar1 = _strtol_l_isra_0((undefined4 *)_impure_ptr,(byte *)__nptr,(byte **)__endptr,__base);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



long strtol(char *__nptr,char **__endptr,int __base)

{
  uint uVar1;
  
  uVar1 = _strtol_l_isra_0((undefined4 *)_impure_ptr,(byte *)__nptr,(byte **)__endptr,__base);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = _stat_r((int *)_impure_ptr,(int)__file,(undefined2 *)__buf);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



void _stat_r(int *param_1,int param_2,undefined2 *param_3)

{
  int iVar1;
  
  errno = 0;
  iVar1 = _stat(param_2,param_3);
  if ((iVar1 == -1) && (errno != 0)) {
    *param_1 = errno;
    gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
    return;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



int _stat(int param_1,undefined2 *param_2)

{
  int *piVar1;
  undefined4 auStack144 [33];
  
  ecall();
  if (param_1 < 0) {
    piVar1 = (int *)__errno();
    *piVar1 = -param_1;
    param_1 = -1;
  }
  _conv_stat(param_2,auStack144);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return param_1;
}



void _conv_stat(undefined2 *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  
  uVar3 = param_2[5];
  uVar1 = param_2[6];
  uVar15 = param_2[7];
  uVar14 = param_2[8];
  uVar13 = param_2[0xc];
  uVar12 = param_2[0x10];
  uVar2 = param_2[0xe];
  uVar10 = param_2[0x12];
  uVar11 = param_2[0x13];
  uVar6 = param_2[0x16];
  uVar4 = param_2[4];
  uVar5 = param_2[2];
  uVar7 = param_2[0x17];
  uVar8 = param_2[0x1a];
  uVar9 = param_2[0x1b];
  *param_1 = (short)*param_2;
  param_1[1] = (short)uVar5;
  *(undefined4 *)(param_1 + 2) = uVar4;
  param_1[4] = (short)uVar3;
  param_1[5] = (short)uVar1;
  param_1[6] = (short)uVar15;
  param_1[7] = (short)uVar14;
  *(undefined4 *)(param_1 + 8) = uVar13;
  *(undefined4 *)(param_1 + 0x24) = uVar12;
  *(undefined4 *)(param_1 + 0x22) = uVar2;
  *(undefined4 *)(param_1 + 0xc) = uVar10;
  *(undefined4 *)(param_1 + 0xe) = uVar11;
  *(undefined4 *)(param_1 + 0x14) = uVar6;
  *(undefined4 *)(param_1 + 0x16) = uVar7;
  *(undefined4 *)(param_1 + 0x1c) = uVar8;
  *(undefined4 *)(param_1 + 0x1e) = uVar9;
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010828)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_BG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101082c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4b4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010830)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO11_SOC(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4be. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010834)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4c8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010838)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_LDO15_RF(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4d2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101083c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4dc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010840)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_SFReg(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4e6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010844)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Enter_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4f0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010848)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_LowPower_Exit_PDS0(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c4fa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101084c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ASM_Delay_Us(uint32_t core,uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c504. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010850)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_US(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c50e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010854)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void BL602_Delay_MS(uint32_t cnt)

{
                    // WARNING: Could not recover jumptable at 0x4200c518. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010858)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy(void *dst,void *src,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c522. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_2101085c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemCpy4(uint32_t *dst,uint32_t *src,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c52c. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_21010860)();
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemCpy_Fast(void *pdst,void *psrc,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c536. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010864)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void * BL602_MemSet(void *s,uint8_t c,uint32_t n)

{
  void *pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c540. Too many branches
                    // WARNING: Treating indirect jump as call
  pvVar1 = (void *)(*_DAT_21010868)();
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t * BL602_MemSet4(uint32_t *dst,uint32_t val,uint32_t n)

{
  uint32_t *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c54a. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (uint32_t *)(*_DAT_2101086c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return puVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int BL602_MemCmp(void *s1,void *s2,uint32_t n)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c554. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010870)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Sw_AHB_Clk_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c55e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010874)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Program_Efuse_0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c568. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010878)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Load_Efuse_R0(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c572. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101087c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_Busy(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c57c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010880)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type EF_Ctrl_AutoLoad_Done(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c586. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010884)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Clear(uint32_t index,uint32_t len)

{
                    // WARNING: Could not recover jumptable at 0x4200c590. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010894)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_System_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c59a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108bc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_CPU_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5a4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_SW_POR_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ae. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_Internal_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5b8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108c8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Select_External_Flash(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5c2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108cc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Deswap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5cc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Swap_Flash_Pin(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5d6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Init(GLB_GPIO_Cfg_Type *cfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5e0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108d8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Enable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5ea. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108dc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_OUTPUT_Disable(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5f4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_GPIO_Set_HZ(GLB_GPIO_Type gpioPin)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c5fe. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108e4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_GPIO_Get_Fun(GLB_GPIO_Type gpioPin)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c608. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108e8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Mode_Enter(HBN_APP_CFG_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c612. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108ec)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Power_Down_Flash(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c61c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void HBN_Enable(uint8_t aGPIOIeCfg,HBN_LDO_LEVEL_Type ldoLevel,HBN_LEVEL_Type hbnLevel)

{
                    // WARNING: Could not recover jumptable at 0x4200c626. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210108f4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c630. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108f8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Aon_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c63a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108fc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Rt_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c644. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010900)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Ldo11_Soc_Vout(HBN_LDO_LEVEL_Type ldoLevel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c64e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010904)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Hw_Pu_Pd_Cfg(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c658. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010924)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Pin_WakeUp_Mask(uint8_t maskVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c662. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010928)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
HBN_GPIO7_Dbg_Pull_Cfg(BL_Fun_Type pupdEn,BL_Fun_Type iesmtEn,BL_Fun_Type dlyEn,uint8_t dlySec)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c66c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101092c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_Embedded_Flash_Pullup(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c676. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010930)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Wrap(BL_Fun_Type wrap)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c680. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010934)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_Set_Way_Disable(uint8_t disableVal)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c68a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010938)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type L1C_IROM_2T_Access_Set(uint8_t enable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c694. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101093c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Reset(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c69e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010940)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Force_Config(PDS_CTL2_Type *cfg2,PDS_CTL3_Type *cfg3)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6a8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010948)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_RAM_Config(PDS_RAM_CFG_Type *ramCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6b2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101094c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
PDS_Default_Level_Config
          (PDS_DEFAULT_LV_CFG_Type *defaultLvCfg,PDS_RAM_CFG_Type *ramCfg,uint32_t pdsSleepCnt)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6bc. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010950)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_On_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6c6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010978)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SEC_Eng_Turn_Off_Sec_Ring(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c6d0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101097c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Init(SF_Ctrl_Cfg_Type *pSfCtrlCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c6da. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010980)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_SetSPIMode(SF_Ctrl_Mode_Type mode)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6e4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010984)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6ee. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010988)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg(SPI_Flash_Cfg_Type *flashCfg,uint8_t regIndex,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c6f8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101098c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SFlash_Busy(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c702. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010990)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c70c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010994)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Qspi_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c716. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010998)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Volatile_Reg_Write_Enable(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c720. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101099c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Chip_Erase(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c72a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Sector_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t secNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c734. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk32_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c73e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109a8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Blk64_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t blkNum)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c748. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ac)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Erase(SPI_Flash_Cfg_Type *flashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c752. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Program(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint32_t addr,uint8_t *data,
              uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c75c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109b4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetUniqueId(uint8_t *data,uint8_t idLen)

{
                    // WARNING: Could not recover jumptable at 0x4200c766. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109b8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetJedecId(SPI_Flash_Cfg_Type *flashCfg,uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c770. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109bc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_GetDeviceId(uint8_t *data)

{
                    // WARNING: Could not recover jumptable at 0x4200c77a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Powerdown(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c784. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Releae_Powerdown(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c78e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109c8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_SetBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c798. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109cc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_DisableBurstWrap(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7a2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Software_Reset(SPI_Flash_Cfg_Type *flashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109d4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Reset_Continue_Read(SPI_Flash_Cfg_Type *flashCfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c7b6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109d8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Set_IDbus_Cfg
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
          uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7c0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109dc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_IDbus_Read_Enable(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7ca. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Enable_Set(uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7d4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SFlash_Cache_Flush(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7de. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109e8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Cache_Read_Enable
          (SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint8_t wayDisable)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7e8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109ec)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Hit_Count_Get(uint32_t *hitCountLow,uint32_t *hitCountHigh)

{
                    // WARNING: Could not recover jumptable at 0x4200c7f2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f0)();
  gp = (undefined *)0x4200c7f0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SFlash_Cache_Miss_Count_Get(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c7fc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210109f4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SFlash_Cache_Read_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c806. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_210109f8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read(SPI_Flash_Cfg_Type *flashCfg,SF_Ctrl_IO_Type ioMode,uint8_t contRead,uint32_t addr,
           uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c810. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210109fc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Read_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t readRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c81a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a00)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
SFlash_Write_Reg_With_Cmd
          (SPI_Flash_Cfg_Type *flashCfg,uint8_t writeRegCmd,uint8_t *regValue,uint8_t regLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c824. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a04)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c82e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a0c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Internal_Flash_Gpio(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c838. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a10)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Deinit_Ext_Flash_Gpio(uint8_t extFlashPin)

{
                    // WARNING: Could not recover jumptable at 0x4200c842. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a14)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Restore_GPIO17_Fun(uint8_t fun)

{
                    // WARNING: Could not recover jumptable at 0x4200c84c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a18)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type SF_Cfg_Get_Flash_Cfg_Need_Lock(uint32_t flashID,SPI_Flash_Cfg_Type *pFlashCfg)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c856. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a1c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Cfg_Init_Flash_Gpio(uint8_t flashPinCfg,uint8_t restoreDefault)

{
                    // WARNING: Could not recover jumptable at 0x4200c860. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a20)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Cfg_Flash_Identify
                   (uint8_t callFromFlash,uint32_t autoScan,uint32_t flashPinCfg,
                   uint8_t restoreDefault,SPI_Flash_Cfg_Type *pFlashCfg)

{
  undefined3 in_register_00002029;
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c86a. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a24)(CONCAT31(in_register_00002029,callFromFlash));
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Enable(SF_Ctrl_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c874. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a28)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Pad(SF_Ctrl_Pad_Sel sel)

{
                    // WARNING: Could not recover jumptable at 0x4200c87e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a2c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Owner(SF_Ctrl_Owner_Type owner)

{
                    // WARNING: Could not recover jumptable at 0x4200c888. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a30)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c892. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a34)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_BE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c89c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a38)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable_LE(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8a6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a3c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Region
               (uint8_t region,uint8_t enable,uint8_t hwKey,uint32_t startAddr,uint32_t endAddr,
               uint8_t locked)

{
                    // WARNING: Could not recover jumptable at 0x4200c8b0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a40)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ba. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a44)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_Key_BE(uint8_t region,uint8_t *key,SF_Ctrl_AES_Key_Type keyType)

{
                    // WARNING: Could not recover jumptable at 0x4200c8c4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a48)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ce. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a4c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Set_IV_BE(uint8_t region,uint8_t *iv,uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8d8. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a50)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Enable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8e2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a54)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_AES_Disable(void)

{
                    // WARNING: Could not recover jumptable at 0x4200c8ec. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a58)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Flash_Image_Offset(uint32_t addrOffset)

{
                    // WARNING: Could not recover jumptable at 0x4200c8f6. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a5c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t SF_Ctrl_Get_Flash_Image_Offset(void)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c900. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a60)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Select_Clock(SF_Ctrl_Sahb_Type sahbType)

{
                    // WARNING: Could not recover jumptable at 0x4200c90a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a64)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_SendCmd(SF_Ctrl_Cmd_Cfg_Type *cfg)

{
                    // WARNING: Could not recover jumptable at 0x4200c914. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a68)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c91e. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a6c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Icache2_Set(SF_Ctrl_Cmd_Cfg_Type *cfg,uint8_t cmdValid)

{
                    // WARNING: Could not recover jumptable at 0x4200c928. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a70)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Sts_Type SF_Ctrl_GetBusyState(void)

{
  BL_Sts_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c932. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a74)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Is_AES_Enable(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c93c. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a78)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t SF_Ctrl_Get_Clock_Delay(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c946. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010a7c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void SF_Ctrl_Set_Clock_Delay(uint8_t delay)

{
                    // WARNING: Could not recover jumptable at 0x4200c950. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010a80)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Save(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t *offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c95a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a84)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_State_Restore(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t offset)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c964. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a88)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Erase_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t startaddr,uint32_t endaddr)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c96e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a8c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Write_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c978. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a90)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_Read_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c982. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a94)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetJedecId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c98c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a98)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_GetDeviceId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c996. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010a9c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type
XIP_SFlash_GetUniqueId_Need_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint8_t *data,uint8_t idLen)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9a0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type XIP_SFlash_Read_Via_Cache_Need_Lock(uint32_t addr,uint8_t *data,uint32_t len)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9aa. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010aa4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Read_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *dst,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9b4. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aa8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Write_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,uint8_t *src,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9be. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010aac)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int XIP_SFlash_Erase_With_Lock(SPI_Flash_Cfg_Type *pFlashCfg,uint32_t addr,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9c8. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*_DAT_21010ab0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return iVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Enter(uint8_t *aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9d2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void XIP_SFlash_Opt_Exit(uint8_t aesEnable)

{
                    // WARNING: Could not recover jumptable at 0x4200c9dc. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010ab8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint32_t BFLB_Soft_CRC32(void *dataIn,uint32_t len)

{
  uint32_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200c9e6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010abc)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type ADC_Trim_TSEN(uint16_t *tsen_offset)

{
  BL_Err_Type BVar1;
  uint uVar2;
  uint8_t uVar3;
  undefined3 extraout_var;
  SFtype a;
  SFtype a_00;
  SFtype a_01;
  uint16_t uVar4;
  char cVar5;
  Efuse_TSEN_Refcode_Corner_Type EStack52;
  Efuse_TSEN_Refcode_Corner_Type trim;
  
  EF_Ctrl_Read_TSEN_Trim(&EStack52);
  if (((int)EStack52 << 0x12 < 0) &&
     (uVar2 = (uint)EStack52 >> 0xc, uVar3 = EF_Ctrl_Get_Trim_Parity((uint)EStack52 & 0xfff,'\f'),
     (uVar2 & 1) == CONCAT31(extraout_var,uVar3))) {
    *tsen_offset = SUB42(EStack52,0) & 0xfff;
    BVar1 = SUCCESS;
    if (((uint)EStack52 & 0x4000) == 0) {
      _DAT_4000f90c = _DAT_4000f90c & 0xfff7ffff;
      cVar5 = '2';
      do {
        cVar5 = cVar5 + -1;
        TSEN_Get_V_Error();
      } while (cVar5 != '\0');
      _DAT_4000f90c = _DAT_4000f90c | 0x80000;
      BVar1 = 0x32;
      do {
        BVar1 = BVar1 + ~SUCCESS;
        a = (SFtype)TSEN_Get_V_Error();
      } while (BVar1 != SUCCESS);
      __extendsfdf2(a);
      __extendsfdf2(a_00);
      __muldf3();
      __subdf3();
      __extendsfdf2(a_01);
      __muldf3();
      __adddf3();
      uVar4 = 0xe000;
      __adddf3();
      __truncdfsf2();
      *tsen_offset = uVar4;
    }
  }
  else {
    BVar1 = ERROR;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type ADC_Gain_Trim(void)

{
  uint uVar1;
  uint8_t uVar2;
  undefined3 extraout_var;
  undefined8 extraout_fa0;
  Efuse_ADC_Gain_Coeff_Type EStack36;
  Efuse_ADC_Gain_Coeff_Type trim;
  SFtype a;
  
  EF_Ctrl_Read_ADC_Gain_Trim(&EStack36);
  if ((int)EStack36 << 0x12 < 0) {
    uVar1 = (uint)EStack36 >> 0xc;
    uVar2 = EF_Ctrl_Get_Trim_Parity((uint)EStack36 & 0xfff,'\f');
    a = (SFtype)CONCAT31(extraout_var,uVar2);
    if ((SFtype)(uVar1 & 1) == a) {
      adcGainCoeffCal.adcGainCoeffEnable = ENABLE;
      adcGainCoeffCal.adcgainCoeffVal = SUB42(EStack36,0) & 0xfff;
      if (((uint)EStack36 & 0x800) == 0) {
        __extendsfdf2(a);
        __muldf3();
        __subdf3();
      }
      else {
        __extendsfdf2(a);
        __muldf3();
        __adddf3();
      }
      __truncdfsf2();
      gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
      ram0x4200d970 = extraout_fa0;
      return SUCCESS;
    }
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return ERROR;
}



uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  undefined3 in_register_0000202d;
  uint uVar1;
  byte bVar2;
  
  uVar1 = 0;
  bVar2 = 0;
  while ((uVar1 & 0xff) < CONCAT31(in_register_0000202d,len)) {
    if ((1 << (uVar1 & 0x1f) & val) != 0) {
      bVar2 = bVar2 + 1;
    }
    uVar1 = uVar1 + 1;
  }
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return (uint8_t)(bVar2 & 1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type *trim)

{
  uint uVar1;
  uint uVar2;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar1 = _DAT_4000700c;
  uVar2 = _DAT_4000700c >> 10;
  *(char *)trim = (char)uVar2;
  *trim = (Efuse_Ana_RC32M_Trim_Type)
          ((uint)*trim & 0xfffffcff | uVar2 & 0x100 | uVar1 >> 10 & 0x200);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *trim = (Efuse_Ana_RC32K_Trim_Type)
          ((uint)*trim & 0xfffff000 | _DAT_4000700c >> 0x14 & 0x3ff | _DAT_4000700c >> 0x14 & 0x400
          | (_DAT_4000700c >> 0x1f) << 0xb);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_TSEN_Trim(Efuse_TSEN_Refcode_Corner_Type *trim)

{
  uint uVar1;
  Efuse_TSEN_Refcode_Corner_Type EVar2;
  uint uVar3;
  uint uVar4;
  
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  uVar3 = (_DAT_40007078 & 1) << 0xd;
  EVar2 = *trim;
  *trim = (Efuse_TSEN_Refcode_Corner_Type)((uint)EVar2 & 0xffffdfff | uVar3);
  uVar4 = _DAT_4000707c & 0xfff;
  uVar1 = _DAT_4000707c & 0x1000;
  *trim = (Efuse_TSEN_Refcode_Corner_Type)((uint)EVar2 & 0xffffc000 | uVar3 | uVar4 | uVar1);
  *trim = (Efuse_TSEN_Refcode_Corner_Type)
          ((uint)EVar2 & 0xffff8000 | uVar3 | uVar4 | uVar1 | (_DAT_40007070 >> 0x1e & 1) << 0xe);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_ADC_Gain_Trim(Efuse_ADC_Gain_Coeff_Type *trim)

{
  EF_Ctrl_Sw_AHB_Clk_0();
  EF_Ctrl_Load_Efuse_R0();
  *trim = (Efuse_ADC_Gain_Coeff_Type)
          ((uint)*trim & 0xffffc000 | (_DAT_40007078 << 0x13) >> 0x14 |
           (_DAT_40007078 >> 0xd & 1) << 0xc | (_DAT_40007078 >> 0xe & 1) << 0xd);
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd8e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010810)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_MBG(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cd98. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010814)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_On_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cda2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010818)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Set_Xtal_CapCode(uint8_t capIn,uint8_t capOut)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdac. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101081c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t AON_Get_Xtal_CapCode(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdb6. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010820)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type AON_Power_Off_XTAL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdc0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010824)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t EF_Ctrl_Get_Trim_Parity(uint32_t val,uint8_t len)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdca. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_21010888)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32M_Trim(Efuse_Ana_RC32M_Trim_Type *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdd4. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_2101088c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void EF_Ctrl_Read_RC32K_Trim(Efuse_Ana_RC32K_Trim_Type *trim)

{
                    // WARNING: Could not recover jumptable at 0x4200cdde. Too many branches
                    // WARNING: Treating indirect jump as call
  (*_DAT_21010890)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

GLB_ROOT_CLK_Type GLB_Get_Root_CLK_Sel(void)

{
  GLB_ROOT_CLK_Type GVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cde8. Too many branches
                    // WARNING: Treating indirect jump as call
  GVar1 = (*_DAT_21010898)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return GVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK_Div(uint8_t hclkDiv,uint8_t bclkDiv)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdf2. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101089c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_BCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cdfc. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint8_t GLB_Get_HCLK_Div(void)

{
  uint8_t uVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce06. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*_DAT_210108a4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type Update_SystemCoreClockWith_XTAL(GLB_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce10. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108a8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_System_CLK(GLB_PLL_XTAL_Type xtalType,GLB_SYS_CLK_Type clkFreq)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce1a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108ac)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type System_Core_Clock_Update_From_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce24. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b0)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_SF_CLK(uint8_t enable,GLB_SFLASH_CLK_Type clkSel,uint8_t div)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce2e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b4)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type GLB_Set_PKA_CLK_Sel(GLB_PKA_CLK_Type clkSel)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce38. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_210108b8)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_32K_Sel(HBN_32K_CLK_Type clkType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce42. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010908)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Set_ROOT_CLK_Sel(HBN_ROOT_CLK_Type rootClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce4c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101090c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce56. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010910)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_Xtal_32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce60. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010914)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_On_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce6a. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010918)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Power_Off_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce74. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101091c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type HBN_Trim_RC32K(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce7e. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010920)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Trim_RC32M(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce88. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010954)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_RC32M_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce92. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010958)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Select_XTAL_As_PLL_Ref(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ce9c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101095c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_On_PLL(PDS_PLL_XTAL_Type xtalType)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cea6. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010960)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceb0. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010964)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_All_Clks(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ceba. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010968)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Enable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cec4. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_2101096c)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Disable_PLL_Clk(PDS_PLL_CLK_Type pllClk)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200cece. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010970)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

BL_Err_Type PDS_Power_Off_PLL(void)

{
  BL_Err_Type BVar1;
  
                    // WARNING: Could not recover jumptable at 0x4200ced8. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = (*_DAT_21010974)();
  gp = (code *)((int)SFlash_Cache_Hit_Count_Get + 6);
  return BVar1;
}


